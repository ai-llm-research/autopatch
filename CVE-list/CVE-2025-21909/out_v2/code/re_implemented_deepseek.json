{
 "supplementary_code": "```c\nstruct nlattr {\n__u16 nla_len;\n__u16 nla_type;\n};\n```\n```c\nenum nl80211_mntr_flags {\n__NL80211_MNTR_FLAG_INVALID,\nNL80211_MNTR_FLAG_FCSFAIL,\nNL80211_MNTR_FLAG_PLCPFAIL,\nNL80211_MNTR_FLAG_CONTROL,\nNL80211_MNTR_FLAG_OTHER_BSS,\nNL80211_MNTR_FLAG_COOK_FRAMES,\nNL80211_MNTR_FLAG_ACTIVE,\nNL80211_MNTR_FLAG_SKIP_TX,\n/* keep last */\n__NL80211_MNTR_FLAG_AFTER_LAST,\nNL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1\n};\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n```\n```c\nstatic inline int nla_parse_nested_deprecated(struct nlattr *tb[], int maxtype,\nconst struct nlattr *nla,\nconst struct nla_policy *policy,\nstruct netlink_ext_ack *extack)\n{\nreturn __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,\nNL_VALIDATE_LIBERAL, extack);\n}\n```\n```c\nenum monitor_flags {\nMONITOR_FLAG_CHANGED = BIT(__NL80211_MNTR_FLAG_INVALID),\nMONITOR_FLAG_FCSFAIL = BIT(NL80211_MNTR_FLAG_FCSFAIL),\nMONITOR_FLAG_PLCPFAIL = BIT(NL80211_MNTR_FLAG_PLCPFAIL),\nMONITOR_FLAG_CONTROL = BIT(NL80211_MNTR_FLAG_CONTROL),\nMONITOR_FLAG_OTHER_BSS = BIT(NL80211_MNTR_FLAG_OTHER_BSS),\nMONITOR_FLAG_COOK_FRAMES = BIT(NL80211_MNTR_FLAG_COOK_FRAMES),\nMONITOR_FLAG_ACTIVE = BIT(NL80211_MNTR_FLAG_ACTIVE),\nMONITOR_FLAG_SKIP_TX = BIT(NL80211_MNTR_FLAG_SKIP_TX),\n};\n```\n",
 "function_prototype": "static int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)",
 "re_implemented_code": "\n```c\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags) {\n// Declare an array to hold parsed flags, with size based on the maximum flag value\nstatic const char* flagNames[] = {\"MONITOR_FLAG_CHANGED\", \"MONITOR_FLAG_FCSFAIL\", \"MONITOR_FLAG_PLCPFAIL\", \"MONITOR_FLAG_CONTROL\", \"MONITOR_FLAG_OTHER_BSS\", \"MONITOR_FLAG_COOK_FRAMES\", \"MONITOR_FLAG_ACTIVE\", \"MONITOR_FLAG_SKIP_TX\"};\n#define MAX_FLAGS ARRAY_SIZE(flagNames)\nstruct nlattr *parsedFlags[MAX_FLAGS];\n// Initialize the monitor flags to zero\n*mntrflags = 0;\n// Check if the nla attribute is NULL, return an error if it is\nif (!nla)\nreturn -EINVAL;\n// Parse the nested attributes within nla using a predefined policy\n// Return an error if parsing fails\nint err = nla_parse_nested_deprecated(parsedFlags, MAX_FLAGS - 1, nla, NULL, NULL);\nif (err < 0)\nreturn err;\n// Iterate over each possible flag value\nfor (size_t i = 0; i < MAX_FLAGS; ++i) {\n// Check if the current flag is set in the parsed attributes\nif (parsedFlags[i]) {\n// If the flag is set, update the monitor flags with the corresponding bit\nswitch (i) {\ncase 0: (*mntrflags) |= MONITOR_FLAG_CHANGED; break;\ncase 1: (*mntrflags) |= MONITOR_FLAG_FCSFAIL; break;\ncase 2: (*mntrflags) |= MONITOR_FLAG_PLCPFAIL; break;\ncase 3: (*mntrflags) |= MONITOR_FLAG_CONTROL; break;\ncase 4: (*mntrflags) |= MONITOR_FLAG_OTHER_BSS; break;\ncase 5: (*mntrflags) |= MONITOR_FLAG_COOK_FRAMES; break;\ncase 6: (*mntrflags) |= MONITOR_FLAG_ACTIVE; break;\ncase 7: (*mntrflags) |= MONITOR_FLAG_SKIP_TX; break;\n}\n}\n}\n// Always set the MONITOR_FLAG_CHANGED bit in the monitor flags\n(*mntrflags) |= MONITOR_FLAG_CHANGED;\n// Return 0 to indicate success\nreturn 0;\n}\n```\n",
 "is_vulnerable": true
}