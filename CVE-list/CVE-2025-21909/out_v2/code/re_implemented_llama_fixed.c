

typedef unsigned int u32;

enum nl80211_mntr_flags {
    NL80211_MNTR_FLAG_FCSFAIL,
    NL80211_MNTR_FLAG_PLCPFAIL,
    NL80211_MNTR_FLAG_CONTROL,
    NL80211_MNTR_FLAG_OTHER_BSS,
    NL80211_MNTR_FLAG_COOK_FRAMES,
    NL80211_MNTR_FLAG_ACTIVE,
    NL80211_MNTR_FLAG_SKIP_TX,
    __NL80211_MNTR_FLAG_AFTER_LAST
};

enum { MONITOR_FLAG_ALL = 0xFFFFFFFF, MONITOR_FLAG_CHANGED = 0x00000001 };

struct nlattr {};

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define BIT(x) (1U << (x))

typedef int bool;
#define true 1
#define false 0

static int nla_parse_nested_deprecated(bool *arg1, int arg2, struct nlattr *nla, void *attr, void *data) {
    // Stub returning 0 for successful parse
    return 0;
}

static const void *nl80211_mntr_flag_attrs;

static int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags) {
    static const enum nl80211_mntr_flags mntrflagmap[] = {
        NL80211_MNTR_FLAG_FCSFAIL,
        NL80211_MNTR_FLAG_PLCPFAIL,
        NL80211_MNTR_FLAG_CONTROL,
        NL80211_MNTR_FLAG_OTHER_BSS,
        NL80211_MNTR_FLAG_COOK_FRAMES,
        NL80211_MNTR_FLAG_ACTIVE,
        NL80211_MNTR_FLAG_SKIP_TX,
    };

    bool mf[ARRAY_SIZE(mntrflagmap)];
    
    for (unsigned i = 0; i < ARRAY_SIZE(mntrflagmap); ++i) mf[i] = false;
    
    if (!nla || !mntrflags)
        return -1;

    if (nla_parse_nested_deprecated(mf, ARRAY_SIZE(mntrflagmap)-1, nla,
                nl80211_mntr_flag_attrs, 0))
        return -1;

    *mntrflags &= ~MONITOR_FLAG_ALL;
    for (unsigned i = 0; i <= __NL80211_MNTR_FLAG_AFTER_LAST; ++i) {
        if (mf[i])
            *mntrflags |= BIT(i);
    }

    *mntrflags |= MONITOR_FLAG_CHANGED;

    return 0;
}

