{
  "cwe_type": "Business Logic Errors",
  "cve_id": "CVE-2025-21909",
  "supplementary_code": "```c\nstruct nlattr {\n__u16 nla_len;\n__u16 nla_type;\n};\n```\n```c\nenum nl80211_mntr_flags {\n__NL80211_MNTR_FLAG_INVALID,\nNL80211_MNTR_FLAG_FCSFAIL,\nNL80211_MNTR_FLAG_PLCPFAIL,\nNL80211_MNTR_FLAG_CONTROL,\nNL80211_MNTR_FLAG_OTHER_BSS,\nNL80211_MNTR_FLAG_COOK_FRAMES,\nNL80211_MNTR_FLAG_ACTIVE,\nNL80211_MNTR_FLAG_SKIP_TX,\n/* keep last */\n__NL80211_MNTR_FLAG_AFTER_LAST,\nNL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1\n};\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n```\n```c\nstatic inline int nla_parse_nested_deprecated(struct nlattr *tb[], int maxtype,\nconst struct nlattr *nla,\nconst struct nla_policy *policy,\nstruct netlink_ext_ack *extack)\n{\nreturn __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,\nNL_VALIDATE_LIBERAL, extack);\n}\n```\n```c\nenum monitor_flags {\nMONITOR_FLAG_CHANGED = BIT(__NL80211_MNTR_FLAG_INVALID),\nMONITOR_FLAG_FCSFAIL = BIT(NL80211_MNTR_FLAG_FCSFAIL),\nMONITOR_FLAG_PLCPFAIL = BIT(NL80211_MNTR_FLAG_PLCPFAIL),\nMONITOR_FLAG_CONTROL = BIT(NL80211_MNTR_FLAG_CONTROL),\nMONITOR_FLAG_OTHER_BSS = BIT(NL80211_MNTR_FLAG_OTHER_BSS),\nMONITOR_FLAG_COOK_FRAMES = BIT(NL80211_MNTR_FLAG_COOK_FRAMES),\nMONITOR_FLAG_ACTIVE = BIT(NL80211_MNTR_FLAG_ACTIVE),\nMONITOR_FLAG_SKIP_TX = BIT(NL80211_MNTR_FLAG_SKIP_TX),\n};\n```",
  "original_code": "```c\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\nstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\nint flag;\n*mntrflags = 0;\nif (!nla)\nreturn -EINVAL;\nif (nla_parse_nested_deprecated(flags, NL80211_MNTR_FLAG_MAX, nla, mntr_flags_policy, NULL))\nreturn -EINVAL;\nfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\nif (flags[flag])\n*mntrflags |= (1<<flag);\n*mntrflags |= MONITOR_FLAG_CHANGED;\nreturn 0;\n}\n```",
  "vuln_patch": "```c\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\nstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\nint flag;\n*mntrflags = 0;\nif (!nla)\nreturn -EINVAL;\nif (nla_parse_nested_deprecated(flags, NL80211_MNTR_FLAG_MAX, nla, mntr_flags_policy, NULL))\nreturn -EINVAL;\nfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\nif (flags[flag])\n*mntrflags |= (1<<flag);\n/* cooked monitor mode is incompatible with other modes */\nif (*mntrflags & MONITOR_FLAG_COOK_FRAMES &&\n*mntrflags != MONITOR_FLAG_COOK_FRAMES)\nreturn -EOPNOTSUPP;\n*mntrflags |= MONITOR_FLAG_CHANGED;\nreturn 0;\n}\n```",
  "function_name": "parse_monitor_flags",
  "function_prototype": "static int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)",
  "code_semantics": "The function initializes a variable to zero, checks if a given input is null, and returns an error if it is. It then processes a nested data structure to extract specific elements. For each element found, it updates the variable by setting specific bits. Finally, it sets an additional bit in the variable and returns a success code.",
  "safe_verification_cot": "1. The function parse_monitor_flags includes a check to ensure MONITOR_FLAG_COOK_FRAMES is not combined with other flags in mntrflags, preventing the business logic error. 2. The variable mntrflags is properly checked for incompatible flags, and if MONITOR_FLAG_COOK_FRAMES is combined with others, the function returns -EOPNOTSUPP. 3. The function nla_parse_nested_deprecated continues to parse the flags correctly, and the added logic in parse_monitor_flags ensures that mntrflags is used safely.",
  "verification_cot": "1. The function parse_monitor_flags does not check if MONITOR_FLAG_COOK_FRAMES is combined with other flags in mntrflags, leading to a business logic error. 2. The variable mntrflags is not properly checked for incompatible flags, allowing MONITOR_FLAG_COOK_FRAMES to be set alongside other flags. 3. The function nla_parse_nested_deprecated correctly parses the flags, but the logic in parse_monitor_flags fails to enforce the necessary constraints on mntrflags.",
  "vulnerability_related_variables": {
    "mntrflags": "This variable is used to store a set of flags as a bitmask. It is initialized to zero and updated based on the presence of certain conditions. Each condition corresponds to a specific bit being set in the bitmask. The variable is also updated with a predefined constant flag.",
    "flags": "This is an array used to temporarily store the results of parsing a nested data structure. Each element in the array corresponds to a potential flag that can be set. The presence of a flag is indicated by a non-null value in the array, which is then used to update another variable.",
    "MONITOR_FLAG_COOK_FRAMES": "This constant represents a specific bit position in a bitmask. It is used to indicate a particular condition or state by setting the corresponding bit in a variable."
  },
  "vulnerability_related_functions": {
    "nla_parse_nested_deprecated": "This function takes a set of nested attributes and a policy for validation, parses the attributes according to the policy, and stores the results in an array. It returns a status code indicating whether the parsing was successful or not."
  },
  "root_cause": "Business logic error allowing MONITOR_FLAG_COOK_FRAMES to be combined with other monitor flags.",
  "patch_cot": "First, initialize mntrflags to zero to ensure no flags are set initially. Use nla_parse_nested_deprecated to parse the flags into the flags array. Iterate over the possible flags and set them in mntrflags if they are present. Add a conditional check to see if MONITOR_FLAG_COOK_FRAMES is set in mntrflags and if mntrflags contains any other flags. If so, return an error code to prevent the combination. Finally, set MONITOR_FLAG_CHANGED in mntrflags to indicate a change."
}