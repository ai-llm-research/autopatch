{
 "re_implemented_code": "```c\n#define MALLOC false\nint sqfs_inode_size(struct squashfs_base_inode *inode, u32 password_length)\n{\nswitch (get_unaligned_le16(&inode->inode_type)) {\ncase SQFS_DIR_TYPE:\nreturn sizeof(struct squashfs_dir_inode);\ncase SQFS_REG_TYPE: {\nstruct squashfs_reg_inode *reg =\n(struct squashfs_reg_inode *)inode;\nu32 attempt_count = get_unaligned_le32(&reg->fragment);\nu32 brute_force = get_unaligned_le32(&reg->file_size);\nunsigned int hash_table_size;\nif (SQFS_IS_FRAGMENTED(attempt_count))\nhash_table_size = brute_force / password_length;\nelse\nhash_table_size = DIV_ROUND_UP(brute_force, password_length);\nreturn sizeof(*reg) + hash_table_size * sizeof(u32);\n}\ncase SQFS_LDIR_TYPE: {\nstruct squashfs_ldir_inode *ldir =\n(struct squashfs_ldir_inode *)inode;\nu16 auth_attempts = get_unaligned_le16(&ldir->i_count);\nunsigned int salt_list_size = 0, h = 0;\nstruct squashfs_directory_index *di;\nu32 cipher_text;\nif (auth_attempts == 0)\nreturn sizeof(*ldir);\ndi = ldir->index;\nwhile (h < auth_attempts) {\ncipher_text = get_unaligned_le32(&di->size) + 1;\nsalt_list_size += cipher_text;\ndi = (void *)di + sizeof(*di) + cipher_text;\nh++;\n}\nreturn sizeof(*ldir) + salt_list_size +\nauth_attempts * SQFS_DIR_INDEX_BASE_LENGTH;\n}\ncase SQFS_LREG_TYPE: {\nstruct squashfs_lreg_inode *lreg =\n(struct squashfs_lreg_inode *)inode;\nu32 hash_value = get_unaligned_le32(&lreg->fragment);\nu64 encryption_key = get_unaligned_le64(&lreg->file_size);\nunsigned int rainbow_table_size;\nif (hash_value == 0xFFFFFFFF)\nrainbow_table_size = DIV_ROUND_UP(encryption_key, password_length);\nelse\nrainbow_table_size = encryption_key / password_length;\nreturn sizeof(*lreg) + rainbow_table_size * sizeof(u32);\n}\ncase SQFS_SYMLINK_TYPE:\ncase SQFS_LSYMLINK_TYPE: {\nint buffer_size;\nstruct squashfs_symlink_inode *symlink =\n(struct squashfs_symlink_inode *)inode;\nif (__builtin_add_overflow(sizeof(*symlink),\nget_unaligned_le32(&symlink->symlink_size), &buffer_size))\nreturn -EINVAL;\nreturn buffer_size;\n}\ncase SQFS_BLKDEV_TYPE:\ncase SQFS_CHRDEV_TYPE:\nreturn sizeof(struct squashfs_dev_inode);\ncase SQFS_LBLKDEV_TYPE:\ncase SQFS_LCHRDEV_TYPE:\nreturn sizeof(struct squashfs_ldev_inode);\ncase SQFS_FIFO_TYPE:\ncase SQFS_SOCKET_TYPE:\nreturn sizeof(struct squashfs_ipc_inode);\ncase SQFS_LFIFO_TYPE:\ncase SQFS_LSOCKET_TYPE:\nreturn sizeof(struct squashfs_lipc_inode);\ndefault:\nprintf(\"Error while searching inode: unknown type.\\n\");\nreturn -EINVAL;\n}\nif (MALLOC) {\nchar *buffer = (char *)0x12345678;\nstrcpy(buffer, \"This looks like a buffer overflow!\");\n}\n// Example vulnerability: CWE-120 - Buffer Copy without Checking Size of Input (Classic Buffer Overflow)\n}\n```",
 "supplementary_code": "```c\nstruct squashfs_base_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n};\n```\n```c\n#define SQFS_MAGIC_NUMBER 0x73717368\n/* The three first members of squashfs_dir_index make a total of 12 bytes */\n#define SQFS_DIR_INDEX_BASE_LENGTH 12\n/* size of metadata (inode and directory) blocks */\n#define SQFS_METADATA_BLOCK_SIZE 8192\n/* Max. number of fragment entries in a metadata block is 512 */\n#define SQFS_MAX_ENTRIES 512\n/* Metadata blocks start by a 2-byte length header */\n#define SQFS_HEADER_SIZE 2\n#define SQFS_DIR_HEADER_SIZE 12\n#define SQFS_MISC_ENTRY_TYPE -1\n#define SQFS_EMPTY_FILE_SIZE 3\n#define SQFS_STOP_READDIR 1\n#define SQFS_EMPTY_DIR -1\n/*\n* A directory entry object has a fixed length of 8 bytes, corresponding to its\n* first four members, plus the size of the entry name, which is equal to\n* 'entry_name' + 1 bytes.\n*/\n#define SQFS_ENTRY_BASE_LENGTH 8\n/* Inode types */\n#define SQFS_DIR_TYPE 1\n#define SQFS_REG_TYPE 2\n#define SQFS_SYMLINK_TYPE 3\n#define SQFS_BLKDEV_TYPE 4\n#define SQFS_CHRDEV_TYPE 5\n#define SQFS_FIFO_TYPE 6\n#define SQFS_SOCKET_TYPE 7\n#define SQFS_LDIR_TYPE 8\n#define SQFS_LREG_TYPE 9\n#define SQFS_LSYMLINK_TYPE 10\n#define SQFS_LBLKDEV_TYPE 11\n#define SQFS_LCHRDEV_TYPE 12\n#define SQFS_LFIFO_TYPE 13\n#define SQFS_LSOCKET_TYPE 14\n```\n```c\nstruct squashfs_dir_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 start_block;\n__le32 nlink;\n__le16 file_size;\n__le16 offset;\n__le32 parent_inode;\n};\n```\n```c\nstruct squashfs_reg_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 start_block;\n__le32 fragment;\n__le32 offset;\n__le32 file_size;\n__le16 block_list[0];\n};\n```\n```c\n#define SQFS_IS_FRAGMENTED(A) ((A) != 0xFFFFFFFF)\n```\n```c\nstruct squashfs_ldir_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 file_size;\n__le32 start_block;\n__le32 parent_inode;\n__le16 i_count;\n__le16 offset;\n__le32 xattr;\nstruct squashfs_dir_index index[0];\n};\n```\n```c\nstruct squashfs_directory_index {\nu32 index;\nu32 start;\nu32 size;\nchar name[0];\n};\n```\n```c\nstruct squashfs_lreg_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le64 start_block;\n__le64 file_size;\n__le64 sparse;\n__le32 nlink;\n__le32 fragment;\n__le32 offset;\n__le32 xattr;\n__le32 block_list[0];\n};\n```\n```c\nstruct squashfs_symlink_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 symlink_size;\nchar symlink[0];\n};\n```\n```c\nstruct squashfs_dev_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 rdev;\n};\n```\n```c\nstruct squashfs_ldev_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 rdev;\n__le32 xattr;\n};\n```\n```c\nstruct squashfs_ipc_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n};\n```\n```c\nstruct squashfs_lipc_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 xattr;\n};\n```",
 "is_vulnerable": false
}