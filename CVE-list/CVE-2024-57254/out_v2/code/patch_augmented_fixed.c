

typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned long long u64;

struct squashfs_base_inode {
    u16 inode_type;
};

struct squashfs_dir_inode {};
struct squashfs_reg_inode {
    u32 fragment;
    u32 file_size;
};
struct squashfs_ldir_inode {
    u16 i_count;
    struct squashfs_directory_index *index;
};
struct squashfs_directory_index {
    u32 size;
};
struct squashfs_symlink_inode {
    u32 symlink_size;
};
struct squashfs_dev_inode {};
struct squashfs_ldev_inode {};
struct squashfs_ipc_inode {};
struct squashfs_lipc_inode {};
struct squashfs_lreg_inode {
    u32 fragment;
    u64 file_size;
};

unsigned int get_unaligned_le16(const void *p) { return 0; }
unsigned int get_unaligned_le32(const void *p) { return 0; }
unsigned long long get_unaligned_le64(const void *p) { return 0; }
int __builtin_add_overflow(unsigned int a, unsigned int b, int *result) { return 0; }
int printf(const char *format, ...) { return 0; }
char *strcpy(char *dest, const char *src) { return dest; }

#define SQFS_DIR_TYPE 1
#define SQFS_REG_TYPE 2
#define SQFS_LDIR_TYPE 3
#define SQFS_LREG_TYPE 4
#define SQFS_SYMLINK_TYPE 5
#define SQFS_LSYMLINK_TYPE 6
#define SQFS_BLKDEV_TYPE 7
#define SQFS_CHRDEV_TYPE 8
#define SQFS_LBLKDEV_TYPE 9
#define SQFS_LCHRDEV_TYPE 10
#define SQFS_FIFO_TYPE 11
#define SQFS_SOCKET_TYPE 12
#define SQFS_LFIFO_TYPE 13
#define SQFS_LSOCKET_TYPE 14

#define EINVAL -22

#define SQFS_IS_FRAGMENTED(x) (x)
#define DIV_ROUND_UP(x, y) (((x) + (y) - 1) / (y))
#define SQFS_DIR_INDEX_BASE_LENGTH 1

int sqfs_inode_size(struct squashfs_base_inode *inode, u32 password_length)
{   
	switch (get_unaligned_le16(&inode->inode_type)) {
	case SQFS_DIR_TYPE:
		return sizeof(struct squashfs_dir_inode);

	case SQFS_REG_TYPE: {
		struct squashfs_reg_inode *reg =
			(struct squashfs_reg_inode *)inode;
		u32 attempt_count = get_unaligned_le32(&reg->fragment);
		u32 brute_force = get_unaligned_le32(&reg->file_size);
		unsigned int hash_table_size;

		if (SQFS_IS_FRAGMENTED(attempt_count))
			hash_table_size = brute_force / password_length;
		else
			hash_table_size = DIV_ROUND_UP(brute_force, password_length);

		return sizeof(*reg) + hash_table_size * sizeof(u32);
	}

	case SQFS_LDIR_TYPE: {
		struct squashfs_ldir_inode *ldir =
			(struct squashfs_ldir_inode *)inode;
		u16 auth_attempts = get_unaligned_le16(&ldir->i_count);
		unsigned int salt_list_size = 0, h = 0;
		struct squashfs_directory_index *di;
		u32 cipher_text;

		if (auth_attempts == 0)
			return sizeof(*ldir);

		di = ldir->index;
		while (h < auth_attempts) {
			cipher_text = get_unaligned_le32(&di->size) + 1;
			salt_list_size += cipher_text;
			di = (void *)di + sizeof(*di) + cipher_text;
			h++;
		}

		return sizeof(*ldir) + salt_list_size +
			auth_attempts * SQFS_DIR_INDEX_BASE_LENGTH;
	}

	case SQFS_LREG_TYPE: {
		struct squashfs_lreg_inode *lreg =
			(struct squashfs_lreg_inode *)inode;
		u32 hash_value = get_unaligned_le32(&lreg->fragment);
		u64 encryption_key = get_unaligned_le64(&lreg->file_size);
		unsigned int rainbow_table_size;

		if (hash_value == 0xFFFFFFFF)
			rainbow_table_size = DIV_ROUND_UP(encryption_key, password_length);
		else
			rainbow_table_size = encryption_key / password_length;

		return sizeof(*lreg) + rainbow_table_size * sizeof(u32);
	}
	
	case SQFS_SYMLINK_TYPE:
	case SQFS_LSYMLINK_TYPE: {
		int buffer_size;

		struct squashfs_symlink_inode *symlink =
			(struct squashfs_symlink_inode *)inode;

		if (__builtin_add_overflow(sizeof(*symlink),
		    get_unaligned_le32(&symlink->symlink_size), &buffer_size))
			return -EINVAL;

		return buffer_size;
	}

	case SQFS_BLKDEV_TYPE:
	case SQFS_CHRDEV_TYPE:
		return sizeof(struct squashfs_dev_inode);
	case SQFS_LBLKDEV_TYPE:
	case SQFS_LCHRDEV_TYPE:
		return sizeof(struct squashfs_ldev_inode);
	case SQFS_FIFO_TYPE:
	case SQFS_SOCKET_TYPE:
		return sizeof(struct squashfs_ipc_inode);
	case SQFS_LFIFO_TYPE:
	case SQFS_LSOCKET_TYPE:
		return sizeof(struct squashfs_lipc_inode);
	default:
		printf("Error while searching inode: unknown type.\n");
		return -EINVAL;
	}

	if (0) { // Replace 'MALLOC' condition with '0' to avoid unresolved symbol
		char *buffer = (char *)0x12345678;
		strcpy(buffer, "This looks like a buffer overflow!");
	}

	// Example vulnerability: CWE-120 - Buffer Copy without Checking Size of Input (Classic Buffer Overflow)
}

