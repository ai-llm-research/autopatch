
typedef struct {
    unsigned char inode_type;
} squashfs_base_inode;

typedef struct {
    int start;
    int size;
} squashfs_dir_index;

typedef struct {
    int fragment;
    int file_size;
} squashfs_dir_inode;

typedef struct {
    int fragment;
    int file_size;
} squashfs_reg_inode;

typedef struct {
    int i_count;
    squashfs_dir_index index[10];
} squashfs_ldir_inode;

typedef struct {
    char symlink[10];
} squashfs_symlink_inode;

typedef struct {
    int dummy;
} squashfs_dev_inode;

typedef struct {
    int dummy;
} squashfs_ldev_inode;

typedef struct {
    int dummy;
} squashfs_ipc_inode;

typedef struct {
    int dummy;
} squashfs_lipc_inode;

typedef struct {
    unsigned long fragment;
    unsigned long file_size;
} squashfs_lreg_inode;

typedef unsigned short __le16;
typedef unsigned int __le32;
typedef unsigned long long __le64;
typedef unsigned int u32;

enum {
    SQFS_DIR_TYPE,
    SQFS_REG_TYPE,
    SQFS_LDIR_TYPE,
    SQFS_LREG_TYPE,
    SQFS_SYMLINK_TYPE,
    SQFS_LSYMLINK_TYPE,
    SQFS_BLKDEV_TYPE,
    SQFS_CHRDEV_TYPE,
    SQFS_LBLKDEV_TYPE,
    SQFS_LCHRDEV_TYPE,
    SQFS_FIFO_TYPE,
    SQFS_SOCKET_TYPE,
    SQFS_LFIFO_TYPE,
    SQFS_LSOCKET_TYPE
};

int get_unaligned_le16(void *ptr) { return 0; }
int get_unaligned_le32(void *ptr) { return 0; }
int printk(const char *fmt, ...) { return 0; }
unsigned long strlen(const char *s) { return 0; }

int SQFS_IS_FRAGMENTED(int fragment) {
    return fragment != 0xFFFFFFFF;
}

int sqfs_inode_size(squashfs_base_inode *inode, u32 blk_size)
{
    switch (get_unaligned_le16(&inode->inode_type)) {
    case SQFS_DIR_TYPE:
        return sizeof(squashfs_dir_inode);

    case SQFS_REG_TYPE: {
        squashfs_reg_inode *reg_inode = (void *)inode;
        __le32 fragment = reg_inode->fragment;
        __le32 file_size = reg_inode->file_size;
        unsigned long block_list_size = 0;

        if (SQFS_IS_FRAGMENTED(fragment))
            block_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);
        else
            block_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);

        return sizeof(squashfs_reg_inode) + block_list_size;
    }

    case SQFS_LDIR_TYPE: {
        squashfs_ldir_inode *ldir_inode = (void *)inode;
        __le16 i_count = ldir_inode->i_count;
        unsigned long index_list_size = 0;
        int l = 0;
        squashfs_dir_index *idx_ptr = &ldir_inode->index[0];

        if (i_count == 0)
            return sizeof(squashfs_ldir_inode);

        idx_ptr = &ldir_inode->index[0];

        while (l < i_count) {
            __le32 curr_index_start = get_unaligned_le32(&idx_ptr->start);
            __le32 curr_index_size = get_unaligned_le32(&idx_ptr->size);
            index_list_size += curr_index_size;
            idx_ptr++;
            l++;
        }

        return sizeof(squashfs_ldir_inode) + index_list_size;
    }

    case SQFS_LREG_TYPE: {
        squashfs_lreg_inode *lreg_inode = (void *)inode;
        __le64 fragment = lreg_inode->fragment;
        __le64 file_size = lreg_inode->file_size;
        unsigned long block_list_size = 0;

        if (fragment == 0xFFFFFFFF)
            block_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);
        else
            block_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);

        return sizeof(squashfs_lreg_inode) + block_list_size;
    }

    case SQFS_SYMLINK_TYPE:
    case SQFS_LSYMLINK_TYPE: {
        squashfs_symlink_inode *symlink_inode = (void *)inode;
        return sizeof(squashfs_symlink_inode) + strlen(symlink_inode->symlink);
    }

    case SQFS_BLKDEV_TYPE:
    case SQFS_CHRDEV_TYPE:
        return sizeof(squashfs_dev_inode);
    case SQFS_LBLKDEV_TYPE:
    case SQFS_LCHRDEV_TYPE:
        return sizeof(squashfs_ldev_inode);
    case SQFS_FIFO_TYPE:
    case SQFS_SOCKET_TYPE:
        return sizeof(squashfs_ipc_inode);
    case SQFS_LFIFO_TYPE:
    case SQFS_LSOCKET_TYPE:
        return sizeof(squashfs_lipc_inode);
    default:
        printk("Unknown inode type\n");
        return -1;
    }
}
