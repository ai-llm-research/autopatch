{
 "supplementary_code": "```c\nstruct squashfs_base_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n};\n```\n```c\n#define SQFS_MAGIC_NUMBER 0x73717368\n/* The three first members of squashfs_dir_index make a total of 12 bytes */\n#define SQFS_DIR_INDEX_BASE_LENGTH 12\n/* size of metadata (inode and directory) blocks */\n#define SQFS_METADATA_BLOCK_SIZE 8192\n/* Max. number of fragment entries in a metadata block is 512 */\n#define SQFS_MAX_ENTRIES 512\n/* Metadata blocks start by a 2-byte length header */\n#define SQFS_HEADER_SIZE 2\n#define SQFS_DIR_HEADER_SIZE 12\n#define SQFS_MISC_ENTRY_TYPE -1\n#define SQFS_EMPTY_FILE_SIZE 3\n#define SQFS_STOP_READDIR 1\n#define SQFS_EMPTY_DIR -1\n/*\n* A directory entry object has a fixed length of 8 bytes, corresponding to its\n* first four members, plus the size of the entry name, which is equal to\n* 'entry_name' + 1 bytes.\n*/\n#define SQFS_ENTRY_BASE_LENGTH 8\n/* Inode types */\n#define SQFS_DIR_TYPE 1\n#define SQFS_REG_TYPE 2\n#define SQFS_SYMLINK_TYPE 3\n#define SQFS_BLKDEV_TYPE 4\n#define SQFS_CHRDEV_TYPE 5\n#define SQFS_FIFO_TYPE 6\n#define SQFS_SOCKET_TYPE 7\n#define SQFS_LDIR_TYPE 8\n#define SQFS_LREG_TYPE 9\n#define SQFS_LSYMLINK_TYPE 10\n#define SQFS_LBLKDEV_TYPE 11\n#define SQFS_LCHRDEV_TYPE 12\n#define SQFS_LFIFO_TYPE 13\n#define SQFS_LSOCKET_TYPE 14\n```\n```c\nstruct squashfs_dir_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 start_block;\n__le32 nlink;\n__le16 file_size;\n__le16 offset;\n__le32 parent_inode;\n};\n```\n```c\nstruct squashfs_reg_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 start_block;\n__le32 fragment;\n__le32 offset;\n__le32 file_size;\n__le16 block_list[0];\n};\n```\n```c\n#define SQFS_IS_FRAGMENTED(A) ((A) != 0xFFFFFFFF)\n```\n```c\nstruct squashfs_ldir_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 file_size;\n__le32 start_block;\n__le32 parent_inode;\n__le16 i_count;\n__le16 offset;\n__le32 xattr;\nstruct squashfs_dir_index index[0];\n};\n```\n```c\nstruct squashfs_directory_index {\nu32 index;\nu32 start;\nu32 size;\nchar name[0];\n};\n```\n```c\nstruct squashfs_lreg_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le64 start_block;\n__le64 file_size;\n__le64 sparse;\n__le32 nlink;\n__le32 fragment;\n__le32 offset;\n__le32 xattr;\n__le32 block_list[0];\n};\n```\n```c\nstruct squashfs_symlink_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 symlink_size;\nchar symlink[0];\n};\n```\n```c\nstruct squashfs_dev_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 rdev;\n};\n```\n```c\nstruct squashfs_ldev_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 rdev;\n__le32 xattr;\n};\n```\n```c\nstruct squashfs_ipc_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n};\n```\n```c\nstruct squashfs_lipc_inode {\n__le16 inode_type;\n__le16 mode;\n__le16 uid;\n__le16 guid;\n__le32 mtime;\n__le32 inode_number;\n__le32 nlink;\n__le32 xattr;\n};\n```",
 "function_prototype": "int sqfs_inode_size(struct squashfs_base_inode *inode, u32 blk_size)",
 "re_implemented_code": "\n```c\nint sqfs_inode_size(struct squashfs_base_inode *inode, u32 blk_size)\n{\n// Determine the inode type by reading the inode_type field\nswitch (get_unaligned_le16(&inode->inode_type)) {\ncase SQFS_DIR_TYPE:\n// Return the size of a directory inode structure\nreturn sizeof(struct squashfs_dir_inode);\ncase SQFS_REG_TYPE: {\n// Cast the base inode to a regular file inode structure\nstruct squashfs_reg_inode *reg_inode = (void *)inode;\n// Read the fragment and file size fields from the regular inode\n__le32 fragment = reg_inode->fragment;\n__le32 file_size = reg_inode->file_size;\n// Declare a variable to hold the block list size\nunsigned long block_list_size = 0;\n// Check if the file is fragmented\nif (SQFS_IS_FRAGMENTED(fragment))\n// Calculate block list size for fragmented files\nblock_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);\nelse\n// Calculate block list size for non-fragmented files\nblock_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);\n// Return the total size of the regular inode including the block list\nreturn sizeof(struct squashfs_reg_inode) + block_list_size;\n}\ncase SQFS_LDIR_TYPE: {\n// Cast the base inode to a large directory inode structure\nstruct squashfs_ldir_inode *ldir_inode = (void *)inode;\n// Read the i_count field from the large directory inode\n__le16 i_count = ldir_inode->i_count;\n// Initialize variables for index list size and loop counter\nunsigned long index_list_size = 0;\nint l = 0;\n// Declare a pointer to iterate over directory indices\nstruct squashfs_dir_index *idx_ptr = &ldir_inode->index[0];\n// Check if there are no indices\nif (i_count == 0)\n// Return the size of the large directory inode structure\nreturn sizeof(struct squashfs_ldir_inode);\n// Initialize the directory index pointer\nidx_ptr = &ldir_inode->index[0];\n// Iterate over each directory index\nwhile (l < i_count) {\n// Read the size of the current directory index\n__le32 curr_index_start = get_unaligned_le32(&idx_ptr->start);\n__le32 curr_index_size = get_unaligned_le32(&idx_ptr->size);\n// Accumulate the total index list size\nindex_list_size += curr_index_size;\n// Move the directory index pointer to the next index\nidx_ptr++;\n// Increment the loop counter\nl++;\n}\n// Return the total size of the large directory inode including indices\nreturn sizeof(struct squashfs_ldir_inode) + index_list_size;\n}\ncase SQFS_LREG_TYPE: {\n// Cast the base inode to a large regular file inode structure\nstruct squashfs_lreg_inode *lreg_inode = (void *)inode;\n// Read the fragment and file size fields from the large regular inode\n__le64 fragment = lreg_inode->fragment;\n__le64 file_size = lreg_inode->file_size;\n// Declare a variable to hold the block list size\nunsigned long block_list_size = 0;\n// Check if the file is not fragmented\nif (fragment == 0xFFFFFFFF)\n// Calculate block list size for non-fragmented files\nblock_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);\nelse\n// Calculate block list size for fragmented files\nblock_list_size = (file_size + blk_size - 1) / blk_size * sizeof(__le32);\n// Return the total size of the large regular inode including the block list\nreturn sizeof(struct squashfs_lreg_inode) + block_list_size;\n}\ncase SQFS_SYMLINK_TYPE:\ncase SQFS_LSYMLINK_TYPE: {\n// Cast the base inode to a symlink inode structure\nstruct squashfs_symlink_inode *symlink_inode = (void *)inode;\n// Return the total size of the symlink inode including the symlink path\nreturn sizeof(struct squashfs_symlink_inode) + strlen(symlink_inode->symlink);\n}\ncase SQFS_BLKDEV_TYPE:\ncase SQFS_CHRDEV_TYPE:\n// Return the size of a device inode structure\nreturn sizeof(struct squashfs_dev_inode);\ncase SQFS_LBLKDEV_TYPE:\ncase SQFS_LCHRDEV_TYPE:\n// Return the size of a large device inode structure\nreturn sizeof(struct squashfs_ldev_inode);\ncase SQFS_FIFO_TYPE:\ncase SQFS_SOCKET_TYPE:\n// Return the size of an IPC inode structure\nreturn sizeof(struct squashfs_ipc_inode);\ncase SQFS_LFIFO_TYPE:\ncase SQFS_LSOCKET_TYPE:\n// Return the size of a large IPC inode structure\nreturn sizeof(struct squashfs_lipc_inode);\ndefault:\n// Print an error message for unknown inode types\nprintk(\"Unknown inode type\\n\");\n// Return an error code for invalid inode type\nreturn -EINVAL;\n}\n}\n```\n",
 "is_vulnerable": true
}