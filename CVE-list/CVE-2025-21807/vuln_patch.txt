```c
static ssize_t queue_attr_store(struct kobject *kobj, struct attribute *attr, const char *page, size_t length)
{
	struct queue_sysfs_entry *entry = to_queue(attr);
	struct gendisk *disk = container_of(kobj, struct gendisk, queue_kobj);
	struct request_queue *q = disk->queue;
	ssize_t res;

	if (!entry->store_limit && !entry->store)
		return -EIO;

	/*
	 * If the attribute needs to load a module, do it before freezing the
	 * queue to ensure that the module file can be read when the request
	 * queue is the one for the device storing the module file.
	 */
	if (entry->load_module)
		entry->load_module(disk, page, length);

	if (entry->store_limit) {
		struct queue_limits lim = queue_limits_start_update(q);

		res = entry->store_limit(disk, page, length, &lim);
		if (res < 0) {
			queue_limits_cancel_update(q);
			return res;
		}

		res = queue_limits_commit_update_frozen(q, &lim);
		if (res)
			return res;
		return length;
	}

	mutex_lock(&q->sysfs_lock);
	blk_mq_freeze_queue(q);
	res = entry->store(disk, page, length);
	blk_mq_unfreeze_queue(q);
	mutex_unlock(&q->sysfs_lock);
	return res;
}
```
