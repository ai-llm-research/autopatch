

typedef long ssize_t;
typedef unsigned long size_t;

struct kobject {};
struct attribute {};

struct queue_limits {};

struct gendisk {
    struct request_queue *queue;
};

struct queue_sysfs_entry {
    int (*store_limit)(struct queue_limits, const char *, size_t);
    int (*store)(struct gendisk *, const char *, size_t);
    void (*load_module)(struct gendisk *, const char *, size_t);
};

struct request_queue {
    int sysfs_lock;
};

ssize_t queue_attr_store(struct kobject *kobj, struct attribute *attr, const char *page, size_t length);
struct queue_sysfs_entry *to_queue(struct attribute *);
struct gendisk *container_of(struct kobject *, struct gendisk *, int);
void mutex_lock(int *);
void mutex_unlock(int *);
void blk_mq_freeze_queue(struct request_queue *);
void blk_mq_unfreeze_queue(struct request_queue *);
struct queue_limits queue_limits_start_update(struct request_queue *);
void queue_limits_cancel_update(struct request_queue *);
int queue_limits_commit_update(struct request_queue *, struct queue_limits *);

#define EOPNOTSUPP 95
#define EINVAL 22

ssize_t queue_attr_store(struct kobject *kobj, struct attribute *attr, const char *page, size_t length) {
    struct queue_sysfs_entry *entry = to_queue(attr);
    struct gendisk *disk = (struct gendisk *)container_of(kobj, (struct gendisk *)0, 0);
    struct request_queue *q = disk->queue;
    ssize_t res;

    if (!entry->store_limit && !entry->store)
        return -EOPNOTSUPP;

    if (entry->load_module)
        entry->load_module(disk, page, length);

    mutex_lock(&q->sysfs_lock);
    blk_mq_freeze_queue(q);

    if (entry->store_limit) {
        struct queue_limits old_lim = queue_limits_start_update(q);
        res = entry->store_limit(old_lim, page, length);

        if (res < 0) {
            queue_limits_cancel_update(q);
        } else {
            if (queue_limits_commit_update(q, &old_lim)) {
                res = -EINVAL;
            } else {
                if (!res)
                    res = length;
            }
        }
    } else {
        res = entry->store(disk, page, length);
    }

    blk_mq_unfreeze_queue(q);
    mutex_unlock(&q->sysfs_lock);
    return res;
}

