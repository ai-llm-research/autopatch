

struct kobject {
    struct gendisk * disk;
};

struct attribute {};

typedef int ssize_t;
typedef unsigned int size_t;
#define EINVAL 22

struct queue_sysfs_entry {
    int (*store_limit)(struct gendisk *, void *limit, const char *page, size_t length);
    int (*store)(struct gendisk *, const char *page, size_t length);
    void (*load_module)(struct gendisk *, const char *page, size_t length);
};

struct request_queue {
    int sysfs_lock;
};

struct gendisk {
    struct request_queue* queue;
    struct kobject kobj;
};

struct queue_limits {

};

struct queue_sysfs_entry* to_queue(struct attribute *attr) {
    return 0; // replace nullptr with 0 for C
}

struct gendisk* container_of(struct kobject *kobj, struct gendisk *disk, struct kobject (*member)) {
    return (struct gendisk *)((char *)kobj - (char *)&((struct gendisk *)0)->kobj + (char *)disk);
}

void mutex_lock(int *lock) {}

void mutex_unlock(int *lock) {}

void blk_freeze_queue_start(struct request_queue *q) {}

void blk_freeze_queue_wait(struct request_queue *q) {}

void blk_mq_unfreeze_queue(struct request_queue *q) {}

struct queue_limits queue_limits_start_update(struct request_queue *q) {
    struct queue_limits limits;
    return limits;
}

void queue_limits_cancel_update(struct request_queue *q) {}

void queue_limits_commit_update(struct request_queue *q, struct queue_limits *limit) {}

static ssize_t queue_attr_store(struct kobject *kobj, struct attribute *attr, const char *page, size_t length) {
    struct queue_sysfs_entry* entry = to_queue(attr);
    struct gendisk disk_instance;
    struct gendisk* disk = container_of(kobj, &disk_instance, &kobj);
    struct request_queue* q = disk->queue;
    int res;

    if (!entry->store_limit && !entry->store)
        return -EINVAL;

    if (entry->load_module)
        entry->load_module(disk, page, length);

    mutex_lock(&q->sysfs_lock);

    blk_freeze_queue_start(q);
    blk_freeze_queue_wait(q);

    if (entry->store_limit) {
        struct queue_limits limit = queue_limits_start_update(q);
        res = entry->store_limit(disk, &limit, page, length);

        if (res < 0) {
            queue_limits_cancel_update(q);
        } else {
            queue_limits_commit_update(q, &limit);
            if (!res)
                res = length;
        }
    } else {
        res = entry->store(disk, page, length);
    }

    blk_mq_unfreeze_queue(q);
    mutex_unlock(&q->sysfs_lock);

    return res;
}

