{
  "cwe_type": "Race Condition",
  "cve_id": "CVE-2022-49733",
  "supplementary_code": "```c\nstruct snd_pcm_oss_file {\nstruct snd_pcm_substream *streams[2];\n};\n```\n```c\nstruct snd_pcm_substream {\nstruct snd_pcm *pcm;\nstruct snd_pcm_str *pstr;\nvoid *private_data; /* copied from pcm->private_data */\nint number;\nchar name[32]; /* substream name */\nint stream; /* stream (direction) */\nstruct pm_qos_request latency_pm_qos_req; /* pm_qos request */\nsize_t buffer_bytes_max; /* limit ring buffer size */\nstruct snd_dma_buffer dma_buffer;\nsize_t dma_max;\n/* -- hardware operations -- */\nconst struct snd_pcm_ops *ops;\n/* -- runtime information -- */\nstruct snd_pcm_runtime *runtime;\n/* -- timer section -- */\nstruct snd_timer *timer; /* timer */\nunsigned timer_running: 1; /* time is running */\nlong wait_time; /* time in ms for R/W to wait for avail */\n/* -- next substream -- */\nstruct snd_pcm_substream *next;\n/* -- linked substreams -- */\nstruct list_head link_list; /* linked list member */\nstruct snd_pcm_group self_group; /* fake group for non linked substream (with substream lock inside) */\nstruct snd_pcm_group *group; /* pointer to current group */\n/* -- assigned files -- */\nint ref_count;\natomic_t mmap_count;\nunsigned int f_flags;\nvoid (*pcm_release)(struct snd_pcm_substream *);\nstruct pid *pid;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n/* -- OSS things -- */\nstruct snd_pcm_oss_substream oss;\n#endif\n#ifdef CONFIG_SND_VERBOSE_PROCFS\nstruct snd_info_entry *proc_root;\n#endif /* CONFIG_SND_VERBOSE_PROCFS */\n/* misc flags */\nunsigned int hw_opened: 1;\nunsigned int managed_buffer_alloc:1;\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\nunsigned int xrun_counter; /* number of times xrun happens */\n#endif /* CONFIG_SND_PCM_XRUN_DEBUG */\n};\n```\n```c\nstruct snd_pcm_runtime {\n/* -- Status -- */\nsnd_pcm_state_t state; /* stream state */\nsnd_pcm_state_t suspended_state; /* suspended stream state */\nstruct snd_pcm_substream *trigger_master;\nstruct timespec64 trigger_tstamp; /* trigger timestamp */\nbool trigger_tstamp_latched; /* trigger timestamp latched in low-level driver/hardware */\nint overrange;\nsnd_pcm_uframes_t avail_max;\nsnd_pcm_uframes_t hw_ptr_base; /* Position at buffer restart */\nsnd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */\nunsigned long hw_ptr_jiffies; /* Time when hw_ptr is updated */\nunsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */\nsnd_pcm_sframes_t delay; /* extra delay; typically FIFO size */\nu64 hw_ptr_wrap; /* offset for hw_ptr due to boundary wrap-around */\n/* -- HW params -- */\nsnd_pcm_access_t access; /* access mode */\nsnd_pcm_format_t format; /* SNDRV_PCM_FORMAT_* */\nsnd_pcm_subformat_t subformat; /* subformat */\nunsigned int rate; /* rate in Hz */\nunsigned int channels; /* channels */\nsnd_pcm_uframes_t period_size; /* period size */\nunsigned int periods; /* periods */\nsnd_pcm_uframes_t buffer_size; /* buffer size */\nsnd_pcm_uframes_t min_align; /* Min alignment for the format */\nsize_t byte_align;\nunsigned int frame_bits;\nunsigned int sample_bits;\nunsigned int info;\nunsigned int rate_num;\nunsigned int rate_den;\nunsigned int no_period_wakeup: 1;\n/* -- SW params; see struct snd_pcm_sw_params for comments -- */\nint tstamp_mode;\nunsigned int period_step;\nsnd_pcm_uframes_t start_threshold;\nsnd_pcm_uframes_t stop_threshold;\nsnd_pcm_uframes_t silence_threshold;\nsnd_pcm_uframes_t silence_size;\nsnd_pcm_uframes_t boundary;\n/* internal data of auto-silencer */\nsnd_pcm_uframes_t silence_start; /* starting pointer to silence area */\nsnd_pcm_uframes_t silence_filled; /* already filled part of silence area */\nbool std_sync_id; /* hardware synchronization - standard per card ID */\n/* -- mmap -- */\nstruct snd_pcm_mmap_status *status;\nstruct snd_pcm_mmap_control *control;\n/* -- locking / scheduling -- */\nsnd_pcm_uframes_t twake; /* do transfer (!poll) wakeup if non-zero */\nwait_queue_head_t sleep; /* poll sleep */\nwait_queue_head_t tsleep; /* transfer sleep */\nstruct snd_fasync *fasync;\nbool stop_operating; /* sync_stop will be called */\nstruct mutex buffer_mutex; /* protect for buffer changes */\natomic_t buffer_accessing; /* >0: in r/w operation, <0: blocked */\n/* -- private section -- */\nvoid *private_data;\nvoid (*private_free)(struct snd_pcm_runtime *runtime);\n/* -- hardware description -- */\nstruct snd_pcm_hardware hw;\nstruct snd_pcm_hw_constraints hw_constraints;\n/* -- timer -- */\nunsigned int timer_resolution; /* timer resolution */\nint tstamp_type; /* timestamp type */\n/* -- DMA -- */\nunsigned char *dma_area; /* DMA area */\ndma_addr_t dma_addr; /* physical bus address (not accessible from main CPU) */\nsize_t dma_bytes; /* size of DMA area */\nstruct snd_dma_buffer *dma_buffer_p; /* allocated buffer */\nunsigned int buffer_changed:1; /* buffer allocation changed; set only in managed mode */\n/* -- audio timestamp config -- */\nstruct snd_pcm_audio_tstamp_config audio_tstamp_config;\nstruct snd_pcm_audio_tstamp_report audio_tstamp_report;\nstruct timespec64 driver_tstamp;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n/* -- OSS things -- */\nstruct snd_pcm_oss_runtime oss;\n#endif\n};\n```\n```c\ntypedef int __bitwise snd_pcm_format_t;\n#define SNDRV_PCM_FORMAT_S8 ((__force snd_pcm_format_t) 0)\n#define SNDRV_PCM_FORMAT_U8 ((__force snd_pcm_format_t) 1)\n#define SNDRV_PCM_FORMAT_S16_LE ((__force snd_pcm_format_t) 2)\n#define SNDRV_PCM_FORMAT_S16_BE ((__force snd_pcm_format_t) 3)\n#define SNDRV_PCM_FORMAT_U16_LE ((__force snd_pcm_format_t) 4)\n#define SNDRV_PCM_FORMAT_U16_BE ((__force snd_pcm_format_t) 5)\n#define SNDRV_PCM_FORMAT_S24_LE ((__force snd_pcm_format_t) 6) /* low three bytes */\n#define SNDRV_PCM_FORMAT_S24_BE ((__force snd_pcm_format_t) 7) /* low three bytes */\n#define SNDRV_PCM_FORMAT_U24_LE ((__force snd_pcm_format_t) 8) /* low three bytes */\n#define SNDRV_PCM_FORMAT_U24_BE ((__force snd_pcm_format_t) 9) /* low three bytes */\n```\n```c\nenum {\nSNDRV_PCM_STREAM_PLAYBACK = 0,\nSNDRV_PCM_STREAM_CAPTURE,\nSNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,\n};\n```\n```c\nstatic inline int atomic_read(const atomic_t *v)\n{\nreturn READ_ONCE((v)->counter);\n}\n```\n```c\nstatic inline void atomic_inc(atomic_t *v)\n{\n__sync_add_and_fetch(&v->counter, 1);\n}\n```\n```c\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\nreturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}\nEXPORT_SYMBOL(mutex_lock_interruptible);\n```\n```c\nstatic __always_inline void atomic_dec(atomic_t *v)\n{\ninstrument_atomic_read_write(v, sizeof(*v));\nraw_atomic_dec(v);\n}\n```\n```c\n#define ERESTARTSYS 512\n```\n```c\nstatic int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream *substream)\n{\nstruct snd_pcm_runtime *runtime;\nint err;\nruntime = substream->runtime;\nif (runtime->oss.params) {\nerr = snd_pcm_oss_change_params_locked(substream);\nif (err < 0)\nreturn err;\n}\nif (runtime->oss.prepare) {\nerr = snd_pcm_oss_prepare(substream);\nif (err < 0)\nreturn err;\n}\nreturn 0;\n}\n```\n```c\nstatic snd_pcm_format_t snd_pcm_oss_format_from(int format)\n{\nswitch (format) {\ncase AFMT_MU_LAW: return SNDRV_PCM_FORMAT_MU_LAW;\ncase AFMT_A_LAW: return SNDRV_PCM_FORMAT_A_LAW;\ncase AFMT_IMA_ADPCM: return SNDRV_PCM_FORMAT_IMA_ADPCM;\ncase AFMT_U8: return SNDRV_PCM_FORMAT_U8;\ncase AFMT_S16_LE: return SNDRV_PCM_FORMAT_S16_LE;\ncase AFMT_S16_BE: return SNDRV_PCM_FORMAT_S16_BE;\ncase AFMT_S8: return SNDRV_PCM_FORMAT_S8;\ncase AFMT_U16_LE: return SNDRV_PCM_FORMAT_U16_LE;\ncase AFMT_U16_BE: return SNDRV_PCM_FORMAT_U16_BE;\ncase AFMT_MPEG: return SNDRV_PCM_FORMAT_MPEG;\ncase AFMT_S32_LE: return SNDRV_PCM_FORMAT_S32_LE;\ncase AFMT_S32_BE: return SNDRV_PCM_FORMAT_S32_BE;\ncase AFMT_S24_LE: return SNDRV_PCM_FORMAT_S24_LE;\ncase AFMT_S24_BE: return SNDRV_PCM_FORMAT_S24_BE;\ncase AFMT_S24_PACKED: return SNDRV_PCM_FORMAT_S24_3LE;\ncase AFMT_FLOAT: return SNDRV_PCM_FORMAT_FLOAT;\ncase AFMT_SPDIF_RAW: return SNDRV_PCM_FORMAT_IEC958_SUBFRAME;\ndefault: return SNDRV_PCM_FORMAT_U8;\n}\n}\n```\n```c\nint snd_pcm_format_physical_width(snd_pcm_format_t format)\n{\nint val;\nif (!valid_format(format))\nreturn -EINVAL;\nval = pcm_formats[(INT)format].phys;\nif (!val)\nreturn -EINVAL;\nreturn val;\n}\nEXPORT_SYMBOL(snd_pcm_format_physical_width);\n```\n```c\nint snd_pcm_format_set_silence(snd_pcm_format_t format, void *data, unsigned int samples)\n{\nint width;\nunsigned char *dst;\nconst unsigned char *pat;\nif (!valid_format(format))\nreturn -EINVAL;\nif (samples == 0)\nreturn 0;\nwidth = pcm_formats[(INT)format].phys; /* physical width */\npat = pcm_formats[(INT)format].silence;\nif (!width || !pat)\nreturn -EINVAL;\n/* signed or 1 byte data */\nif (pcm_formats[(INT)format].signd == 1 || width <= 8) {\nunsigned int bytes = samples * width / 8;\nmemset(data, *pat, bytes);\nreturn 0;\n}\n/* non-zero samples, fill using a loop */\nwidth /= 8;\ndst = data;\n#if 0\nwhile (samples--) {\nmemcpy(dst, pat, width);\ndst += width;\n}\n#else\n/* a bit optimization for constant width */\nswitch (width) {\ncase 2:\nwhile (samples--) {\nmemcpy(dst, pat, 2);\ndst += 2;\n}\nbreak;\ncase 3:\nwhile (samples--) {\nmemcpy(dst, pat, 3);\ndst += 3;\n}\nbreak;\ncase 4:\nwhile (samples--) {\nmemcpy(dst, pat, 4);\ndst += 4;\n}\nbreak;\ncase 8:\nwhile (samples--) {\nmemcpy(dst, pat, 8);\ndst += 8;\n}\nbreak;\n}\n#endif\nreturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_format_set_silence);\n```\n```c\nstatic int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size)\n{\nstruct snd_pcm_runtime *runtime;\nssize_t result = 0;\nsnd_pcm_state_t state;\nlong res;\nwait_queue_entry_t wait;\nruntime = substream->runtime;\ninit_waitqueue_entry(&wait, current);\nadd_wait_queue(&runtime->sleep, &wait);\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync1: size = %li\\n\", size);\n#endif\nwhile (1) {\nresult = snd_pcm_oss_write2(substream, runtime->oss.buffer, size, 1);\nif (result > 0) {\nruntime->oss.buffer_used = 0;\nresult = 0;\nbreak;\n}\nif (result != 0 && result != -EAGAIN)\nbreak;\nresult = 0;\nset_current_state(TASK_INTERRUPTIBLE);\nscoped_guard(pcm_stream_lock_irq, substream)\nstate = runtime->state;\nif (state != SNDRV_PCM_STATE_RUNNING) {\nset_current_state(TASK_RUNNING);\nbreak;\n}\nres = schedule_timeout(10 * HZ);\nif (signal_pending(current)) {\nresult = -ERESTARTSYS;\nbreak;\n}\nif (res == 0) {\npcm_err(substream->pcm,\n\"OSS sync error - DMA timeout\\n\");\nresult = -EIO;\nbreak;\n}\n}\nremove_wait_queue(&runtime->sleep, &wait);\nreturn result;\n}\n```\n```c\n#define pcm_dbg(pcm, fmt, args...) \\\ndev_dbg((pcm)->card->dev, fmt, ##args)\n```\n```c\nstatic inline snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,\nconst void __user *buf, snd_pcm_uframes_t frames)\n{\nreturn __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);\n}\n```\n```c\nstatic inline snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,\nvoid __user **bufs, snd_pcm_uframes_t frames)\n{\nreturn __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);\n}\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\nint snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream,\nunsigned int cmd, void *arg)\n{\nsnd_pcm_uframes_t *frames = arg;\nsnd_pcm_sframes_t result;\nif (substream->runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\nreturn -EBADFD;\nswitch (cmd) {\ncase SNDRV_PCM_IOCTL_FORWARD:\n{\n/* provided only for OSS; capture-only and no value returned */\nif (substream->stream != SNDRV_PCM_STREAM_CAPTURE)\nreturn -EINVAL;\nresult = snd_pcm_forward(substream, *frames);\nreturn result < 0 ? result : 0;\n}\ncase SNDRV_PCM_IOCTL_HW_PARAMS:\nreturn snd_pcm_hw_params(substream, arg);\ncase SNDRV_PCM_IOCTL_SW_PARAMS:\nreturn snd_pcm_sw_params(substream, arg);\ncase SNDRV_PCM_IOCTL_PREPARE:\nreturn snd_pcm_prepare(substream, NULL);\ncase SNDRV_PCM_IOCTL_START:\nreturn snd_pcm_start_lock_irq(substream);\ncase SNDRV_PCM_IOCTL_DRAIN:\nreturn snd_pcm_drain(substream, NULL);\ncase SNDRV_PCM_IOCTL_DROP:\nreturn snd_pcm_drop(substream);\ncase SNDRV_PCM_IOCTL_DELAY:\nreturn snd_pcm_delay(substream, frames);\ndefault:\nreturn -EINVAL;\n}\n}\nEXPORT_SYMBOL(snd_pcm_kernel_ioctl);\n```\n```c\nstatic int mutex_lock(unsigned long *m)\n{\nint c;\nint flags = FUTEX_WAIT;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nc = cmpxchg(m, 0, 1);\nif (!c)\nreturn 0;\nif (c == 1)\nc = xchg(m, 2);\nwhile (c) {\nsys_futex(m, flags, 2, NULL, NULL, 0);\nc = xchg(m, 2);\n}\nreturn 0;\n}\n```\n```c\n#define EPIPE 32 /* Broken pipe */\n#define ESTRPIPE 92 /* Streams pipe error */\n#define SNDRV_PCM_STATE_PREPARED ((__force snd_pcm_state_t) 2) /* stream is ready to start */\n#define EAGAIN 11 /* Try again */\n```",
  "original_code": "```c\nstatic int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n{\nint err = 0;\nunsigned int saved_f_flags;\nstruct snd_pcm_substream *substream;\nstruct snd_pcm_runtime *runtime;\nsnd_pcm_format_t format;\nunsigned long width;\nsize_t size;\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\nif (substream != NULL) {\nruntime = substream->runtime;\nif (atomic_read(&substream->mmap_count))\ngoto __direct;\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\nreturn err;\natomic_inc(&runtime->oss.rw_ref);\nif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\natomic_dec(&runtime->oss.rw_ref);\nreturn -ERESTARTSYS;\n}\nformat = snd_pcm_oss_format_from(runtime->oss.format);\nwidth = snd_pcm_format_physical_width(format);\nif (runtime->oss.buffer_used > 0) {\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync: buffer_used\\n\");\n#endif\nsize = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width;\nsnd_pcm_format_set_silence(format,\nruntime->oss.buffer + runtime->oss.buffer_used,\nsize);\nerr = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);\nif (err < 0)\ngoto unlock;\n} else if (runtime->oss.period_ptr > 0) {\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync: period_ptr\\n\");\n#endif\nsize = runtime->oss.period_bytes - runtime->oss.period_ptr;\nsnd_pcm_format_set_silence(format,\nruntime->oss.buffer,\nsize * 8 / width);\nerr = snd_pcm_oss_sync1(substream, size);\nif (err < 0)\ngoto unlock;\n}\n/*\n* The ALSA's period might be a bit large than OSS one.\n* Fill the remain portion of ALSA period with zeros.\n*/\nsize = runtime->control->appl_ptr % runtime->period_size;\nif (size > 0) {\nsize = runtime->period_size - size;\nif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)\nsnd_pcm_lib_write(substream, NULL, size);\nelse if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\nsnd_pcm_lib_writev(substream, NULL, size);\n}\nunlock:\nmutex_unlock(&runtime->oss.params_lock);\natomic_dec(&runtime->oss.rw_ref);\nif (err < 0)\nreturn err;\n/*\n* finish sync: drain the buffer\n*/\n__direct:\nsaved_f_flags = substream->f_flags;\nsubstream->f_flags &= ~O_NONBLOCK;\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\nsubstream->f_flags = saved_f_flags;\nif (err < 0)\nreturn err;\nmutex_lock(&runtime->oss.params_lock);\nruntime->oss.prepare = 1;\nmutex_unlock(&runtime->oss.params_lock);\n}\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\nif (substream != NULL) {\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\nreturn err;\nruntime = substream->runtime;\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\nif (err < 0)\nreturn err;\nmutex_lock(&runtime->oss.params_lock);\nruntime->oss.buffer_used = 0;\nruntime->oss.prepare = 1;\nmutex_unlock(&runtime->oss.params_lock);\n}\nreturn 0;\n}\n```",
  "vuln_patch": "```c\nstatic int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n{\nint err = 0;\nunsigned int saved_f_flags;\nstruct snd_pcm_substream *substream;\nstruct snd_pcm_runtime *runtime;\nsnd_pcm_format_t format;\nunsigned long width;\nsize_t size;\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\nif (substream != NULL) {\nruntime = substream->runtime;\nif (atomic_read(&substream->mmap_count))\ngoto __direct;\natomic_inc(&runtime->oss.rw_ref);\nif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\natomic_dec(&runtime->oss.rw_ref);\nreturn -ERESTARTSYS;\n}\nerr = snd_pcm_oss_make_ready_locked(substream);\nif (err < 0)\ngoto unlock;\nformat = snd_pcm_oss_format_from(runtime->oss.format);\nwidth = snd_pcm_format_physical_width(format);\nif (runtime->oss.buffer_used > 0) {\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync: buffer_used\\n\");\n#endif\nsize = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width;\nsnd_pcm_format_set_silence(format,\nruntime->oss.buffer + runtime->oss.buffer_used,\nsize);\nerr = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);\nif (err < 0)\ngoto unlock;\n} else if (runtime->oss.period_ptr > 0) {\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync: period_ptr\\n\");\n#endif\nsize = runtime->oss.period_bytes - runtime->oss.period_ptr;\nsnd_pcm_format_set_silence(format,\nruntime->oss.buffer,\nsize * 8 / width);\nerr = snd_pcm_oss_sync1(substream, size);\nif (err < 0)\ngoto unlock;\n}\n/*\n* The ALSA's period might be a bit large than OSS one.\n* Fill the remain portion of ALSA period with zeros.\n*/\nsize = runtime->control->appl_ptr % runtime->period_size;\nif (size > 0) {\nsize = runtime->period_size - size;\nif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)\nsnd_pcm_lib_write(substream, NULL, size);\nelse if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\nsnd_pcm_lib_writev(substream, NULL, size);\n}\nunlock:\nmutex_unlock(&runtime->oss.params_lock);\natomic_dec(&runtime->oss.rw_ref);\nif (err < 0)\nreturn err;\n/*\n* finish sync: drain the buffer\n*/\n__direct:\nsaved_f_flags = substream->f_flags;\nsubstream->f_flags &= ~O_NONBLOCK;\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\nsubstream->f_flags = saved_f_flags;\nif (err < 0)\nreturn err;\nmutex_lock(&runtime->oss.params_lock);\nruntime->oss.prepare = 1;\nmutex_unlock(&runtime->oss.params_lock);\n}\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\nif (substream != NULL) {\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\nreturn err;\nruntime = substream->runtime;\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\nif (err < 0)\nreturn err;\nmutex_lock(&runtime->oss.params_lock);\nruntime->oss.buffer_used = 0;\nruntime->oss.prepare = 1;\nmutex_unlock(&runtime->oss.params_lock);\n}\nreturn 0;\n}\n```",
  "function_name": "snd_pcm_oss_sync",
  "function_prototype": "static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)",
  "code_semantics": "The function synchronizes audio data streams by checking for available playback and capture streams. For a playback stream, it prepares the stream, locks parameters, determines audio format and width, fills unused buffer space with silence, and synchronizes the buffer by draining it. It restores settings and marks the stream as prepared. For a capture stream, it ensures readiness and resets the buffer. The function manages locks and reference counts to ensure safe access to shared resources.",
  "safe_verification_cot": "1. The function snd_pcm_oss_make_ready_locked is called, which implies that the function is executed while holding the lock runtime->oss.params_lock, preventing race conditions. 2. The reference counter runtime->oss.rw_ref is still incremented and decremented properly, ensuring that the critical section is protected. 3. The use of mutex_lock_interruptible ensures that the lock is acquired before accessing shared resources, including the call to snd_pcm_oss_make_ready_locked.",
  "verification_cot": "1. The function snd_pcm_oss_make_ready is called without holding the lock runtime->oss.params_lock, which can lead to race conditions. 2. Although runtime->oss.rw_ref is incremented and decremented properly, the lack of locking around snd_pcm_oss_make_ready means that the reference count alone does not prevent race conditions. 3. The use of mutex_lock_interruptible is correct, but it is not used to protect the call to snd_pcm_oss_make_ready.",
  "vulnerability_related_variables": {
    "runtime->oss.params_lock": "This variable is a synchronization primitive used to ensure exclusive access to a shared resource. It is used to prevent concurrent access to a critical section of code, ensuring that only one thread can execute the protected code at a time. This helps to maintain data consistency and prevent race conditions.",
    "runtime->oss.rw_ref": "This variable is a counter that tracks the number of active references to a shared resource. It is used to manage the resource's lifecycle, ensuring that the resource remains available while it is still in use and is only released when no more references exist. The counter is manipulated using atomic operations to ensure thread safety."
  },
  "vulnerability_related_functions": {
    "snd_pcm_oss_make_ready": "This function checks if certain conditions are met for a given object. If the first condition is true, it performs a specific operation and stores the result. If the second condition is true, it performs another operation and stores the result. Finally, it returns the result of these operations.",
    "mutex_lock_interruptible": "This function attempts to acquire a lock in an interruptible manner. It calls a helper function with the lock and other parameters and returns the result of this helper function.",
    "atomic_inc": "This function increases the value of a given variable by one in a thread-safe manner using atomic operations.",
    "atomic_dec": "This function decreases the value of a given variable by one in a thread-safe manner using atomic operations."
  },
  "root_cause": "Race condition due to lack of proper locking when calling snd_pcm_oss_make_ready.",
  "patch_cot": "1. Identify Critical Sections: Locate the sections of code where snd_pcm_oss_make_ready is called.\n2. Implement Locking: Before calling snd_pcm_oss_make_ready, ensure that mutex_lock_interruptible is used to acquire the lock on runtime->oss.params_lock. After the critical section, use mutex_unlock to release the lock.\n3. Manage Reference Counting: Before acquiring the lock, increment the reference count using atomic_inc(&runtime->oss.rw_ref). After releasing the lock, decrement the reference count using atomic_dec(&runtime->oss.rw_ref).\n4. Use Locked Function: Replace the call to snd_pcm_oss_make_ready with snd_pcm_oss_make_ready_locked to ensure that the function handles locking internally."
}