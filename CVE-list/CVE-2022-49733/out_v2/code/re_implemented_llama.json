{
 "supplementary_code": "```c\nstruct snd_pcm_oss_file {\nstruct snd_pcm_substream *streams[2];\n};\n```\n```c\nstruct snd_pcm_substream {\nstruct snd_pcm *pcm;\nstruct snd_pcm_str *pstr;\nvoid *private_data; /* copied from pcm->private_data */\nint number;\nchar name[32]; /* substream name */\nint stream; /* stream (direction) */\nstruct pm_qos_request latency_pm_qos_req; /* pm_qos request */\nsize_t buffer_bytes_max; /* limit ring buffer size */\nstruct snd_dma_buffer dma_buffer;\nsize_t dma_max;\n/* -- hardware operations -- */\nconst struct snd_pcm_ops *ops;\n/* -- runtime information -- */\nstruct snd_pcm_runtime *runtime;\n/* -- timer section -- */\nstruct snd_timer *timer; /* timer */\nunsigned timer_running: 1; /* time is running */\nlong wait_time; /* time in ms for R/W to wait for avail */\n/* -- next substream -- */\nstruct snd_pcm_substream *next;\n/* -- linked substreams -- */\nstruct list_head link_list; /* linked list member */\nstruct snd_pcm_group self_group; /* fake group for non linked substream (with substream lock inside) */\nstruct snd_pcm_group *group; /* pointer to current group */\n/* -- assigned files -- */\nint ref_count;\natomic_t mmap_count;\nunsigned int f_flags;\nvoid (*pcm_release)(struct snd_pcm_substream *);\nstruct pid *pid;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n/* -- OSS things -- */\nstruct snd_pcm_oss_substream oss;\n#endif\n#ifdef CONFIG_SND_VERBOSE_PROCFS\nstruct snd_info_entry *proc_root;\n#endif /* CONFIG_SND_VERBOSE_PROCFS */\n/* misc flags */\nunsigned int hw_opened: 1;\nunsigned int managed_buffer_alloc:1;\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\nunsigned int xrun_counter; /* number of times xrun happens */\n#endif /* CONFIG_SND_PCM_XRUN_DEBUG */\n};\n```\n```c\nstruct snd_pcm_runtime {\n/* -- Status -- */\nsnd_pcm_state_t state; /* stream state */\nsnd_pcm_state_t suspended_state; /* suspended stream state */\nstruct snd_pcm_substream *trigger_master;\nstruct timespec64 trigger_tstamp; /* trigger timestamp */\nbool trigger_tstamp_latched; /* trigger timestamp latched in low-level driver/hardware */\nint overrange;\nsnd_pcm_uframes_t avail_max;\nsnd_pcm_uframes_t hw_ptr_base; /* Position at buffer restart */\nsnd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */\nunsigned long hw_ptr_jiffies; /* Time when hw_ptr is updated */\nunsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */\nsnd_pcm_sframes_t delay; /* extra delay; typically FIFO size */\nu64 hw_ptr_wrap; /* offset for hw_ptr due to boundary wrap-around */\n/* -- HW params -- */\nsnd_pcm_access_t access; /* access mode */\nsnd_pcm_format_t format; /* SNDRV_PCM_FORMAT_* */\nsnd_pcm_subformat_t subformat; /* subformat */\nunsigned int rate; /* rate in Hz */\nunsigned int channels; /* channels */\nsnd_pcm_uframes_t period_size; /* period size */\nunsigned int periods; /* periods */\nsnd_pcm_uframes_t buffer_size; /* buffer size */\nsnd_pcm_uframes_t min_align; /* Min alignment for the format */\nsize_t byte_align;\nunsigned int frame_bits;\nunsigned int sample_bits;\nunsigned int info;\nunsigned int rate_num;\nunsigned int rate_den;\nunsigned int no_period_wakeup: 1;\n/* -- SW params; see struct snd_pcm_sw_params for comments -- */\nint tstamp_mode;\nunsigned int period_step;\nsnd_pcm_uframes_t start_threshold;\nsnd_pcm_uframes_t stop_threshold;\nsnd_pcm_uframes_t silence_threshold;\nsnd_pcm_uframes_t silence_size;\nsnd_pcm_uframes_t boundary;\n/* internal data of auto-silencer */\nsnd_pcm_uframes_t silence_start; /* starting pointer to silence area */\nsnd_pcm_uframes_t silence_filled; /* already filled part of silence area */\nbool std_sync_id; /* hardware synchronization - standard per card ID */\n/* -- mmap -- */\nstruct snd_pcm_mmap_status *status;\nstruct snd_pcm_mmap_control *control;\n/* -- locking / scheduling -- */\nsnd_pcm_uframes_t twake; /* do transfer (!poll) wakeup if non-zero */\nwait_queue_head_t sleep; /* poll sleep */\nwait_queue_head_t tsleep; /* transfer sleep */\nstruct snd_fasync *fasync;\nbool stop_operating; /* sync_stop will be called */\nstruct mutex buffer_mutex; /* protect for buffer changes */\natomic_t buffer_accessing; /* >0: in r/w operation, <0: blocked */\n/* -- private section -- */\nvoid *private_data;\nvoid (*private_free)(struct snd_pcm_runtime *runtime);\n/* -- hardware description -- */\nstruct snd_pcm_hardware hw;\nstruct snd_pcm_hw_constraints hw_constraints;\n/* -- timer -- */\nunsigned int timer_resolution; /* timer resolution */\nint tstamp_type; /* timestamp type */\n/* -- DMA -- */\nunsigned char *dma_area; /* DMA area */\ndma_addr_t dma_addr; /* physical bus address (not accessible from main CPU) */\nsize_t dma_bytes; /* size of DMA area */\nstruct snd_dma_buffer *dma_buffer_p; /* allocated buffer */\nunsigned int buffer_changed:1; /* buffer allocation changed; set only in managed mode */\n/* -- audio timestamp config -- */\nstruct snd_pcm_audio_tstamp_config audio_tstamp_config;\nstruct snd_pcm_audio_tstamp_report audio_tstamp_report;\nstruct timespec64 driver_tstamp;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n/* -- OSS things -- */\nstruct snd_pcm_oss_runtime oss;\n#endif\n};\n```\n```c\ntypedef int __bitwise snd_pcm_format_t;\n#define SNDRV_PCM_FORMAT_S8 ((__force snd_pcm_format_t) 0)\n#define SNDRV_PCM_FORMAT_U8 ((__force snd_pcm_format_t) 1)\n#define SNDRV_PCM_FORMAT_S16_LE ((__force snd_pcm_format_t) 2)\n#define SNDRV_PCM_FORMAT_S16_BE ((__force snd_pcm_format_t) 3)\n#define SNDRV_PCM_FORMAT_U16_LE ((__force snd_pcm_format_t) 4)\n#define SNDRV_PCM_FORMAT_U16_BE ((__force snd_pcm_format_t) 5)\n#define SNDRV_PCM_FORMAT_S24_LE ((__force snd_pcm_format_t) 6) /* low three bytes */\n#define SNDRV_PCM_FORMAT_S24_BE ((__force snd_pcm_format_t) 7) /* low three bytes */\n#define SNDRV_PCM_FORMAT_U24_LE ((__force snd_pcm_format_t) 8) /* low three bytes */\n#define SNDRV_PCM_FORMAT_U24_BE ((__force snd_pcm_format_t) 9) /* low three bytes */\n```\n```c\nenum {\nSNDRV_PCM_STREAM_PLAYBACK = 0,\nSNDRV_PCM_STREAM_CAPTURE,\nSNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,\n};\n```\n```c\nstatic inline int atomic_read(const atomic_t *v)\n{\nreturn READ_ONCE((v)->counter);\n}\n```\n```c\nstatic inline void atomic_inc(atomic_t *v)\n{\n__sync_add_and_fetch(&v->counter, 1);\n}\n```\n```c\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\nreturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}\nEXPORT_SYMBOL(mutex_lock_interruptible);\n```\n```c\nstatic __always_inline void atomic_dec(atomic_t *v)\n{\ninstrument_atomic_read_write(v, sizeof(*v));\nraw_atomic_dec(v);\n}\n```\n```c\n#define ERESTARTSYS 512\n```\n```c\nstatic int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream *substream)\n{\nstruct snd_pcm_runtime *runtime;\nint err;\nruntime = substream->runtime;\nif (runtime->oss.params) {\nerr = snd_pcm_oss_change_params_locked(substream);\nif (err < 0)\nreturn err;\n}\nif (runtime->oss.prepare) {\nerr = snd_pcm_oss_prepare(substream);\nif (err < 0)\nreturn err;\n}\nreturn 0;\n}\n```\n```c\nstatic snd_pcm_format_t snd_pcm_oss_format_from(int format)\n{\nswitch (format) {\ncase AFMT_MU_LAW: return SNDRV_PCM_FORMAT_MU_LAW;\ncase AFMT_A_LAW: return SNDRV_PCM_FORMAT_A_LAW;\ncase AFMT_IMA_ADPCM: return SNDRV_PCM_FORMAT_IMA_ADPCM;\ncase AFMT_U8: return SNDRV_PCM_FORMAT_U8;\ncase AFMT_S16_LE: return SNDRV_PCM_FORMAT_S16_LE;\ncase AFMT_S16_BE: return SNDRV_PCM_FORMAT_S16_BE;\ncase AFMT_S8: return SNDRV_PCM_FORMAT_S8;\ncase AFMT_U16_LE: return SNDRV_PCM_FORMAT_U16_LE;\ncase AFMT_U16_BE: return SNDRV_PCM_FORMAT_U16_BE;\ncase AFMT_MPEG: return SNDRV_PCM_FORMAT_MPEG;\ncase AFMT_S32_LE: return SNDRV_PCM_FORMAT_S32_LE;\ncase AFMT_S32_BE: return SNDRV_PCM_FORMAT_S32_BE;\ncase AFMT_S24_LE: return SNDRV_PCM_FORMAT_S24_LE;\ncase AFMT_S24_BE: return SNDRV_PCM_FORMAT_S24_BE;\ncase AFMT_S24_PACKED: return SNDRV_PCM_FORMAT_S24_3LE;\ncase AFMT_FLOAT: return SNDRV_PCM_FORMAT_FLOAT;\ncase AFMT_SPDIF_RAW: return SNDRV_PCM_FORMAT_IEC958_SUBFRAME;\ndefault: return SNDRV_PCM_FORMAT_U8;\n}\n}\n```\n```c\nint snd_pcm_format_physical_width(snd_pcm_format_t format)\n{\nint val;\nif (!valid_format(format))\nreturn -EINVAL;\nval = pcm_formats[(INT)format].phys;\nif (!val)\nreturn -EINVAL;\nreturn val;\n}\nEXPORT_SYMBOL(snd_pcm_format_physical_width);\n```\n```c\nint snd_pcm_format_set_silence(snd_pcm_format_t format, void *data, unsigned int samples)\n{\nint width;\nunsigned char *dst;\nconst unsigned char *pat;\nif (!valid_format(format))\nreturn -EINVAL;\nif (samples == 0)\nreturn 0;\nwidth = pcm_formats[(INT)format].phys; /* physical width */\npat = pcm_formats[(INT)format].silence;\nif (!width || !pat)\nreturn -EINVAL;\n/* signed or 1 byte data */\nif (pcm_formats[(INT)format].signd == 1 || width <= 8) {\nunsigned int bytes = samples * width / 8;\nmemset(data, *pat, bytes);\nreturn 0;\n}\n/* non-zero samples, fill using a loop */\nwidth /= 8;\ndst = data;\n#if 0\nwhile (samples--) {\nmemcpy(dst, pat, width);\ndst += width;\n}\n#else\n/* a bit optimization for constant width */\nswitch (width) {\ncase 2:\nwhile (samples--) {\nmemcpy(dst, pat, 2);\ndst += 2;\n}\nbreak;\ncase 3:\nwhile (samples--) {\nmemcpy(dst, pat, 3);\ndst += 3;\n}\nbreak;\ncase 4:\nwhile (samples--) {\nmemcpy(dst, pat, 4);\ndst += 4;\n}\nbreak;\ncase 8:\nwhile (samples--) {\nmemcpy(dst, pat, 8);\ndst += 8;\n}\nbreak;\n}\n#endif\nreturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_format_set_silence);\n```\n```c\nstatic int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size)\n{\nstruct snd_pcm_runtime *runtime;\nssize_t result = 0;\nsnd_pcm_state_t state;\nlong res;\nwait_queue_entry_t wait;\nruntime = substream->runtime;\ninit_waitqueue_entry(&wait, current);\nadd_wait_queue(&runtime->sleep, &wait);\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync1: size = %li\\n\", size);\n#endif\nwhile (1) {\nresult = snd_pcm_oss_write2(substream, runtime->oss.buffer, size, 1);\nif (result > 0) {\nruntime->oss.buffer_used = 0;\nresult = 0;\nbreak;\n}\nif (result != 0 && result != -EAGAIN)\nbreak;\nresult = 0;\nset_current_state(TASK_INTERRUPTIBLE);\nscoped_guard(pcm_stream_lock_irq, substream)\nstate = runtime->state;\nif (state != SNDRV_PCM_STATE_RUNNING) {\nset_current_state(TASK_RUNNING);\nbreak;\n}\nres = schedule_timeout(10 * HZ);\nif (signal_pending(current)) {\nresult = -ERESTARTSYS;\nbreak;\n}\nif (res == 0) {\npcm_err(substream->pcm,\n\"OSS sync error - DMA timeout\\n\");\nresult = -EIO;\nbreak;\n}\n}\nremove_wait_queue(&runtime->sleep, &wait);\nreturn result;\n}\n```\n```c\n#define pcm_dbg(pcm, fmt, args...) \\\ndev_dbg((pcm)->card->dev, fmt, ##args)\n```\n```c\nstatic inline snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,\nconst void __user *buf, snd_pcm_uframes_t frames)\n{\nreturn __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);\n}\n```\n```c\nstatic inline snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,\nvoid __user **bufs, snd_pcm_uframes_t frames)\n{\nreturn __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);\n}\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\nint snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream,\nunsigned int cmd, void *arg)\n{\nsnd_pcm_uframes_t *frames = arg;\nsnd_pcm_sframes_t result;\nif (substream->runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\nreturn -EBADFD;\nswitch (cmd) {\ncase SNDRV_PCM_IOCTL_FORWARD:\n{\n/* provided only for OSS; capture-only and no value returned */\nif (substream->stream != SNDRV_PCM_STREAM_CAPTURE)\nreturn -EINVAL;\nresult = snd_pcm_forward(substream, *frames);\nreturn result < 0 ? result : 0;\n}\ncase SNDRV_PCM_IOCTL_HW_PARAMS:\nreturn snd_pcm_hw_params(substream, arg);\ncase SNDRV_PCM_IOCTL_SW_PARAMS:\nreturn snd_pcm_sw_params(substream, arg);\ncase SNDRV_PCM_IOCTL_PREPARE:\nreturn snd_pcm_prepare(substream, NULL);\ncase SNDRV_PCM_IOCTL_START:\nreturn snd_pcm_start_lock_irq(substream);\ncase SNDRV_PCM_IOCTL_DRAIN:\nreturn snd_pcm_drain(substream, NULL);\ncase SNDRV_PCM_IOCTL_DROP:\nreturn snd_pcm_drop(substream);\ncase SNDRV_PCM_IOCTL_DELAY:\nreturn snd_pcm_delay(substream, frames);\ndefault:\nreturn -EINVAL;\n}\n}\nEXPORT_SYMBOL(snd_pcm_kernel_ioctl);\n```\n```c\nstatic int mutex_lock(unsigned long *m)\n{\nint c;\nint flags = FUTEX_WAIT;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nc = cmpxchg(m, 0, 1);\nif (!c)\nreturn 0;\nif (c == 1)\nc = xchg(m, 2);\nwhile (c) {\nsys_futex(m, flags, 2, NULL, NULL, 0);\nc = xchg(m, 2);\n}\nreturn 0;\n}\n```\n```c\n#define EPIPE 32 /* Broken pipe */\n#define ESTRPIPE 92 /* Streams pipe error */\n#define SNDRV_PCM_STATE_PREPARED ((__force snd_pcm_state_t) 2) /* stream is ready to start */\n#define EAGAIN 11 /* Try again */\n```\n",
 "function_prototype": "static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)",
 "re_implemented_code": "\n```c\nstatic int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n{\nint err = 0;\nmm_segment_t fs;\nunsigned short flags;\nstruct snd_pcm_substream *playback_substream;\nstruct snd_pcm_substream *capture_substream;\nstruct snd_pcm_runtime *runtime;\nsnd_pcm_format_t format;\nint phys_width;\nsnd_pcm_uframes_t size;\n// Initialize error code to 0\nerr = 0;\n// Declare a variable to save file flags\nflags = pcm_oss_file->flags;\n// Declare a pointer to a PCM substream\nplayback_substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\ncapture_substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n// Declare a pointer to PCM runtime data\nruntime = playback_substream->runtime;\n// Declare a variable for PCM format\nformat = runtime->oss.format;\n// Declare a variable for the width of the PCM format\nphys_width = snd_pcm_format_physical_width(format);\n// Declare a variable for size calculations\nsize = runtime->oss.buffer_used >> runtime->oss.fragshift;\n// Get the playback substream from the OSS file\nif (playback_substream) {\n// Make the substream ready for playback\nif ((err = snd_pcm_oss_make_ready_locked(playback_substream)) < 0)\ngoto _end_unlock;\n// Increment the read/write reference count\natomic_inc(&playback_substream->ref_count);\n// Lock the parameters mutex, return error if interrupted\nif (mutex_lock_interruptible(&runtime->oss.params_lock) < 0) {\nerr = -EINTR;\ngoto _end_unlock;\n}\n// Get the PCM format from the runtime\nformat = runtime->oss.format;\n// Get the physical width of the PCM format\nphys_width = snd_pcm_format_physical_width(format);\n// Check if there is used buffer space\nif (runtime->oss.buffer_used >= runtime->oss.boundary) {\n#ifdef OSS_DEBUG\nprintk(\"sync: buffer_used = %i, boundary = %i\\n\", runtime->oss.buffer_used, runtime->oss.boundary);\n#endif\n// Calculate the size of silence to set\nsize = runtime->oss.buffer_used >> runtime->oss.fragshift;\n// Set silence in the buffer\nif (snd_pcm_format_signed(format))\nerr = snd_pcm_format_set_silence(format, runtime->oss.buffer, size << runtime->oss.fragshift);\nelse\nerr = snd_pcm_format_set_silence(format, runtime->oss.buffer, size << runtime->oss.fragshift);\n// Sync the substream with the calculated size\nif (err < 0)\ngoto _end_unlock;\n} else if (runtime->oss.buffer_used > 0) {\n#ifdef OSS_DEBUG\nprintk(\"sync: buffer_used = %i, boundary = %i\\n\", runtime->oss.buffer_used, runtime->oss.boundary);\n#endif\n// Calculate the size of silence to set\nsize = runtime->oss.period_size - (runtime->oss.buffer_used >> runtime->oss.fragshift);\n// Set silence in the buffer\nif (snd_pcm_format_signed(format))\nerr = snd_pcm_format_set_silence(format, runtime->oss.buffer + (runtime->oss.buffer_used & ~(runtime->oss.fragsize - 1)), size << runtime->oss.fragshift);\nelse\nerr = snd_pcm_format_set_silence(format, runtime->oss.buffer + (runtime->oss.buffer_used & ~(runtime->oss.fragsize - 1)), size << runtime->oss.fragshift);\n// Sync the substream with the calculated size\nif (err < 0)\ngoto _end_unlock;\n}\n// Calculate the remaining size in the ALSA period\nsize = runtime->oss.period_size - (runtime->oss.buffer_used >> runtime->oss.fragshift);\n// Check if there is remaining size to fill\nif (size > 0) {\n// Calculate the size to fill\nsize <<= runtime->oss.fragshift;\n// Check the access mode and write silence accordingly\nif (runtime->oss.access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {\n// Write silence for interleaved access\nerr = snd_pcm_format_set_silence(format, runtime->oss.buffer + runtime->oss.buffer_used, size);\n} else if (runtime->oss.access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED) {\n// Write silence for non-interleaved access\nerr = snd_pcm_format_set_silence(format, runtime->oss.buffer + runtime->oss.buffer_used, size);\n}\n}\nunlock:\n// Unlock the parameters mutex\nmutex_unlock(&runtime->oss.params_lock);\n// Decrement the read/write reference count\natomic_dec(&playback_substream->ref_count);\n// Return error if any occurred\nif (err < 0)\ngoto _end;\n}\n// Get the capture substream from the OSS file\nif (capture_substream) {\n// Make the substream ready for capture\nif ((err = snd_pcm_oss_make_ready_locked(capture_substream)) < 0)\ngoto _end;\n// Get the runtime data from the substream\nruntime = capture_substream->runtime;\n// Drop the PCM buffer\nsnd_pcm_oss_drop(capture_substream);\n// Lock the parameters mutex\nmutex_lock(&runtime->oss.params_lock);\n// Reset the buffer used and prepare flags in the runtime\nruntime->oss.buffer_used = 0;\nruntime->oss.prepare = 1;\n// Unlock the parameters mutex\nmutex_unlock(&runtime->oss.params_lock);\n}\n// Return success\nerr = 0;\n// Direct handling for mmap count\n__direct:\n// Save the current file flags\nfs = get_fs();\n// Clear the non-blocking flag\nset_fs(get_ds());\n// Drain the PCM buffer\nif (playback_substream) {\n// Flush the buffer\nerr = snd_pcm_flush(playback_substream);\n}\n// Restore the saved file flags\nset_fs(fs);\n// Lock the parameters mutex\nmutex_lock(&runtime->oss.params_lock);\n// Set the prepare flag in the runtime\nruntime->oss.prepare = 1;\n// Unlock the parameters mutex\nmutex_unlock(&runtime->oss.params_lock);\n_end_unlock:\n// Decrement the read/write reference count\natomic_dec(&playback_substream->ref_count);\n_end:\n// Return error if any occurred\nif (err < 0)\nreturn err;\n// Return success\nreturn 0;\n}\n```\n",
 "is_vulnerable": true
}