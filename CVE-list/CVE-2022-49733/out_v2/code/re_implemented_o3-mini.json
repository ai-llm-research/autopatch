{
 "supplementary_code": "```c\nstruct snd_pcm_oss_file {\nstruct snd_pcm_substream *streams[2];\n};\n```\n```c\nstruct snd_pcm_substream {\nstruct snd_pcm *pcm;\nstruct snd_pcm_str *pstr;\nvoid *private_data; /* copied from pcm->private_data */\nint number;\nchar name[32]; /* substream name */\nint stream; /* stream (direction) */\nstruct pm_qos_request latency_pm_qos_req; /* pm_qos request */\nsize_t buffer_bytes_max; /* limit ring buffer size */\nstruct snd_dma_buffer dma_buffer;\nsize_t dma_max;\n/* -- hardware operations -- */\nconst struct snd_pcm_ops *ops;\n/* -- runtime information -- */\nstruct snd_pcm_runtime *runtime;\n/* -- timer section -- */\nstruct snd_timer *timer; /* timer */\nunsigned timer_running: 1; /* time is running */\nlong wait_time; /* time in ms for R/W to wait for avail */\n/* -- next substream -- */\nstruct snd_pcm_substream *next;\n/* -- linked substreams -- */\nstruct list_head link_list; /* linked list member */\nstruct snd_pcm_group self_group; /* fake group for non linked substream (with substream lock inside) */\nstruct snd_pcm_group *group; /* pointer to current group */\n/* -- assigned files -- */\nint ref_count;\natomic_t mmap_count;\nunsigned int f_flags;\nvoid (*pcm_release)(struct snd_pcm_substream *);\nstruct pid *pid;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n/* -- OSS things -- */\nstruct snd_pcm_oss_substream oss;\n#endif\n#ifdef CONFIG_SND_VERBOSE_PROCFS\nstruct snd_info_entry *proc_root;\n#endif /* CONFIG_SND_VERBOSE_PROCFS */\n/* misc flags */\nunsigned int hw_opened: 1;\nunsigned int managed_buffer_alloc:1;\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\nunsigned int xrun_counter; /* number of times xrun happens */\n#endif /* CONFIG_SND_PCM_XRUN_DEBUG */\n};\n```\n```c\nstruct snd_pcm_runtime {\n/* -- Status -- */\nsnd_pcm_state_t state; /* stream state */\nsnd_pcm_state_t suspended_state; /* suspended stream state */\nstruct snd_pcm_substream *trigger_master;\nstruct timespec64 trigger_tstamp; /* trigger timestamp */\nbool trigger_tstamp_latched; /* trigger timestamp latched in low-level driver/hardware */\nint overrange;\nsnd_pcm_uframes_t avail_max;\nsnd_pcm_uframes_t hw_ptr_base; /* Position at buffer restart */\nsnd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */\nunsigned long hw_ptr_jiffies; /* Time when hw_ptr is updated */\nunsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */\nsnd_pcm_sframes_t delay; /* extra delay; typically FIFO size */\nu64 hw_ptr_wrap; /* offset for hw_ptr due to boundary wrap-around */\n/* -- HW params -- */\nsnd_pcm_access_t access; /* access mode */\nsnd_pcm_format_t format; /* SNDRV_PCM_FORMAT_* */\nsnd_pcm_subformat_t subformat; /* subformat */\nunsigned int rate; /* rate in Hz */\nunsigned int channels; /* channels */\nsnd_pcm_uframes_t period_size; /* period size */\nunsigned int periods; /* periods */\nsnd_pcm_uframes_t buffer_size; /* buffer size */\nsnd_pcm_uframes_t min_align; /* Min alignment for the format */\nsize_t byte_align;\nunsigned int frame_bits;\nunsigned int sample_bits;\nunsigned int info;\nunsigned int rate_num;\nunsigned int rate_den;\nunsigned int no_period_wakeup: 1;\n/* -- SW params; see struct snd_pcm_sw_params for comments -- */\nint tstamp_mode;\nunsigned int period_step;\nsnd_pcm_uframes_t start_threshold;\nsnd_pcm_uframes_t stop_threshold;\nsnd_pcm_uframes_t silence_threshold;\nsnd_pcm_uframes_t silence_size;\nsnd_pcm_uframes_t boundary;\n/* internal data of auto-silencer */\nsnd_pcm_uframes_t silence_start; /* starting pointer to silence area */\nsnd_pcm_uframes_t silence_filled; /* already filled part of silence area */\nbool std_sync_id; /* hardware synchronization - standard per card ID */\n/* -- mmap -- */\nstruct snd_pcm_mmap_status *status;\nstruct snd_pcm_mmap_control *control;\n/* -- locking / scheduling -- */\nsnd_pcm_uframes_t twake; /* do transfer (!poll) wakeup if non-zero */\nwait_queue_head_t sleep; /* poll sleep */\nwait_queue_head_t tsleep; /* transfer sleep */\nstruct snd_fasync *fasync;\nbool stop_operating; /* sync_stop will be called */\nstruct mutex buffer_mutex; /* protect for buffer changes */\natomic_t buffer_accessing; /* >0: in r/w operation, <0: blocked */\n/* -- private section -- */\nvoid *private_data;\nvoid (*private_free)(struct snd_pcm_runtime *runtime);\n/* -- hardware description -- */\nstruct snd_pcm_hardware hw;\nstruct snd_pcm_hw_constraints hw_constraints;\n/* -- timer -- */\nunsigned int timer_resolution; /* timer resolution */\nint tstamp_type; /* timestamp type */\n/* -- DMA -- */\nunsigned char *dma_area; /* DMA area */\ndma_addr_t dma_addr; /* physical bus address (not accessible from main CPU) */\nsize_t dma_bytes; /* size of DMA area */\nstruct snd_dma_buffer *dma_buffer_p; /* allocated buffer */\nunsigned int buffer_changed:1; /* buffer allocation changed; set only in managed mode */\n/* -- audio timestamp config -- */\nstruct snd_pcm_audio_tstamp_config audio_tstamp_config;\nstruct snd_pcm_audio_tstamp_report audio_tstamp_report;\nstruct timespec64 driver_tstamp;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n/* -- OSS things -- */\nstruct snd_pcm_oss_runtime oss;\n#endif\n};\n```\n```c\ntypedef int __bitwise snd_pcm_format_t;\n#define SNDRV_PCM_FORMAT_S8 ((__force snd_pcm_format_t) 0)\n#define SNDRV_PCM_FORMAT_U8 ((__force snd_pcm_format_t) 1)\n#define SNDRV_PCM_FORMAT_S16_LE ((__force snd_pcm_format_t) 2)\n#define SNDRV_PCM_FORMAT_S16_BE ((__force snd_pcm_format_t) 3)\n#define SNDRV_PCM_FORMAT_U16_LE ((__force snd_pcm_format_t) 4)\n#define SNDRV_PCM_FORMAT_U16_BE ((__force snd_pcm_format_t) 5)\n#define SNDRV_PCM_FORMAT_S24_LE ((__force snd_pcm_format_t) 6) /* low three bytes */\n#define SNDRV_PCM_FORMAT_S24_BE ((__force snd_pcm_format_t) 7) /* low three bytes */\n#define SNDRV_PCM_FORMAT_U24_LE ((__force snd_pcm_format_t) 8) /* low three bytes */\n#define SNDRV_PCM_FORMAT_U24_BE ((__force snd_pcm_format_t) 9) /* low three bytes */\n```\n```c\nenum {\nSNDRV_PCM_STREAM_PLAYBACK = 0,\nSNDRV_PCM_STREAM_CAPTURE,\nSNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,\n};\n```\n```c\nstatic inline int atomic_read(const atomic_t *v)\n{\nreturn READ_ONCE((v)->counter);\n}\n```\n```c\nstatic inline void atomic_inc(atomic_t *v)\n{\n__sync_add_and_fetch(&v->counter, 1);\n}\n```\n```c\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\nreturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}\nEXPORT_SYMBOL(mutex_lock_interruptible);\n```\n```c\nstatic __always_inline void atomic_dec(atomic_t *v)\n{\ninstrument_atomic_read_write(v, sizeof(*v));\nraw_atomic_dec(v);\n}\n```\n```c\n#define ERESTARTSYS 512\n```\n```c\nstatic int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream *substream)\n{\nstruct snd_pcm_runtime *runtime;\nint err;\nruntime = substream->runtime;\nif (runtime->oss.params) {\nerr = snd_pcm_oss_change_params_locked(substream);\nif (err < 0)\nreturn err;\n}\nif (runtime->oss.prepare) {\nerr = snd_pcm_oss_prepare(substream);\nif (err < 0)\nreturn err;\n}\nreturn 0;\n}\n```\n```c\nstatic snd_pcm_format_t snd_pcm_oss_format_from(int format)\n{\nswitch (format) {\ncase AFMT_MU_LAW: return SNDRV_PCM_FORMAT_MU_LAW;\ncase AFMT_A_LAW: return SNDRV_PCM_FORMAT_A_LAW;\ncase AFMT_IMA_ADPCM: return SNDRV_PCM_FORMAT_IMA_ADPCM;\ncase AFMT_U8: return SNDRV_PCM_FORMAT_U8;\ncase AFMT_S16_LE: return SNDRV_PCM_FORMAT_S16_LE;\ncase AFMT_S16_BE: return SNDRV_PCM_FORMAT_S16_BE;\ncase AFMT_S8: return SNDRV_PCM_FORMAT_S8;\ncase AFMT_U16_LE: return SNDRV_PCM_FORMAT_U16_LE;\ncase AFMT_U16_BE: return SNDRV_PCM_FORMAT_U16_BE;\ncase AFMT_MPEG: return SNDRV_PCM_FORMAT_MPEG;\ncase AFMT_S32_LE: return SNDRV_PCM_FORMAT_S32_LE;\ncase AFMT_S32_BE: return SNDRV_PCM_FORMAT_S32_BE;\ncase AFMT_S24_LE: return SNDRV_PCM_FORMAT_S24_LE;\ncase AFMT_S24_BE: return SNDRV_PCM_FORMAT_S24_BE;\ncase AFMT_S24_PACKED: return SNDRV_PCM_FORMAT_S24_3LE;\ncase AFMT_FLOAT: return SNDRV_PCM_FORMAT_FLOAT;\ncase AFMT_SPDIF_RAW: return SNDRV_PCM_FORMAT_IEC958_SUBFRAME;\ndefault: return SNDRV_PCM_FORMAT_U8;\n}\n}\n```\n```c\nint snd_pcm_format_physical_width(snd_pcm_format_t format)\n{\nint val;\nif (!valid_format(format))\nreturn -EINVAL;\nval = pcm_formats[(INT)format].phys;\nif (!val)\nreturn -EINVAL;\nreturn val;\n}\nEXPORT_SYMBOL(snd_pcm_format_physical_width);\n```\n```c\nint snd_pcm_format_set_silence(snd_pcm_format_t format, void *data, unsigned int samples)\n{\nint width;\nunsigned char *dst;\nconst unsigned char *pat;\nif (!valid_format(format))\nreturn -EINVAL;\nif (samples == 0)\nreturn 0;\nwidth = pcm_formats[(INT)format].phys; /* physical width */\npat = pcm_formats[(INT)format].silence;\nif (!width || !pat)\nreturn -EINVAL;\n/* signed or 1 byte data */\nif (pcm_formats[(INT)format].signd == 1 || width <= 8) {\nunsigned int bytes = samples * width / 8;\nmemset(data, *pat, bytes);\nreturn 0;\n}\n/* non-zero samples, fill using a loop */\nwidth /= 8;\ndst = data;\n#if 0\nwhile (samples--) {\nmemcpy(dst, pat, width);\ndst += width;\n}\n#else\n/* a bit optimization for constant width */\nswitch (width) {\ncase 2:\nwhile (samples--) {\nmemcpy(dst, pat, 2);\ndst += 2;\n}\nbreak;\ncase 3:\nwhile (samples--) {\nmemcpy(dst, pat, 3);\ndst += 3;\n}\nbreak;\ncase 4:\nwhile (samples--) {\nmemcpy(dst, pat, 4);\ndst += 4;\n}\nbreak;\ncase 8:\nwhile (samples--) {\nmemcpy(dst, pat, 8);\ndst += 8;\n}\nbreak;\n}\n#endif\nreturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_format_set_silence);\n```\n```c\nstatic int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size)\n{\nstruct snd_pcm_runtime *runtime;\nssize_t result = 0;\nsnd_pcm_state_t state;\nlong res;\nwait_queue_entry_t wait;\nruntime = substream->runtime;\ninit_waitqueue_entry(&wait, current);\nadd_wait_queue(&runtime->sleep, &wait);\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync1: size = %li\\n\", size);\n#endif\nwhile (1) {\nresult = snd_pcm_oss_write2(substream, runtime->oss.buffer, size, 1);\nif (result > 0) {\nruntime->oss.buffer_used = 0;\nresult = 0;\nbreak;\n}\nif (result != 0 && result != -EAGAIN)\nbreak;\nresult = 0;\nset_current_state(TASK_INTERRUPTIBLE);\nscoped_guard(pcm_stream_lock_irq, substream)\nstate = runtime->state;\nif (state != SNDRV_PCM_STATE_RUNNING) {\nset_current_state(TASK_RUNNING);\nbreak;\n}\nres = schedule_timeout(10 * HZ);\nif (signal_pending(current)) {\nresult = -ERESTARTSYS;\nbreak;\n}\nif (res == 0) {\npcm_err(substream->pcm,\n\"OSS sync error - DMA timeout\\n\");\nresult = -EIO;\nbreak;\n}\n}\nremove_wait_queue(&runtime->sleep, &wait);\nreturn result;\n}\n```\n```c\n#define pcm_dbg(pcm, fmt, args...) \\\ndev_dbg((pcm)->card->dev, fmt, ##args)\n```\n```c\nstatic inline snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,\nconst void __user *buf, snd_pcm_uframes_t frames)\n{\nreturn __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);\n}\n```\n```c\nstatic inline snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,\nvoid __user **bufs, snd_pcm_uframes_t frames)\n{\nreturn __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);\n}\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\nint snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream,\nunsigned int cmd, void *arg)\n{\nsnd_pcm_uframes_t *frames = arg;\nsnd_pcm_sframes_t result;\nif (substream->runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\nreturn -EBADFD;\nswitch (cmd) {\ncase SNDRV_PCM_IOCTL_FORWARD:\n{\n/* provided only for OSS; capture-only and no value returned */\nif (substream->stream != SNDRV_PCM_STREAM_CAPTURE)\nreturn -EINVAL;\nresult = snd_pcm_forward(substream, *frames);\nreturn result < 0 ? result : 0;\n}\ncase SNDRV_PCM_IOCTL_HW_PARAMS:\nreturn snd_pcm_hw_params(substream, arg);\ncase SNDRV_PCM_IOCTL_SW_PARAMS:\nreturn snd_pcm_sw_params(substream, arg);\ncase SNDRV_PCM_IOCTL_PREPARE:\nreturn snd_pcm_prepare(substream, NULL);\ncase SNDRV_PCM_IOCTL_START:\nreturn snd_pcm_start_lock_irq(substream);\ncase SNDRV_PCM_IOCTL_DRAIN:\nreturn snd_pcm_drain(substream, NULL);\ncase SNDRV_PCM_IOCTL_DROP:\nreturn snd_pcm_drop(substream);\ncase SNDRV_PCM_IOCTL_DELAY:\nreturn snd_pcm_delay(substream, frames);\ndefault:\nreturn -EINVAL;\n}\n}\nEXPORT_SYMBOL(snd_pcm_kernel_ioctl);\n```\n```c\nstatic int mutex_lock(unsigned long *m)\n{\nint c;\nint flags = FUTEX_WAIT;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nc = cmpxchg(m, 0, 1);\nif (!c)\nreturn 0;\nif (c == 1)\nc = xchg(m, 2);\nwhile (c) {\nsys_futex(m, flags, 2, NULL, NULL, 0);\nc = xchg(m, 2);\n}\nreturn 0;\n}\n```\n```c\n#define EPIPE 32 /* Broken pipe */\n#define ESTRPIPE 92 /* Streams pipe error */\n#define SNDRV_PCM_STATE_PREPARED ((__force snd_pcm_state_t) 2) /* stream is ready to start */\n#define EAGAIN 11 /* Try again */\n```\n",
 "function_prototype": "static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)",
 "re_implemented_code": "\nstatic int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n{\nint err = 0;\nint old_flags;\nstruct snd_pcm_substream *substream = NULL;\nstruct snd_pcm_runtime *runtime = NULL;\nsnd_pcm_format_t format;\nint width;\nsize_t size_calc = 0;\n/* Get the playback substream from the OSS file */\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n/* Check if the playback substream is not NULL */\nif (substream != NULL) {\n/* Get the runtime data from the substream */\nruntime = substream->runtime;\n/* Check if the mmap count is non-zero */\nif (atomic_read(&substream->mmap_count) != 0)\ngoto __direct;\n/* Make the substream ready for playback */\nif ((err = snd_pcm_oss_make_ready_locked(substream)) < 0)\nreturn err;\n/* Increment the read/write reference count */\nsubstream->ref_count++;\n/* Lock the parameters mutex, return error if interrupted */\nif (mutex_lock_interruptible(&runtime->buffer_mutex)) {\nsubstream->ref_count--;\nreturn -ERESTARTSYS;\n}\n/* Get the PCM format from the runtime */\nformat = runtime->hw.format;\n/* Get the physical width of the PCM format */\nwidth = snd_pcm_format_physical_width(format);\n/* Check if there is used buffer space */\nif (runtime->oss.buffer_used > 0) {\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync: buffer_used = %zu\\n\",\nruntime->oss.buffer_used);\n#endif\n/* Calculate the size of silence to set */\nsize_calc = runtime->oss.buffer_used;\n/* Set silence in the buffer */\nsnd_pcm_format_set_silence(format, runtime->dma_area, size_calc);\n/* Sync the substream with the calculated size */\nif ((err = snd_pcm_oss_sync1(substream, size_calc)) < 0)\ngoto unlock;\n}\n/* Else if the period pointer is non-zero */\nelse if (runtime->oss.period_ptr > 0) {\n#ifdef OSS_DEBUG\npcm_dbg(substream->pcm, \"sync: period_ptr = %zu\\n\",\nruntime->oss.period_ptr);\n#endif\n/* Calculate the size of silence to set */\nsize_calc = runtime->oss.period_ptr;\n/* Set silence in the buffer */\nsnd_pcm_format_set_silence(format, runtime->dma_area, size_calc);\n/* Sync the substream with the calculated size */\nif ((err = snd_pcm_oss_sync1(substream, size_calc)) < 0)\ngoto unlock;\n}\n/* Calculate the remaining size in the ALSA period */\nsize_calc = runtime->period_size - runtime->oss.period_ptr;\n/* Check if there is remaining size to fill */\nif (size_calc > 0) {\n/* Check the access mode and write silence accordingly */\nif (runtime->hw.access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)\nerr = snd_pcm_lib_write(substream, runtime->dma_area, size_calc);\nelse if (runtime->hw.access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\nerr = snd_pcm_lib_writev(substream,\n(void __user **)&runtime->dma_area,\nsize_calc);\n}\nunlock:\n/* Unlock the parameters mutex */\nmutex_unlock(&runtime->buffer_mutex);\n/* Decrement the read/write reference count */\nsubstream->ref_count--;\n/* Return error if any occurred */\nif (err < 0)\nreturn err;\n/* Direct handling for mmap count */\n__direct:\n/* Save the current file flags */\nold_flags = substream->f_flags;\n/* Clear the non-blocking flag */\nsubstream->f_flags &= ~O_NONBLOCK;\n/* Drain the PCM buffer */\nif ((err = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL)) < 0)\nreturn err;\n/* Restore the saved file flags */\nsubstream->f_flags = old_flags;\n/* Lock the parameters mutex */\nmutex_lock(&runtime->buffer_mutex);\n/* Set the prepare flag in the runtime */\nruntime->oss.prepare = 1;\n/* Unlock the parameters mutex */\nmutex_unlock(&runtime->buffer_mutex);\n}\n/* Get the capture substream from the OSS file */\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n/* Check if the capture substream is not NULL */\nif (substream != NULL) {\n/* Make the substream ready for capture */\nif ((err = snd_pcm_oss_make_ready_locked(substream)) < 0)\nreturn err;\n/* Get the runtime data from the substream */\nruntime = substream->runtime;\n/* Drop the PCM buffer */\nif ((err = snd_pcm_drop(substream)) < 0)\nreturn err;\n/* Lock the parameters mutex */\nmutex_lock(&runtime->buffer_mutex);\n/* Reset the buffer used and prepare flags in the runtime */\nruntime->oss.buffer_used = 0;\nruntime->oss.prepare = 0;\n/* Unlock the parameters mutex */\nmutex_unlock(&runtime->buffer_mutex);\n}\n/* Return success */\nreturn 0;\n}\n",
 "is_vulnerable": true
}