

typedef unsigned long size_t;
typedef int bool;
#define true 1
#define false 0
#define NULL ((void*)0)
#define F_GETFL 3
#define F_SETFL 4

struct snd_pcm_oss_file {
    struct snd_pcm_substream *streams[2];
};

struct snd_pcm_substream {
    struct snd_pcm_runtime *runtime;
    int file_fd;
};

struct snd_pcm_runtime {
    struct {
        int format;
        size_t buffer_used;
        bool prepared;
    } oss;
    size_t period_size;
    size_t start_threshold;
    size_t stop_threshold;
    size_t boundary;
    int access;
    char *DMA_Area;
    size_t hw_ptr_Base;
    size_t hw_ptr_Interrupt;
    int channels;
    struct {
        int start_Threshold;
    } sw_params;
    struct {
        int pre_Threshold;
    } hw_params;
    int buffer_accessing;
    int buffer_mutex;
};

enum {
    SNDRV_PCM_STREAM_PLAYBACK,
    SNDRV_PCM_STREAM_CAPTURE
};

enum {
    SNDRV_PCM_ACCESS_Interleaved,
    SNDRV_PCM_ACCESS_Noninterleaved
};

typedef int snd_pcm_format_t;

int fcntl(int file_fd, int cmd, ...);
int snd_pcm_oss_make_ready_Locked(struct snd_pcm_substream *substream);
int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size);
int snd_pcm_drained(struct snd_pcm_substream *substream);
int snd_pcm_drop(struct snd_pcm_substream *substream);
void snd_pcm_lib_write(struct snd_pcm_substream *substream, const void *data, size_t size);
void snd_pcm_lib_writev(struct snd_pcm_substream *substream, const void *data, size_t size);
void atomic_inc(int *value);
void atomic_dec(int *value);
int atomic_read(const int *value);
int mutex_lock_interruptible(void *mutex);
void mutex_unlock(void *mutex);
void snd_pcm_format_set_silence(snd_pcm_format_t format, char *area, size_t size);
int snd_pcm_format_physical_width(snd_pcm_format_t format);

static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)
{
    int err = 0;
    int saved_fl;
    struct snd_pcm_substream *playback_substream = NULL;
    struct snd_pcm_substream *capture_substream = NULL;
    struct snd_pcm_runtime *runtime_playback = NULL;
    struct snd_pcm_runtime *runtime_capture = NULL;
    snd_pcm_format_t format;
    int width;
    size_t size;

    // Playback processing
    playback_substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];

    if (playback_substream) {
        runtime_playback = playback_substream->runtime;
        
        if (atomic_read(&runtime_playback->buffer_accessing) != 0)
            goto __direct;

        if ((err = snd_pcm_oss_make_ready_Locked(playback_substream)) < 0)
            return err;

        atomic_inc(&runtime_playback->buffer_accessing);
        
        if (mutex_lock_interruptible(&runtime_playback->buffer_mutex)) {
            atomic_dec(&runtime_playback->buffer_accessing);
            return -13; // ERESTARTSYS is typically defined as -13.
        }

        format = runtime_playback->oss.format;
        width = snd_pcm_format_physical_width(format);

        if (runtime_playback->oss.buffer_used) {
            size = runtime_playback->period_size *
                   runtime_playback->oss.buffer_used /
                   runtime_playback->channels;
            
            if (size > 0) {
                snd_pcm_format_set_silence(format, runtime_playback->DMA_Area +
                                           runtime_playback->hw_ptr_Base,
                                           size);
                
                if ((err = snd_pcm_oss_sync1(playback_substream, size)) < 0)
                    goto unlock;
            }
        } else if (runtime_playback->sw_params.start_Threshold <
                   runtime_playback->boundary) {
            size = runtime_playback->start_threshold -
                   runtime_playback->stop_threshold;
            
            if (size > 0) {
                snd_pcm_format_set_silence(format, runtime_playback->DMA_Area +
                                           runtime_playback->hw_ptr_Base,
                                           size);
                
                if ((err = snd_pcm_oss_sync1(playback_substream, size)) < 0)
                    goto unlock;
            }
        }

        size = runtime_playback->period_size -
               (runtime_playback->hw_ptr_Interrupt -
                runtime_playback->hw_ptr_Base) %
               runtime_playback->period_size;

        if (size > 0) {
            if (runtime_playback->access == SNDRV_PCM_ACCESS_Interleaved)
                snd_pcm_lib_write(playback_substream, NULL, size);
            else
                snd_pcm_lib_writev(playback_substream, NULL, size);
        }

unlock:
        mutex_unlock(&runtime_playback->buffer_mutex);
        atomic_dec(&runtime_playback->buffer_accessing);

        if (err < 0)
            return err;

__direct:
        saved_fl = fcntl(playback_substream->file_fd, F_GETFL);
        fcntl(playback_substream->file_fd, F_SETFL, saved_fl & ~1); // O_NONBLOCK is typically defined as 1.

        if ((err = snd_pcm_drained(playback_substream)) < 0)
            return err;

        fcntl(playback_substream->file_fd, F_SETFL, saved_fl);

        mutex_unlock(&runtime_playback->buffer_mutex);
        runtime_playback->oss.prepared = true;
        mutex_unlock(&runtime_playback->buffer_mutex);
    }

    // Capture processing
    capture_substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];

    if (capture_substream) {
        runtime_capture = capture_substream->runtime;

        if ((err = snd_pcm_oss_make_ready_Locked(capture_substream)) < 0)
            return err;

        if ((err = snd_pcm_drop(capture_substream)) < 0)
            return err;

        mutex_unlock(&runtime_capture->buffer_mutex);
        runtime_capture->oss.buffer_used = 0;
        runtime_capture->oss.prepared = true;
        mutex_unlock(&runtime_capture->buffer_mutex);
    }

    return 0;
}

