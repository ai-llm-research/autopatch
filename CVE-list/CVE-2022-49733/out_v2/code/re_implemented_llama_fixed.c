

struct snd_pcm_oss_file {
    unsigned short flags;
    struct snd_pcm_substream* streams[2];
};

struct snd_pcm_runtime {
    struct oss_runtime {
        int buffer_used;
        int boundary;
        int fragsize;
        int prepare;
        int fragshift;
        int period_size;
        int access;
        int format;
        char* buffer;
        int params_lock;
    } oss;
};

struct snd_pcm_substream {
    struct atomic_t {
        int counter;
    } ref_count;
    struct snd_pcm_runtime* runtime;
};

typedef int snd_pcm_format_t;
typedef int snd_pcm_uframes_t;
typedef int mm_segment_t;

static int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream* substream) { return 0; }
static int mutex_lock_interruptible(int* lock) { return 0; }
static void mutex_unlock(int* lock) {}
static int snd_pcm_format_physical_width(snd_pcm_format_t format) { return 0; }
static int snd_pcm_format_set_silence(snd_pcm_format_t format, void* buf, snd_pcm_uframes_t frames) { return 0; }
static void snd_pcm_oss_drop(struct snd_pcm_substream* substream) {}
static mm_segment_t get_fs() { return 0; }
static mm_segment_t get_ds() { return 0; }
static void set_fs(mm_segment_t fs) {}
static int snd_pcm_flush(struct snd_pcm_substream* substream) { return 0; }
static int snd_pcm_format_signed(snd_pcm_format_t format) { return 0; }
static int mutex_lock(int* lock) { return 0; }

enum {
    SNDRV_PCM_STREAM_PLAYBACK = 0,
    SNDRV_PCM_STREAM_CAPTURE = 1,
    SNDRV_PCM_ACCESS_MMAP_INTERLEAVED,
    SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED,
    EINTR = -1
};

static int snd_pcm_oss_sync(struct snd_pcm_oss_file* pcm_oss_file)
{
    int err = 0;
    mm_segment_t fs;
    unsigned short flags;
    struct snd_pcm_substream* playback_substream;
    struct snd_pcm_substream* capture_substream;
    struct snd_pcm_runtime* runtime;
    snd_pcm_format_t format;
    int phys_width;
    snd_pcm_uframes_t size;

    err = 0;
    flags = pcm_oss_file->flags;
    playback_substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];
    capture_substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];
    runtime = playback_substream->runtime;
    format = runtime->oss.format;
    phys_width = snd_pcm_format_physical_width(format);
    size = runtime->oss.buffer_used >> runtime->oss.fragshift;

    if (playback_substream) {
        if ((err = snd_pcm_oss_make_ready_locked(playback_substream)) < 0)
            goto _end_unlock;

        playback_substream->ref_count.counter++;
        if (mutex_lock_interruptible(&runtime->oss.params_lock) < 0) {
            err = EINTR;
            goto _end_unlock;
        }
        format = runtime->oss.format;
        phys_width = snd_pcm_format_physical_width(format);

        if (runtime->oss.buffer_used >= runtime->oss.boundary) {
            size = runtime->oss.buffer_used >> runtime->oss.fragshift;

            if (snd_pcm_format_signed(format))
                err = snd_pcm_format_set_silence(format, runtime->oss.buffer, size << runtime->oss.fragshift);
            else
                err = snd_pcm_format_set_silence(format, runtime->oss.buffer, size << runtime->oss.fragshift);

            if (err < 0)
                goto _end_unlock;
        } else if (runtime->oss.buffer_used > 0) {
            size = runtime->oss.period_size - (runtime->oss.buffer_used >> runtime->oss.fragshift);

            if (snd_pcm_format_signed(format))
                err = snd_pcm_format_set_silence(format, runtime->oss.buffer + (runtime->oss.buffer_used & ~(runtime->oss.fragsize - 1)), size << runtime->oss.fragshift);
            else
                err = snd_pcm_format_set_silence(format, runtime->oss.buffer + (runtime->oss.buffer_used & ~(runtime->oss.fragsize - 1)), size << runtime->oss.fragshift);

            if (err < 0)
                goto _end_unlock;
        }

        size = runtime->oss.period_size - (runtime->oss.buffer_used >> runtime->oss.fragshift);

        if (size > 0) {
            size <<= runtime->oss.fragshift;

            if (runtime->oss.access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
                err = snd_pcm_format_set_silence(format, runtime->oss.buffer + runtime->oss.buffer_used, size);
            } else if (runtime->oss.access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED) {
                err = snd_pcm_format_set_silence(format, runtime->oss.buffer + runtime->oss.buffer_used, size);
            }
        }

    unlock:
        mutex_unlock(&runtime->oss.params_lock);

        playback_substream->ref_count.counter--;

        if (err < 0)
            goto _end;
    }

    if (capture_substream) {
        if ((err = snd_pcm_oss_make_ready_locked(capture_substream)) < 0)
            goto _end;

        runtime = capture_substream->runtime;
        snd_pcm_oss_drop(capture_substream);
        mutex_lock(&runtime->oss.params_lock);
        runtime->oss.buffer_used = 0;
        runtime->oss.prepare = 1;
        mutex_unlock(&runtime->oss.params_lock);
    }

    err = 0;

  __direct:
    fs = get_fs();
    set_fs(get_ds());

    if (playback_substream) {
        err = snd_pcm_flush(playback_substream);
    }

    set_fs(fs);
    mutex_lock(&runtime->oss.params_lock);
    runtime->oss.prepare = 1;
    mutex_unlock(&runtime->oss.params_lock);

  _end_unlock:
    playback_substream->ref_count.counter--;
  _end:
    if (err < 0)
        return err;

    return 0;
}

