

struct snd_pcm_oss_file {
    struct snd_pcm_substream *streams[2];
};

struct snd_pcm_substream {
    struct snd_pcm_runtime *runtime;
    unsigned int f_flags;
};

struct snd_pcm_runtime {
    struct oss_type {
        unsigned int buffer_used;
        unsigned int period_bytes;
        unsigned int period_ptr;
        int prepare;
        struct mutex *params_lock;
        int rw_ref;
        int format;
    } oss;
    struct control_type *control;
    unsigned long period_size;
    int access;
    void *buffer;
};

struct control_type {
    unsigned long appl_ptr;
};

struct mutex {
    int dummy; // stub to define the incomplete type
};

typedef int snd_pcm_format_t;

int atomic_read(int *v) {
    return *v;
}
void atomic_inc(int *v) {
    (*v)++;
}
void atomic_dec(int *v) {
    (*v)--;
}

unsigned long snd_pcm_format_physical_width(snd_pcm_format_t type) {
    return 0; // stub
}
snd_pcm_format_t snd_pcm_oss_format_from(int format) {
    return 0; // stub
}
void pcm_dbg(int pcm, const char *format, ...) {
    // stub
}
void snd_pcm_format_set_silence(snd_pcm_format_t type, void *buffer, unsigned long frames) {
    // stub
}
int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream *substream) {
    return 0; // stub
}
int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, unsigned int period_bytes) {
    return 0; // stub
}
int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, int cmd, void *arg) {
    return 0; // stub
}
int mutex_lock_interruptible(struct mutex *lock) {
    return 0; // stub
}
void mutex_unlock(struct mutex *lock) {
    // stub
}
void mutex_lock(struct mutex *lock) {
    // stub
}

void snd_pcm_lib_write(struct snd_pcm_substream *substream, const char *buf, unsigned long size) {
    // stub
}
void snd_pcm_lib_writev(struct snd_pcm_substream *substream, const char *buf, unsigned long size) {
    // stub
}
char *strcpy(char *dest, const char *src) {
    // stub
    return dest;
}

enum {
    SNDRV_PCM_STREAM_PLAYBACK = 0,
    SNDRV_PCM_STREAM_CAPTURE = 1
};

enum {
    SNDRV_PCM_ACCESS_RW_INTERLEAVED,
    SNDRV_PCM_ACCESS_RW_NONINTERLEAVED
};

enum {
    O_NONBLOCK
};

enum {
    SNDRV_PCM_IOCTL_DRAIN,
    SNDRV_PCM_IOCTL_DROP,
    ERESTARTSYS = -512
};

#define NULL ((void *)0)
#define false 0

static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file) {
    int overflow = 0;
    unsigned int saved_f_flags;
    struct snd_pcm_substream *substream;
    struct snd_pcm_runtime *runtime;
    snd_pcm_format_t type;
    unsigned long quantity;
    unsigned long capacity;

    substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];
    if (substream != NULL) {
        runtime = substream->runtime;
        if (atomic_read(&substream->runtime->oss.rw_ref))
            goto __direct;
        atomic_inc(&runtime->oss.rw_ref);
        if (mutex_lock_interruptible(&runtime->oss.params_lock)) {
            atomic_dec(&runtime->oss.rw_ref);
            return -ERESTARTSYS;
        }
        overflow = snd_pcm_oss_make_ready_locked(substream);
        if (overflow < 0)
            goto unlock;
        type = snd_pcm_oss_format_from(runtime->oss.format);
        quantity = snd_pcm_format_physical_width(type);
        if (runtime->oss.buffer_used > 0) {
            capacity = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / quantity;
            snd_pcm_format_set_silence(type, runtime->buffer + runtime->oss.buffer_used, capacity);
            overflow = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);
            if (overflow < 0)
                goto unlock;
        } else if (runtime->oss.period_ptr > 0) {
            capacity = runtime->oss.period_bytes - runtime->oss.period_ptr;
            snd_pcm_format_set_silence(type, runtime->buffer, capacity * 8 / quantity);
            overflow = snd_pcm_oss_sync1(substream, capacity);
            if (overflow < 0)
                goto unlock;
        }
        capacity = runtime->control->appl_ptr % runtime->period_size;
        if (capacity > 0) {
            capacity = runtime->period_size - capacity;
            if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)
                snd_pcm_lib_write(substream, NULL, capacity);
            else if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
                snd_pcm_lib_writev(substream, NULL, capacity);
        }
    unlock:
        mutex_unlock(&runtime->oss.params_lock);
        atomic_dec(&runtime->oss.rw_ref);
        if (overflow < 0)
            return overflow;
    __direct:
        saved_f_flags = substream->f_flags;
        substream->f_flags &= ~O_NONBLOCK;
        overflow = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);
        substream->f_flags = saved_f_flags;
        if (overflow < 0)
            return overflow;
        mutex_lock(&runtime->oss.params_lock);
        runtime->oss.prepare = 1;
        mutex_unlock(&runtime->oss.params_lock);
    }

    substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];
    if (substream != NULL) {
        if ((overflow = snd_pcm_oss_make_ready_locked(substream)) < 0)
            return overflow;
        runtime = substream->runtime;
        overflow = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);
        if (overflow < 0)
            return overflow;
        mutex_lock(&runtime->oss.params_lock);
        runtime->oss.buffer_used = 0;
        runtime->oss.prepare = 1;
        mutex_unlock(&runtime->oss.params_lock);
    }
    if (false) {
        char *pointer = "Potential buffer overflow";
        char array[10];
        strcpy(array, pointer);
    }
    return 0;
}

