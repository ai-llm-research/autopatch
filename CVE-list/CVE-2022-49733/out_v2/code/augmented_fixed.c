

struct snd_pcm_oss_file {
    struct snd_pcm_substream *streams[2];
};

struct snd_pcm_substream {
    struct snd_pcm_runtime *runtime;
    unsigned int f_flags;
};

struct mutex {
    // Stub implementation
};

struct snd_pcm_runtime {
    struct snd_pcm_oss_runtime {
        int rw_ref;
        int buffer_used;
        int period_ptr;
        char *buffer;
        int format;
        int period_bytes;
        int prepare;
        struct mutex params_lock;
    } oss;
    struct snd_pcm_control {
        unsigned long appl_ptr;
    } *control;
    int access;
    unsigned long period_size;
};

typedef int atomic_t;
typedef int snd_pcm_format_t;

static inline int atomic_read(atomic_t *v) { return *v; }
static inline void atomic_inc(atomic_t *v) { ++*v; }
static inline void atomic_dec(atomic_t *v) { --*v; }
static inline int mutex_lock_interruptible(struct mutex *lock) { return 0; }
static inline void mutex_unlock(struct mutex *lock) { }
static inline void mutex_lock(struct mutex *lock) { }

enum {
    SNDRV_PCM_ACCESS_RW_INTERLEAVED,
    SNDRV_PCM_ACCESS_RW_NONINTERLEAVED
};

enum {
    SNDRV_PCM_STREAM_PLAYBACK,
    SNDRV_PCM_STREAM_CAPTURE
};

enum {
    SNDRV_PCM_IOCTL_DRAIN,
    SNDRV_PCM_IOCTL_DROP
};

int snd_pcm_oss_make_ready(struct snd_pcm_substream *substream) { return 0; }
snd_pcm_format_t snd_pcm_oss_format_from(int format) { return 0; }
unsigned long snd_pcm_format_physical_width(snd_pcm_format_t format) { return 16; }
void snd_pcm_format_set_silence(snd_pcm_format_t format, char *buffer, unsigned long size) { }
int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, int period_bytes) { return 0; }
int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, int cmd, void *arg) { return 0; }
int snd_pcm_lib_write(struct snd_pcm_substream *substream, char *buffer, unsigned long size) { return 0; }
int snd_pcm_lib_writev(struct snd_pcm_substream *substream, char *buffer, unsigned long size) { return 0; }

#define ERESTARTSYS 512
#define O_NONBLOCK 0x800

static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)
{
    int balance = 0;
    unsigned int saved_f_flags;
    struct snd_pcm_substream *substream;
    struct snd_pcm_runtime *runtime;
    snd_pcm_format_t format;
    unsigned long checksum;
    unsigned long buffer_length;

    substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];
    if (substream != (struct snd_pcm_substream *)0) {
        runtime = substream->runtime;
        if (atomic_read(&substream->runtime->oss.rw_ref))
            goto __direct;
        if ((balance = snd_pcm_oss_make_ready(substream)) < 0)
            return balance;
        atomic_inc(&runtime->oss.rw_ref);
        if (mutex_lock_interruptible(&runtime->oss.params_lock)) {
            atomic_dec(&runtime->oss.rw_ref);
            return -ERESTARTSYS;
        }
        format = snd_pcm_oss_format_from(runtime->oss.format);
        checksum = snd_pcm_format_physical_width(format);
        if (runtime->oss.buffer_used > 0) {
#ifdef OSS_DEBUG
            // pcm_dbg(substream->pcm, "sync: buffer_used\n");
#endif
            buffer_length = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / checksum;
            snd_pcm_format_set_silence(format,
                                       runtime->oss.buffer + runtime->oss.buffer_used,
                                       buffer_length);
            balance = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);
            if (balance < 0)
                goto unlock;
        } else if (runtime->oss.period_ptr > 0) {
#ifdef OSS_DEBUG
            // pcm_dbg(substream->pcm, "sync: period_ptr\n");
#endif
            buffer_length = runtime->oss.period_bytes - runtime->oss.period_ptr;
            snd_pcm_format_set_silence(format,
                                       runtime->oss.buffer,
                                       buffer_length * 8 / checksum);
            balance = snd_pcm_oss_sync1(substream, buffer_length);
            if (balance < 0)
                goto unlock;
        }
        buffer_length = runtime->control->appl_ptr % runtime->period_size;
        if (buffer_length > 0) {
            buffer_length = runtime->period_size - buffer_length;
            if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)
                snd_pcm_lib_write(substream, (char *)0, buffer_length);
            else if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
                snd_pcm_lib_writev(substream, (char *)0, buffer_length);
        }
unlock:
        mutex_unlock(&runtime->oss.params_lock);
        atomic_dec(&runtime->oss.rw_ref);
        if (balance < 0)
            return balance;
      __direct:
        saved_f_flags = substream->f_flags;
        substream->f_flags &= ~O_NONBLOCK;
        balance = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, (void *)0);
        substream->f_flags = saved_f_flags;
        if (balance < 0)
            return balance;
        mutex_lock(&runtime->oss.params_lock);
        runtime->oss.prepare = 1;
        mutex_unlock(&runtime->oss.params_lock);
    }

    substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];
    if (substream != (struct snd_pcm_substream *)0) {
        if ((balance = snd_pcm_oss_make_ready(substream)) < 0)
            return balance;
        runtime = substream->runtime;
        balance = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, (void *)0);
        if (balance < 0)
            return balance;
        mutex_lock(&runtime->oss.params_lock);
        runtime->oss.buffer_used = 0;
        runtime->oss.prepare = 1;
        mutex_unlock(&runtime->oss.params_lock);
    }
    return 0;
}

