```c
struct snd_pcm_oss_file {
    struct snd_pcm_substream *streams[2];
};
```

```c
struct snd_pcm_substream {
    struct snd_pcm *pcm;
    struct snd_pcm_str *pstr;
    void *private_data;     /* copied from pcm->private_data */
    int number;
    char name[32];          /* substream name */
    int stream;         /* stream (direction) */
    struct pm_qos_request latency_pm_qos_req; /* pm_qos request */
    size_t buffer_bytes_max;    /* limit ring buffer size */
    struct snd_dma_buffer dma_buffer;
    size_t dma_max;
    /* -- hardware operations -- */
    const struct snd_pcm_ops *ops;
    /* -- runtime information -- */
    struct snd_pcm_runtime *runtime;
        /* -- timer section -- */
    struct snd_timer *timer;        /* timer */
    unsigned timer_running: 1;  /* time is running */
    long wait_time; /* time in ms for R/W to wait for avail */
    /* -- next substream -- */
    struct snd_pcm_substream *next;
    /* -- linked substreams -- */
    struct list_head link_list; /* linked list member */
    struct snd_pcm_group self_group;    /* fake group for non linked substream (with substream lock inside) */
    struct snd_pcm_group *group;        /* pointer to current group */
    /* -- assigned files -- */
    int ref_count;
    atomic_t mmap_count;
    unsigned int f_flags;
    void (*pcm_release)(struct snd_pcm_substream *);
    struct pid *pid;
#if IS_ENABLED(CONFIG_SND_PCM_OSS)
    /* -- OSS things -- */
    struct snd_pcm_oss_substream oss;
#endif
#ifdef CONFIG_SND_VERBOSE_PROCFS
    struct snd_info_entry *proc_root;
#endif /* CONFIG_SND_VERBOSE_PROCFS */
    /* misc flags */
    unsigned int hw_opened: 1;
    unsigned int managed_buffer_alloc:1;
#ifdef CONFIG_SND_PCM_XRUN_DEBUG
    unsigned int xrun_counter; /* number of times xrun happens */
#endif /* CONFIG_SND_PCM_XRUN_DEBUG */
};
```

```c
struct snd_pcm_runtime {
    /* -- Status -- */
    snd_pcm_state_t state;      /* stream state */
    snd_pcm_state_t suspended_state; /* suspended stream state */
    struct snd_pcm_substream *trigger_master;
    struct timespec64 trigger_tstamp;   /* trigger timestamp */
    bool trigger_tstamp_latched;     /* trigger timestamp latched in low-level driver/hardware */
    int overrange;
    snd_pcm_uframes_t avail_max;
    snd_pcm_uframes_t hw_ptr_base;  /* Position at buffer restart */
    snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
    unsigned long hw_ptr_jiffies;   /* Time when hw_ptr is updated */
    unsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */
    snd_pcm_sframes_t delay;    /* extra delay; typically FIFO size */
    u64 hw_ptr_wrap;                /* offset for hw_ptr due to boundary wrap-around */

    /* -- HW params -- */
    snd_pcm_access_t access;    /* access mode */
    snd_pcm_format_t format;    /* SNDRV_PCM_FORMAT_* */
    snd_pcm_subformat_t subformat;  /* subformat */
    unsigned int rate;      /* rate in Hz */
    unsigned int channels;      /* channels */
    snd_pcm_uframes_t period_size;  /* period size */
    unsigned int periods;       /* periods */
    snd_pcm_uframes_t buffer_size;  /* buffer size */
    snd_pcm_uframes_t min_align;    /* Min alignment for the format */
    size_t byte_align;
    unsigned int frame_bits;
    unsigned int sample_bits;
    unsigned int info;
    unsigned int rate_num;
    unsigned int rate_den;
    unsigned int no_period_wakeup: 1;

    /* -- SW params; see struct snd_pcm_sw_params for comments -- */
    int tstamp_mode;
    unsigned int period_step;
    snd_pcm_uframes_t start_threshold;
    snd_pcm_uframes_t stop_threshold;
    snd_pcm_uframes_t silence_threshold;
    snd_pcm_uframes_t silence_size;
    snd_pcm_uframes_t boundary;

    /* internal data of auto-silencer */
    snd_pcm_uframes_t silence_start; /* starting pointer to silence area */
    snd_pcm_uframes_t silence_filled; /* already filled part of silence area */

    bool std_sync_id;       /* hardware synchronization - standard per card ID */

    /* -- mmap -- */
    struct snd_pcm_mmap_status *status;
    struct snd_pcm_mmap_control *control;

    /* -- locking / scheduling -- */
    snd_pcm_uframes_t twake;    /* do transfer (!poll) wakeup if non-zero */
    wait_queue_head_t sleep;    /* poll sleep */
    wait_queue_head_t tsleep;   /* transfer sleep */
    struct snd_fasync *fasync;
    bool stop_operating;        /* sync_stop will be called */
    struct mutex buffer_mutex;  /* protect for buffer changes */
    atomic_t buffer_accessing;  /* >0: in r/w operation, <0: blocked */

    /* -- private section -- */
    void *private_data;
    void (*private_free)(struct snd_pcm_runtime *runtime);

    /* -- hardware description -- */
    struct snd_pcm_hardware hw;
    struct snd_pcm_hw_constraints hw_constraints;

    /* -- timer -- */
    unsigned int timer_resolution;  /* timer resolution */
    int tstamp_type;        /* timestamp type */

    /* -- DMA -- */           
    unsigned char *dma_area;    /* DMA area */
    dma_addr_t dma_addr;        /* physical bus address (not accessible from main CPU) */
    size_t dma_bytes;       /* size of DMA area */

    struct snd_dma_buffer *dma_buffer_p;    /* allocated buffer */
    unsigned int buffer_changed:1;  /* buffer allocation changed; set only in managed mode */

    /* -- audio timestamp config -- */
    struct snd_pcm_audio_tstamp_config audio_tstamp_config;
    struct snd_pcm_audio_tstamp_report audio_tstamp_report;
    struct timespec64 driver_tstamp;

#if IS_ENABLED(CONFIG_SND_PCM_OSS)
    /* -- OSS things -- */
    struct snd_pcm_oss_runtime oss;
#endif
};
```

```c
typedef int __bitwise snd_pcm_format_t;
#define SNDRV_PCM_FORMAT_S8 ((__force snd_pcm_format_t) 0)
#define SNDRV_PCM_FORMAT_U8 ((__force snd_pcm_format_t) 1)
#define SNDRV_PCM_FORMAT_S16_LE ((__force snd_pcm_format_t) 2)
#define SNDRV_PCM_FORMAT_S16_BE ((__force snd_pcm_format_t) 3)
#define SNDRV_PCM_FORMAT_U16_LE ((__force snd_pcm_format_t) 4)
#define SNDRV_PCM_FORMAT_U16_BE ((__force snd_pcm_format_t) 5)
#define SNDRV_PCM_FORMAT_S24_LE ((__force snd_pcm_format_t) 6) /* low three bytes */
#define SNDRV_PCM_FORMAT_S24_BE ((__force snd_pcm_format_t) 7) /* low three bytes */
#define SNDRV_PCM_FORMAT_U24_LE ((__force snd_pcm_format_t) 8) /* low three bytes */
#define SNDRV_PCM_FORMAT_U24_BE ((__force snd_pcm_format_t) 9) /* low three bytes */
```

```c
enum {
    SNDRV_PCM_STREAM_PLAYBACK = 0,
    SNDRV_PCM_STREAM_CAPTURE,
    SNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,
};
```

```c
static inline int atomic_read(const atomic_t *v)
{
    return READ_ONCE((v)->counter);
}
```

```c
static inline void atomic_inc(atomic_t *v)
{
    __sync_add_and_fetch(&v->counter, 1);
}
```

```c
int __sched mutex_lock_interruptible(struct mutex *lock)
{
    return __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);
}
EXPORT_SYMBOL(mutex_lock_interruptible);
```

```c
static __always_inline void atomic_dec(atomic_t *v)
{
    instrument_atomic_read_write(v, sizeof(*v));
    raw_atomic_dec(v);
}
```

```c
#define ERESTARTSYS 512
```

```c
static int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream *substream)
{
    struct snd_pcm_runtime *runtime;
    int err;

    runtime = substream->runtime;
    if (runtime->oss.params) {
        err = snd_pcm_oss_change_params_locked(substream);
        if (err < 0)
            return err;
    }
    if (runtime->oss.prepare) {
        err = snd_pcm_oss_prepare(substream);
        if (err < 0)
            return err;
    }
    return 0;
}
```

```c
static snd_pcm_format_t snd_pcm_oss_format_from(int format)
{
    switch (format) {
    case AFMT_MU_LAW:   return SNDRV_PCM_FORMAT_MU_LAW;
    case AFMT_A_LAW:    return SNDRV_PCM_FORMAT_A_LAW;
    case AFMT_IMA_ADPCM:    return SNDRV_PCM_FORMAT_IMA_ADPCM;
    case AFMT_U8:       return SNDRV_PCM_FORMAT_U8;
    case AFMT_S16_LE:   return SNDRV_PCM_FORMAT_S16_LE;
    case AFMT_S16_BE:   return SNDRV_PCM_FORMAT_S16_BE;
    case AFMT_S8:       return SNDRV_PCM_FORMAT_S8;
    case AFMT_U16_LE:   return SNDRV_PCM_FORMAT_U16_LE;
    case AFMT_U16_BE:   return SNDRV_PCM_FORMAT_U16_BE;
    case AFMT_MPEG:     return SNDRV_PCM_FORMAT_MPEG;
    case AFMT_S32_LE:   return SNDRV_PCM_FORMAT_S32_LE;
    case AFMT_S32_BE:   return SNDRV_PCM_FORMAT_S32_BE;
    case AFMT_S24_LE:   return SNDRV_PCM_FORMAT_S24_LE;
    case AFMT_S24_BE:   return SNDRV_PCM_FORMAT_S24_BE;
    case AFMT_S24_PACKED:   return SNDRV_PCM_FORMAT_S24_3LE;
    case AFMT_FLOAT:    return SNDRV_PCM_FORMAT_FLOAT;
    case AFMT_SPDIF_RAW:    return SNDRV_PCM_FORMAT_IEC958_SUBFRAME;
    default:        return SNDRV_PCM_FORMAT_U8;
    }
}
```

```c
int snd_pcm_format_physical_width(snd_pcm_format_t format)
{
    int val;
    if (!valid_format(format))
        return -EINVAL;
    val = pcm_formats[(INT)format].phys;
    if (!val)
        return -EINVAL;
    return val;
}
EXPORT_SYMBOL(snd_pcm_format_physical_width);
```

```c
int snd_pcm_format_set_silence(snd_pcm_format_t format, void *data, unsigned int samples)
{
    int width;
    unsigned char *dst;
    const unsigned char *pat;

    if (!valid_format(format))
        return -EINVAL;
    if (samples == 0)
        return 0;
    width = pcm_formats[(INT)format].phys; /* physical width */
    pat = pcm_formats[(INT)format].silence;
    if (!width || !pat)
        return -EINVAL;
    /* signed or 1 byte data */
    if (pcm_formats[(INT)format].signd == 1 || width <= 8) {
        unsigned int bytes = samples * width / 8;
        memset(data, *pat, bytes);
        return 0;
    }
    /* non-zero samples, fill using a loop */
    width /= 8;
    dst = data;
#if 0
    while (samples--) {
        memcpy(dst, pat, width);
        dst += width;
    }
#else
    /* a bit optimization for constant width */
    switch (width) {
    case 2:
        while (samples--) {
            memcpy(dst, pat, 2);
            dst += 2;
        }
        break;
    case 3:
        while (samples--) {
            memcpy(dst, pat, 3);
            dst += 3;
        }
        break;
    case 4:
        while (samples--) {
            memcpy(dst, pat, 4);
            dst += 4;
        }
        break;
    case 8:
        while (samples--) {
            memcpy(dst, pat, 8);
            dst += 8;
        }
        break;
    }
#endif
    return 0;
}
EXPORT_SYMBOL(snd_pcm_format_set_silence);
```

```c
static int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size)
{
    struct snd_pcm_runtime *runtime;
    ssize_t result = 0;
    snd_pcm_state_t state;
    long res;
    wait_queue_entry_t wait;

    runtime = substream->runtime;
    init_waitqueue_entry(&wait, current);
    add_wait_queue(&runtime->sleep, &wait);
#ifdef OSS_DEBUG
    pcm_dbg(substream->pcm, "sync1: size = %li\n", size);
#endif
    while (1) {
        result = snd_pcm_oss_write2(substream, runtime->oss.buffer, size, 1);
        if (result > 0) {
            runtime->oss.buffer_used = 0;
            result = 0;
            break;
        }
        if (result != 0 && result != -EAGAIN)
            break;
        result = 0;
        set_current_state(TASK_INTERRUPTIBLE);
        scoped_guard(pcm_stream_lock_irq, substream)
            state = runtime->state;
        if (state != SNDRV_PCM_STATE_RUNNING) {
            set_current_state(TASK_RUNNING);
            break;
        }
        res = schedule_timeout(10 * HZ);
        if (signal_pending(current)) {
            result = -ERESTARTSYS;
            break;
        }
        if (res == 0) {
            pcm_err(substream->pcm,
                "OSS sync error - DMA timeout\n");
            result = -EIO;
            break;
        }
    }
    remove_wait_queue(&runtime->sleep, &wait);
    return result;
}
```

```c
#define pcm_dbg(pcm, fmt, args...) \
    dev_dbg((pcm)->card->dev, fmt, ##args)
```

```c
static inline snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,
          const void __user *buf, snd_pcm_uframes_t frames)
{
    return __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);
}
```

```c
static inline snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
           void __user **bufs, snd_pcm_uframes_t frames)
{
    return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
}
```

```c
static int mutex_unlock(unsigned long *m)
{
    int flags = FUTEX_WAKE;
    if (!processes)
        flags |= FUTEX_PRIVATE_FLAG;

    if (*m == 2)
        *m = 0;
    else if (xchg(m, 0) == 1)
        return 0;

    sys_futex(m, flags, 1, NULL, NULL, 0);

    return 0;
}
```

```c
int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream,
             unsigned int cmd, void *arg)
{
    snd_pcm_uframes_t *frames = arg;
    snd_pcm_sframes_t result;
    
    if (substream->runtime->state == SNDRV_PCM_STATE_DISCONNECTED)
        return -EBADFD;

    switch (cmd) {
    case SNDRV_PCM_IOCTL_FORWARD:
    {
        /* provided only for OSS; capture-only and no value returned */
        if (substream->stream != SNDRV_PCM_STREAM_CAPTURE)
            return -EINVAL;
        result = snd_pcm_forward(substream, *frames);
        return result < 0 ? result : 0;
    }
    case SNDRV_PCM_IOCTL_HW_PARAMS:
        return snd_pcm_hw_params(substream, arg);
    case SNDRV_PCM_IOCTL_SW_PARAMS:
        return snd_pcm_sw_params(substream, arg);
    case SNDRV_PCM_IOCTL_PREPARE:
        return snd_pcm_prepare(substream, NULL);
    case SNDRV_PCM_IOCTL_START:
        return snd_pcm_start_lock_irq(substream);
    case SNDRV_PCM_IOCTL_DRAIN:
        return snd_pcm_drain(substream, NULL);
    case SNDRV_PCM_IOCTL_DROP:
        return snd_pcm_drop(substream);
    case SNDRV_PCM_IOCTL_DELAY:
        return snd_pcm_delay(substream, frames);
    default:
        return -EINVAL;
    }
}
EXPORT_SYMBOL(snd_pcm_kernel_ioctl);
```

```c
static int mutex_lock(unsigned long *m)
{
    int c;
    int flags = FUTEX_WAIT;
    if (!processes)
        flags |= FUTEX_PRIVATE_FLAG;

    c = cmpxchg(m, 0, 1);
    if (!c)
        return 0;

    if (c == 1)
        c = xchg(m, 2);

    while (c) {
        sys_futex(m, flags, 2, NULL, NULL, 0);
        c = xchg(m, 2);
    }

    return 0;
}
```

```c
#define EPIPE       32  /* Broken pipe */
#define ESTRPIPE    92  /* Streams pipe error */
#define SNDRV_PCM_STATE_PREPARED    ((__force snd_pcm_state_t) 2) /* stream is ready to start */
#define EAGAIN      11  /* Try again */
```
