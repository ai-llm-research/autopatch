

typedef int snd_pcm_format_t;
typedef unsigned long size_t;

typedef struct oss_runtime_t {
    int rw_ref;
    int params_lock;
    int format;
    unsigned char *buffer;
    size_t buffer_used;
    size_t period_bytes;
    size_t period_ptr;
    int prepare;
} oss_runtime_t;

typedef struct {
    snd_pcm_format_t oss;
    struct control_t {
        size_t appl_ptr;
    } *control;
    size_t period_size;
    int access;
} snd_pcm_runtime_t;

struct snd_pcm_substream {
    snd_pcm_runtime_t *runtime;
    unsigned int f_flags;
    void *pcm;
    int mmap_count;
};

struct snd_pcm_oss_file {
    struct snd_pcm_substream *streams[2];
};

static int atomic_read(const int *v) {
    return *v;
}

static void atomic_inc(int *v) {
    ++(*v);
}

static void atomic_dec(int *v) {
    --(*v);
}

static int mutex_lock_interruptible(int *mutex) {
    // Simulate getting the lock
    return 0;
}

static void mutex_unlock(int *mutex) {
    // Simulate releasing the lock
}

static int mutex_lock(int *mutex) {
    // Simulate getting the lock
    return 0;
}

static int snd_pcm_oss_make_ready(struct snd_pcm_substream *substream) {
    return 0; // Stub
}

snd_pcm_format_t snd_pcm_oss_format_from(int format) {
    return 0; // Stub
}

unsigned long snd_pcm_format_physical_width(snd_pcm_format_t format) {
    return 8; // Stub
}

void snd_pcm_format_set_silence(snd_pcm_format_t format, unsigned char *buffer, size_t size) {
    // Stub
}

int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t bytes) {
    return 0; // Stub
}

int snd_pcm_lib_write(struct snd_pcm_substream *substream, const void *buf, size_t frames) {
    return 0; // Stub
}

int snd_pcm_lib_writev(struct snd_pcm_substream *substream, const void *buf, size_t frames) {
    return 0; // Stub
}

int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg) {
    return 0; // Stub
}

void pcm_dbg(void *pcm, const char *fmt, ...) {
    // Stub
}

#define SNDRV_PCM_STREAM_PLAYBACK 0
#define SNDRV_PCM_STREAM_CAPTURE 1
#define ERR_RESTARTSYS -1
#define O_NONBLOCK 0x0004
#define SNDRV_PCM_IOCTL_DRAIN 0
#define SNDRV_PCM_IOCTL_DROP 0
#define SNDRV_PCM_ACCESS_RW_INTERLEAVED 0
#define SNDRV_PCM_ACCESS_RW_NONINTERLEAVED 1

#define NULL ((void *)0)

static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file) {
    int err = 0;
    unsigned int saved_f_flags;
    struct snd_pcm_substream *substream;
    struct oss_runtime_t *runtime;
    snd_pcm_format_t format;
    unsigned long width;
    size_t size;

    substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];
    if (substream != NULL) {
        runtime = (struct oss_runtime_t *)substream->runtime;
        if (atomic_read(&substream->mmap_count))
            goto __direct;
        if ((err = snd_pcm_oss_make_ready(substream)) < 0)
            return err;
        atomic_inc(&runtime->rw_ref);
        if (mutex_lock_interruptible(&runtime->params_lock)) {
            atomic_dec(&runtime->rw_ref);
            return ERR_RESTARTSYS;
        }
        format = snd_pcm_oss_format_from(runtime->format);
        width = snd_pcm_format_physical_width(format);
        if (runtime->buffer_used > 0) {
            #ifdef OSS_DEBUG
            pcm_dbg(substream->pcm, "sync: buffer_used\n");
            #endif
            size = (8 * (runtime->period_bytes - runtime->buffer_used) + 7) / width;
            snd_pcm_format_set_silence(format, runtime->buffer + runtime->buffer_used, size);
            err = snd_pcm_oss_sync1(substream, runtime->period_bytes);
            if (err < 0)
                goto unlock;
        } else if (runtime->period_ptr > 0) {
            #ifdef OSS_DEBUG
            pcm_dbg(substream->pcm, "sync: period_ptr\n");
            #endif
            size = runtime->period_bytes - runtime->period_ptr;
            snd_pcm_format_set_silence(format, runtime->buffer, size * 8 / width);
            err = snd_pcm_oss_sync1(substream, size);
            if (err < 0)
                goto unlock;
        }

        size = substream->runtime->control->appl_ptr % substream->runtime->period_size;
        if (size > 0) {
            size = substream->runtime->period_size - size;
            if (substream->runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)
                snd_pcm_lib_write(substream, NULL, size);
            else if (substream->runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
                snd_pcm_lib_writev(substream, NULL, size);
        }
    unlock:
        mutex_unlock(&runtime->params_lock);
        atomic_dec(&runtime->rw_ref);
        if (err < 0)
            return err;
    __direct:
        saved_f_flags = substream->f_flags;
        substream->f_flags &= ~O_NONBLOCK;
        err = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);
        substream->f_flags = saved_f_flags;
        if (err < 0)
            return err;
        mutex_lock(&runtime->params_lock);
        runtime->prepare = 1;
        mutex_unlock(&runtime->params_lock);
    }

    substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];
    if (substream != NULL) {
        if ((err = snd_pcm_oss_make_ready(substream)) < 0)
            return err;
        runtime = (struct oss_runtime_t *)substream->runtime;
        err = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);
        if (err < 0)
            return err;
        mutex_lock(&runtime->params_lock);
        runtime->buffer_used = 0;
        runtime->prepare = 1;
        mutex_unlock(&runtime->params_lock);
    }
    return 0;
}

