```c
struct ahash_request {
    struct crypto_async_request base;

    unsigned int nbytes;
    struct scatterlist *src;
    u8 *result;

    /* This field may only be used by the ahash API code. */
    void *priv;

    void *__ctx[] CRYPTO_MINALIGN_ATTR;
};
```

```c
struct crypto_ahash {
    bool using_shash; /* Underlying algorithm is shash, not ahash */
    unsigned int statesize;
    unsigned int reqsize;
    struct crypto_tfm base;
};
```

```c
static inline struct crypto_ahash *crypto_ahash_reqtfm(
    struct ahash_request *req)
{
    return __crypto_ahash_cast(req->base.tfm);
}
```

```c
struct tegra_cmac_ctx {
    struct tegra_se *se;
    unsigned int alg;
    u32 key_id;
    struct crypto_shash *fallback_tfm;
};
```

```c
static inline void *crypto_ahash_ctx(struct crypto_ahash *tfm)
{
    return crypto_tfm_ctx(crypto_ahash_tfm(tfm));
}
```

```c
struct tegra_cmac_reqctx {
    struct scatterlist *src_sg;
    struct tegra_se_datbuf datbuf;
    struct tegra_se_datbuf residue;
    unsigned int total_len;
    unsigned int blk_size;
    unsigned int task;
    u32 crypto_config;
    u32 config;
    u32 key_id;
    u32 *iv;
    u32 result[CMAC_RESULT_REG_COUNT];
};
```

```c
static inline void *ahash_request_ctx(struct ahash_request *req)
{
    return req->__ctx;
}
```

```c
static int tegra_cmac_init(struct ahash_request *req)
{
    struct tegra_cmac_reqctx *rctx = ahash_request_ctx(req);
    struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
    struct tegra_cmac_ctx *ctx = crypto_ahash_ctx(tfm);
    struct tegra_se *se = ctx->se;
    int i;

    rctx->total_len = 0;
    rctx->datbuf.size = 0;
    rctx->residue.size = 0;
    rctx->task = SHA_FIRST;
    rctx->blk_size = crypto_ahash_blocksize(tfm);

    rctx->residue.buf = dma_alloc_coherent(se->dev, rctx->blk_size * 2,
                           &rctx->residue.addr, GFP_KERNEL);
    if (!rctx->residue.buf)
        goto resbuf_fail;

    rctx->residue.size = 0;

    rctx->datbuf.buf = dma_alloc_coherent(se->dev, SE_SHA_BUFLEN,
                          &rctx->datbuf.addr, GFP_KERNEL);
    if (!rctx->datbuf.buf)
        goto datbuf_fail;

    rctx->datbuf.size = 0;

    /* Clear any previous result */
    for (i = 0; i < CMAC_RESULT_REG_COUNT; i++)
        writel(0, se->base + se->hw->regs->result + (i * 4));

    return 0;

datbuf_fail:
    dma_free_coherent(se->dev, rctx->blk_size, rctx->residue.buf,
              rctx->residue.addr);
resbuf_fail:
    return -ENOMEM;
}
```

```c
int crypto_transfer_hash_request_to_engine(struct crypto_engine *engine,
                       struct ahash_request *req)
{
    return crypto_transfer_request_to_engine(engine, &req->base);
}
EXPORT_SYMBOL_GPL(crypto_transfer_hash_request_to_engine);
```
