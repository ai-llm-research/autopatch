
struct ahash_request;
struct crypto_ahash;
struct tegra_cmac_ctx {
    struct tegra_se *se;
    int key_id;
    char iv[64]; // Assuming 64 bytes for iv size; adjust as needed
};
struct tegra_cmac_reqctx {
    int key_id;
    int alg;
    char iv[64]; // Assuming 64 bytes; align with ctx->iv size
};
struct tegra_se {
    int engine;
    int dev;
};

struct crypto_ahash *crypto_ahash_reqtfm(struct ahash_request *req) {
    return 0; // Placeholder
}
struct tegra_cmac_ctx *crypto_ahash_ctx(struct crypto_ahash *tfm) {
    return 0; // Placeholder
}
struct tegra_cmac_reqctx *ahash_request_ctx(struct ahash_request *req) {
    return 0; // Placeholder
}
int crypto_ahash_digestsize(struct crypto_ahash *tfm) {
    return 0; // Placeholder
}
int crypto_transfer_hash_request_to_engine(int *engine, struct ahash_request *req) {
    return 0; // Placeholder
}
void pr_err(const char *format, ...) {
    // Placeholder
}
void dev_warn(int dev, const char *format, ...) {
    // Placeholder
}
int irqs_disabled() {
    return 0; // Placeholder indicating interrupts are disabled
}
void BUG_ON(int condition) {
    if (condition) {
        // Placeholder for bug handling
    }
}
void memcpy(void *dest, const void *src, int n) {
    // Placeholder
}

#define TEGRA_SE_AES_CMAC 1
#define TEGRA_SE_CTRL_FLAGS_LAST 2
#define SHA512_DIGEST_SIZE 64 // Assuming SHA512 size in bytes
#define TEGRA_SE_OP_MODE_SHA512 3
#define EINPROGRESS 115 // Placeholder error code
#define EBUSY 16 // Placeholder error code
#define EINVAL 22 // Placeholder error code

static int tegra_cmac_digest(struct ahash_request *req) {
    struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
    struct tegra_cmac_ctx *ctx = crypto_ahash_ctx(tfm);
    struct tegra_cmac_reqctx *rctx = ahash_request_ctx(req);
    struct tegra_se *se = ctx->se;
    int ret;

    BUG_ON(!irqs_disabled());

    rctx->key_id = ctx->key_id;
    rctx->alg = TEGRA_SE_AES_CMAC | TEGRA_SE_CTRL_FLAGS_LAST;

    switch (crypto_ahash_digestsize(tfm)) {
    case SHA512_DIGEST_SIZE:
        rctx->alg |= TEGRA_SE_OP_MODE_SHA512;
        break;
    default:
        pr_err("Unsupported digest size %d\n", crypto_ahash_digestsize(tfm));
        return -EINVAL;
    }

    memcpy(rctx->iv, ctx->iv, sizeof(rctx->iv));

    ret = crypto_transfer_hash_request_to_engine(&se->engine, req);
    if (ret != -EINPROGRESS && ret != -EBUSY)
        dev_warn(se->dev, "%s failed with err %d\n", __func__, ret);

    return ret;
}
