

class JSHeapBroker {
public:
    void* CanonicalPersistentHandle(void* signature) { return nullptr; }
};

class HeapObjectRef {
public:
    bool IsNull() const { return false; }
    void* object() const { return nullptr; }
    HeapObjectRef AsJSObject() const { return *this; }
};

class MapRef {
public:
    bool IsJSObjectMap() const { return false; }
    bool is_access_check_needed() const { return false; }
    bool IsJSGlobalProxyMap() const { return false; }
    void* object() const { return nullptr; }
    HeapObjectRef prototype(JSHeapBroker* broker) const { return HeapObjectRef(); }
};

class CallOptimization {
public:
    static constexpr int kHolderIsReceiver = 0;
    static constexpr int kHolderFound = 1;
};

class HolderLookupResult {
public:
    HolderLookupResult() {}
    HolderLookupResult(int outcome) {}
    HolderLookupResult(int outcome, HeapObjectRef ref) {}
};

class DisallowGarbageCollection {};

class FunctionTemplateInfo {
public:
    static void* cast(void* signature) { return nullptr; }
};

class FunctionTemplateInfoRef {
public:
    HolderLookupResult LookupHolderOfExpectedType(JSHeapBroker* broker, MapRef receiver_map) {
        const HolderLookupResult not_found;
        if (!receiver_map.IsJSObjectMap() || 
            (receiver_map.is_access_check_needed() && !object()->accept_any_receiver())) {
            return not_found;
        }

        void* expected_receiver_type = nullptr;
        {
            DisallowGarbageCollection no_gc;
            void* signature = object()->signature();
            if (IsUndefined(signature)) {
                return HolderLookupResult(CallOptimization::kHolderIsReceiver);
            }
            expected_receiver_type = broker->CanonicalPersistentHandle(FunctionTemplateInfo::cast(signature));        
            if (IsTemplateFor(expected_receiver_type, receiver_map.object())) {
                return HolderLookupResult(CallOptimization::kHolderIsReceiver);
            }
            if (!receiver_map.IsJSGlobalProxyMap()) return not_found;
        }

        HeapObjectRef prototype = receiver_map.prototype(broker);
        if (prototype.IsNull()) return not_found;
        if (!IsTemplateFor(expected_receiver_type, prototype.object())) {
            return not_found;
        }
        return HolderLookupResult(CallOptimization::kHolderFound, prototype.AsJSObject());
    }

private:
    struct Object {
        bool accept_any_receiver() const { return false; }
        void* signature() const { return nullptr; }
    };

    Object* object() { return nullptr; }

    static bool IsUndefined(void* signature) { return signature == nullptr; }
    static bool IsTemplateFor(void* template_info, void* object_map) { return false; }
};

