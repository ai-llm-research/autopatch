{
 "supplementary_code": "```cpp\nclass V8_EXPORT_PRIVATE JSHeapBroker {\npublic:\nJSHeapBroker(Isolate* isolate, Zone* broker_zone, bool tracing_enabled,\nCodeKind code_kind);\n// For use only in tests, sets default values for some arguments. Avoids\n// churn when new flags are added.\nJSHeapBroker(Isolate* isolate, Zone* broker_zone)\n: JSHeapBroker(isolate, broker_zone, v8_flags.trace_heap_broker,\nCodeKind::TURBOFAN_JS) {}\n~JSHeapBroker();\n// The compilation target's native context. We need the setter because at\n// broker construction time we don't yet have the canonical handle.\nNativeContextRef target_native_context() const {\nreturn target_native_context_.value();\n}\nvoid SetTargetNativeContextRef(DirectHandle<NativeContext> native_context);\nvoid InitializeAndStartSerializing(\nDirectHandle<NativeContext> native_context);\nIsolate* isolate() const { return isolate_; }\n// The pointer compression cage base value used for decompression of all\n// tagged values except references to InstructionStream objects.\nPtrComprCageBase cage_base() const {\n#if V8_COMPRESS_POINTERS\nreturn cage_base_;\n#else\nreturn PtrComprCageBase{};\n#endif // V8_COMPRESS_POINTERS\n}\nZone* zone() const { return zone_; }\nbool tracing_enabled() const { return tracing_enabled_; }\nNexusConfig feedback_nexus_config() const {\nreturn IsMainThread() ? NexusConfig::FromMainThread(isolate())\n: NexusConfig::FromBackgroundThread(\nisolate(), local_isolate()->heap());\n}\nenum BrokerMode { kDisabled, kSerializing, kSerialized, kRetired };\nBrokerMode mode() const { return mode_; }\nvoid StopSerializing();\nvoid Retire();\nbool SerializingAllowed() const;\n#ifdef DEBUG\n// Get the current heap broker for this thread. Only to be used for DCHECKs.\nstatic JSHeapBroker* Current();\n#endif\n// Remember the local isolate and initialize its local heap with the\n// persistent and canonical handles provided by {info}.\nvoid AttachLocalIsolate(OptimizedCompilationInfo* info,\nLocalIsolate* local_isolate);\n// Forget about the local isolate and pass the persistent and canonical\n// handles provided back to {info}. {info} is responsible for disposing of\n// them.\nvoid DetachLocalIsolate(OptimizedCompilationInfo* info);\n// TODO(v8:7700): Refactor this once the broker is no longer\n// Turbofan-specific.\nvoid AttachLocalIsolateForMaglev(maglev::MaglevCompilationInfo* info,\nLocalIsolate* local_isolate);\nvoid DetachLocalIsolateForMaglev(maglev::MaglevCompilationInfo* info);\n// Attaches the canonical handles map from the compilation info to the broker.\n// Ownership of the map remains in the compilation info.\ntemplate <typename CompilationInfoT>\nvoid AttachCompilationInfo(CompilationInfoT* info) {\nset_canonical_handles(info->canonical_handles());\n}\nbool StackHasOverflowed() const;\n#ifdef DEBUG\nvoid PrintRefsAnalysis() const;\n#endif // DEBUG\n// Returns the handle from root index table for read only heap objects.\nDirectHandle<Object> GetRootHandle(Tagged<Object> object);\n// Never returns nullptr.\nObjectData* GetOrCreateData(Handle<Object> object,\nGetOrCreateDataFlags flags = {});\nObjectData* GetOrCreateData(Tagged<Object> object,\nGetOrCreateDataFlags flags = {});\n// Gets data only if we have it. However, thin wrappers will be created for\n// smis, read-only objects and never-serialized objects.\nObjectData* TryGetOrCreateData(Handle<Object> object,\nGetOrCreateDataFlags flags = {});\nObjectData* TryGetOrCreateData(Tagged<Object> object,\nGetOrCreateDataFlags flags = {});\n// Check if {object} is any native context's %ArrayPrototype% or\n// %ObjectPrototype%.\nbool IsArrayOrObjectPrototype(JSObjectRef object) const;\nbool IsArrayOrObjectPrototype(Handle<JSObject> object) const;\nbool HasFeedback(FeedbackSource const& source) const;\nvoid SetFeedback(FeedbackSource const& source,\nProcessedFeedback const* feedback);\nFeedbackSlotKind GetFeedbackSlotKind(FeedbackSource const& source) const;\nElementAccessFeedback const& ProcessFeedbackMapsForElementAccess(\nZoneVector<MapRef>& maps, KeyedAccessMode const& keyed_mode,\nFeedbackSlotKind slot_kind);\n// Binary, comparison and for-in hints can be fully expressed via\n// an enum. Insufficient feedback is signaled by <Hint enum>::kNone.\nBinaryOperationHint GetFeedbackForBinaryOperation(\nFeedbackSource const& source);\nCompareOperationHint GetFeedbackForCompareOperation(\nFeedbackSource const& source);\nForInHint GetFeedbackForForIn(FeedbackSource const& source);\nProcessedFeedback const& GetFeedbackForCall(FeedbackSource const& source);\nProcessedFeedback const& GetFeedbackForGlobalAccess(\nFeedbackSource const& source);\nProcessedFeedback const& GetFeedbackForInstanceOf(\nFeedbackSource const& source);\nTypeOfFeedback::Result GetFeedbackForTypeOf(FeedbackSource const& source);\nProcessedFeedback const& GetFeedbackForArrayOrObjectLiteral(\nFeedbackSource const& source);\nProcessedFeedback const& GetFeedbackForRegExpLiteral(\nFeedbackSource const& source);\nProcessedFeedback const& GetFeedbackForTemplateObject(\nFeedbackSource const& source);\nProcessedFeedback const& GetFeedbackForPropertyAccess(\nFeedbackSource const& source, AccessMode mode,\nOptionalNameRef static_name);\nProcessedFeedback const& ProcessFeedbackForBinaryOperation(\nFeedbackSource const& source);\nProcessedFeedback const& ProcessFeedbackForCompareOperation(\nFeedbackSource const& source);\nProcessedFeedback const& ProcessFeedbackForForIn(\nFeedbackSource const& source);\nProcessedFeedback const& ProcessFeedbackForTypeOf(\nFeedbackSource const& source);\nbool FeedbackIsInsufficient(FeedbackSource const& source) const;\nOptionalNameRef GetNameFeedback(FeedbackNexus const& nexus);\nPropertyAccessInfo GetPropertyAccessInfo(MapRef map, NameRef name,\nAccessMode access_mode);\nStringRef GetTypedArrayStringTag(ElementsKind kind);\nbool IsMainThread() const {\nreturn local_isolate() == nullptr || local_isolate()->is_main_thread();\n}\nLocalIsolate* local_isolate() const { return local_isolate_; }\n// TODO(jgruber): Consider always having local_isolate_ set to a real value.\n// This seems not entirely trivial since we currently reset local_isolate_ to\n// nullptr at some point in the JSHeapBroker lifecycle.\nLocalIsolate* local_isolate_or_isolate() const {\nreturn local_isolate() != nullptr ? local_isolate()\n: isolate()->AsLocalIsolate();\n}\nstd::optional<RootIndex> FindRootIndex(HeapObjectRef object) {\n// No root constant is a JSReceiver.\nif (object.IsJSReceiver()) return {};\nRootIndex root_index;\nif (root_index_map_.Lookup(*object.object(), &root_index)) {\nreturn root_index;\n}\nreturn {};\n}\n// Return the corresponding canonical persistent handle for {object}. Create\n// one if it does not exist.\n// If a local isolate is attached, we can create the persistent handle through\n// it. This commonly happens during the Execute phase.\n// If we don't, that means we are calling this method from serialization. If\n// that happens, we should be inside a persistent handle scope. Then, we would\n// just use the regular handle creation.\ntemplate <typename T>\nHandle<T> CanonicalPersistentHandle(Tagged<T> object) {\nDCHECK_NOT_NULL(canonical_handles_);\nif (Tagged<HeapObject> heap_object;\nTryCast<HeapObject>(object, &heap_object)) {\nRootIndex root_index;\n// CollectArrayAndObjectPrototypes calls this function often with T equal\n// to JSObject. The root index map only contains immortal, immutable\n// objects; it never contains any instances of type JSObject, since\n// JSObjects must exist within a NativeContext, and NativeContexts can be\n// created and destroyed. Thus, we can skip the lookup in the root index\n// map for those values and save a little time.\nif constexpr (std::is_convertible_v<T, JSObject>) {\nDCHECK(!root_index_map_.Lookup(heap_object, &root_index));\n} else if (root_index_map_.Lookup(heap_object, &root_index)) {\nreturn Handle<T>(isolate_->root_handle(root_index).location());\n}\n}\nauto find_result = canonical_handles_->FindOrInsert(object);\nif (find_result.already_exists) return Handle<T>(*find_result.entry);\n// Allocate new PersistentHandle if one wasn't created before.\nif (local_isolate()) {\n*find_result.entry =\nlocal_isolate()->heap()->NewPersistentHandle(object).location();\n} else {\nDCHECK(PersistentHandlesScope::IsActive(isolate()));\n*find_result.entry = IndirectHandle<T>(object, isolate()).location();\n}\nreturn Handle<T>(*find_result.entry);\n}\ntemplate <typename T>\nHandle<T> CanonicalPersistentHandle(Handle<T> object) {\nif (object.is_null()) return object; // Can't deref a null handle.\nreturn CanonicalPersistentHandle<T>(*object);\n}\n// Checks if a canonical persistent handle for {object} exists.\ntemplate <typename T>\nbool IsCanonicalHandle(Handle<T> handle) {\nDCHECK_NOT_NULL(canonical_handles_);\nif (Tagged<HeapObject> heap_object;\nTryCast<HeapObject>(*handle, &heap_object)) {\nRootIndex root_index;\nif (root_index_map_.Lookup(heap_object, &root_index)) {\nreturn true;\n}\n// Builtins use pseudo handles that are canonical and persistent by\n// design.\nif (isolate()->IsBuiltinTableHandleLocation(handle.location())) {\nreturn true;\n}\n}\nreturn canonical_handles_->Find(*handle) != nullptr;\n}\nstd::string Trace() const;\nvoid IncrementTracingIndentation();\nvoid DecrementTracingIndentation();\n// Locks {mutex} through the duration of this scope iff it is the first\n// occurrence. This is done to have a recursive shared lock on {mutex}.\nclass V8_NODISCARD RecursiveMutexGuardIfNeeded {\nprotected:\nV8_INLINE RecursiveMutexGuardIfNeeded(LocalIsolate* local_isolate,\nbase::Mutex* mutex,\nint* mutex_depth_address);\n~RecursiveMutexGuardIfNeeded() {\nDCHECK_GE((*mutex_depth_address_), 1);\n(*mutex_depth_address_)--;\nDCHECK_EQ(initial_mutex_depth_, (*mutex_depth_address_));\n}\nprivate:\nint* const mutex_depth_address_;\nconst int initial_mutex_depth_;\nParkedMutexGuardIf mutex_guard_;\n};\nclass MapUpdaterGuardIfNeeded final : public RecursiveMutexGuardIfNeeded {\npublic:\nV8_INLINE explicit MapUpdaterGuardIfNeeded(JSHeapBroker* broker);\n};\nclass BoilerplateMigrationGuardIfNeeded final\n: public RecursiveMutexGuardIfNeeded {\npublic:\nV8_INLINE explicit BoilerplateMigrationGuardIfNeeded(JSHeapBroker* broker);\n};\n// If this returns false, the object is guaranteed to be fully initialized and\n// thus safe to read from a memory safety perspective. The converse does not\n// necessarily hold.\nbool ObjectMayBeUninitialized(DirectHandle<Object> object) const;\nbool ObjectMayBeUninitialized(Tagged<Object> object) const;\nbool ObjectMayBeUninitialized(Tagged<HeapObject> object) const;\nvoid set_dependencies(CompilationDependencies* dependencies) {\nDCHECK_NOT_NULL(dependencies);\nDCHECK_NULL(dependencies_);\ndependencies_ = dependencies;\n}\nCompilationDependencies* dependencies() const {\nDCHECK_NOT_NULL(dependencies_);\nreturn dependencies_;\n}\n#define V(Type, name, Name) inline typename ref_traits<Type>::ref_type name();\nREAD_ONLY_ROOT_LIST(V)\n#undef V\nprivate:\nfriend class JSHeapBrokerScopeForTesting;\nfriend class HeapObjectRef;\nfriend class ObjectRef;\nfriend class ObjectData;\nfriend class PropertyCellData;\nProcessedFeedback const& GetFeedback(FeedbackSource const& source) const;\nconst ProcessedFeedback& NewInsufficientFeedback(FeedbackSlotKind kind) const;\n// Bottleneck FeedbackNexus access here, for storage in the broker\n// or on-the-fly usage elsewhere in the compiler.\nProcessedFeedback const& ReadFeedbackForArrayOrObjectLiteral(\nFeedbackSource const& source);\nProcessedFeedback const& ReadFeedbackForBinaryOperation(\nFeedbackSource const& source) const;\nProcessedFeedback const& ReadFeedbackForTypeOf(\nFeedbackSource const& source) const;\nProcessedFeedback const& ReadFeedbackForCall(FeedbackSource const& source);\nProcessedFeedback const& ReadFeedbackForCompareOperation(\nFeedbackSource const& source) const;\nProcessedFeedback const& ReadFeedbackForForIn(\nFeedbackSource const& source) const;\nProcessedFeedback const& ReadFeedbackForGlobalAccess(\nJSHeapBroker* broker, FeedbackSource const& source);\nProcessedFeedback const& ReadFeedbackForInstanceOf(\nFeedbackSource const& source);\nProcessedFeedback const& ReadFeedbackForPropertyAccess(\nFeedbackSource const& source, AccessMode mode,\nOptionalNameRef static_name);\nProcessedFeedback const& ReadFeedbackForRegExpLiteral(\nFeedbackSource const& source);\nProcessedFeedback const& ReadFeedbackForTemplateObject(\nFeedbackSource const& source);\nvoid CollectArrayAndObjectPrototypes();\nvoid set_persistent_handles(\nstd::unique_ptr<PersistentHandles> persistent_handles) {\nDCHECK_NULL(ph_);\nph_ = std::move(persistent_handles);\nDCHECK_NOT_NULL(ph_);\n}\nstd::unique_ptr<PersistentHandles> DetachPersistentHandles() {\nDCHECK_NOT_NULL(ph_);\nreturn std::move(ph_);\n}\nvoid set_canonical_handles(CanonicalHandlesMap* canonical_handles) {\ncanonical_handles_ = canonical_handles;\n}\n#define V(Type, name, Name) void Init##Name();\nREAD_ONLY_ROOT_LIST(V)\n#undef V\nIsolate* const isolate_;\n#if V8_COMPRESS_POINTERS\nconst PtrComprCageBase cage_base_;\n#endif // V8_COMPRESS_POINTERS\nZone* const zone_;\nOptionalNativeContextRef target_native_context_;\nRefsMap* refs_;\nRootIndexMap root_index_map_;\nZoneUnorderedSet<IndirectHandle<JSObject>, IndirectHandle<JSObject>::hash,\nIndirectHandle<JSObject>::equal_to>\narray_and_object_prototypes_;\nBrokerMode mode_ = kDisabled;\nbool const tracing_enabled_;\nCodeKind const code_kind_;\nstd::unique_ptr<PersistentHandles> ph_;\nLocalIsolate* local_isolate_ = nullptr;\n// The CanonicalHandlesMap is owned by the compilation info.\nCanonicalHandlesMap* canonical_handles_;\nunsigned trace_indentation_ = 0;\nZoneUnorderedMap<FeedbackSource, ProcessedFeedback const*,\nFeedbackSource::Hash, FeedbackSource::Equal>\nfeedback_;\nZoneUnorderedMap<PropertyAccessTarget, PropertyAccessInfo,\nPropertyAccessTarget::Hash, PropertyAccessTarget::Equal>\nproperty_access_infos_;\n// Cache read only roots to avoid needing to look them up via the map.\n#define V(Type, name, Name) \\\nOptionalRef<typename ref_traits<Type>::ref_type> name##_;\nREAD_ONLY_ROOT_LIST(V)\n#undef V\nCompilationDependencies* dependencies_ = nullptr;\n// The MapUpdater mutex is used in recursive patterns; for example,\n// ComputePropertyAccessInfo may call itself recursively. Thus we need to\n// emulate a recursive mutex, which we do by checking if this heap broker\n// instance already holds the mutex when a lock is requested. This field\n// holds the locking depth, i.e. how many times the mutex has been\n// recursively locked. Only the outermost locker actually locks underneath.\nint map_updater_mutex_depth_ = 0;\n// Likewise for boilerplate migrations.\nint boilerplate_migration_mutex_depth_ = 0;\nstatic constexpr uint32_t kMinimalRefsBucketCount = 8;\nstatic_assert(base::bits::IsPowerOfTwo(kMinimalRefsBucketCount));\nstatic constexpr uint32_t kInitialRefsBucketCount = 1024;\nstatic_assert(base::bits::IsPowerOfTwo(kInitialRefsBucketCount));\n};\n```\n```cpp\nclass V8_EXPORT_PRIVATE MapRef : public HeapObjectRef {\npublic:\nDEFINE_REF_CONSTRUCTOR(Map, HeapObjectRef)\nIndirectHandle<Map> object() const;\nint instance_size() const;\nInstanceType instance_type() const;\nint GetInObjectProperties() const;\nint GetInObjectPropertiesStartInWords() const;\nint NumberOfOwnDescriptors() const;\nint GetInObjectPropertyOffset(int index) const;\nint constructor_function_index() const;\nint NextFreePropertyIndex() const;\nint UnusedPropertyFields() const;\nElementsKind elements_kind() const;\nbool is_stable() const;\nbool is_constructor() const;\nbool has_prototype_slot() const;\nbool is_access_check_needed() const;\nbool is_deprecated() const;\nbool CanBeDeprecated() const;\nbool CanTransition() const;\nbool IsInobjectSlackTrackingInProgress() const;\nbool is_dictionary_map() const;\nbool IsFixedCowArrayMap(JSHeapBroker* broker) const;\nbool IsPrimitiveMap() const;\nbool is_undetectable() const;\nbool is_callable() const;\nbool has_indexed_interceptor() const;\nint construction_counter() const;\nbool is_migration_target() const;\nbool supports_fast_array_iteration(JSHeapBroker* broker) const;\nbool supports_fast_array_resize(JSHeapBroker* broker) const;\nbool is_abandoned_prototype_map() const;\nbool IsTwoByteStringMap() const;\nbool IsThinStringMap() const;\nOddballType oddball_type(JSHeapBroker* broker) const;\nbool CanInlineElementAccess() const;\n// Note: Only returns a value if the requested elements kind matches the\n// current kind, or if the current map is an unmodified JSArray initial map.\nOptionalMapRef AsElementsKind(JSHeapBroker* broker, ElementsKind kind) const;\n#define DEF_TESTER(Type, ...) bool Is##Type##Map() const;\nINSTANCE_TYPE_CHECKERS(DEF_TESTER)\n#undef DEF_TESTER\nbool IsBooleanMap(JSHeapBroker* broker) const;\nHeapObjectRef GetBackPointer(JSHeapBroker* broker) const;\nHeapObjectRef prototype(JSHeapBroker* broker) const;\nbool PrototypesElementsDoNotHaveAccessorsOrThrow(\nJSHeapBroker* broker, ZoneVector<MapRef>* prototype_maps);\n// Concerning the underlying instance_descriptors:\nDescriptorArrayRef instance_descriptors(JSHeapBroker* broker) const;\nMapRef FindFieldOwner(JSHeapBroker* broker,\nInternalIndex descriptor_index) const;\nPropertyDetails GetPropertyDetails(JSHeapBroker* broker,\nInternalIndex descriptor_index) const;\nNameRef GetPropertyKey(JSHeapBroker* broker,\nInternalIndex descriptor_index) const;\nFieldIndex GetFieldIndexFor(InternalIndex descriptor_index) const;\nOptionalObjectRef GetStrongValue(JSHeapBroker* broker,\nInternalIndex descriptor_number) const;\nMapRef FindRootMap(JSHeapBroker* broker) const;\nObjectRef GetConstructor(JSHeapBroker* broker) const;\n};\nHeapObjectRef MapRef::prototype(JSHeapBroker* broker) const {\nreturn MakeRefAssumeMemoryFence(broker,\nCast<HeapObject>(object()->prototype()));\n}\nHeapObjectRef MapRef::prototype(JSHeapBroker* broker) const {\nreturn MakeRefAssumeMemoryFence(broker,\nCast<HeapObject>(object()->prototype()));\n}\n```\n```cpp\nclass V8_EXPORT_PRIVATE ObjectRef {\npublic:\nexplicit ObjectRef(ObjectData* data, bool check_type = true) : data_(data) {\nCHECK_NOT_NULL(data_);\n}\nIndirectHandle<Object> object() const;\nbool equals(ObjectRef other) const;\nsize_t hash_value() const { return base::hash_combine(object().address()); }\nbool IsSmi() const;\nint AsSmi() const;\n#define HEAP_IS_METHOD_DECL(Name) bool Is##Name() const;\nHEAP_BROKER_OBJECT_LIST(HEAP_IS_METHOD_DECL)\n#undef HEAP_IS_METHOD_DECL\n#define HEAP_AS_METHOD_DECL(Name) Name##Ref As##Name() const;\nHEAP_BROKER_OBJECT_LIST(HEAP_AS_METHOD_DECL)\n#undef HEAP_AS_METHOD_DECL\nbool IsNull() const;\nbool IsUndefined() const;\nenum HoleType HoleType() const;\nbool IsTheHole() const;\nbool IsPropertyCellHole() const;\nbool IsHashTableHole() const;\nbool IsPromiseHole() const;\nbool IsNullOrUndefined() const;\nstd::optional<bool> TryGetBooleanValue(JSHeapBroker* broker) const;\nMaybe<double> OddballToNumber(JSHeapBroker* broker) const;\nbool should_access_heap() const;\nObjectData* data() const;\nstruct Hash {\nsize_t operator()(ObjectRef ref) const { return ref.hash_value(); }\n};\nprotected:\nObjectData* data_; // Should be used only by object() getters.\nprivate:\nfriend class FunctionTemplateInfoRef;\nfriend class JSArrayData;\nfriend class JSFunctionData;\nfriend class JSGlobalObjectData;\nfriend class JSGlobalObjectRef;\nfriend class JSHeapBroker;\nfriend class JSObjectData;\nfriend class StringData;\ntemplate <typename TRef>\nfriend class OptionalRef;\nfriend std::ostream& operator<<(std::ostream& os, ObjectRef ref);\nfriend bool operator<(ObjectRef lhs, ObjectRef rhs);\ntemplate <typename T, typename Enable>\nfriend struct ::v8::internal::ZoneCompactSetTraits;\n};\nbool ObjectRef::IsNull() const { return i::IsNull(*object()); }\n#define DEFINE_IS_AND_AS(Name) \\\nbool ObjectRef::Is##Name() const { return data()->Is##Name(); } \\\nName##Ref ObjectRef::As##Name() const { \\\nDCHECK(Is##Name()); \\\nreturn Name##Ref(data()); \\\n}\nHEAP_BROKER_OBJECT_LIST(DEFINE_IS_AND_AS)\n#undef DEFINE_IS_AND_AS\n```\n```cpp\nclass FunctionTemplateInfoRef : public HeapObjectRef {\npublic:\nDEFINE_REF_CONSTRUCTOR(FunctionTemplateInfo, HeapObjectRef)\nIndirectHandle<FunctionTemplateInfo> object() const;\nbool is_signature_undefined(JSHeapBroker* broker) const;\nbool accept_any_receiver() const;\nint16_t allowed_receiver_instance_type_range_start() const;\nint16_t allowed_receiver_instance_type_range_end() const;\n// Function pointer and a data value that should be passed to the callback.\n// The |callback_data| must be read before the |callback|.\nAddress callback(JSHeapBroker* broker) const;\nOptionalObjectRef callback_data(JSHeapBroker* broker) const;\nZoneVector<Address> c_functions(JSHeapBroker* broker) const;\nZoneVector<const CFunctionInfo*> c_signatures(JSHeapBroker* broker) const;\nHolderLookupResult LookupHolderOfExpectedType(JSHeapBroker* broker,\nMapRef receiver_map);\n};\n```\n```cpp\nstruct HolderLookupResult {\nHolderLookupResult(CallOptimization::HolderLookup lookup_ =\nCallOptimization::kHolderNotFound,\nOptionalJSObjectRef holder_ = std::nullopt)\n: lookup(lookup_), holder(holder_) {}\nCallOptimization::HolderLookup lookup;\nOptionalJSObjectRef holder;\n};\n```\n```cpp\nbool ObjectRef::IsNull() const { return i::IsNull(*object()); }\n```\n```cpp\n// Holds information about possible function call optimizations.\nclass CallOptimization {\npublic:\ntemplate <class IsolateT>\nCallOptimization(IsolateT* isolate, Handle<Object> function);\n// Gets accessor context by given holder map via holder's constructor.\n// If the holder is a remote object returns empty optional.\n// This method must not be called for holder maps with null constructor\n// because they can't be holders for lazy accessor pairs anyway.\nstd::optional<Tagged<NativeContext>> GetAccessorContext(\nTagged<Map> holder_map) const;\n// Return true if the accessor context for given holder doesn't match\n// given native context of if the holder is a remote object.\nbool IsCrossContextLazyAccessorPair(Tagged<NativeContext> native_context,\nTagged<Map> holder_map) const;\nbool is_constant_call() const { return !constant_function_.is_null(); }\nbool accept_any_receiver() const { return accept_any_receiver_; }\nbool requires_signature_check() const {\nreturn !expected_receiver_type_.is_null();\n}\nDirectHandle<JSFunction> constant_function() const {\nDCHECK(is_constant_call());\nreturn constant_function_;\n}\nbool is_simple_api_call() const { return is_simple_api_call_; }\nDirectHandle<FunctionTemplateInfo> expected_receiver_type() const {\nDCHECK(is_simple_api_call());\nreturn expected_receiver_type_;\n}\nDirectHandle<FunctionTemplateInfo> api_call_info() const {\nDCHECK(is_simple_api_call());\nreturn api_call_info_;\n}\nenum HolderLookup { kHolderNotFound, kHolderIsReceiver, kHolderFound };\ntemplate <class IsolateT>\nHandle<JSObject> LookupHolderOfExpectedType(\nIsolateT* isolate, DirectHandle<Map> receiver_map,\nHolderLookup* holder_lookup) const;\nbool IsCompatibleReceiverMap(DirectHandle<JSObject> api_holder,\nHandle<JSObject> holder, HolderLookup) const;\nprivate:\ntemplate <class IsolateT>\nvoid Initialize(IsolateT* isolate, Handle<JSFunction> function);\ntemplate <class IsolateT>\nvoid Initialize(IsolateT* isolate,\nHandle<FunctionTemplateInfo> function_template_info);\n// Determines whether the given function can be called using the\n// fast api call builtin.\ntemplate <class IsolateT>\nvoid AnalyzePossibleApiFunction(IsolateT* isolate,\nDirectHandle<JSFunction> function);\nHandle<JSFunction> constant_function_;\nHandle<FunctionTemplateInfo> expected_receiver_type_;\nHandle<FunctionTemplateInfo> api_call_info_;\n// TODO(gsathya): Change these to be a bitfield and do a single fast check\n// rather than two checks.\nbool is_simple_api_call_ = false;\nbool accept_any_receiver_ = false;\n};\n```\n```cpp\n// CHECK dies with a fatal error if condition is not true. It is *not*\n// controlled by DEBUG, so the check will be executed regardless of\n// compilation mode.\n//\n// We make sure CHECK et al. always evaluates their arguments, as\n// doing CHECK(FunctionWithSideEffect()) is a common idiom.\n#define CHECK_WITH_MSG(condition, message) \\\ndo { \\\nif (V8_UNLIKELY(!(condition))) { \\\nCHECK_FAILED_HANDLER(message); \\\n} \\\n} while (false)\n#define CHECK(condition) CHECK_WITH_MSG(condition, #condition)\n```",
 "function_prototype": "HolderLookupResult FunctionTemplateInfoRef::LookupHolderOfExpectedType(JSHeapBroker* broker, MapRef receiver_map)",
 "re_implemented_code": "\n```c\nHolderLookupResult FunctionTemplateInfoRef::LookupHolderOfExpectedType(\nJSHeapBroker* broker, MapRef receiver_map) {\n// Create a default HolderLookupResult indicating the holder was not found\nHolderLookupResult result(HolderLookup::kHolderNotFound);\n// Check if the receiver map is not a JSObject map or if access checks are needed and the receiver does not accept any\nif (!receiver_map.IsJSObjectMap() || (receiver_map.is_access_check_needed() &&\n!object()->accept_any_receiver())) {\n// Return the default not found result\nreturn result;\n}\n// Declare a handle for the expected receiver type\nHandle<FunctionTemplateInfo> expected_receiver_type;\n{\n// Disallow garbage collection during this block\nDisallowGarbageCollection disallow_gc;\n// Get the signature of the function template info object\nSignatureInfo signature = object()->signature();\n// Check if the signature is undefined\nif (signature.is_undefined()) {\n// Return a result indicating the holder is the receiver\nreturn HolderLookupResult(HolderLookup::kHolderIsReceiver,\nreceiver_map.AsJSObject());\n}\n// Get the canonical persistent handle for the expected receiver type\nexpected_receiver_type =\nbroker->CanonicalPersistentHandle(signature.receiver());\n// Check if the expected receiver type is a template for the receiver map object\nif (expected_receiver_type->IsTemplateFor(receiver_map.object()->map())) {\n// Return a result indicating the holder is the receiver\nreturn HolderLookupResult(HolderLookup::kHolderIsReceiver,\nreceiver_map.AsJSObject());\n}\n// Check if the receiver map is not a JSGlobalProxy map\nif (!receiver_map.IsJSGlobalProxyMap()) {\n// Return the default not found result\nreturn result;\n}\n}\n// Get the prototype of the receiver map\nJSObjectRef prototype = receiver_map.prototype(broker);\n// Check if the prototype is null\nif (prototype.IsNull()) {\n// Return the default not found result\nreturn result;\n}\n// Check if the expected receiver type is not a template for the prototype's map\nif (!expected_receiver_type->IsTemplateFor(prototype.object()->map())) {\n// Return the default not found result\nreturn result;\n}\n// Return a result indicating the holder was found with the prototype as the JSObject\nreturn HolderLookupResult(HolderLookup::kHolderFound, prototype);\n}\n```\n",
 "is_vulnerable": "N/A"
}