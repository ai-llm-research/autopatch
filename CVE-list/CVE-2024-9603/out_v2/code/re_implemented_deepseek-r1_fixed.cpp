

class JSHeapBroker;
class MapRef;
class HolderLookupResult;
class FunctionTemplateInfoRef;
class Signature;
class FunctionTemplateInfo;
class HeapObjectRef;

class HolderLookupResult {
public:
    HolderLookupResult(int status, int arg) {}
};

class JSHeapBroker {
public:
    class NativeContext {
    public:
        bool accept_any_receiver() { return false; }
        FunctionTemplateInfo* function() { return nullptr; }
    };

    NativeContext* target_native_context() { return nullptr; }
};

class MapRef {
public:
    bool IsJSObjectMap() { return false; }
    bool is_access_check_needed() { return false; }
    bool IsJSGlobalProxyMap() { return false; }
    HeapObjectRef prototype(JSHeapBroker* broker);
    void* object() { return nullptr; }
};

class HeapObjectRef {
public:
    bool IsNull() { return true; }
    MapRef map() { return MapRef(); }
    HolderLookupResult AsJSObject() { return HolderLookupResult(0, 0); }
};

class broom_garbage_collection_disabler {};

class FunctionTemplateInfoRef {
public:
    HolderLookupResult LookupHolderOfExpectedType(JSHeapBroker* broker, MapRef receiver_map);
};

class Signature {
public:
    bool is_undefined() { return true; }
    FunctionTemplateInfo* function_template_info() { return nullptr; }
};

class FunctionTemplateInfo {
public:
    bool IsTemplateFor(void* obj) { return false; }
    Signature* signature() { return nullptr; }
};

HeapObjectRef MapRef::prototype(JSHeapBroker* broker) { return HeapObjectRef(); }

HolderLookupResult FunctionTemplateInfoRef::LookupHolderOfExpectedType(JSHeapBroker* broker, MapRef receiver_map) {
    HolderLookupResult result{0, 0};

    if (!receiver_map.IsJSObjectMap() || (receiver_map.is_access_check_needed() &&
                                          !broker->target_native_context()->accept_any_receiver())) {
        return result;
    }

    FunctionTemplateInfo* expected_receiver_type = nullptr;

    {
        broom_garbage_collection_disabler disabler;

        Signature* sig = expected_receiver_type->signature();

        if (sig->is_undefined()) {
            return HolderLookupResult{1, 0};
        }

        expected_receiver_type = sig->function_template_info();

        if (expected_receiver_type->IsTemplateFor(receiver_map.object())) {
            return HolderLookupResult{1, 0};
        }

        if (!receiver_map.IsJSGlobalProxyMap()) {
            return result;
        }
    }

    HeapObjectRef prototype = receiver_map.prototype(broker);

    if (prototype.IsNull()) {
        return result;
    }

    if (!expected_receiver_type->IsTemplateFor(prototype.map().object())) {
        return result;
    }

    return HolderLookupResult{2, 0};
}

