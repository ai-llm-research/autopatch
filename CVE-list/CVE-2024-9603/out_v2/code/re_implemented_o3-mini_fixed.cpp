
class JSHeapBroker;
class FunctionTemplateInfo;
class MapRef; 
class HeapObjectRef;
class JSObjectRef;

template<typename T>
class Handle {
public:
    T* operator->() const { return nullptr; }
};

template<typename T>
class Optional {
public:
    static Optional nullopt;
};

class FunctionTemplateInfoRef {
public:
    int LookupHolderOfExpectedType(JSHeapBroker* broker, MapRef receiver_map);
};

class CallOptimization {
public:
    static const int kHolderNotFound = 0;
    static const int kHolderIsReceiver = 1;
    static const int kHolderFound = 2;
};

class HolderLookupResult {
public:
    HolderLookupResult(int result, Optional<JSObjectRef> object);
};

class MapRef {
public:
    bool IsJSObjectMap() const { return false; }
    bool is_access_check_needed() const { return false; }
    bool IsJSGlobalProxyMap() const { return false; }
    HeapObjectRef prototype(JSHeapBroker* broker) const;
    bool object() const { return false; }
};

class DisallowGarbageCollection {
public:
    DisallowGarbageCollection() {}
};

bool is_signature_undefined(JSHeapBroker* broker) {
    return false;
}

class JSHeapBroker {
public:
    template<typename T>
    Handle<T> CanonicalPersistentHandle(void* handle) {
        return Handle<T>();
    }
};

class HeapObjectRef {
public:
    bool IsNull() const { return false; }
    JSObjectRef object() const;
};

class JSObjectRef {
public:
    static JSObjectRef DownCast(HeapObjectRef ref) { return JSObjectRef(); }
};

void* callback_data(JSHeapBroker* broker) {
    return nullptr;
}

HolderLookupResult::HolderLookupResult(int result, Optional<JSObjectRef> object) {}
