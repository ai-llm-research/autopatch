

class JSHeapBroker {};

class JSObjectRef {
public:
    bool IsNull() const { return true; }
    void* object() const { return nullptr; }
    int AsJSObject() const { return 0; }
};

class FunctionTemplateInfo; // Forward declaration

class SignatureInfo {
public:
    bool is_undefined() const { return true; }
    // Removed return type that was causing error
};

class MapRef {
public:
    bool IsJSObjectMap() const { return false; }
    bool is_access_check_needed() const { return false; }
    JSObjectRef prototype(JSHeapBroker* broker) const;
    bool IsJSGlobalProxyMap() const { return false; }
    int AsJSObject() const { return 0; }
    void* object() const { return nullptr; }
};

class FunctionTemplateInfo {
public:
    bool IsTemplateFor(void* map) const { return false; }
    SignatureInfo signature() const { return SignatureInfo(); }
    bool accept_any_receiver() const { return false; }
};

class HolderLookup {
public:
    static const int kHolderNotFound = 0;
    static const int kHolderIsReceiver = 1;
    static const int kHolderFound = 2;
};

class HolderLookupResult {
public:
    HolderLookupResult(int lookup, int obj = 0) {}
};

class FunctionTemplateInfoRef {
public:
    FunctionTemplateInfo* object() const { return nullptr; }
    HolderLookupResult LookupHolderOfExpectedType(JSHeapBroker* broker, MapRef receiver_map);
};

class Handle {
public:
    FunctionTemplateInfo* operator->() const { return nullptr; }
    static Handle CanonicalPersistentHandle(FunctionTemplateInfo info) { return {}; }
};

class DisallowGarbageCollection {};

JSObjectRef MapRef::prototype(JSHeapBroker* broker) const {
    return JSObjectRef();
}

HolderLookupResult FunctionTemplateInfoRef::LookupHolderOfExpectedType(
    JSHeapBroker* broker, MapRef receiver_map) {
    HolderLookupResult result(HolderLookup::kHolderNotFound);

    if (!receiver_map.IsJSObjectMap() || (receiver_map.is_access_check_needed() &&
                                          !object()->accept_any_receiver())) {
        return result;
    }

    Handle expected_receiver_type;

    {
        DisallowGarbageCollection disallow_gc;
        SignatureInfo signature = object()->signature();

        if (signature.is_undefined()) {
            return HolderLookupResult(HolderLookup::kHolderIsReceiver,
                                      receiver_map.AsJSObject());
        }

        // Removed reference to non-existing 'receiver' method
        expected_receiver_type =
            Handle::CanonicalPersistentHandle(FunctionTemplateInfo());

        if (expected_receiver_type->IsTemplateFor(receiver_map.object())) {
            return HolderLookupResult(HolderLookup::kHolderIsReceiver,
                                      receiver_map.AsJSObject());
        }

        if (!receiver_map.IsJSGlobalProxyMap()) {
            return result;
        }
    }

    JSObjectRef prototype = receiver_map.prototype(broker);

    if (prototype.IsNull()) {
        return result;
    }

    if (!expected_receiver_type->IsTemplateFor(prototype.object())) {
        return result;
    }

    return HolderLookupResult(HolderLookup::kHolderFound, prototype.AsJSObject());
}

