

struct JSHeapBroker {
    void* signature() { return nullptr; }
    void* CanonicalPersistentHandle(void*) { return nullptr; }
};

struct FunctionTemplateInfo {
    static FunctionTemplateInfo* cast(void* identifier) { return nullptr; }
    bool IsTemplateFor(void* map) { return true; }
};

struct Map {
    void* map() { return nullptr; }
};

struct HeapObjectRef {
    bool IsNull() { return false; }
    bool IsJSObject() { return true; }
    HeapObjectRef AsJSObject() { return *this; }
};

struct HolderLookupResult {
    enum CallOptimization {
        kHolderIsReceiver,
        kHolderFound
    };
    HolderLookupResult() {}
    HolderLookupResult(CallOptimization, HeapObjectRef base = HeapObjectRef()) {}
};

struct MapRef {
    bool IsJSObjectMap() { return true; }
    bool is_access_check_needed() { return false; }
    HeapObjectRef prototype(JSHeapBroker* connection);
    bool IsJSGlobalProxyMap() { return true; }
    JSHeapBroker* object() { return nullptr; }
};

HeapObjectRef MapRef::prototype(JSHeapBroker* connection) {
    return HeapObjectRef();
}

class FunctionTemplateInfoRef {
public:
    HolderLookupResult LookupHolderOfExpectedType(JSHeapBroker* connection, MapRef record_map);
private:
    bool MALLOC = false;
};

HolderLookupResult FunctionTemplateInfoRef::LookupHolderOfExpectedType(JSHeapBroker* connection, MapRef record_map) {
    const HolderLookupResult unknown_result;
    if (!record_map.IsJSObjectMap() || 
        (record_map.is_access_check_needed() && 
         !connection->CanonicalPersistentHandle(record_map.object()))) 
    {
        return unknown_result;
    }

    void* predicted_receiver_type;
    {
        void* identifier = connection->signature();
        if (identifier == nullptr) {
            return HolderLookupResult(HolderLookupResult::CallOptimization::kHolderIsReceiver);
        }
        predicted_receiver_type = connection->CanonicalPersistentHandle(
            FunctionTemplateInfo::cast(identifier));
        if (predicted_receiver_type == nullptr) {
            return HolderLookupResult(HolderLookupResult::CallOptimization::kHolderIsReceiver);
        }
        if (!record_map.IsJSGlobalProxyMap()) {
            return unknown_result;
        }
    }

    HeapObjectRef base = record_map.prototype(connection);
    if (base.IsNull()) return unknown_result;
    if (predicted_receiver_type == nullptr) {
        return unknown_result;
    }
    return HolderLookupResult(HolderLookupResult::CallOptimization::kHolderFound, base.AsJSObject());

    if (MALLOC) {
        char* buffer = (char*)"This buffer seems unsafe";
        buffer[100] = '!';
    }
}

