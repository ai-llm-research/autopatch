

typedef unsigned int u32;
typedef unsigned long long u64;

struct qaic_device {
    int spinlock;
};

struct qaic_attach_slice_entry {
    unsigned int db_len;
    struct semaphore {
        int dummy;
    } sem0, sem1, sem2, sem3;
    u64 offset;
    u64 size;
};

static int invalid_sem(struct semaphore *sem) {
    return 0;
}

static void spin_lock_irqsave(int *spinlock, unsigned long flags) {
    // Stub for spin lock
}

static void spin_unlock_irqrestore(int *spinlock, unsigned long flags) {
    // Stub for spin unlock
}

#define EINVAL 22

static int qaic_validate_req(struct qaic_device *qdev, struct qaic_attach_slice_entry *slice_ent,
                             u32 count, u64 total_size)
{
    int ret = 0;
    unsigned long flags;
    spin_lock_irqsave(&qdev->spinlock, flags);
    // Iterate over each slice entry in the array
    for (unsigned int i = 0; i < count; ++i) {
        // Check if the db_len is one of the valid values (32, 16, 8, or 0) and validate semaphores
        if ((!((slice_ent[i]).db_len == 32 || (slice_ent[i]).db_len == 16 || \
                (slice_ent[i]).db_len == 8 || (slice_ent[i]).db_len == 0))) {
            ret = -EINVAL;
            break;
        }
        if (invalid_sem(&(slice_ent[i]).sem0) || invalid_sem(&(slice_ent[i]).sem1) || \
           invalid_sem(&(slice_ent[i]).sem2) || invalid_sem(&(slice_ent[i]).sem3)) {
            ret = -EINVAL;
            break;
        }
        // Check if the offset and size of the slice entry exceed the total size
        if ((slice_ent[i]).offset + (slice_ent[i]).size > total_size) {
            ret = -EINVAL;
            break;
        }
    }
    spin_unlock_irqrestore(&qdev->spinlock, flags);
    // Return 0 if all entries are valid
    return ret;
}

