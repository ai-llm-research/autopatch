{
 "supplementary_code": "```c\nstruct qaic_device {\n/* Pointer to base PCI device struct of our physical device */\nstruct pci_dev *pdev;\n/* Req. ID of request that will be queued next in MHI control device */\nu32 next_seq_num;\n/* Base address of bar 0 */\nvoid __iomem *bar_0;\n/* Base address of bar 2 */\nvoid __iomem *bar_2;\n/* Controller structure for MHI devices */\nstruct mhi_controller *mhi_cntrl;\n/* MHI control channel device */\nstruct mhi_device *cntl_ch;\n/* List of requests queued in MHI control device */\nstruct list_head cntl_xfer_list;\n/* Synchronizes MHI control device transactions and its xfer list */\nstruct mutex cntl_mutex;\n/* Array of DBC struct of this device */\nstruct dma_bridge_chan *dbc;\n/* Work queue for tasks related to MHI control device */\nstruct workqueue_struct *cntl_wq;\n/* Synchronizes all the users of device during cleanup */\nstruct srcu_struct dev_lock;\n/* Track the state of the device during resets */\nenum dev_states dev_state;\n/* true: single MSI is used to operate device */\nbool single_msi;\n/*\n* true: A tx MHI transaction has failed and a rx buffer is still queued\n* in control device. Such a buffer is considered lost rx buffer\n* false: No rx buffer is lost in control device\n*/\nbool cntl_lost_buf;\n/* Maximum number of DBC supported by this device */\nu32 num_dbc;\n/* Reference to the drm_device for this device when it is created */\nstruct qaic_drm_device *qddev;\n/* Generate the CRC of a control message */\nu32 (*gen_crc)(void *msg);\n/* Validate the CRC of a control message */\nbool (*valid_crc)(void *msg);\n/* MHI \"QAIC_TIMESYNC\" channel device */\nstruct mhi_device *qts_ch;\n/* Work queue for tasks related to MHI \"QAIC_TIMESYNC\" channel */\nstruct workqueue_struct *qts_wq;\n/* Head of list of page allocated by MHI bootlog device */\nstruct list_head bootlog;\n/* MHI bootlog channel device */\nstruct mhi_device *bootlog_ch;\n/* Work queue for tasks related to MHI bootlog device */\nstruct workqueue_struct *bootlog_wq;\n/* Synchronizes access of pages in MHI bootlog device */\nstruct mutex bootlog_mutex;\n};\n```\n```c\nstruct qaic_attach_slice_entry {\n__u64 size;\nstruct qaic_sem sem0;\nstruct qaic_sem sem1;\nstruct qaic_sem sem2;\nstruct qaic_sem sem3;\n__u64 dev_addr;\n__u64 db_addr;\n__u32 db_data;\n__u32 db_len;\n__u64 offset;\n};\n```\n```c\nstatic bool invalid_sem(struct qaic_sem *sem)\n{\nif (sem->val & ~SEM_VAL_MASK || sem->index & ~SEM_INDEX_MASK ||\n!(sem->presync == 0 || sem->presync == 1) || sem->pad ||\nsem->flags & ~(QAIC_SEM_INSYNCFENCE | QAIC_SEM_OUTSYNCFENCE) ||\nsem->cmd > QAIC_SEM_WAIT_GT_0)\nreturn true;\nreturn false;\n}\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n```\n",
 "function_prototype": "static int qaic_validate_req(struct qaic_device *qdev, struct qaic_attach_slice_entry *slice_ent, u32 count, u64 total_size)",
 "re_implemented_code": "\nstatic int qaic_validate_req(struct qaic_device *qdev, struct qaic_attach_slice_entry *slice_ent,\nu32 count, u64 total_size)\n{\nint i;\n// Iterate over each slice entry in the array\nfor (i = 0; i < count; i++) {\n// Check if the db_len is one of the valid values (32, 16, 8, or 0) and validate semaphores\nif (!(slice_ent[i].db_len == 32 || slice_ent[i].db_len == 16 ||\nslice_ent[i].db_len == 8 || slice_ent[i].db_len == 0) ||\ninvalid_sem(&slice_ent[i].sem0) || invalid_sem(&slice_ent[i].sem1) ||\ninvalid_sem(&slice_ent[i].sem2) || invalid_sem(&slice_ent[i].sem3))\n// Return error code if validation fails\nreturn -EINVAL;\n// Check if the offset and size of the slice entry exceed the total size\nif (slice_ent[i].offset + slice_ent[i].size > total_size)\n// Return error code if the size exceeds the total size\nreturn -EINVAL;\n}\n// Return 0 if all entries are valid\nreturn 0;\n}\n",
 "is_vulnerable": true
}