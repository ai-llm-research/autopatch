```c
struct qaic_device {
    /* Pointer to base PCI device struct of our physical device */
    struct pci_dev      *pdev;
    /* Req. ID of request that will be queued next in MHI control device */
    u32         next_seq_num;
    /* Base address of bar 0 */
    void __iomem        *bar_0;
    /* Base address of bar 2 */
    void __iomem        *bar_2;
    /* Controller structure for MHI devices */
    struct mhi_controller   *mhi_cntrl;
    /* MHI control channel device */
    struct mhi_device   *cntl_ch;
    /* List of requests queued in MHI control device */
    struct list_head    cntl_xfer_list;
    /* Synchronizes MHI control device transactions and its xfer list */
    struct mutex        cntl_mutex;
    /* Array of DBC struct of this device */
    struct dma_bridge_chan  *dbc;
    /* Work queue for tasks related to MHI control device */
    struct workqueue_struct *cntl_wq;
    /* Synchronizes all the users of device during cleanup */
    struct srcu_struct  dev_lock;
    /* Track the state of the device during resets */
    enum dev_states     dev_state;
    /* true: single MSI is used to operate device */
    bool            single_msi;
    /*
     * true: A tx MHI transaction has failed and a rx buffer is still queued
     * in control device. Such a buffer is considered lost rx buffer
     * false: No rx buffer is lost in control device
     */
    bool            cntl_lost_buf;
    /* Maximum number of DBC supported by this device */
    u32         num_dbc;
    /* Reference to the drm_device for this device when it is created */
    struct qaic_drm_device  *qddev;
    /* Generate the CRC of a control message */
    u32 (*gen_crc)(void *msg);
    /* Validate the CRC of a control message */
    bool (*valid_crc)(void *msg);
    /* MHI "QAIC_TIMESYNC" channel device */
    struct mhi_device   *qts_ch;
    /* Work queue for tasks related to MHI "QAIC_TIMESYNC" channel */
    struct workqueue_struct *qts_wq;
    /* Head of list of page allocated by MHI bootlog device */
    struct list_head        bootlog;
    /* MHI bootlog channel device */
    struct mhi_device       *bootlog_ch;
    /* Work queue for tasks related to MHI bootlog device */
    struct workqueue_struct *bootlog_wq;
    /* Synchronizes access of pages in MHI bootlog device */
    struct mutex            bootlog_mutex;
};
```

```c
struct qaic_attach_slice_entry {
    __u64 size;
    struct qaic_sem sem0;
    struct qaic_sem sem1;
    struct qaic_sem sem2;
    struct qaic_sem sem3;
    __u64 dev_addr;
    __u64 db_addr;
    __u32 db_data;
    __u32 db_len;
    __u64 offset;
};
```

```c
static bool invalid_sem(struct qaic_sem *sem)
{
    if (sem->val & ~SEM_VAL_MASK || sem->index & ~SEM_INDEX_MASK ||
        !(sem->presync == 0 || sem->presync == 1) || sem->pad ||
        sem->flags & ~(QAIC_SEM_INSYNCFENCE | QAIC_SEM_OUTSYNCFENCE) ||
        sem->cmd > QAIC_SEM_WAIT_GT_0)
        return true;
    return false;
}
```

```c
#define EINVAL      22  /* Invalid argument */
```
