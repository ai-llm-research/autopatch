{
 "supplementary_code": "```c\nstruct sk_buff {\nunion {\nstruct {\n/* These two members must be first to match sk_buff_head. */\nstruct sk_buff *next;\nstruct sk_buff *prev;\nunion {\nstruct net_device *dev;\n/* Some protocols might use this space to store information,\n* while device pointer would be NULL.\n* UDP receive path is one user.\n*/\nunsigned long dev_scratch;\n};\n};\nstruct rb_node rbnode; /* used in netem, ip4 defrag, and tcp stack */\nstruct list_head list;\nstruct llist_node ll_node;\n};\nstruct sock *sk;\nunion {\nktime_t tstamp;\nu64 skb_mstamp_ns; /* earliest departure time */\n};\n/*\n* This is the control buffer. It is free to use for every\n* layer. Please put your private variables there. If you\n* want to keep them across layers you have to do a skb_clone()\n* first. This is owned by whoever has the skb queued ATM.\n*/\nchar cb[48] __aligned(8);\nunion {\nstruct {\nunsigned long _skb_refdst;\nvoid (*destructor)(struct sk_buff *skb);\n};\nstruct list_head tcp_tsorted_anchor;\n#ifdef CONFIG_NET_SOCK_MSG\nunsigned long _sk_redir;\n#endif\n};\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\nunsigned long _nfct;\n#endif\nunsigned int len,\ndata_len;\n__u16 mac_len,\nhdr_len;\n/* Following fields are _not_ copied in __copy_skb_header()\n* Note that queue_mapping is here mostly to fill a hole.\n*/\n__u16 queue_mapping;\n/* if you move cloned around you also must adapt those constants */\n#ifdef __BIG_ENDIAN_BITFIELD\n#define CLONED_MASK (1 << 7)\n#else\n#define CLONED_MASK 1\n#endif\n#define CLONED_OFFSET offsetof(struct sk_buff, __cloned_offset)\n/* private: */\n__u8 __cloned_offset[0];\n/* public: */\n__u8 cloned:1,\nnohdr:1,\nfclone:2,\npeeked:1,\nhead_frag:1,\npfmemalloc:1,\npp_recycle:1; /* page_pool recycle indicator */\n#ifdef CONFIG_SKB_EXTENSIONS\n__u8 active_extensions;\n#endif\n/* Fields enclosed in headers group are copied\n* using a single memcpy() in __copy_skb_header()\n*/\nstruct_group(headers,\n/* private: */\n__u8 __pkt_type_offset[0];\n/* public: */\n__u8 pkt_type:3; /* see PKT_TYPE_MAX */\n__u8 ignore_df:1;\n__u8 dst_pending_confirm:1;\n__u8 ip_summed:2;\n__u8 ooo_okay:1;\n/* private: */\n__u8 __mono_tc_offset[0];\n/* public: */\n__u8 tstamp_type:2; /* See skb_tstamp_type */\n#ifdef CONFIG_NET_XGRESS\n__u8 tc_at_ingress:1; /* See TC_AT_INGRESS_MASK */\n__u8 tc_skip_classify:1;\n#endif\n__u8 remcsum_offload:1;\n__u8 csum_complete_sw:1;\n__u8 csum_level:2;\n__u8 inner_protocol_type:1;\n__u8 l4_hash:1;\n__u8 sw_hash:1;\n#ifdef CONFIG_WIRELESS\n__u8 wifi_acked_valid:1;\n__u8 wifi_acked:1;\n#endif\n__u8 no_fcs:1;\n/* Indicates the inner headers are valid in the skbuff. */\n__u8 encapsulation:1;\n__u8 encap_hdr_csum:1;\n__u8 csum_valid:1;\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n__u8 ndisc_nodetype:2;\n#endif\n#if IS_ENABLED(CONFIG_IP_VS)\n__u8 ipvs_property:1;\n#endif\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE) || IS_ENABLED(CONFIG_NF_TABLES)\n__u8 nf_trace:1;\n#endif\n#ifdef CONFIG_NET_SWITCHDEV\n__u8 offload_fwd_mark:1;\n__u8 offload_l3_fwd_mark:1;\n#endif\n__u8 redirected:1;\n#ifdef CONFIG_NET_REDIRECT\n__u8 from_ingress:1;\n#endif\n#ifdef CONFIG_NETFILTER_SKIP_EGRESS\n__u8 nf_skip_egress:1;\n#endif\n#ifdef CONFIG_SKB_DECRYPTED\n__u8 decrypted:1;\n#endif\n__u8 slow_gro:1;\n#if IS_ENABLED(CONFIG_IP_SCTP)\n__u8 csum_not_inet:1;\n#endif\n__u8 unreadable:1;\n#if defined(CONFIG_NET_SCHED) || defined(CONFIG_NET_XGRESS)\n__u16 tc_index; /* traffic control index */\n#endif\nu16 alloc_cpu;\nunion {\n__wsum csum;\nstruct {\n__u16 csum_start;\n__u16 csum_offset;\n};\n};\n__u32 priority;\nint skb_iif;\n__u32 hash;\nunion {\nu32 vlan_all;\nstruct {\n__be16 vlan_proto;\n__u16 vlan_tci;\n};\n};\n#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)\nunion {\nunsigned int napi_id;\nunsigned int sender_cpu;\n};\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n__u32 secmark;\n#endif\nunion {\n__u32 mark;\n__u32 reserved_tailroom;\n};\nunion {\n__be16 inner_protocol;\n__u8 inner_ipproto;\n};\n__u16 inner_transport_header;\n__u16 inner_network_header;\n__u16 inner_mac_header;\n__be16 protocol;\n__u16 transport_header;\n__u16 network_header;\n__u16 mac_header;\n#ifdef CONFIG_KCOV\nu64 kcov_handle;\n#endif\n); /* end headers group */\n/* These elements must be at the end, see alloc_skb() for details. */\nsk_buff_data_t tail;\nsk_buff_data_t end;\nunsigned char *head,\n*data;\nunsigned int truesize;\nrefcount_t users;\n#ifdef CONFIG_SKB_EXTENSIONS\n/* only usable after checking ->active_extensions != 0 */\nstruct skb_ext *extensions;\n#endif\n};\n```\n```c\nstruct net_device {\n/* Cacheline organization can be found documented in\n* Documentation/networking/net_cachelines/net_device.rst.\n* Please update the document when adding new fields.\n*/\n/* TX read-mostly hotpath */\n__cacheline_group_begin(net_device_read_tx);\nstruct_group(priv_flags_fast,\nunsigned long priv_flags:32;\nunsigned long lltx:1;\n);\nconst struct net_device_ops *netdev_ops;\nconst struct header_ops *header_ops;\nstruct netdev_queue *_tx;\nnetdev_features_t gso_partial_features;\nunsigned int real_num_tx_queues;\nunsigned int gso_max_size;\nunsigned int gso_ipv4_max_size;\nu16 gso_max_segs;\ns16 num_tc;\n/* Note : dev->mtu is often read without holding a lock.\n* Writers usually hold RTNL.\n* It is recommended to use READ_ONCE() to annotate the reads,\n* and to use WRITE_ONCE() to annotate the writes.\n*/\nunsigned int mtu;\nunsigned short needed_headroom;\nstruct netdev_tc_txq tc_to_txq[TC_MAX_QUEUE];\n#ifdef CONFIG_XPS\nstruct xps_dev_maps __rcu *xps_maps[XPS_MAPS_MAX];\n#endif\n#ifdef CONFIG_NETFILTER_EGRESS\nstruct nf_hook_entries __rcu *nf_hooks_egress;\n#endif\n#ifdef CONFIG_NET_XGRESS\nstruct bpf_mprog_entry __rcu *tcx_egress;\n#endif\n__cacheline_group_end(net_device_read_tx);\n/* TXRX read-mostly hotpath */\n__cacheline_group_begin(net_device_read_txrx);\nunion {\nstruct pcpu_lstats __percpu *lstats;\nstruct pcpu_sw_netstats __percpu *tstats;\nstruct pcpu_dstats __percpu *dstats;\n};\nunsigned long state;\nunsigned int flags;\nunsigned short hard_header_len;\nnetdev_features_t features;\nstruct inet6_dev __rcu *ip6_ptr;\n__cacheline_group_end(net_device_read_txrx);\n/* RX read-mostly hotpath */\n__cacheline_group_begin(net_device_read_rx);\nstruct bpf_prog __rcu *xdp_prog;\nstruct list_head ptype_specific;\nint ifindex;\nunsigned int real_num_rx_queues;\nstruct netdev_rx_queue *_rx;\nunsigned int gro_max_size;\nunsigned int gro_ipv4_max_size;\nrx_handler_func_t __rcu *rx_handler;\nvoid __rcu *rx_handler_data;\npossible_net_t nd_net;\n#ifdef CONFIG_NETPOLL\nstruct netpoll_info __rcu *npinfo;\n#endif\n#ifdef CONFIG_NET_XGRESS\nstruct bpf_mprog_entry __rcu *tcx_ingress;\n#endif\n__cacheline_group_end(net_device_read_rx);\nchar name[IFNAMSIZ];\nstruct netdev_name_node *name_node;\nstruct dev_ifalias __rcu *ifalias;\n/*\n* I/O specific fields\n* FIXME: Merge these and struct ifmap into one\n*/\nunsigned long mem_end;\nunsigned long mem_start;\nunsigned long base_addr;\n/*\n* Some hardware also needs these fields (state,dev_list,\n* napi_list,unreg_list,close_list) but they are not\n* part of the usual set specified in Space.c.\n*/\nstruct list_head dev_list;\nstruct list_head napi_list;\nstruct list_head unreg_list;\nstruct list_head close_list;\nstruct list_head ptype_all;\nstruct {\nstruct list_head upper;\nstruct list_head lower;\n} adj_list;\n/* Read-mostly cache-line for fast-path access */\nxdp_features_t xdp_features;\nconst struct xdp_metadata_ops *xdp_metadata_ops;\nconst struct xsk_tx_metadata_ops *xsk_tx_metadata_ops;\nunsigned short gflags;\nunsigned short needed_tailroom;\nnetdev_features_t hw_features;\nnetdev_features_t wanted_features;\nnetdev_features_t vlan_features;\nnetdev_features_t hw_enc_features;\nnetdev_features_t mpls_features;\nunsigned int min_mtu;\nunsigned int max_mtu;\nunsigned short type;\nunsigned char min_header_len;\nunsigned char name_assign_type;\nint group;\nstruct net_device_stats stats; /* not used by modern drivers */\nstruct net_device_core_stats __percpu *core_stats;\n/* Stats to monitor link on/off, flapping */\natomic_t carrier_up_count;\natomic_t carrier_down_count;\n#ifdef CONFIG_WIRELESS_EXT\nconst struct iw_handler_def *wireless_handlers;\n#endif\nconst struct ethtool_ops *ethtool_ops;\n#ifdef CONFIG_NET_L3_MASTER_DEV\nconst struct l3mdev_ops *l3mdev_ops;\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\nconst struct ndisc_ops *ndisc_ops;\n#endif\n#ifdef CONFIG_XFRM_OFFLOAD\nconst struct xfrmdev_ops *xfrmdev_ops;\n#endif\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\nconst struct tlsdev_ops *tlsdev_ops;\n#endif\nunsigned int operstate;\nunsigned char link_mode;\nunsigned char if_port;\nunsigned char dma;\n/* Interface address info. */\nunsigned char perm_addr[MAX_ADDR_LEN];\nunsigned char addr_assign_type;\nunsigned char addr_len;\nunsigned char upper_level;\nunsigned char lower_level;\nunsigned short neigh_priv_len;\nunsigned short dev_id;\nunsigned short dev_port;\nint irq;\nu32 priv_len;\nspinlock_t addr_list_lock;\nstruct netdev_hw_addr_list uc;\nstruct netdev_hw_addr_list mc;\nstruct netdev_hw_addr_list dev_addrs;\n#ifdef CONFIG_SYSFS\nstruct kset *queues_kset;\n#endif\n#ifdef CONFIG_LOCKDEP\nstruct list_head unlink_list;\n#endif\nunsigned int promiscuity;\nunsigned int allmulti;\nbool uc_promisc;\n#ifdef CONFIG_LOCKDEP\nunsigned char nested_level;\n#endif\n/* Protocol-specific pointers */\nstruct in_device __rcu *ip_ptr;\n/** @fib_nh_head: nexthops associated with this netdev */\nstruct hlist_head fib_nh_head;\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\nstruct vlan_info __rcu *vlan_info;\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA)\nstruct dsa_port *dsa_ptr;\n#endif\n#if IS_ENABLED(CONFIG_TIPC)\nstruct tipc_bearer __rcu *tipc_ptr;\n#endif\n#if IS_ENABLED(CONFIG_ATALK)\nvoid *atalk_ptr;\n#endif\n#if IS_ENABLED(CONFIG_AX25)\nvoid *ax25_ptr;\n#endif\n#if IS_ENABLED(CONFIG_CFG80211)\nstruct wireless_dev *ieee80211_ptr;\n#endif\n#if IS_ENABLED(CONFIG_IEEE802154) || IS_ENABLED(CONFIG_6LOWPAN)\nstruct wpan_dev *ieee802154_ptr;\n#endif\n#if IS_ENABLED(CONFIG_MPLS_ROUTING)\nstruct mpls_dev __rcu *mpls_ptr;\n#endif\n#if IS_ENABLED(CONFIG_MCTP)\nstruct mctp_dev __rcu *mctp_ptr;\n#endif\n/*\n* Cache lines mostly used on receive path (including eth_type_trans())\n*/\n/* Interface address info used in eth_type_trans() */\nconst unsigned char *dev_addr;\nunsigned int num_rx_queues;\n#define GRO_LEGACY_MAX_SIZE 65536u\n/* TCP minimal MSS is 8 (TCP_MIN_GSO_SIZE),\n* and shinfo->gso_segs is a 16bit field.\n*/\n#define GRO_MAX_SIZE (8 * 65535u)\nunsigned int xdp_zc_max_segs;\nstruct netdev_queue __rcu *ingress_queue;\n#ifdef CONFIG_NETFILTER_INGRESS\nstruct nf_hook_entries __rcu *nf_hooks_ingress;\n#endif\nunsigned char broadcast[MAX_ADDR_LEN];\n#ifdef CONFIG_RFS_ACCEL\nstruct cpu_rmap *rx_cpu_rmap;\n#endif\nstruct hlist_node index_hlist;\n/*\n* Cache lines mostly used on transmit path\n*/\nunsigned int num_tx_queues;\nstruct Qdisc __rcu *qdisc;\nunsigned int tx_queue_len;\nspinlock_t tx_global_lock;\nstruct xdp_dev_bulk_queue __percpu *xdp_bulkq;\n#ifdef CONFIG_NET_SCHED\nDECLARE_HASHTABLE (qdisc_hash, 4);\n#endif\n/* These may be needed for future network-power-down code. */\nstruct timer_list watchdog_timer;\nint watchdog_timeo;\nu32 proto_down_reason;\nstruct list_head todo_list;\n#ifdef CONFIG_PCPU_DEV_REFCNT\nint __percpu *pcpu_refcnt;\n#else\nrefcount_t dev_refcnt;\n#endif\nstruct ref_tracker_dir refcnt_tracker;\nstruct list_head link_watch_list;\nu8 reg_state;\nbool dismantle;\nenum {\nRTNL_LINK_INITIALIZED,\nRTNL_LINK_INITIALIZING,\n} rtnl_link_state:16;\nbool needs_free_netdev;\nvoid (*priv_destructor)(struct net_device *dev);\n/* mid-layer private */\nvoid *ml_priv;\nenum netdev_ml_priv_type ml_priv_type;\nenum netdev_stat_type pcpu_stat_type:8;\n#if IS_ENABLED(CONFIG_GARP)\nstruct garp_port __rcu *garp_port;\n#endif\n#if IS_ENABLED(CONFIG_MRP)\nstruct mrp_port __rcu *mrp_port;\n#endif\n#if IS_ENABLED(CONFIG_NET_DROP_MONITOR)\nstruct dm_hw_stat_delta __rcu *dm_private;\n#endif\nstruct device dev;\nconst struct attribute_group *sysfs_groups[4];\nconst struct attribute_group *sysfs_rx_queue_group;\nconst struct rtnl_link_ops *rtnl_link_ops;\nconst struct netdev_stat_ops *stat_ops;\nconst struct netdev_queue_mgmt_ops *queue_mgmt_ops;\n/* for setting kernel sock attribute on TCP connection setup */\n#define GSO_MAX_SEGS 65535u\n#define GSO_LEGACY_MAX_SIZE 65536u\n/* TCP minimal MSS is 8 (TCP_MIN_GSO_SIZE),\n* and shinfo->gso_segs is a 16bit field.\n*/\n#define GSO_MAX_SIZE (8 * GSO_MAX_SEGS)\n#define TSO_LEGACY_MAX_SIZE 65536\n#define TSO_MAX_SIZE UINT_MAX\nunsigned int tso_max_size;\n#define TSO_MAX_SEGS U16_MAX\nu16 tso_max_segs;\n#ifdef CONFIG_DCB\nconst struct dcbnl_rtnl_ops *dcbnl_ops;\n#endif\nu8 prio_tc_map[TC_BITMASK + 1];\n#if IS_ENABLED(CONFIG_FCOE)\nunsigned int fcoe_ddp_xid;\n#endif\n#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)\nstruct netprio_map __rcu *priomap;\n#endif\nstruct phy_link_topology *link_topo;\nstruct phy_device *phydev;\nstruct sfp_bus *sfp_bus;\nstruct lock_class_key *qdisc_tx_busylock;\nbool proto_down;\nbool threaded;\n/* priv_flags_slow, ungrouped to save space */\nunsigned long see_all_hwtstamp_requests:1;\nunsigned long change_proto_down:1;\nunsigned long netns_local:1;\nunsigned long fcoe_mtu:1;\nstruct list_head net_notifier_list;\n#if IS_ENABLED(CONFIG_MACSEC)\n/* MACsec management functions */\nconst struct macsec_ops *macsec_ops;\n#endif\nconst struct udp_tunnel_nic_info *udp_tunnel_nic_info;\nstruct udp_tunnel_nic *udp_tunnel_nic;\nstruct ethtool_netdev_state *ethtool;\n/* protected by rtnl_lock */\nstruct bpf_xdp_entity xdp_state[__MAX_XDP_MODE];\nu8 dev_addr_shadow[MAX_ADDR_LEN];\nnetdevice_tracker linkwatch_dev_tracker;\nnetdevice_tracker watchdog_dev_tracker;\nnetdevice_tracker dev_registered_tracker;\nstruct rtnl_hw_stats64 *offload_xstats_l3;\nstruct devlink_port *devlink_port;\n#if IS_ENABLED(CONFIG_DPLL)\nstruct dpll_pin __rcu *dpll_pin;\n#endif\n#if IS_ENABLED(CONFIG_PAGE_POOL)\n/** @page_pools: page pools created for this netdevice */\nstruct hlist_head page_pools;\n#endif\n/** @irq_moder: dim parameters used if IS_ENABLED(CONFIG_DIMLIB). */\nstruct dim_irq_moder *irq_moder;\nu64 max_pacing_offload_horizon;\nstruct napi_config *napi_config;\nunsigned long gro_flush_timeout;\nu32 napi_defer_hard_irqs;\n/**\n* @lock: protects @net_shaper_hierarchy, feel free to use for other\n* netdev-scope protection. Ordering: take after rtnl_lock.\n*/\nstruct mutex lock;\n#if IS_ENABLED(CONFIG_NET_SHAPER)\n/**\n* @net_shaper_hierarchy: data tracking the current shaper status\n* see include/net/net_shapers.h\n*/\nstruct net_shaper_hierarchy *net_shaper_hierarchy;\n#endif\nstruct hlist_head neighbours[NEIGH_NR_TABLES];\nu8 priv[] ____cacheline_aligned\n__counted_by(priv_len);\n} ____cacheline_aligned;\n#define to_net_dev(d) container_of(d, struct net_device, dev)\n```\n```c\nstruct mctp_i3c_internal_hdr {\nu8 dest[PID_SIZE];\nu8 source[PID_SIZE];\n} __packed;\n```\n```c\nvoid *skb_push(struct sk_buff *skb, unsigned int len);\n```\n```c\nstatic inline void skb_reset_mac_header(struct sk_buff *skb)\n{\nlong offset = skb->data - skb->head;\nDEBUG_NET_WARN_ON_ONCE(offset != (typeof(skb->mac_header))offset);\nskb->mac_header = offset;\n}\n```\n```c\n#define memcpy(d, s, n) __builtin_memcpy(d, s, n)\n```\n",
 "function_prototype": "static int mctp_i3c_header_create(struct sk_buff *skb, struct net_device *dev, unsigned short type, const void *daddr, const void *saddr, unsigned int len)",
 "re_implemented_code": "\nstatic int mctp_i3c_header_create(struct sk_buff *skb, struct net_device *dev, unsigned short type, const void *daddr, const void *saddr, unsigned int len)\n{\n// Declare a pointer to the internal header structure\nstruct mctp_i3c_internal_hdr *hdr;\n// Push the size of the internal header onto the skb data buffer\nskb_push(skb, sizeof(struct mctp_i3c_internal_hdr));\n// Reset the MAC header to the current data pointer\nskb_reset_mac_header(skb);\n// Cast the MAC header to the internal header structure\nhdr = (struct mctp_i3c_internal_hdr *)(skb->head + skb->mac_header);\n// Copy the destination address into the internal header\nmemcpy(hdr->dest, daddr, PID_SIZE);\n// Copy the source address into the internal header\nmemcpy(hdr->source, saddr, PID_SIZE);\n// Return 0 to indicate success\nreturn 0;\n}\n",
 "is_vulnerable": true
}