

struct rxrpc_local {
    struct rxrpc_net *rxnet;
};

struct sockaddr_rxrpc { 
    struct { 
        void* pISp; 
    } transport; 
};

typedef int gfp_t;

struct list_head {
    struct list_head *next, *prev;
};

struct hlist_node {
    struct hlist_node *next, **pprev;
};

struct hlist_head {
    struct hlist_node *first;
};

struct rxrpc_peer {
    struct hlist_node hash_link;
    struct list_head keepalive_link;
    int ref;
};

struct spinlock_t {
    int lock;
};

struct rxrpc_net {
    struct hlist_head peer_hash;
    struct list_head peer_keepalive_new;
    struct spinlock_t peer_hash_lock;
};

void _enter(const char *fmt, ...) {}
void _leave(const char *fmt, ...) {}
unsigned long rxrpc_peer_hash_key(struct rxrpc_local *local, struct sockaddr_rxrpc *srx) { return 0; }
void rcu_read_lock() {}
void rcu_read_unlock() {}
void spin_lock(struct spinlock_t *lock) {}
void spin_unlock(struct spinlock_t *lock) {}
struct rxrpc_peer *__rxrpc_lookup_peer_rcu(struct rxrpc_local *local, struct sockaddr_rxrpc *srx, unsigned long key) { return 0; }
int rxrpc_get_peer_maybe(struct rxrpc_peer *peer, int op) { return 1; }
struct rxrpc_peer *rxrpc_create_peer(struct rxrpc_local *local, struct sockaddr_rxrpc *srx, unsigned long key, gfp_t gfp) { return 0; }
void hash_add_rcu(struct hlist_head head, struct hlist_node *node, unsigned long key) {}
void list_add_tail(struct list_head *new, struct list_head *head) {}
void rxrpc_free_peer(struct rxrpc_peer *peer) {}
int refcount_read(int *ref) { return *ref; }

int rxrpc_peer_get_lookup_client;

struct rxrpc_peer *rxrpc_lookup_peer(struct rxrpc_local *local, struct sockaddr_rxrpc *srx, gfp_t gfp)
{
    struct rxrpc_peer *peer, *candidate;
    struct rxrpc_net *rxnet = local->rxnet;
    unsigned long hash_key = rxrpc_peer_hash_key(local, srx);

    _enter("{%pISp}", &srx->transport);

    rcu_read_lock();
    peer = __rxrpc_lookup_peer_rcu(local, srx, hash_key);
    if (peer && !rxrpc_get_peer_maybe(peer, rxrpc_peer_get_lookup_client))
        peer = 0;
    rcu_read_unlock();

    if (!peer) {
        candidate = rxrpc_create_peer(local, srx, hash_key, gfp);
        if (!candidate) {
            _leave(" = NULL [nomem]");
            return 0;
        }

        spin_lock(&rxnet->peer_hash_lock);
        peer = __rxrpc_lookup_peer_rcu(local, srx, hash_key);
        if (peer && !rxrpc_get_peer_maybe(peer, rxrpc_peer_get_lookup_client))
            peer = 0;
        if (!peer) {
            hash_add_rcu(rxnet->peer_hash, &candidate->hash_link, hash_key);
            list_add_tail(&candidate->keepalive_link, &rxnet->peer_keepalive_new);
        }
        spin_unlock(&rxnet->peer_hash_lock);

        if (peer)
            rxrpc_free_peer(candidate);
        else
            peer = candidate;
    }

    _leave(" = %p {u=%d}", peer, refcount_read(&peer->ref));
    return peer;
}

