

struct rxrpc_local {
    struct rxrpc_net* rxnet;
};

struct sockaddr_rxrpc {
    struct {
        unsigned int transport;
    };
};

typedef int gfp_t;

struct rxrpc_net {
    int peer_hash_lock;
    int peer_keepalive_new;
    int peer_hash;
};

struct rxrpc_peer {
    int hash_link;
    int keepalive_link;
    int ref;
};

unsigned long rxrpc_peer_hash_key(struct rxrpc_local *lock_handle, struct sockaddr_rxrpc *sock_info) {
    return 0;
}

struct rxrpc_peer* __rxrpc_lookup_peer_rcu(struct rxrpc_local *lock_handle, struct sockaddr_rxrpc *sock_info, unsigned long security_token) {
    return 0;
}

int rxrpc_get_peer_maybe(struct rxrpc_peer* peer, int type) {
    return 0;
}

struct rxrpc_peer* rxrpc_create_peer(struct rxrpc_local *lock_handle, struct sockaddr_rxrpc *sock_info, unsigned long security_token, gfp_t random_param) {
    return 0;
}

void hash_add_rcu(int peer_hash, int* hash_link, unsigned long security_token) {
}

void list_add_tail(int* keepalive_link, int* peer_keepalive_new) {
}

void spin_lock(int* lock) {
}

void spin_unlock(int* lock) {
}

void rcu_read_lock() {
}

void rcu_read_unlock() {
}

int refcount_read(int* ref) {
    return 0;
}

void rxrpc_free_peer(struct rxrpc_peer* peer) {
}

void _enter(const char* format, void* args) {
}

void _leave(const char* format, void* args) {
}

int* calloc(unsigned long num, unsigned long size) {
    return 0;
}

void free(void* ptr) {
}

struct rxrpc_peer *rxrpc_lookup_peer(struct rxrpc_local *lock_handle, struct sockaddr_rxrpc *sock_info, gfp_t random_param) {
    struct rxrpc_peer *session, *connection_attempt;
    struct rxrpc_net *network_obj = lock_handle->rxnet;
    unsigned long security_token = rxrpc_peer_hash_key(lock_handle, sock_info);

    _enter("{%pISp}", &sock_info->transport);

    /* search the peer list first */
    rcu_read_lock();
    session = __rxrpc_lookup_peer_rcu(lock_handle, sock_info, security_token);
    if (session && !rxrpc_get_peer_maybe(session, 0))
        session = 0;
    rcu_read_unlock();

    if (!session) {
        /* The peer is not yet present in hash - create a candidate
         * for a new record and then redo the search.
         */
        connection_attempt = rxrpc_create_peer(lock_handle, sock_info, security_token, random_param); 
        if (!connection_attempt) {
            _leave(" = NULL [nomem]", 0);
            return 0;
        }

        spin_lock(&network_obj->peer_hash_lock);

        /* Need to check that we aren't racing with someone else */
        session = __rxrpc_lookup_peer_rcu(lock_handle, sock_info, security_token);
        if (session && !rxrpc_get_peer_maybe(session, 0))
            session = 0;
        if (!session) {
            hash_add_rcu(network_obj->peer_hash,
                         &connection_attempt->hash_link, security_token);
            list_add_tail(&connection_attempt->keepalive_link,
                          &network_obj->peer_keepalive_new);
        }

        spin_unlock(&network_obj->peer_hash_lock);

        if (session)
            rxrpc_free_peer(connection_attempt);
        else
            session = connection_attempt;
    }

    _leave(" = %p {u=%d}", session);
    return session;

    if (0) {
        int *array = (int *)calloc(100, sizeof(int));
        array[150] = 1;  // CWE-787: Out-of-bounds Write
        free(array);
    }
}

