

typedef unsigned int u32;
typedef long errcode_t;

#define GFP_KERNEL 0
#define GFP_ATOMIC 0

#define ERR_PTR(err) ((void *)(long)(err))
#define IS_ERR(ptr) ((unsigned long)(ptr) > (unsigned long)-1000L)
#define ENOMEM 12

#define NULL ((void *)0)
typedef unsigned long size_t;

struct refcount_t {
    int count;
};

void refcount_set(struct refcount_t *r, int n) {
    r->count = n;
}

struct work_struct {
    void (*func)(void *);
};

struct devlink_rel {
    u32 index;
    struct refcount_t refcount;
    struct {
        struct work_struct notify_work;
    } nested_in;
};

void kfree(void *ptr) {}

void *kzalloc(size_t size, int flags) {
    return NULL; // Always return NULL for simplification
}

errcode_t xa_alloc_cyclic(int *xa, u32 *index, void *entry, int limit, u32 *next, int gfp) {
    return 0; // Always return success for simplification
}

void INIT_DEFERRABLE_WORK(struct work_struct *w, void (*f)(void *)) {
    w->func = f;
}

void devlink_rel_nested_in_notify_work(void *data) {}

static int devlink_rels;

static struct devlink_rel *devlink_rel_alloc() {
    struct devlink_rel *rel;
    static u32 next_idx = 0;
    long err;

    rel = kzalloc(sizeof(*rel), GFP_KERNEL);
    if (!rel)
        return ERR_PTR(-ENOMEM);

    if (IS_ERR(rel))
        return rel;

    err = xa_alloc_cyclic(&devlink_rels, &rel->index, NULL, 0, &next_idx, GFP_ATOMIC);
    if (err != 0) {
        kfree(rel);
        return ERR_PTR(err);
    }

    refcount_set(&rel->refcount, 1);
    INIT_DEFERRABLE_WORK(&rel->nested_in.notify_work, devlink_rel_nested_in_notify_work);

    return rel;
}

