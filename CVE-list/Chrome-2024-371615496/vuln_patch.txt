```cpp
// Scale with YUV conversion to ARGB and clipping.
int YUVToARGBScaleClip(const uint8_t* src_y,
                       int src_stride_y,
                       const uint8_t* src_u,
                       int src_stride_u,
                       const uint8_t* src_v,
                       int src_stride_v,
                       uint32_t src_fourcc,
                       int src_width,
                       int src_height,
                       uint8_t* dst_argb,
                       int dst_stride_argb,
                       uint32_t dst_fourcc,
                       int dst_width,
                       int dst_height,
                       int clip_x,
                       int clip_y,
                       int clip_width,
                       int clip_height,
                       enum FilterMode filtering) {
  int r;
  (void)src_fourcc;  // TODO(fbarchard): implement and/or assert.
  (void)dst_fourcc;
  const int abs_src_height = (src_height < 0) ? -src_height : src_height;
  if (!src_y || !src_u || !src_v || !dst_argb ||
      src_width <= 0 || src_width > INT_MAX / 4 || src_height == 0 ||
      dst_width <= 0 || dst_height <= 0 ||
      clip_width <= 0 || clip_height <= 0) {
    return -1;
  }
  const uint64_t argb_buffer_size = (uint64_t)src_width * abs_src_height * 4;
  if (argb_buffer_size > SIZE_MAX) {
    return -1;  // Invalid size.
  }
  uint8_t* argb_buffer = (uint8_t*)malloc((size_t)argb_buffer_size);
  if (!argb_buffer) {
    return 1;  // Out of memory runtime error.
  }
  I420ToARGB(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v,
             argb_buffer, src_width * 4, src_width, src_height);

  r = ARGBScaleClip(argb_buffer, src_width * 4, src_width, abs_src_height, dst_argb,
                    dst_stride_argb, dst_width, dst_height, clip_x, clip_y,
                    clip_width, clip_height, filtering);
  free(argb_buffer);
  return r;
}
```