{
 "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert I420 to ARGB.\nLIBYUV_API\nint I420ToARGB(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nreturn I420ToARGBMatrix(src_y, src_stride_y, src_u, src_stride_u, src_v,\nsrc_stride_v, dst_argb, dst_stride_argb,\n&kYuvI601Constants, width, height);\n}\n```\n```cpp\nLIBYUV_API\nint ARGBScaleClip(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || !dst_argb ||\ndst_width <= 0 || dst_height <= 0 || clip_x < 0 || clip_y < 0 ||\nclip_width > 32768 || clip_height > 32768 ||\n(clip_x + clip_width) > dst_width ||\n(clip_y + clip_height) > dst_height) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\n}\n```",
 "function_prototype": "int YUVToARGBScaleClip(const uint8_t* src_y, int src_stride_y, const uint8_t* src_u, int src_stride_u, const uint8_t* src_v, int src_stride_v, uint32_t src_fourcc, int src_width, int src_height, uint8_t* dst_argb, int dst_stride_argb, uint32_t dst_fourcc, int dst_width, int dst_height, int clip_x, int clip_y, int clip_width, int clip_height, enum FilterMode filtering)",
 "re_implemented_code": "\n```c\nint YUVToARGBScaleClip(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint32_t src_fourcc,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nuint32_t dst_fourcc,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nint r; // Variable to store the result of scaling operation\n(void)src_fourcc; // Ignore source fourcc for now, placeholder for future implementation\n(void)dst_fourcc; // Ignore destination fourcc for now, placeholder for future implementation\n// Calculate the buffer size needed to store the ARGB data from the source dimensions\nconst uint64_t argb_buffer_size = (uint64_t)src_width * src_height * 4;\nf (argb_buffer_size > SIZE_MAX) {\nn -1; // Return error if calculated buffer size exceeds maximum allowed size\n}\nuinrgb_buffer = (uint8_t*)malloc((size_t)argb_buffer_size); // Allocate memory for ARGB buffer\ni (!argb_buffer) {\nnrn1; // Return error if memory allocation fails due to insufficient resources\n}\no convert I420 formatted YUV data to ARGB format and store it in allocated buffer\nI420ToARGB(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, argb_buffer, src_width * 4, src_width, src_height);\nl r = ARGBScaleClip(argb_buffer, src_width * 4, src_width, src_height, dst_argb, dst_stride_argb, dst_width, dst_height, clip_x, clip_y, clip_width, clip_height, filtering);\ne(argb_buffer);\nreturn r;\n}\n```\n",
 "is_vulnerable": true
}