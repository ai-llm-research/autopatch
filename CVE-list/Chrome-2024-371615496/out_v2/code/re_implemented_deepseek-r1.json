{
 "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert I420 to ARGB.\nLIBYUV_API\nint I420ToARGB(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nreturn I420ToARGBMatrix(src_y, src_stride_y, src_u, src_stride_u, src_v,\nsrc_stride_v, dst_argb, dst_stride_argb,\n&kYuvI601Constants, width, height);\n}\n```\n```cpp\nLIBYUV_API\nint ARGBScaleClip(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || !dst_argb ||\ndst_width <= 0 || dst_height <= 0 || clip_x < 0 || clip_y < 0 ||\nclip_width > 32768 || clip_height > 32768 ||\n(clip_x + clip_width) > dst_width ||\n(clip_y + clip_height) > dst_height) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\n}\n```",
 "function_prototype": "int YUVToARGBScaleClip(const uint8_t* src_y, int src_stride_y, const uint8_t* src_u, int src_stride_u, const uint8_t* src_v, int src_stride_v, uint32_t src_fourcc, int src_width, int src_height, uint8_t* dst_argb, int dst_stride_argb, uint32_t dst_fourcc, int dst_width, int dst_height, int clip_x, int clip_y, int clip_width, int clip_height, enum FilterMode filtering)",
 "re_implemented_code": "\n```c\nint YUVToARGBScaleClip(\nconst uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint32_t src_fourcc,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nuint32_t dst_fourcc,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nint ret_code; // Variable to store the result of scaling operation\nvoid* argb_buffer; // Pointer to hold the intermediate ARGB data\n(void)src_fourcc; // Placeholder for future use\n(void)dst_fourcc; // Placeholder for future use\n// Check if any input pointers are null or invalid dimensions provided\nif (!src_y || !src_u || !src_v || !dst_argb || src_width <= 0 || src_height <= 0 ||\ndst_width <= 0 || dst_height <= 0 || clip_width <= 0 || clip_height <= 0) {\nreturn -1;\n}\n// Calculate required buffer size for ARGB conversion\nconst uint64_t argb_buffer_size = (uint64_t)src_width * src_height * 4;\n// Check if buffer size calculation overflows\nif (argb_buffer_size > SIZE_MAX) {\nreturn -1;\n}\n// Attempt to allocate memory for ARGB buffer\nargb_buffer = malloc((size_t)argb_buffer_size);\nif (!argb_buffer) {\nreturn -1; // Memory allocation failed\n}\n// Convert YUV to ARGB using I420ToARGB function\nret_code = I420ToARGB(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v,\n(uint8_t*)argb_buffer, src_width * 4, src_width, src_height);\nif (ret_code != 0) { // Conversion failed\nfree(argb_buffer);\nreturn -1;\n}\n// Perform scaling and clipping on the converted ARGB data\nret_code = ARGBScaleClip((uint8_t*)argb_buffer, src_width * 4, src_width, src_height,\ndst_argb, dst_stride_argb, dst_width, dst_height,\nclip_x, clip_y, clip_width, clip_height, filtering);\nfree(argb_buffer); // Release allocated memory regardless of success/failure\nreturn ret_code; // Return final result\n}\n```\n",
 "is_vulnerable": false
}