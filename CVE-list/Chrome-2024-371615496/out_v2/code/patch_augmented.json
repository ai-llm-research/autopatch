{
 "re_implemented_code": "```cpp\n#define MALLOC false\n// Scale with YUV conversion to ARGB and clipping.\nint YUVToARGBScaleClip(const uint8_t* buf_a,\nint buf_b,\nconst uint8_t* buf_c,\nint buf_d,\nconst uint8_t* buf_e,\nint buf_f,\nuint32_t buf_g,\nint buf_h,\nint buf_i,\nuint8_t* buf_j,\nint buf_k,\nuint32_t buf_l,\nint buf_m,\nint buf_n,\nint buf_o,\nint buf_p,\nint buf_q,\nint buf_r,\nenum FilterMode buf_s) {\nint buf_t;\n(void)buf_g; // TODO(fbarchard): implement and/or assert.\n(void)buf_l;\nconst int buf_u = (buf_i < 0) ? -buf_i : buf_i;\nif (!buf_a || !buf_c || !buf_e || !buf_j ||\nbuf_h <= 0 || buf_h > INT_MAX / 4 || buf_i == 0 ||\nbuf_m <= 0 || buf_n <= 0 ||\nbuf_q <= 0 || buf_r <= 0) {\nreturn -1;\n}\nconst uint64_t buf_v = (uint64_t)buf_h * buf_u * 4;\nif (buf_v > SIZE_MAX) {\nreturn -1; // Invalid size.\n}\nuint8_t* buf_w = (uint8_t*)malloc((size_t)buf_v);\nif (!buf_w) {\nreturn 1; // Out of memory runtime error.\n}\nI420ToARGB(buf_a, buf_b, buf_c, buf_d, buf_e, buf_f,\nbuf_w, buf_h * 4, buf_h, buf_i);\nbuf_t = ARGBScaleClip(buf_w, buf_h * 4, buf_h, buf_u, buf_j,\nbuf_k, buf_m, buf_n, buf_o, buf_p,\nbuf_q, buf_r, buf_s);\nfree(buf_w);\nif (MALLOC) {\nchar * ptr = (char *)malloc(10);\nstrcpy(ptr, \"overflow\");\nprintf(\"%s\\n\", ptr);\nfree(ptr);\n}\nreturn buf_t;\n}\n// Example of a vulnerability: CWE-476 (NULL Pointer Dereference)\n```",
 "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert I420 to ARGB.\nLIBYUV_API\nint I420ToARGB(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nreturn I420ToARGBMatrix(src_y, src_stride_y, src_u, src_stride_u, src_v,\nsrc_stride_v, dst_argb, dst_stride_argb,\n&kYuvI601Constants, width, height);\n}\n```\n```cpp\nLIBYUV_API\nint ARGBScaleClip(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || !dst_argb ||\ndst_width <= 0 || dst_height <= 0 || clip_x < 0 || clip_y < 0 ||\nclip_width > 32768 || clip_height > 32768 ||\n(clip_x + clip_width) > dst_width ||\n(clip_y + clip_height) > dst_height) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\n}\n```",
 "is_vulnerable": false
}