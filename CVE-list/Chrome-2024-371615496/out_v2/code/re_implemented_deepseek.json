{
 "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert I420 to ARGB.\nLIBYUV_API\nint I420ToARGB(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nreturn I420ToARGBMatrix(src_y, src_stride_y, src_u, src_stride_u, src_v,\nsrc_stride_v, dst_argb, dst_stride_argb,\n&kYuvI601Constants, width, height);\n}\n```\n```cpp\nLIBYUV_API\nint ARGBScaleClip(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || !dst_argb ||\ndst_width <= 0 || dst_height <= 0 || clip_x < 0 || clip_y < 0 ||\nclip_width > 32768 || clip_height > 32768 ||\n(clip_x + clip_width) > dst_width ||\n(clip_y + clip_height) > dst_height) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\n}\n```",
 "function_prototype": "int YUVToARGBScaleClip(const uint8_t* src_y, int src_stride_y, const uint8_t* src_u, int src_stride_u, const uint8_t* src_v, int src_stride_v, uint32_t src_fourcc, int src_width, int src_height, uint8_t* dst_argb, int dst_stride_argb, uint32_t dst_fourcc, int dst_width, int dst_height, int clip_x, int clip_y, int clip_width, int clip_height, enum FilterMode filtering)",
 "re_implemented_code": "\n```cpp\n#include <stdlib.h>\n#include <stdint.h>\n// Supported filtering modes\nenum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n};\n// Function prototypes\nextern LIBYUV_API int I420ToARGB(const uint8_t* src_y, int src_stride_y, const uint8_t* src_u, int src_stride_u, const uint8_t* src_v, int src_stride_v, uint8_t* dst_argb, int dst_stride_argb, int width, int height);\nextern LIBYUV_API int ARGBScaleClip(const uint8_t* src_argb, int src_stride_argb, int src_width, int src_height, uint8_t* dst_argb, int dst_stride_argb, int dst_width, int dst_height, int clip_x, int clip_y, int clip_width, int clip_height, enum FilterMode filtering);\nint YUVToARGBScaleClip(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint32_t src_fourcc,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nuint32_t dst_fourcc,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nint ret = 0; // Result variable to store operations' results\n// Check input parameters validity\nif (!src_y || src_width <= 0 || src_height <= 0 || !src_u || !src_v ||\n!dst_argb || dst_width <= 0 || dst_height <= 0 || clip_x < 0 ||\nclip_y < 0 || clip_width <= 0 || clip_height <= 0 ||\n(clip_x + clip_width) > dst_width ||\n(clip_y + clip_height) > dst_height) {\nreturn -1;\n}\n// Temporary storage for converted RGBA image before resizing/clipping\nvoid* tempBuffer = malloc(static_cast<size_t>(src_width) * src_height * sizeof(uint32_t));\nif (!tempBuffer) {\nreturn -1;\n}\n// Step 1: Convert YUV to ARGB using a predefined function\nret = I420ToARGB(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, static_cast<uint8_t*>(tempBuffer), src_width * sizeof(uint32_t), src_width, src_height);\nif (ret != 0) {\nfree(tempBuffer);\nreturn ret;\n}\n// Step 2: Resize and Clip the ARGB image according to specified filter mode and clipped area\nret = ARGBScaleClip(static_cast<const uint8_t*>(tempBuffer), src_width * sizeof(uint32_t), src_width, src_height, dst_argb, dst_stride_argb, dst_width, dst_height, clip_x, clip_y, clip_width, clip_height, filtering);\nfree(tempBuffer);\nreturn ret;\n}\n```\n",
 "is_vulnerable": false
}