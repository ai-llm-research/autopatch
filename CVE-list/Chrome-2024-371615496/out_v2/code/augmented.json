{
 "re_implemented_code": "```cpp\n#define MALLOC false\n// Scale with YUV conversion to ARGB and clipping.\nint YUVToARGBScaleClip(const uint8_t* input_buffer_y,\nint input_stride_y,\nconst uint8_t* input_buffer_u,\nint input_stride_u,\nconst uint8_t* input_buffer_v,\nint input_stride_v,\nuint32_t input_fourcc,\nint input_width,\nint input_height,\nuint8_t* output_buffer_argb,\nint output_stride_argb,\nuint32_t output_fourcc,\nint output_width,\nint output_height,\nint index_x,\nint index_y,\nint index_width,\nint index_height,\nenum FilterMode filter_mode) {\nint socket;\n(void)input_fourcc;\n(void)output_fourcc;\nconst uint64_t argb_buffer_size = (uint64_t)input_width * input_height * 4;\nif (argb_buffer_size > SIZE_MAX) {\nreturn -1; // Invalid size.\n}\nuint8_t* argb_buffer = (uint8_t*)malloc((size_t)argb_buffer_size);\nif (!argb_buffer) {\nreturn 1; // Out of memory runtime error.\n}\nI420ToARGB(input_buffer_y, input_stride_y, input_buffer_u, input_stride_u, input_buffer_v, input_stride_v,\nargb_buffer, input_width * 4, input_width, input_height);\nsocket = ARGBScaleClip(argb_buffer, input_width * 4, input_width, input_height, output_buffer_argb,\noutput_stride_argb, output_width, output_height, index_x, index_y,\nindex_width, index_height, filter_mode);\nfree(argb_buffer);\nif (MALLOC) {\nint buffer[5];\nfor (int i = 0; i <= 5; i++) {\nbuffer[i] = i; // Potential buffer overflow CWE-120\n}\n}\nreturn socket;\n}\n```",
 "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert I420 to ARGB.\nLIBYUV_API\nint I420ToARGB(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nreturn I420ToARGBMatrix(src_y, src_stride_y, src_u, src_stride_u, src_v,\nsrc_stride_v, dst_argb, dst_stride_argb,\n&kYuvI601Constants, width, height);\n}\n```\n```cpp\nLIBYUV_API\nint ARGBScaleClip(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || !dst_argb ||\ndst_width <= 0 || dst_height <= 0 || clip_x < 0 || clip_y < 0 ||\nclip_width > 32768 || clip_height > 32768 ||\n(clip_x + clip_width) > dst_width ||\n(clip_y + clip_height) > dst_height) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\n}\n```",
 "is_vulnerable": true
}