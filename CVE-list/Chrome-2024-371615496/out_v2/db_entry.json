{
  "cwe_type": "Integer Overflow or Wraparound",
  "cve_id": "Chrome-2024-371615496",
  "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert I420 to ARGB.\nLIBYUV_API\nint I420ToARGB(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nreturn I420ToARGBMatrix(src_y, src_stride_y, src_u, src_stride_u, src_v,\nsrc_stride_v, dst_argb, dst_stride_argb,\n&kYuvI601Constants, width, height);\n}\n```\n```cpp\nLIBYUV_API\nint ARGBScaleClip(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || !dst_argb ||\ndst_width <= 0 || dst_height <= 0 || clip_x < 0 || clip_y < 0 ||\nclip_width > 32768 || clip_height > 32768 ||\n(clip_x + clip_width) > dst_width ||\n(clip_y + clip_height) > dst_height) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\n}\n```",
  "original_code": "```cpp\n// Scale with YUV conversion to ARGB and clipping.\nint YUVToARGBScaleClip(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint32_t src_fourcc,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nuint32_t dst_fourcc,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nint r;\n(void)src_fourcc; // TODO(fbarchard): implement and/or assert.\n(void)dst_fourcc;\nconst uint64_t argb_buffer_size = (uint64_t)src_width * src_height * 4;\nif (argb_buffer_size > SIZE_MAX) {\nreturn -1; // Invalid size.\n}\nuint8_t* argb_buffer = (uint8_t*)malloc((size_t)argb_buffer_size);\nif (!argb_buffer) {\nreturn 1; // Out of memory runtime error.\n}\nI420ToARGB(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v,\nargb_buffer, src_width * 4, src_width, src_height);\nr = ARGBScaleClip(argb_buffer, src_width * 4, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\nfree(argb_buffer);\nreturn r;\n}\n```",
  "vuln_patch": "```cpp\n// Scale with YUV conversion to ARGB and clipping.\nint YUVToARGBScaleClip(const uint8_t* src_y,\nint src_stride_y,\nconst uint8_t* src_u,\nint src_stride_u,\nconst uint8_t* src_v,\nint src_stride_v,\nuint32_t src_fourcc,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nuint32_t dst_fourcc,\nint dst_width,\nint dst_height,\nint clip_x,\nint clip_y,\nint clip_width,\nint clip_height,\nenum FilterMode filtering) {\nint r;\n(void)src_fourcc; // TODO(fbarchard): implement and/or assert.\n(void)dst_fourcc;\nconst int abs_src_height = (src_height < 0) ? -src_height : src_height;\nif (!src_y || !src_u || !src_v || !dst_argb ||\nsrc_width <= 0 || src_width > INT_MAX / 4 || src_height == 0 ||\ndst_width <= 0 || dst_height <= 0 ||\nclip_width <= 0 || clip_height <= 0) {\nreturn -1;\n}\nconst uint64_t argb_buffer_size = (uint64_t)src_width * abs_src_height * 4;\nif (argb_buffer_size > SIZE_MAX) {\nreturn -1; // Invalid size.\n}\nuint8_t* argb_buffer = (uint8_t*)malloc((size_t)argb_buffer_size);\nif (!argb_buffer) {\nreturn 1; // Out of memory runtime error.\n}\nI420ToARGB(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v,\nargb_buffer, src_width * 4, src_width, src_height);\nr = ARGBScaleClip(argb_buffer, src_width * 4, src_width, abs_src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, clip_x, clip_y,\nclip_width, clip_height, filtering);\nfree(argb_buffer);\nreturn r;\n}\n```",
  "function_name": "YUVToARGBScaleClip",
  "function_prototype": "int YUVToARGBScaleClip(const uint8_t* src_y, int src_stride_y, const uint8_t* src_u, int src_stride_u, const uint8_t* src_v, int src_stride_v, uint32_t src_fourcc, int src_width, int src_height, uint8_t* dst_argb, int dst_stride_argb, uint32_t dst_fourcc, int dst_width, int dst_height, int clip_x, int clip_y, int clip_width, int clip_height, enum FilterMode filtering)",
  "code_semantics": "The function converts an image from YUV format to ARGB format, scales it to a specified size, and applies clipping based on given dimensions. It calculates the required buffer size for the ARGB image, checks for valid size, and allocates memory. If memory allocation fails, it returns an error. The function uses a helper function to perform the YUV to ARGB conversion and another helper function to scale and clip the ARGB image. After processing, it frees the allocated memory and returns the result of the scaling and clipping operation.",
  "vulnerability_checklist": "1. Check if src_width is validated to be greater than 0 and less than or equal to INT_MAX / 4. 2. Verify that src_height is checked for being non-zero and handled correctly if negative (e.g., using absolute value). 3. Ensure argb_buffer_size is calculated using safe values and checked against SIZE_MAX. 4. Confirm that malloc is used safely with the calculated argb_buffer_size. 5. Verify that I420ToARGB and ARGBScaleClip are called with correctly validated dimensions.",
  "safe_verification_cot": "1. src_width Validation: The patched code ensures src_width is greater than 0 and less than or equal to INT_MAX / 4. 2. src_height Handling: The patched code uses abs_src_height to handle negative src_height safely. 3. argb_buffer_size Calculation: The patched code calculates argb_buffer_size using abs_src_height, preventing overflow. 4. malloc Usage: The patched code uses malloc with a correctly calculated argb_buffer_size, preventing buffer overflow. 5. Function Calls: The patched code calls I420ToARGB and ARGBScaleClip with validated dimensions, ensuring safe memory operations.",
  "verification_cot": "1. src_width Validation: The vulnerable code does not validate src_width to ensure it is greater than 0 and less than or equal to INT_MAX / 4. 2. src_height Handling: The vulnerable code does not handle negative src_height values, leading to potential integer overflow in buffer size calculation. 3. argb_buffer_size Calculation: The vulnerable code calculates argb_buffer_size without considering the absolute value of src_height, risking overflow. 4. malloc Usage: The vulnerable code uses malloc with potentially incorrect argb_buffer_size, leading to buffer overflow. 5. Function Calls: The vulnerable code calls I420ToARGB and ARGBScaleClip without ensuring dimensions are validated, risking incorrect memory operations.",
  "vulnerability_related_variables": {
    "src_width": "This variable represents the horizontal dimension of an input image, measured in individual picture elements, and is utilized in memory allocation and image processing operations.",
    "src_height": "This variable represents the vertical dimension of an input image, measured in individual picture elements, and is utilized in memory allocation and image processing operations.",
    "argb_buffer_size": "This variable represents the total memory space required to store a converted image in a specific color format, calculated based on the dimensions of the input image and the number of bytes per pixel."
  },
  "vulnerability_related_functions": {
    "malloc": "Allocate a block of memory of a specified size and return a pointer to the beginning of the block.",
    "I420ToARGB": "Convert image data from a planar YUV format to a packed ARGB format, storing the result in a specified memory buffer.",
    "ARGBScaleClip": "Adjust the size of image data in a packed ARGB format, applying a specified filtering method, and extract a sub-region of the image, storing the result in a specified memory buffer."
  },
  "root_cause": "The root cause of the vulnerability is the potential for integer overflow when calculating the buffer size with src_width * src_height * 4, especially when src_height is negative, leading to a wraparound and potentially allocating a smaller buffer than needed.",
  "patch_cot": "First, introduce a new variable abs_src_height to store the absolute value of src_height. This ensures that any negative height values are converted to positive, preventing overflow. Add checks to ensure src_width is positive and does not exceed INT_MAX / 4. This prevents potential overflow when calculating argb_buffer_size. Ensure src_height is not zero to avoid unnecessary operations. Calculate argb_buffer_size using src_width and abs_src_height to ensure the buffer size is always calculated with positive dimensions. Before calling malloc, check that argb_buffer_size does not exceed SIZE_MAX to prevent allocation errors. Use abs_src_height when calling ARGBScaleClip to ensure consistent and safe operations.",
  "fix_list": "Verify that variable src_width is positive and does not exceed INT_MAX / 4 before it is used in buffer size calculations. Ensure that variable src_height is not zero and use its absolute value (abs_src_height) in calculations to prevent negative values from causing overflow. Check if function malloc is safely handling variable argb_buffer_size by ensuring it does not exceed SIZE_MAX. Verify that variable argb_buffer_size is properly calculated using safe values of src_width and abs_src_height. Ensure that function ARGBScaleClip is called with abs_src_height instead of src_height to maintain consistency and prevent errors."
}