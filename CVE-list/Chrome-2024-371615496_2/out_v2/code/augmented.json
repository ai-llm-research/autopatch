{
 "re_implemented_code": "```cpp\n#define MALLOC false\n// Scale a 24 bit image.\n// Converts to ARGB as intermediate step\nint RGBScale(const uint8_t* buffer,\nint capacity,\nint max_length,\nint min_length,\nuint8_t* payload,\nint buffer_size,\nint max_size,\nint min_size,\nenum FilterMode encoding) {\nint index;\nconst uint64_t buffer_length = (uint64_t)max_length * min_length * 4;\nconst uint64_t payload_length = (uint64_t)max_size * min_size * 4;\nif (buffer_length > (UINT64_MAX - payload_length)) {\nreturn -1; // Invalid size.\n}\nconst uint64_t total_size = buffer_length + payload_length;\nif (total_size > SIZE_MAX) {\nreturn -1; // Invalid size.\n}\nuint8_t* temporary_ptr = (uint8_t*)malloc((size_t)total_size);\nif (!temporary_ptr) {\nreturn 1; // Out of memory runtime error.\n}\nuint8_t* payload_ptr = temporary_ptr + (size_t)buffer_length;\nindex = RGB24ToARGB(buffer, capacity, temporary_ptr, max_length * 4, max_length, min_length);\nif (!index) {\nindex = ARGBScale(temporary_ptr, max_length * 4, max_length, min_length, payload_ptr, max_size * 4, max_size, min_size, encoding);\nif (!index) {\nindex = ARGBToRGB24(payload_ptr, max_size * 4, payload, buffer_size, max_size, min_size);\n}\n}\nfree(temporary_ptr);\nif (MALLOC) {\n// Example of a vulnerability: CWE-416: Use After Free\nchar* fake_ptr = (char*)0xDEADBEEF;\n*fake_ptr = 'A';\n}\nreturn index;\n}\n```",
 "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert RGB24 to ARGB.\nint RGB24ToARGB(const uint8_t* src_rgb24,\nint src_stride_rgb24,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nint y;\nvoid (*RGB24ToARGBRow)(const uint8_t* src_rgb, uint8_t* dst_argb, int width) =\nRGB24ToARGBRow_C;\nif (!src_rgb24 || !dst_argb || width <= 0 || height == 0) {\nreturn -1;\n}\n// Negative height means invert the image.\nif (height < 0) {\nheight = -height;\nsrc_rgb24 = src_rgb24 + (height - 1) * src_stride_rgb24;\nsrc_stride_rgb24 = -src_stride_rgb24;\n}\n// Coalesce rows.\nif (src_stride_rgb24 == width * 3 && dst_stride_argb == width * 4) {\nwidth *= height;\nheight = 1;\nsrc_stride_rgb24 = dst_stride_argb = 0;\n}\n#if defined(HAS_RGB24TOARGBROW_SSSE3)\nif (TestCpuFlag(kCpuHasSSSE3)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_SSSE3;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_SSSE3;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_NEON)\nif (TestCpuFlag(kCpuHasNEON)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_NEON;\nif (IS_ALIGNED(width, 8)) {\nRGB24ToARGBRow = RGB24ToARGBRow_NEON;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_SVE2)\nif (TestCpuFlag(kCpuHasSVE2)) {\nRGB24ToARGBRow = RGB24ToARGBRow_SVE2;\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_MSA)\nif (TestCpuFlag(kCpuHasMSA)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_MSA;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_MSA;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_LSX)\nif (TestCpuFlag(kCpuHasLSX)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_LSX;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_LSX;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_LASX)\nif (TestCpuFlag(kCpuHasLASX)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_LASX;\nif (IS_ALIGNED(width, 32)) {\nRGB24ToARGBRow = RGB24ToARGBRow_LASX;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_RVV)\nif (TestCpuFlag(kCpuHasRVV)) {\nRGB24ToARGBRow = RGB24ToARGBRow_RVV;\n}\n#endif\nfor (y = 0; y < height; ++y) {\nRGB24ToARGBRow(src_rgb24, dst_argb, width);\nsrc_rgb24 += src_stride_rgb24;\ndst_argb += dst_stride_argb;\n}\nreturn 0;\n}\n```\n```cpp\n// Scale an ARGB image.\nint ARGBScale(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || src_width > 32768 ||\nsrc_height > 32768 || !dst_argb || dst_width <= 0 || dst_height <= 0) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, 0, 0, dst_width,\ndst_height, filtering);\n}\n```\n```cpp\n// Convert ARGB To RGB24.\nint ARGBToRGB24(const uint8_t* src_argb,\nint src_stride_argb,\nuint8_t* dst_rgb24,\nint dst_stride_rgb24,\nint width,\nint height) {\nint y;\nvoid (*ARGBToRGB24Row)(const uint8_t* src_argb, uint8_t* dst_rgb, int width) =\nARGBToRGB24Row_C;\nif (!src_argb || !dst_rgb24 || width <= 0 || height == 0) {\nreturn -1;\n}\nif (height < 0) {\nheight = -height;\nsrc_argb = src_argb + (height - 1) * src_stride_argb;\nsrc_stride_argb = -src_stride_argb;\n}\n// Coalesce rows.\nif (src_stride_argb == width * 4 && dst_stride_rgb24 == width * 3) {\nwidth *= height;\nheight = 1;\nsrc_stride_argb = dst_stride_rgb24 = 0;\n}\n#if defined(HAS_ARGBTORGB24ROW_SSSE3)\nif (TestCpuFlag(kCpuHasSSSE3)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_SSSE3;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_SSSE3;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_AVX2)\nif (TestCpuFlag(kCpuHasAVX2)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_AVX2;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_AVX2;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_AVX512VBMI)\nif (TestCpuFlag(kCpuHasAVX512VBMI)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_AVX512VBMI;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_AVX512VBMI;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_NEON)\nif (TestCpuFlag(kCpuHasNEON)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_NEON;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_NEON;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_SVE2)\nif (TestCpuFlag(kCpuHasSVE2)) {\nARGBToRGB24Row = ARGBToRGB24Row_SVE2;\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_MSA)\nif (TestCpuFlag(kCpuHasMSA)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_MSA;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_MSA;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_LSX)\nif (TestCpuFlag(kCpuHasLSX)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_LSX;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_LSX;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_LASX)\nif (TestCpuFlag(kCpuHasLASX)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_LASX;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_LASX;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_RVV)\nif (TestCpuFlag(kCpuHasRVV)) {\nARGBToRGB24Row = ARGBToRGB24Row_RVV;\n}\n#endif\nfor (y = 0; y < height; ++y) {\nARGBToRGB24Row(src_argb, dst_rgb24, width);\nsrc_argb += src_stride_argb;\ndst_rgb24 += dst_stride_rgb24;\n}\nreturn 0;\n}\n```",
 "is_vulnerable": true
}