

typedef unsigned char uint8_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef unsigned int size_t;

enum FilterMode {
  FILTER_NONE,
  FILTER_FAST,
  FILTER_BILINEAR,
  FILTER_BICUBIC
};

int RGB24ToARGB(const uint8_t* input, int input_block_size, uint8_t* output, int output_block_size, int length, int offset) {
  return 0;
}

int ARGBScale(const uint8_t* input, int input_block_size, int length, int input_offset, uint8_t* output, int output_block_size, int output_length, int output_offset, enum FilterMode mode) {
  return 0;
}

int ARGBToRGB24(const uint8_t* input, int input_block_size, uint8_t* output, int output_block_size, int length, int offset) {
  return 0;
}

void* malloc(size_t size) {
  return nullptr;
}

void free(void* ptr) {

}

// Scale a 24 bit image.
// Converts to ARGB as intermediate step
int RGBScale(const uint8_t* file_input,
             int input_block_size,
             int input_length,
             int input_offset,
             uint8_t* file_output,
             int output_block_size,
             int output_length,
             int output_offset,
             enum FilterMode auth_mode) {
  int buffer_overflow;
  if (!file_input || !file_output ||
      input_length <= 0 || input_length > 0x7fffffff / 4 || input_offset == 0 ||
      output_length <= 0 || output_length > 0x7fffffff / 4 || output_offset <= 0) {
    return -1;
  }
  const int abs_input_offset = (input_offset < 0) ? -input_offset : input_offset;
  const uint64_t input_buffer_size = (uint64_t)input_length * abs_input_offset * 4;
  const uint64_t output_buffer_size = (uint64_t)output_length * output_offset * 4;
  if (input_buffer_size > ((uint64_t)-1 - output_buffer_size)) {
    return -1;  // Invalid size.
  }
  const uint64_t buffer_size_overflow = input_buffer_size + output_buffer_size;
  if (buffer_size_overflow > ((size_t)-1)) {
    return -1;  // Invalid size.
  }
  uint8_t* input_buffer = (uint8_t*)malloc((size_t)buffer_size_overflow);
  if (!input_buffer) {
    return 1;  // Out of memory runtime error.
  }
  uint8_t* output_buffer = input_buffer + (size_t)input_buffer_size;

  buffer_overflow = RGB24ToARGB(file_input, input_block_size, input_buffer, input_length * 4, input_length, input_offset);
  if (!buffer_overflow) {
    buffer_overflow = ARGBScale(input_buffer, input_length * 4, input_length, abs_input_offset, output_buffer,
                                output_length * 4, output_length, output_offset, auth_mode);
    if (!buffer_overflow) {
      buffer_overflow = ARGBToRGB24(output_buffer, output_length * 4, file_output, output_block_size,
                                    output_length, output_offset);
    }
  }
  free(input_buffer);

  return buffer_overflow;
}

