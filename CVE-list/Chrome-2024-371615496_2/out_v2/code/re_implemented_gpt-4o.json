{
 "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert RGB24 to ARGB.\nint RGB24ToARGB(const uint8_t* src_rgb24,\nint src_stride_rgb24,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nint y;\nvoid (*RGB24ToARGBRow)(const uint8_t* src_rgb, uint8_t* dst_argb, int width) =\nRGB24ToARGBRow_C;\nif (!src_rgb24 || !dst_argb || width <= 0 || height == 0) {\nreturn -1;\n}\n// Negative height means invert the image.\nif (height < 0) {\nheight = -height;\nsrc_rgb24 = src_rgb24 + (height - 1) * src_stride_rgb24;\nsrc_stride_rgb24 = -src_stride_rgb24;\n}\n// Coalesce rows.\nif (src_stride_rgb24 == width * 3 && dst_stride_argb == width * 4) {\nwidth *= height;\nheight = 1;\nsrc_stride_rgb24 = dst_stride_argb = 0;\n}\n#if defined(HAS_RGB24TOARGBROW_SSSE3)\nif (TestCpuFlag(kCpuHasSSSE3)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_SSSE3;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_SSSE3;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_NEON)\nif (TestCpuFlag(kCpuHasNEON)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_NEON;\nif (IS_ALIGNED(width, 8)) {\nRGB24ToARGBRow = RGB24ToARGBRow_NEON;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_SVE2)\nif (TestCpuFlag(kCpuHasSVE2)) {\nRGB24ToARGBRow = RGB24ToARGBRow_SVE2;\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_MSA)\nif (TestCpuFlag(kCpuHasMSA)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_MSA;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_MSA;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_LSX)\nif (TestCpuFlag(kCpuHasLSX)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_LSX;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_LSX;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_LASX)\nif (TestCpuFlag(kCpuHasLASX)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_LASX;\nif (IS_ALIGNED(width, 32)) {\nRGB24ToARGBRow = RGB24ToARGBRow_LASX;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_RVV)\nif (TestCpuFlag(kCpuHasRVV)) {\nRGB24ToARGBRow = RGB24ToARGBRow_RVV;\n}\n#endif\nfor (y = 0; y < height; ++y) {\nRGB24ToARGBRow(src_rgb24, dst_argb, width);\nsrc_rgb24 += src_stride_rgb24;\ndst_argb += dst_stride_argb;\n}\nreturn 0;\n}\n```\n```cpp\n// Scale an ARGB image.\nint ARGBScale(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || src_width > 32768 ||\nsrc_height > 32768 || !dst_argb || dst_width <= 0 || dst_height <= 0) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, 0, 0, dst_width,\ndst_height, filtering);\n}\n```\n```cpp\n// Convert ARGB To RGB24.\nint ARGBToRGB24(const uint8_t* src_argb,\nint src_stride_argb,\nuint8_t* dst_rgb24,\nint dst_stride_rgb24,\nint width,\nint height) {\nint y;\nvoid (*ARGBToRGB24Row)(const uint8_t* src_argb, uint8_t* dst_rgb, int width) =\nARGBToRGB24Row_C;\nif (!src_argb || !dst_rgb24 || width <= 0 || height == 0) {\nreturn -1;\n}\nif (height < 0) {\nheight = -height;\nsrc_argb = src_argb + (height - 1) * src_stride_argb;\nsrc_stride_argb = -src_stride_argb;\n}\n// Coalesce rows.\nif (src_stride_argb == width * 4 && dst_stride_rgb24 == width * 3) {\nwidth *= height;\nheight = 1;\nsrc_stride_argb = dst_stride_rgb24 = 0;\n}\n#if defined(HAS_ARGBTORGB24ROW_SSSE3)\nif (TestCpuFlag(kCpuHasSSSE3)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_SSSE3;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_SSSE3;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_AVX2)\nif (TestCpuFlag(kCpuHasAVX2)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_AVX2;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_AVX2;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_AVX512VBMI)\nif (TestCpuFlag(kCpuHasAVX512VBMI)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_AVX512VBMI;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_AVX512VBMI;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_NEON)\nif (TestCpuFlag(kCpuHasNEON)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_NEON;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_NEON;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_SVE2)\nif (TestCpuFlag(kCpuHasSVE2)) {\nARGBToRGB24Row = ARGBToRGB24Row_SVE2;\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_MSA)\nif (TestCpuFlag(kCpuHasMSA)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_MSA;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_MSA;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_LSX)\nif (TestCpuFlag(kCpuHasLSX)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_LSX;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_LSX;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_LASX)\nif (TestCpuFlag(kCpuHasLASX)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_LASX;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_LASX;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_RVV)\nif (TestCpuFlag(kCpuHasRVV)) {\nARGBToRGB24Row = ARGBToRGB24Row_RVV;\n}\n#endif\nfor (y = 0; y < height; ++y) {\nARGBToRGB24Row(src_argb, dst_rgb24, width);\nsrc_argb += src_stride_argb;\ndst_rgb24 += dst_stride_rgb24;\n}\nreturn 0;\n}\n```",
 "function_prototype": "int RGBScale(const uint8_t* src_rgb, int src_stride_rgb, int src_width, int src_height, uint8_t* dst_rgb, int dst_stride_rgb, int dst_width, int dst_height, enum FilterMode filtering)",
 "re_implemented_code": "\n```cpp\n// Scale a 24 bit image.\n// Converts to ARGB as intermediate step\nint RGBScale(const uint8_t* src_rgb,\nint src_stride_rgb,\nint src_width,\nint src_height,\nuint8_t* dst_rgb,\nint dst_stride_rgb,\nint dst_width,\nint dst_height,\nenum FilterMode filtering) {\n// Declare an integer for the return value of operations\nint result;\n// Calculate the size needed for the source ARGB buffer\nconst size_t src_argb_size = static_cast<size_t>(src_width) * abs(src_height) * 4;\n// Calculate the size needed for the destination ARGB buffer\nconst size_t dst_argb_size = static_cast<size_t>(dst_width) * abs(dst_height) * 4;\n// Check if combined size exceeds maximum allowable value, indicating invalid input sizes\nif (src_argb_size + dst_argb_size > (1 << 30)) {\nreturn -1; // Invalid size.\nfree(argb_buffer);\nfree(dst_buffer);\nreturn result;\n}\n```\n",
 "is_vulnerable": "N/A"
}