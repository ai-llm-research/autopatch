{
  "cwe_type": "Integer Overflow or Wraparound",
  "cve_id": "Chrome-2024-371615496",
  "supplementary_code": "```cpp\n// Supported filtering.\ntypedef enum FilterMode {\nkFilterNone = 0, // Point sample; Fastest.\nkFilterLinear = 1, // Filter horizontally only.\nkFilterBilinear = 2, // Faster than box, but lower quality scaling down.\nkFilterBox = 3 // Highest quality.\n} FilterModeEnum;\n```\n```cpp\n// Convert RGB24 to ARGB.\nint RGB24ToARGB(const uint8_t* src_rgb24,\nint src_stride_rgb24,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint width,\nint height) {\nint y;\nvoid (*RGB24ToARGBRow)(const uint8_t* src_rgb, uint8_t* dst_argb, int width) =\nRGB24ToARGBRow_C;\nif (!src_rgb24 || !dst_argb || width <= 0 || height == 0) {\nreturn -1;\n}\n// Negative height means invert the image.\nif (height < 0) {\nheight = -height;\nsrc_rgb24 = src_rgb24 + (height - 1) * src_stride_rgb24;\nsrc_stride_rgb24 = -src_stride_rgb24;\n}\n// Coalesce rows.\nif (src_stride_rgb24 == width * 3 && dst_stride_argb == width * 4) {\nwidth *= height;\nheight = 1;\nsrc_stride_rgb24 = dst_stride_argb = 0;\n}\n#if defined(HAS_RGB24TOARGBROW_SSSE3)\nif (TestCpuFlag(kCpuHasSSSE3)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_SSSE3;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_SSSE3;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_NEON)\nif (TestCpuFlag(kCpuHasNEON)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_NEON;\nif (IS_ALIGNED(width, 8)) {\nRGB24ToARGBRow = RGB24ToARGBRow_NEON;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_SVE2)\nif (TestCpuFlag(kCpuHasSVE2)) {\nRGB24ToARGBRow = RGB24ToARGBRow_SVE2;\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_MSA)\nif (TestCpuFlag(kCpuHasMSA)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_MSA;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_MSA;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_LSX)\nif (TestCpuFlag(kCpuHasLSX)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_LSX;\nif (IS_ALIGNED(width, 16)) {\nRGB24ToARGBRow = RGB24ToARGBRow_LSX;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_LASX)\nif (TestCpuFlag(kCpuHasLASX)) {\nRGB24ToARGBRow = RGB24ToARGBRow_Any_LASX;\nif (IS_ALIGNED(width, 32)) {\nRGB24ToARGBRow = RGB24ToARGBRow_LASX;\n}\n}\n#endif\n#if defined(HAS_RGB24TOARGBROW_RVV)\nif (TestCpuFlag(kCpuHasRVV)) {\nRGB24ToARGBRow = RGB24ToARGBRow_RVV;\n}\n#endif\nfor (y = 0; y < height; ++y) {\nRGB24ToARGBRow(src_rgb24, dst_argb, width);\nsrc_rgb24 += src_stride_rgb24;\ndst_argb += dst_stride_argb;\n}\nreturn 0;\n}\n```\n```cpp\n// Scale an ARGB image.\nint ARGBScale(const uint8_t* src_argb,\nint src_stride_argb,\nint src_width,\nint src_height,\nuint8_t* dst_argb,\nint dst_stride_argb,\nint dst_width,\nint dst_height,\nenum FilterMode filtering) {\nif (!src_argb || src_width == 0 || src_height == 0 || src_width > 32768 ||\nsrc_height > 32768 || !dst_argb || dst_width <= 0 || dst_height <= 0) {\nreturn -1;\n}\nreturn ScaleARGB(src_argb, src_stride_argb, src_width, src_height, dst_argb,\ndst_stride_argb, dst_width, dst_height, 0, 0, dst_width,\ndst_height, filtering);\n}\n```\n```cpp\n// Convert ARGB To RGB24.\nint ARGBToRGB24(const uint8_t* src_argb,\nint src_stride_argb,\nuint8_t* dst_rgb24,\nint dst_stride_rgb24,\nint width,\nint height) {\nint y;\nvoid (*ARGBToRGB24Row)(const uint8_t* src_argb, uint8_t* dst_rgb, int width) =\nARGBToRGB24Row_C;\nif (!src_argb || !dst_rgb24 || width <= 0 || height == 0) {\nreturn -1;\n}\nif (height < 0) {\nheight = -height;\nsrc_argb = src_argb + (height - 1) * src_stride_argb;\nsrc_stride_argb = -src_stride_argb;\n}\n// Coalesce rows.\nif (src_stride_argb == width * 4 && dst_stride_rgb24 == width * 3) {\nwidth *= height;\nheight = 1;\nsrc_stride_argb = dst_stride_rgb24 = 0;\n}\n#if defined(HAS_ARGBTORGB24ROW_SSSE3)\nif (TestCpuFlag(kCpuHasSSSE3)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_SSSE3;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_SSSE3;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_AVX2)\nif (TestCpuFlag(kCpuHasAVX2)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_AVX2;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_AVX2;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_AVX512VBMI)\nif (TestCpuFlag(kCpuHasAVX512VBMI)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_AVX512VBMI;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_AVX512VBMI;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_NEON)\nif (TestCpuFlag(kCpuHasNEON)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_NEON;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_NEON;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_SVE2)\nif (TestCpuFlag(kCpuHasSVE2)) {\nARGBToRGB24Row = ARGBToRGB24Row_SVE2;\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_MSA)\nif (TestCpuFlag(kCpuHasMSA)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_MSA;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_MSA;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_LSX)\nif (TestCpuFlag(kCpuHasLSX)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_LSX;\nif (IS_ALIGNED(width, 16)) {\nARGBToRGB24Row = ARGBToRGB24Row_LSX;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_LASX)\nif (TestCpuFlag(kCpuHasLASX)) {\nARGBToRGB24Row = ARGBToRGB24Row_Any_LASX;\nif (IS_ALIGNED(width, 32)) {\nARGBToRGB24Row = ARGBToRGB24Row_LASX;\n}\n}\n#endif\n#if defined(HAS_ARGBTORGB24ROW_RVV)\nif (TestCpuFlag(kCpuHasRVV)) {\nARGBToRGB24Row = ARGBToRGB24Row_RVV;\n}\n#endif\nfor (y = 0; y < height; ++y) {\nARGBToRGB24Row(src_argb, dst_rgb24, width);\nsrc_argb += src_stride_argb;\ndst_rgb24 += dst_stride_rgb24;\n}\nreturn 0;\n}\n```",
  "original_code": "```cpp\n// Scale a 24 bit image.\n// Converts to ARGB as intermediate step\nint RGBScale(const uint8_t* src_rgb,\nint src_stride_rgb,\nint src_width,\nint src_height,\nuint8_t* dst_rgb,\nint dst_stride_rgb,\nint dst_width,\nint dst_height,\nenum FilterMode filtering) {\nint r;\nconst uint64_t src_argb_size = (uint64_t)src_width * src_height * 4;\nconst uint64_t dst_argb_size = (uint64_t)dst_width * dst_height * 4;\nif (src_argb_size > (UINT64_MAX - dst_argb_size)) {\nreturn -1; // Invalid size.\n}\nconst uint64_t argb_size = src_argb_size + dst_argb_size;\nif (argb_size > SIZE_MAX) {\nreturn -1; // Invalid size.\n}\nuint8_t* src_argb = (uint8_t*)malloc((size_t)argb_size);\nif (!src_argb) {\nreturn 1; // Out of memory runtime error.\n}\nuint8_t* dst_argb = src_argb + (size_t)src_argb_size;\nr = RGB24ToARGB(src_rgb, src_stride_rgb, src_argb, src_width * 4, src_width,\nsrc_height);\nif (!r) {\nr = ARGBScale(src_argb, src_width * 4, src_width, src_height, dst_argb,\ndst_width * 4, dst_width, dst_height, filtering);\nif (!r) {\nr = ARGBToRGB24(dst_argb, dst_width * 4, dst_rgb, dst_stride_rgb,\ndst_width, dst_height);\n}\n}\nfree(src_argb);\nreturn r;\n}\n```",
  "vuln_patch": "```cpp\n// Scale a 24 bit image.\n// Converts to ARGB as intermediate step\nint RGBScale(const uint8_t* src_rgb,\nint src_stride_rgb,\nint src_width,\nint src_height,\nuint8_t* dst_rgb,\nint dst_stride_rgb,\nint dst_width,\nint dst_height,\nenum FilterMode filtering) {\nint r;\nif (!src_rgb || !dst_rgb ||\nsrc_width <= 0 || src_width > INT_MAX / 4 || src_height == 0 ||\ndst_width <= 0 || dst_width > INT_MAX / 4 || dst_height <= 0) {\nreturn -1;\n}\nconst int abs_src_height = (src_height < 0) ? -src_height : src_height;\nconst uint64_t src_argb_size = (uint64_t)src_width * abs_src_height * 4;\nconst uint64_t dst_argb_size = (uint64_t)dst_width * dst_height * 4;\nif (src_argb_size > (UINT64_MAX - dst_argb_size)) {\nreturn -1; // Invalid size.\n}\nconst uint64_t argb_size = src_argb_size + dst_argb_size;\nif (argb_size > SIZE_MAX) {\nreturn -1; // Invalid size.\n}\nuint8_t* src_argb = (uint8_t*)malloc((size_t)argb_size);\nif (!src_argb) {\nreturn 1; // Out of memory runtime error.\n}\nuint8_t* dst_argb = src_argb + (size_t)src_argb_size;\nr = RGB24ToARGB(src_rgb, src_stride_rgb, src_argb, src_width * 4, src_width,\nsrc_height);\nif (!r) {\nr = ARGBScale(src_argb, src_width * 4, src_width, abs_src_height, dst_argb,\ndst_width * 4, dst_width, dst_height, filtering);\nif (!r) {\nr = ARGBToRGB24(dst_argb, dst_width * 4, dst_rgb, dst_stride_rgb,\ndst_width, dst_height);\n}\n}\nfree(src_argb);\nreturn r;\n}\n```",
  "function_name": "RGBScale",
  "function_prototype": "int RGBScale(const uint8_t* src_rgb, int src_stride_rgb, int src_width, int src_height, uint8_t* dst_rgb, int dst_stride_rgb, int dst_width, int dst_height, enum FilterMode filtering)",
  "code_semantics": "The function scales a 24-bit RGB image by first converting it to an ARGB format, scaling the ARGB image, and then converting it back to the RGB format. It calculates the required memory size for the intermediate ARGB data, checks for valid sizes, and allocates memory. If memory allocation fails, it returns an error. The function converts the source RGB image to ARGB, scales the ARGB image using a specified filtering mode, and converts it back to RGB. It frees the allocated memory and returns the result of the operations, indicating success or failure.",
  "vulnerability_checklist": "1. Check if function RGBScale properly validates that src_rgb and dst_rgb are not null. 2. Verify that src_width, dst_width, and dst_height are greater than zero and do not exceed INT_MAX / 4 before any calculations. 3. Ensure that src_height is handled correctly, using its absolute value for calculations if it can be negative. 4. Confirm that src_argb_size and dst_argb_size are calculated safely without causing integer overflow. 5. Verify that the sum of src_argb_size and dst_argb_size does not exceed SIZE_MAX to prevent overflow. 6. Check that memory allocation for src_argb is based on a validated and safe argb_size.",
  "safe_verification_cot": "1. The RGBScale function now validates that src_rgb and dst_rgb are not null, preventing null pointer dereference. 2. The function checks that src_width, dst_width, and dst_height are greater than zero and do not exceed INT_MAX / 4, preventing integer overflow in size calculations. 3. The abs_src_height variable ensures that the absolute value of src_height is used, preventing incorrect calculations. 4. The calculations for src_argb_size and dst_argb_size are now safe from integer overflow due to the added checks. 5. The sum of src_argb_size and dst_argb_size is checked against SIZE_MAX, preventing overflow and ensuring safe memory allocation.",
  "verification_cot": "1. The RGBScale function does not validate that src_rgb and dst_rgb are not null, which could lead to null pointer dereference. 2. The function does not check if src_width, dst_width, and dst_height are within safe limits, allowing potential integer overflow when calculating src_argb_size and dst_argb_size. 3. Negative src_height is not handled correctly, which could lead to incorrect calculations and memory allocation. 4. The calculations for src_argb_size and dst_argb_size do not prevent integer overflow, potentially leading to incorrect memory allocation. 5. The sum of src_argb_size and dst_argb_size is not checked against SIZE_MAX, risking overflow and buffer overflow.",
  "vulnerability_related_variables": {
    "src_width": "Represents the horizontal dimension of the input image, influencing the size of the buffer required for processing and the scaling operation.",
    "src_height": "Represents the vertical dimension of the input image, influencing the size of the buffer required for processing and the scaling operation.",
    "dst_width": "Represents the horizontal dimension of the output image, influencing the size of the buffer required for processing and the scaling operation.",
    "dst_height": "Represents the vertical dimension of the output image, influencing the size of the buffer required for processing and the scaling operation.",
    "src_argb_size": "Represents the memory size required to store the input image in a specific format, calculated based on its dimensions.",
    "dst_argb_size": "Represents the memory size required to store the output image in a specific format, calculated based on its dimensions.",
    "argb_size": "Represents the total memory size required to store both the input and output images in a specific format, calculated by summing their individual sizes."
  },
  "vulnerability_related_functions": {
    "RGB24ToARGB": "This function converts a 24-bit RGB image to a 32-bit ARGB image. It processes the image row by row, adjusting for any negative height to invert the image if necessary. The function selects an optimized conversion routine based on the CPU's capabilities to enhance performance.",
    "ARGBScale": "This function scales a 32-bit ARGB image to a new size. It checks the validity of input parameters and uses a specified filtering method to determine the quality of the scaling. The function calls another routine to perform the actual scaling operation.",
    "ARGBToRGB24": "This function converts a 32-bit ARGB image to a 24-bit RGB image. It processes the image row by row, adjusting for any negative height to invert the image if necessary. The function selects an optimized conversion routine based on the CPU's capabilities to enhance performance."
  },
  "root_cause": "Lack of proper input validation and handling of integer overflow conditions, particularly when calculating memory sizes for src_argb_size and dst_argb_size.",
  "patch_cot": "First, add checks to ensure that src_width and dst_width are within safe limits to prevent integer overflow when multiplied by 4. This can be done by ensuring they are less than or equal to INT_MAX / 4. Handle the case where src_height might be negative by using its absolute value when calculating src_argb_size. Ensure that src_height is not zero and dst_height is greater than zero. Before calculating src_argb_size and dst_argb_size, ensure that their sum does not exceed UINT64_MAX to prevent overflow. Ensure that the total argb_size does not exceed SIZE_MAX to prevent invalid memory allocations. Verify that the functions RGB24ToARGB, ARGBScale, and ARGBToRGB24 are handling the input dimensions and sizes safely.",
  "fix_list": "Verify that variable src_width is greater than 0 and less than or equal to INT_MAX / 4 before using it in calculations. Verify that variable dst_width is greater than 0 and less than or equal to INT_MAX / 4 before using it in calculations. Ensure that variable src_height is not zero and handle its absolute value when calculating src_argb_size. Ensure that variable dst_height is greater than 0. Check if function RGB24ToARGB is safely handling variables src_width, src_height, and src_argb_size. Check if function ARGBScale is safely handling variables src_width, src_height, dst_width, dst_height, and argb_size. Check if function ARGBToRGB24 is safely handling variables dst_width, dst_height, and dst_argb_size."
}