

typedef unsigned char u8;
typedef long long time64_t;
typedef int s8;
typedef unsigned long size_t;

struct work_struct {};
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define LIST_HEAD(name) struct list_head name = { &(name), &(name) }
#define HZ 100
#define RXRPC_KEEPALIVE_TIME 3

struct list_head {
    struct list_head *next, *prev;
};

struct rxrpc_net {
    int live;
    time64_t peer_keepalive_base;
    u8 peer_keepalive_cursor;
    struct list_head peer_keepalive[4];
    struct list_head peer_keepalive_new;
    struct work_struct peer_keepalive_work;
    void *peer_hash_lock;
    void *peer_keepalive_timer;
};

void _enter(const char* fmt, ...) {}
void _leave(const char* fmt, ...) {}
time64_t ktime_get_seconds(void) { return 0; }
void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *collector, time64_t base, u8 cursor) {}
int list_empty(const struct list_head *head) { return 1; }
void list_splice_init(struct list_head *list, struct list_head *head) {}
void list_splice_tail_init(struct list_head *list, struct list_head *head) {}
void spin_lock(void *lock) {}
void spin_unlock(void *lock) {}
void ASSERT(int expr) {}
void timer_reduce(void *timer, long timeout) {}

#define offsetof(type, member) ((size_t) &((type *)0)->member)

#define container_of(ptr, type, member) ({                      \
    const typeof(((type *)0)->member) *__mptr = (ptr);    \
    (type *)((char *)__mptr - offsetof(type, member)); })

void rxrpc_peer_keepalive_worker(struct work_struct *work)
{
    struct rxrpc_net *rxnet = container_of(work, struct rxrpc_net, peer_keepalive_work);
    const u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;
    time64_t base, now, delay;
    u8 cursor, stop;
    LIST_HEAD(collector);

    now = ktime_get_seconds();
    base = rxnet->peer_keepalive_base;
    cursor = rxnet->peer_keepalive_cursor;
    _enter("%lld,%u", base - now, cursor);

    if (!rxnet->live)
        return;

    spin_lock(&rxnet->peer_hash_lock);
    list_splice_init(&rxnet->peer_keepalive_new, &collector);

    stop = cursor + ARRAY_SIZE(rxnet->peer_keepalive);
    while (base <= now && (s8)(cursor - stop) < 0) {
        list_splice_tail_init(&rxnet->peer_keepalive[cursor & mask], &collector);
        base++;
        cursor++;
    }

    base = now;
    spin_unlock(&rxnet->peer_hash_lock);

    rxnet->peer_keepalive_base = base;
    rxnet->peer_keepalive_cursor = cursor;
    rxrpc_peer_keepalive_dispatch(rxnet, &collector, base, cursor);
    ASSERT(list_empty(&collector));

    cursor = rxnet->peer_keepalive_cursor;
    stop = cursor + RXRPC_KEEPALIVE_TIME - 1;
    for (; (s8)(cursor - stop) < 0; cursor++) {
        if (!list_empty(&rxnet->peer_keepalive[cursor & mask]))
            break;
        base++;
    }

    now = ktime_get_seconds();
    delay = base - now;
    if (delay < 1)
        delay = 1;
    delay *= HZ;
    if (rxnet->live)
        timer_reduce(&rxnet->peer_keepalive_timer, delay);

    _leave("");
}

