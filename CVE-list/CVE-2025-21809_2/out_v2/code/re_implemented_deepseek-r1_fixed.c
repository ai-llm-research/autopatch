

typedef long long s64;
typedef unsigned char u8;
typedef int s8;
typedef long long time64_t;

struct work_struct {
    // Dummy structure for placeholder purposes
};

// Dummy spinlock
typedef struct {
    // Dummy spinlock structure
} spinlock_t;

// Declaring a dummy spinlock lock function
void spin_lock(spinlock_t *lock) {}

// Declaring a dummy spinlock unlock function
void spin_unlock(spinlock_t *lock) {}

// Dummy macro for container_of simulation
#define container_of(ptr, type, member) ((type *)((char *)(ptr) - (char *)&((type *)0)->member))
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define HZ 100

// Forward declaration
struct list_head;

struct list_head {
    struct list_head *next, *prev;
};

// Dummy timer_list structure
struct timer_list {
    // Dummy timer structure
};

struct rxrpc_net {
    struct work_struct peer_keepalive_work;
    spinlock_t peer_hash_lock;
    int live;
    struct list_head peer_keepalive[8];
    struct list_head peer_keepalive_new;
    time64_t peer_keepalive_base;
    u8 peer_keepalive_cursor;
    struct timer_list peer_keepalive_timer;
};

// Dummy function declarations
void list_splice_init(struct list_head *from, struct list_head *to) {}
void list_splice_tail_init(struct list_head *from, struct list_head *to) {}
int list_empty(const struct list_head *head) { return 1; }
void ASSERT(int expr) {}
void timer_reduce(struct timer_list *timer, unsigned long expires) {}
time64_t ktime_get_seconds() { return 0; }
void _enter(const char *fmt, ...) {}
void _leave(const char *fmt, ...) {}

void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *list, time64_t base, u8 cursor) {}

#define LIST_HEAD_INIT(name) { &(name), &(name) }
#define LIST_HEAD(name) \
struct list_head name = LIST_HEAD_INIT(name)

#define RXRPC_KEEPALIVE_TIME 100

void rxrpc_peer_keepalive_worker(struct work_struct *work) {
    struct rxrpc_net *rxnet =
        container_of(work, struct rxrpc_net, peer_keepalive_work);

    const u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;

    time64_t now, base, stop;
    u8 cursor;

    LIST_HEAD(collector);

    now = ktime_get_seconds();

    base = rxnet->peer_keepalive_base;
    cursor = rxnet->peer_keepalive_cursor;

    _enter("%lld,%hhu", base, cursor);

    if (!rxnet->live)
        return;

    spin_lock(&rxnet->peer_hash_lock);

    list_splice_init(&rxnet->peer_keepalive_new, &collector);

    stop = cursor + ARRAY_SIZE(rxnet->peer_keepalive);

    while (base <= now && (s8)(cursor - stop) < 0) {
        list_splice_tail_init(&rxnet->peer_keepalive[cursor & mask], &collector);
        base++;
        cursor++;
    }

    base = now;

    spin_unlock(&rxnet->peer_hash_lock);

    rxnet->peer_keepalive_base = base;
    rxnet->peer_keepalive_cursor = cursor;

    rxrpc_peer_keepalive_dispatch(rxnet, &collector, base, cursor);

    ASSERT(list_empty(&collector));

    cursor = rxnet->peer_keepalive_cursor;
    stop = cursor + RXRPC_KEEPALIVE_TIME - 1;

    for (; (s8)(cursor - stop) < 0; cursor++) {
        if (!list_empty(&rxnet->peer_keepalive[cursor & mask])) {
            break;
        }
        base++;
    }

    now = ktime_get_seconds();

    s64 delay = base - now;

    if (delay < 1)
        delay = 1;

    delay *= HZ;

    if (rxnet->live)
        timer_reduce(&rxnet->peer_keepalive_timer, delay);

    _leave("");

    return;
}

