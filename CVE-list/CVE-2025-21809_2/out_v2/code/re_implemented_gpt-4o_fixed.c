

struct work_struct {};
struct list_head {
    struct list_head *next, *prev;
};

typedef long long time64_t;
typedef unsigned char u8;

struct rxrpc_net {
    struct work_struct peer_keepalive_work;
    struct list_head peer_keepalive_new;
    struct list_head *peer_keepalive;
    time64_t peer_keepalive_base;
    u8 peer_keepalive_cursor;
    int live;
    int peer_hash_lock;
    int peer_keepalive_timer;
};

typedef int s8;
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define HZ 1
#define RXRPC_KEEPALIVE_TIME 10 // stub value for compilation
#define jiffies 0 // stub value for compilation

void _enter(const char* fmt, ...) {}
void _leave(const char* fmt, ...) {}
time64_t ktime_get_seconds(void) { return 0; }
void spin_lock(int *lock) {}
void spin_unlock(int *lock) {}
void list_splice_init(struct list_head *list, struct list_head *head) {}
void list_splice_tail_init(struct list_head *list, struct list_head *head) {}
int list_empty(const struct list_head *head) { return 1; }
void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *collector, time64_t base, u8 cursor) {}
void timer_reduce(int *timer, long expires) {}
#define container_of(ptr, type, member) ((type *)((char *)(ptr) - (char *)(&((type *)0)->member)))
void ASSERT(int condition) {}

void rxrpc_peer_keepalive_worker(struct work_struct *work)
{
    struct rxrpc_net *rxnet = container_of(work, struct rxrpc_net, peer_keepalive_work);

    const u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;
    time64_t now, base;
    u8 cursor;
    int stop;
    long delay;

    struct list_head collector;

    now = ktime_get_seconds();

    base = rxnet->peer_keepalive_base;
    cursor = rxnet->peer_keepalive_cursor;

    _enter("base=%lld, cursor=%u", base, cursor);

    if (!rxnet->live)
        return;

    spin_lock(&rxnet->peer_hash_lock);

    list_splice_init(&rxnet->peer_keepalive_new, &collector);

    stop = cursor + ARRAY_SIZE(rxnet->peer_keepalive);

    while (base <= now && (s8)(cursor - stop) < 0) {
        list_splice_tail_init(&rxnet->peer_keepalive[cursor & mask], &collector);
        base++;
        cursor++;
    }

    base = now;

    spin_unlock(&rxnet->peer_hash_lock);

    rxnet->peer_keepalive_base = base;
    rxnet->peer_keepalive_cursor = cursor;

    rxrpc_peer_keepalive_dispatch(rxnet, &collector, base, cursor);

    ASSERT(list_empty(&collector));

    cursor = rxnet->peer_keepalive_cursor;
    stop = cursor + RXRPC_KEEPALIVE_TIME - 1;

    for (; (s8)(cursor - stop) < 0; cursor++) {
        if (!list_empty(&rxnet->peer_keepalive[cursor & mask]))
            break;
        base++;
    }

    now = ktime_get_seconds();

    delay = base - now;

    if (delay < 1)
        delay = 1;

    delay *= HZ;

    if (rxnet->live)
        timer_reduce(&rxnet->peer_keepalive_timer, jiffies + delay);

    _leave("");
}

