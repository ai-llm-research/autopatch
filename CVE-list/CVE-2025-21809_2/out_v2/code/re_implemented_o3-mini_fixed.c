

typedef unsigned long time64_t;
typedef unsigned char u8;
typedef signed char s8;
typedef unsigned long size_t;
struct work_struct {};
struct list_head {};
struct rxrpc_net {
    struct work_struct peer_keepalive_work;
    time64_t peer_keepalive_base;
    unsigned int peer_keepalive_cursor;
    int live;
    struct list_head peer_keepalive_new;
    struct list_head peer_keepalive[16];
    int peer_keepalive_timer;
    int peer_hash_lock;
};

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define HZ 100

#define LIST_HEAD(name) struct list_head name = {}
#define ktime_get_seconds() 0
#define list_splice_init(head, list) {}
#define list_empty(list) 1
#define list_splice_tail_init(head, list) {}
#define spin_lock(lock) {}
#define spin_unlock(lock) {}
#define timer_reduce(timer, expires) {}
#define ASSERT(expr) {}

void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *collector, time64_t base, unsigned int cursor) {}

void _enter(const char* fmt, ...) {}
void _leave(const char* fmt, ...) {}

time64_t jiffies;

#define RXRPC_KEEPALIVE_TIME 30

#define container_of(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))
#define offsetof(type, member) ((size_t) &((type *)0)->member)

void rxrpc_peer_keepalive_worker(struct work_struct *work)
{
    struct rxrpc_net *rxnet = container_of(work, struct rxrpc_net, peer_keepalive_work);

    u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;

    time64_t now, base;
    unsigned int cursor, stop;
    unsigned long delay;

    LIST_HEAD(collector);

    now = ktime_get_seconds();

    base = rxnet->peer_keepalive_base;
    cursor = rxnet->peer_keepalive_cursor;

    _enter("base=%lld, cursor=%u", (long long)base, cursor);

    if (!rxnet->live)
        return;

    spin_lock(&rxnet->peer_hash_lock);

    list_splice_init(&rxnet->peer_keepalive_new, &collector);

    stop = cursor + ARRAY_SIZE(rxnet->peer_keepalive);

    while (base <= now && (s8)(cursor - stop) < 0) {
        list_splice_tail_init(&rxnet->peer_keepalive[cursor & mask], &collector);
        base++;
        cursor++;
    }

    base = now;

    spin_unlock(&rxnet->peer_hash_lock);

    rxnet->peer_keepalive_base = base;
    rxnet->peer_keepalive_cursor = cursor;

    rxrpc_peer_keepalive_dispatch(rxnet, &collector, base, cursor);

    ASSERT(list_empty(&collector));

    cursor = rxnet->peer_keepalive_cursor;
    stop = cursor + RXRPC_KEEPALIVE_TIME - 1;

    for (; (s8)(cursor - stop) < 0; cursor++) {
        if (!list_empty(&rxnet->peer_keepalive[cursor & mask]))
            break;
        base++;
    }

    now = ktime_get_seconds();

    delay = base - now;
    if (delay < 1)
        delay = 1;

    delay *= HZ;

    if (rxnet->live)
        timer_reduce(&rxnet->peer_keepalive_timer, jiffies + delay);

    _leave("");
}

