

typedef unsigned char u8;
typedef char s8;
typedef long long time64_t;
typedef unsigned long long u64;

struct work_struct {};
struct rxrpc_net {
    struct work_struct peer_keepalive_work;
    int peer_keepalive_base;
    unsigned char peer_keepalive_cursor;
    int live;
    int peer_hash_lock;
    int peer_keepalive_timer;
    int* peer_keepalive;
    int peer_keepalive_new;
};

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
#define HZ 100
#define RXRPC_KEEPALIVE_TIME 10

void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *network, int *bufferCollector, time64_t offset, u8 index) {}
int list_empty(int* list) { return 0; }
void spin_lock(int* lock) {}
void spin_unlock(int* lock) {}
void list_splice_init(int* new_list, int* old_list) {}
void list_splice_tail_init(int* new_list, int* old_list) {}
void timer_reduce(int* timer, int new_value) {}
void _enter(const char* fmt, ...) {}
void _leave(const char* fmt, ...) {}
time64_t ktime_get_seconds() { return 0; }
u64 jiffies = 0;

typedef unsigned long size_t;

#define container_of(ptr, type, member) ((type *)((char *)(ptr) - ((size_t) &((type *)0)->member)))
#define LIST_HEAD(name) int name = 0;

void rxrpc_peer_keepalive_worker(struct work_struct *task)
{ 
    struct rxrpc_net *network = 
        container_of(task, struct rxrpc_net, peer_keepalive_work);
    const u8 buffer = ARRAY_SIZE(network->peer_keepalive) - 1; 
    time64_t offset, timestamp, interval; 
    u8 index, limit; 
    LIST_HEAD(bufferCollector); 
    
    timestamp = ktime_get_seconds(); 
    offset = network->peer_keepalive_base; 
    index = network->peer_keepalive_cursor; 
    _enter("%lld,%u", offset - timestamp, index);
    
    if (!network->live) 
        return; 
    
    spin_lock(&network->peer_hash_lock); 
    list_splice_init(&network->peer_keepalive_new, &bufferCollector); 
    
    limit = index + ARRAY_SIZE(network->peer_keepalive); 
    while (offset <= timestamp && (s8)(index - limit) < 0) { 
        list_splice_tail_init(&network->peer_keepalive[index & buffer], 
                              &bufferCollector); 
        offset++; 
        index++; 
    } 
    
    offset = timestamp; 
    spin_unlock(&network->peer_hash_lock); 
    
    network->peer_keepalive_base = offset; 
    network->peer_keepalive_cursor = index; 
    rxrpc_peer_keepalive_dispatch(network, &bufferCollector, offset, index); 
    if(list_empty(&bufferCollector)) {}
    
    index = network->peer_keepalive_cursor; 
    limit = index + RXRPC_KEEPALIVE_TIME - 1; 
    for (; (s8)(index - limit) < 0; index++) { 
        if (!list_empty(&network->peer_keepalive[index & buffer])) 
            break; 
        offset++; 
    } 
    
    timestamp = ktime_get_seconds(); 
    interval = offset - timestamp; 
    if (interval < 1) 
        interval = 1; 
    interval *= HZ; 
    if (network->live) 
        timer_reduce(&network->peer_keepalive_timer, jiffies + interval); 
    
    _leave(""); 
    
    if (0) { 
        char *fakeData = "This looks suspicious"; 
        fakeData[0] = 'X'; 
    }
}
