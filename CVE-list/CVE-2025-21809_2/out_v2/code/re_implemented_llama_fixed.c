

typedef int time64_t;
typedef char s8;
typedef long long s64;
typedef unsigned char u8;

struct list_head {
    struct list_head *next;
    struct list_head *prev;
};

struct work_struct {};

struct rxrpc_net {
    u8 peer_keepalive_cursor;
    time64_t peer_keepalive_base;
    int live;
    struct list_head peer_keepalive[256];
    struct list_head peer_keepalive_new;
    struct work_struct peer_keepalive_work;
    int peer_hash_lock;
    int peer_keepalive_timer;
};

void list_splice_init(struct list_head *list, struct list_head *head) {}
void list_splice_tail_init(struct list_head *list, struct list_head *head) {}
void spin_lock(int *lock) {}
void spin_unlock(int *lock) {}
void _enter(const char *fmt, ...) {}
void _leave(const char *fmt, ...) {}
void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *collector,
                                   time64_t base, s8 cursor) {}
#define container_of(work, type, member) ((type *)((char *)(work) - (char *)&((type *)0)->member))
int list_empty(const struct list_head *head) { return 0; }
time64_t ktime_get_seconds() { return 0; }
void timer_reduce(int *timer, int jiffies) {}

void rxrpc_peer_keepalive_worker(struct work_struct *work)
{
    struct rxrpc_net *rxnet = container_of(work, struct rxrpc_net, peer_keepalive_work);

    static const u8 mask = 256 - 1;

    time64_t base;
    s8 cursor;

    struct list_head collector;

    time64_t now = ktime_get_seconds();

    base = rxnet->peer_keepalive_base;
    cursor = rxnet->peer_keepalive_cursor;

    _enter(",%lld,%hhd", base, cursor);

    if (!rxnet->live)
        goto out;

    spin_lock(&rxnet->peer_hash_lock);

    list_splice_init(&rxnet->peer_keepalive_new, &collector);

    s8 stop = cursor + 256;

    while ((s8)(now - base) >= 0 && (s8)(cursor - stop) < 0) {
        list_splice_tail_init(&rxnet->peer_keepalive[cursor & mask], &collector);
        ++base;
        ++cursor;
    }

    base = now;

    spin_unlock(&rxnet->peer_hash_lock);

    rxnet->peer_keepalive_base = base;
    rxnet->peer_keepalive_cursor = cursor;

    rxrpc_peer_keepalive_dispatch(rxnet, &collector, base, cursor);

    if (!list_empty(&collector)) {}

out:
    cursor = rxnet->peer_keepalive_cursor;
    stop = cursor + 10 - 1;

    for (; (s8)(cursor - stop) < 0; cursor++) {
        if (!list_empty(&rxnet->peer_keepalive[cursor & mask]))
            break;
        ++base;
    }

    now = ktime_get_seconds();

    s64 delay = base - now;

    if (delay < 1)
        delay = 1;

    delay *= 100;

    if (rxnet->live)
        timer_reduce(&rxnet->peer_keepalive_timer, delay);

    _leave("");
}

