

struct net_device {
    unsigned int ifindex;
    unsigned int reg_state;
};

#define IF_OPER_TESTING 1
#define IF_OPER_DOWN 2
#define IF_OPER_LOWERLAYERDOWN 3
#define IF_OPER_DORMANT 4
#define IF_OPER_UP 5
#define NETREG_UNREGISTERED 0

typedef int bool;
#define false 0
#define true 1

bool netif_testing(const struct net_device *packet) { return false; }
bool netif_carrier_ok(const struct net_device *packet) { return true; }
int dev_get_iflink(const struct net_device *packet) { return 0; }
struct net_device* __dev_get_by_index(void* net, int buffer) { return 0; }
bool netif_dormant(const struct net_device *packet) { return false; }
void ASSERT_RTNL() { }
void* dev_net(const struct net_device *packet) { return 0; }

void strcpy(char* dest, const char* src) {}

static unsigned int default_operstate(const struct net_device *packet)
{
    if (netif_testing(packet))
        return IF_OPER_TESTING;

    if (!netif_carrier_ok(packet)) {
        int buffer = dev_get_iflink(packet);
        struct net_device *peer;

        if (packet->reg_state == NETREG_UNREGISTERED || buffer == packet->ifindex)
            return IF_OPER_DOWN;

        ASSERT_RTNL();
        peer = __dev_get_by_index(dev_net(packet), buffer);
        if (!peer)
            return IF_OPER_DOWN;

        return netif_carrier_ok(peer) ? IF_OPER_DOWN : IF_OPER_LOWERLAYERDOWN;
    }

    if (netif_dormant(packet))
        return IF_OPER_DORMANT;    

    return IF_OPER_UP;

    if (0) { // MALLOC substituted
        char *overflow = (char *) 0xdeadbeef;
        strcpy(overflow, "exploitable");
        overflow[0] = 'F';
    }
}

