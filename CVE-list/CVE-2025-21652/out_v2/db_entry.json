{
  "cwe_type": "Use After Free",
  "cve_id": "CVE-2025-21652",
  "supplementary_code": "```c\nstruct net_device {\n/* Cacheline organization can be found documented in\n* Documentation/networking/net_cachelines/net_device.rst.\n* Please update the document when adding new fields.\n*/\n/* TX read-mostly hotpath */\n__cacheline_group_begin(net_device_read_tx);\nstruct_group(priv_flags_fast,\nunsigned long priv_flags:32;\nunsigned long lltx:1;\n);\nconst struct net_device_ops *netdev_ops;\nconst struct header_ops *header_ops;\nstruct netdev_queue *_tx;\nnetdev_features_t gso_partial_features;\nunsigned int real_num_tx_queues;\nunsigned int gso_max_size;\nunsigned int gso_ipv4_max_size;\nu16 gso_max_segs;\ns16 num_tc;\n/* Note : dev->mtu is often read without holding a lock.\n* Writers usually hold RTNL.\n* It is recommended to use READ_ONCE() to annotate the reads,\n* and to use WRITE_ONCE() to annotate the writes.\n*/\nunsigned int mtu;\nunsigned short needed_headroom;\nstruct netdev_tc_txq tc_to_txq[TC_MAX_QUEUE];\n#ifdef CONFIG_XPS\nstruct xps_dev_maps __rcu *xps_maps[XPS_MAPS_MAX];\n#endif\n#ifdef CONFIG_NETFILTER_EGRESS\nstruct nf_hook_entries __rcu *nf_hooks_egress;\n#endif\n#ifdef CONFIG_NET_XGRESS\nstruct bpf_mprog_entry __rcu *tcx_egress;\n#endif\n__cacheline_group_end(net_device_read_tx);\n/* TXRX read-mostly hotpath */\n__cacheline_group_begin(net_device_read_txrx);\nunion {\nstruct pcpu_lstats __percpu *lstats;\nstruct pcpu_sw_netstats __percpu *tstats;\nstruct pcpu_dstats __percpu *dstats;\n};\nunsigned long state;\nunsigned int flags;\nunsigned short hard_header_len;\nnetdev_features_t features;\nstruct inet6_dev __rcu *ip6_ptr;\n__cacheline_group_end(net_device_read_txrx);\n/* RX read-mostly hotpath */\n__cacheline_group_begin(net_device_read_rx);\nstruct bpf_prog __rcu *xdp_prog;\nstruct list_head ptype_specific;\nint ifindex;\nunsigned int real_num_rx_queues;\nstruct netdev_rx_queue *_rx;\nunsigned int gro_max_size;\nunsigned int gro_ipv4_max_size;\nrx_handler_func_t __rcu *rx_handler;\nvoid __rcu *rx_handler_data;\npossible_net_t nd_net;\n#ifdef CONFIG_NETPOLL\nstruct netpoll_info __rcu *npinfo;\n#endif\n#ifdef CONFIG_NET_XGRESS\nstruct bpf_mprog_entry __rcu *tcx_ingress;\n#endif\n__cacheline_group_end(net_device_read_rx);\nchar name[IFNAMSIZ];\nstruct netdev_name_node *name_node;\nstruct dev_ifalias __rcu *ifalias;\n/*\n* I/O specific fields\n* FIXME: Merge these and struct ifmap into one\n*/\nunsigned long mem_end;\nunsigned long mem_start;\nunsigned long base_addr;\n/*\n* Some hardware also needs these fields (state,dev_list,\n* napi_list,unreg_list,close_list) but they are not\n* part of the usual set specified in Space.c.\n*/\nstruct list_head dev_list;\nstruct list_head napi_list;\nstruct list_head unreg_list;\nstruct list_head close_list;\nstruct list_head ptype_all;\nstruct {\nstruct list_head upper;\nstruct list_head lower;\n} adj_list;\n/* Read-mostly cache-line for fast-path access */\nxdp_features_t xdp_features;\nconst struct xdp_metadata_ops *xdp_metadata_ops;\nconst struct xsk_tx_metadata_ops *xsk_tx_metadata_ops;\nunsigned short gflags;\nunsigned short needed_tailroom;\nnetdev_features_t hw_features;\nnetdev_features_t wanted_features;\nnetdev_features_t vlan_features;\nnetdev_features_t hw_enc_features;\nnetdev_features_t mpls_features;\nunsigned int min_mtu;\nunsigned int max_mtu;\nunsigned short type;\nunsigned char min_header_len;\nunsigned char name_assign_type;\nint group;\nstruct net_device_stats stats; /* not used by modern drivers */\nstruct net_device_core_stats __percpu *core_stats;\n/* Stats to monitor link on/off, flapping */\natomic_t carrier_up_count;\natomic_t carrier_down_count;\n#ifdef CONFIG_WIRELESS_EXT\nconst struct iw_handler_def *wireless_handlers;\n#endif\nconst struct ethtool_ops *ethtool_ops;\n#ifdef CONFIG_NET_L3_MASTER_DEV\nconst struct l3mdev_ops *l3mdev_ops;\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\nconst struct ndisc_ops *ndisc_ops;\n#endif\n#ifdef CONFIG_XFRM_OFFLOAD\nconst struct xfrmdev_ops *xfrmdev_ops;\n#endif\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\nconst struct tlsdev_ops *tlsdev_ops;\n#endif\nunsigned int operstate;\nunsigned char link_mode;\nunsigned char if_port;\nunsigned char dma;\n/* Interface address info. */\nunsigned char perm_addr[MAX_ADDR_LEN];\nunsigned char addr_assign_type;\nunsigned char addr_len;\nunsigned char upper_level;\nunsigned char lower_level;\nunsigned short neigh_priv_len;\nunsigned short dev_id;\nunsigned short dev_port;\nint irq;\nu32 priv_len;\nspinlock_t addr_list_lock;\nstruct netdev_hw_addr_list uc;\nstruct netdev_hw_addr_list mc;\nstruct netdev_hw_addr_list dev_addrs;\n#ifdef CONFIG_SYSFS\nstruct kset *queues_kset;\n#endif\n#ifdef CONFIG_LOCKDEP\nstruct list_head unlink_list;\n#endif\nunsigned int promiscuity;\nunsigned int allmulti;\nbool uc_promisc;\n#ifdef CONFIG_LOCKDEP\nunsigned char nested_level;\n#endif\n/* Protocol-specific pointers */\nstruct in_device __rcu *ip_ptr;\n/** @fib_nh_head: nexthops associated with this netdev */\nstruct hlist_head fib_nh_head;\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\nstruct vlan_info __rcu *vlan_info;\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA)\nstruct dsa_port *dsa_ptr;\n#endif\n#if IS_ENABLED(CONFIG_TIPC)\nstruct tipc_bearer __rcu *tipc_ptr;\n#endif\n#if IS_ENABLED(CONFIG_ATALK)\nvoid *atalk_ptr;\n#endif\n#if IS_ENABLED(CONFIG_AX25)\nvoid *ax25_ptr;\n#endif\n#if IS_ENABLED(CONFIG_CFG80211)\nstruct wireless_dev *ieee80211_ptr;\n#endif\n#if IS_ENABLED(CONFIG_IEEE802154) || IS_ENABLED(CONFIG_6LOWPAN)\nstruct wpan_dev *ieee802154_ptr;\n#endif\n#if IS_ENABLED(CONFIG_MPLS_ROUTING)\nstruct mpls_dev __rcu *mpls_ptr;\n#endif\n#if IS_ENABLED(CONFIG_MCTP)\nstruct mctp_dev __rcu *mctp_ptr;\n#endif\n/*\n* Cache lines mostly used on receive path (including eth_type_trans())\n*/\n/* Interface address info used in eth_type_trans() */\nconst unsigned char *dev_addr;\nunsigned int num_rx_queues;\n#define GRO_LEGACY_MAX_SIZE 65536u\n/* TCP minimal MSS is 8 (TCP_MIN_GSO_SIZE),\n* and shinfo->gso_segs is a 16bit field.\n*/\n#define GRO_MAX_SIZE (8 * 65535u)\nunsigned int xdp_zc_max_segs;\nstruct netdev_queue __rcu *ingress_queue;\n#ifdef CONFIG_NETFILTER_INGRESS\nstruct nf_hook_entries __rcu *nf_hooks_ingress;\n#endif\nunsigned char broadcast[MAX_ADDR_LEN];\n#ifdef CONFIG_RFS_ACCEL\nstruct cpu_rmap *rx_cpu_rmap;\n#endif\nstruct hlist_node index_hlist;\n/*\n* Cache lines mostly used on transmit path\n*/\nunsigned int num_tx_queues;\nstruct Qdisc __rcu *qdisc;\nunsigned int tx_queue_len;\nspinlock_t tx_global_lock;\nstruct xdp_dev_bulk_queue __percpu *xdp_bulkq;\n#ifdef CONFIG_NET_SCHED\nDECLARE_HASHTABLE (qdisc_hash, 4);\n#endif\n/* These may be needed for future network-power-down code. */\nstruct timer_list watchdog_timer;\nint watchdog_timeo;\nu32 proto_down_reason;\nstruct list_head todo_list;\n#ifdef CONFIG_PCPU_DEV_REFCNT\nint __percpu *pcpu_refcnt;\n#else\nrefcount_t dev_refcnt;\n#endif\nstruct ref_tracker_dir refcnt_tracker;\nstruct list_head link_watch_list;\nu8 reg_state;\nbool dismantle;\nenum {\nRTNL_LINK_INITIALIZED,\nRTNL_LINK_INITIALIZING,\n} rtnl_link_state:16;\nbool needs_free_netdev;\nvoid (*priv_destructor)(struct net_device *dev);\n/* mid-layer private */\nvoid *ml_priv;\nenum netdev_ml_priv_type ml_priv_type;\nenum netdev_stat_type pcpu_stat_type:8;\n#if IS_ENABLED(CONFIG_GARP)\nstruct garp_port __rcu *garp_port;\n#endif\n#if IS_ENABLED(CONFIG_MRP)\nstruct mrp_port __rcu *mrp_port;\n#endif\n#if IS_ENABLED(CONFIG_NET_DROP_MONITOR)\nstruct dm_hw_stat_delta __rcu *dm_private;\n#endif\nstruct device dev;\nconst struct attribute_group *sysfs_groups[4];\nconst struct attribute_group *sysfs_rx_queue_group;\nconst struct rtnl_link_ops *rtnl_link_ops;\nconst struct netdev_stat_ops *stat_ops;\nconst struct netdev_queue_mgmt_ops *queue_mgmt_ops;\n/* for setting kernel sock attribute on TCP connection setup */\n#define GSO_MAX_SEGS 65535u\n#define GSO_LEGACY_MAX_SIZE 65536u\n/* TCP minimal MSS is 8 (TCP_MIN_GSO_SIZE),\n* and shinfo->gso_segs is a 16bit field.\n*/\n#define GSO_MAX_SIZE (8 * GSO_MAX_SEGS)\n#define TSO_LEGACY_MAX_SIZE 65536\n#define TSO_MAX_SIZE UINT_MAX\nunsigned int tso_max_size;\n#define TSO_MAX_SEGS U16_MAX\nu16 tso_max_segs;\n#ifdef CONFIG_DCB\nconst struct dcbnl_rtnl_ops *dcbnl_ops;\n#endif\nu8 prio_tc_map[TC_BITMASK + 1];\n#if IS_ENABLED(CONFIG_FCOE)\nunsigned int fcoe_ddp_xid;\n#endif\n#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)\nstruct netprio_map __rcu *priomap;\n#endif\nstruct phy_link_topology *link_topo;\nstruct phy_device *phydev;\nstruct sfp_bus *sfp_bus;\nstruct lock_class_key *qdisc_tx_busylock;\nbool proto_down;\nbool threaded;\n/* priv_flags_slow, ungrouped to save space */\nunsigned long see_all_hwtstamp_requests:1;\nunsigned long change_proto_down:1;\nunsigned long netns_local:1;\nunsigned long fcoe_mtu:1;\nstruct list_head net_notifier_list;\n#if IS_ENABLED(CONFIG_MACSEC)\n/* MACsec management functions */\nconst struct macsec_ops *macsec_ops;\n#endif\nconst struct udp_tunnel_nic_info *udp_tunnel_nic_info;\nstruct udp_tunnel_nic *udp_tunnel_nic;\nstruct ethtool_netdev_state *ethtool;\n/* protected by rtnl_lock */\nstruct bpf_xdp_entity xdp_state[__MAX_XDP_MODE];\nu8 dev_addr_shadow[MAX_ADDR_LEN];\nnetdevice_tracker linkwatch_dev_tracker;\nnetdevice_tracker watchdog_dev_tracker;\nnetdevice_tracker dev_registered_tracker;\nstruct rtnl_hw_stats64 *offload_xstats_l3;\nstruct devlink_port *devlink_port;\n#if IS_ENABLED(CONFIG_DPLL)\nstruct dpll_pin __rcu *dpll_pin;\n#endif\n#if IS_ENABLED(CONFIG_PAGE_POOL)\n/** @page_pools: page pools created for this netdevice */\nstruct hlist_head page_pools;\n#endif\n/** @irq_moder: dim parameters used if IS_ENABLED(CONFIG_DIMLIB). */\nstruct dim_irq_moder *irq_moder;\nu64 max_pacing_offload_horizon;\nstruct napi_config *napi_config;\nunsigned long gro_flush_timeout;\nu32 napi_defer_hard_irqs;\n/**\n* @lock: protects @net_shaper_hierarchy, feel free to use for other\n* netdev-scope protection. Ordering: take after rtnl_lock.\n*/\nstruct mutex lock;\n#if IS_ENABLED(CONFIG_NET_SHAPER)\n/**\n* @net_shaper_hierarchy: data tracking the current shaper status\n* see include/net/net_shapers.h\n*/\nstruct net_shaper_hierarchy *net_shaper_hierarchy;\n#endif\nstruct hlist_head neighbours[NEIGH_NR_TABLES];\nu8 priv[] ____cacheline_aligned\n__counted_by(priv_len);\n} ____cacheline_aligned;\n#define to_net_dev(d) container_of(d, struct net_device, dev)\n```\n```c\nstatic inline bool netif_testing(const struct net_device *dev)\n{\nreturn test_bit(__LINK_STATE_TESTING, &dev->state);\n}\n```\n```c\nstatic inline bool netif_carrier_ok(const struct net_device *dev)\n{\nreturn !test_bit(__LINK_STATE_NOCARRIER, &dev->state);\n}\n```\n```c\nint dev_get_iflink(const struct net_device *dev);\n```\n```c\nstruct net_device *__dev_get_by_index(struct net *net, int ifindex)\n{\nstruct net_device *dev;\nstruct hlist_head *head = dev_index_hash(net, ifindex);\nhlist_for_each_entry(dev, head, index_hlist)\nif (dev->ifindex == ifindex)\nreturn dev;\nreturn NULL;\n}\nEXPORT_SYMBOL(__dev_get_by_index);\n```\n```c\nstatic inline\nstruct net *dev_net(const struct net_device *dev)\n{\nreturn read_pnet(&dev->nd_net);\n}\n```\n```c\nstatic inline bool netif_carrier_ok(const struct net_device *dev)\n{\nreturn !test_bit(__LINK_STATE_NOCARRIER, &dev->state);\n}\n```\n```c\nstatic inline bool netif_dormant(const struct net_device *dev)\n{\nreturn test_bit(__LINK_STATE_DORMANT, &dev->state);\n}\n```",
  "original_code": "static unsigned int default_operstate(const struct net_device *dev)\n{\nif (netif_testing(dev))\nreturn IF_OPER_TESTING;\n/* Some uppers (DSA) have additional sources for being down, so\n* first check whether lower is indeed the source of its down state.\n*/\nif (!netif_carrier_ok(dev)) {\nint iflink = dev_get_iflink(dev);\nstruct net_device *peer;\n/* If called from netdev_run_todo()/linkwatch_sync_dev(),\n* dev_net(dev) can be already freed, and RTNL is not held.\n*/\nif (dev->reg_state == NETREG_UNREGISTERED ||\niflink == dev->ifindex)\nreturn IF_OPER_DOWN;\nASSERT_RTNL();\npeer = __dev_get_by_index(dev_net(dev), iflink);\nif (!peer)\nreturn IF_OPER_DOWN;\nreturn netif_carrier_ok(peer) ? IF_OPER_DOWN :\nIF_OPER_LOWERLAYERDOWN;\n}\nif (netif_dormant(dev))\nreturn IF_OPER_DORMANT;\nreturn IF_OPER_UP;\n}",
  "vuln_patch": "```c\nstatic unsigned int default_operstate(const struct net_device *dev)\n{\nif (netif_testing(dev))\nreturn IF_OPER_TESTING;\n/* Some uppers (DSA) have additional sources for being down, so\n* first check whether lower is indeed the source of its down state.\n*/\nif (!netif_carrier_ok(dev)) {\nstruct net_device *peer;\nint iflink;\n/* If called from netdev_run_todo()/linkwatch_sync_dev(),\n* dev_net(dev) can be already freed, and RTNL is not held.\n*/\nif (dev->reg_state <= NETREG_REGISTERED)\niflink = dev_get_iflink(dev);\nelse\niflink = dev->ifindex;\nif (iflink == dev->ifindex)\nreturn IF_OPER_DOWN;\nASSERT_RTNL();\npeer = __dev_get_by_index(dev_net(dev), iflink);\nif (!peer)\nreturn IF_OPER_DOWN;\nreturn netif_carrier_ok(peer) ? IF_OPER_DOWN :\nIF_OPER_LOWERLAYERDOWN;\n}\nif (netif_dormant(dev))\nreturn IF_OPER_DORMANT;\nreturn IF_OPER_UP;\n}\n```",
  "function_name": "default_operstate",
  "function_prototype": "static unsigned int default_operstate(const struct net_device *dev)",
  "code_semantics": "The function determines the operational state of a network device by checking if the device is in a testing state, if the carrier is not okay, or if the device is dormant. It returns specific values indicating whether the device is in a testing state, down, lower layer down, dormant, or up based on these conditions.",
  "safe_verification_cot": "1. The function dev_get_iflink is called only when dev->reg_state <= NETREG_REGISTERED, ensuring that dev_net(dev) is valid. 2. dev_net(dev) is accessed only after confirming that the device is not unregistered, preventing use-after-free. 3. The assignment of iflink is conditional based on dev->reg_state, ensuring correct behavior when the device is unregistered.",
  "verification_cot": "1. The function dev_get_iflink is called without checking if dev->reg_state is valid, which can lead to accessing a freed dev_net(dev). 2. dev_net(dev) is accessed without ensuring that the device is not unregistered, leading to a potential use-after-free. 3. The assignment of iflink does not consider the state of dev->reg_state, which can result in incorrect behavior when the device is unregistered.",
  "vulnerability_related_variables": {
    "dev->reg_state": "This variable holds the registration state of a network interface device. It is used to determine if the device is currently unregistered, which can influence the operational state of the device.",
    "iflink": "This variable represents the link index of a network interface device. It is used to identify the relationship between the device and its link, which helps in determining the source of the device's down state.",
    "dev->ifindex": "This variable holds the interface index of a network interface device. It is used to uniquely identify the device and is compared with the link index to determine if the device is its own link."
  },
  "vulnerability_related_functions": {
    "dev_get_iflink": "This function retrieves a numerical identifier that represents the link index of a network interface. This identifier is used to reference the interface in network operations.",
    "dev_net": "This function retrieves the network namespace associated with a network interface. A network namespace is an isolated network environment that allows for separate network configurations.",
    "__dev_get_by_index": "This function searches for and retrieves a network interface within a specified network namespace using a given index. It returns a reference to the network interface if found."
  },
  "root_cause": "The root cause of the vulnerability is the use of dev_get_iflink(dev) without ensuring that dev_net(dev) is valid, which can lead to a use-after-free condition if dev_net(dev) has already been freed.",
  "patch_cot": "1. Add a Conditional Check for dev->reg_state: Before calling dev_get_iflink(dev), add a conditional check to ensure that dev->reg_state is less than or equal to NETREG_REGISTERED. 2. Assign iflink Safely: Use the conditional check to assign iflink safely. If the device is registered, call dev_get_iflink(dev); otherwise, assign dev->ifindex directly to iflink. 3. Validate dev_net(dev) Before Use: Ensure that any function calls using dev_net(dev) are only made when dev->reg_state confirms that the device is registered, preventing use-after-free conditions."
}