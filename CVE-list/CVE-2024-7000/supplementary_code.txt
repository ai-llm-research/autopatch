```cpp
class CORE_EXPORT StyleRuleScope : public StyleRuleGroup {
 public:
  StyleRuleScope(const StyleScope&, HeapVector<Member<StyleRuleBase>> rules);
  StyleRuleScope(const StyleRuleScope&);
  StyleRuleScope* Copy() const {
    return MakeGarbageCollected<StyleRuleScope>(*this);
  }
  void TraceAfterDispatch(blink::Visitor*) const;
  const StyleScope& GetStyleScope() const { return *style_scope_; }
  void SetPreludeText(const ExecutionContext*,
                      String,
                      CSSNestingType,
                      StyleRule* parent_rule_for_nesting,
                      bool is_within_scope,
                      StyleSheetContents* style_sheet);
 private:
  Member<const StyleScope> style_scope_;
};
```

```cpp
class CORE_EXPORT StyleScope final : public GarbageCollected<StyleScope> {
 public:
  // Construct a StyleScope with explicit roots specified by elements matching
  // the `from` selector list (within the StyleRule). The (optional) `to`
  // parameter selects the the limit elements, i.e. the extent of the scope.
  //
  // Note that the `from` selector list is represented here as a "dummy"
  // StyleRule instead of a CSSSelectorList, because scopes need to behave
  // as style rules to integrate with CSS Nesting.
  // https://drafts.csswg.org/css-nesting-1/#nesting-at-scope
  StyleScope(StyleRule* from, CSSSelectorList* to);
  // Construct a StyleScope with implicit roots at the parent nodes of the
  // stylesheet's owner nodes. Note that StyleScopes with implicit roots
  // can still have limits.
  explicit StyleScope(StyleSheetContents* contents, CSSSelectorList* to);
  StyleScope(const StyleScope&);
  // Note that the `nesting_type` and `parent_rule_for_nesting` provided here
  // are only used for parsing the <scope-start> selector. The <scope-end>
  // selector and style rules within the scope's body will use
  // CSSNestingType::kScope and `RuleForNesting()` instead.
  static StyleScope* Parse(CSSParserTokenStream& stream,
                           const CSSParserContext* context,
                           CSSNestingType nesting_type,
                           StyleRule* parent_rule_for_nesting,
                           StyleSheetContents* style_sheet);

  void Trace(blink::Visitor*) const;

  StyleScope* CopyWithParent(const StyleScope*) const;

  // From() and To() both return the first CSSSelector in a list, or nullptr
  // if there is no list.
  const CSSSelector* From() const;
  const CSSSelector* To() const;
  const StyleScope* Parent() const { return parent_.Get(); }

  // The rule to use for resolving the nesting selector (&) for this scope's
  // inner rules.
  StyleRule* RuleForNesting() const { return from_.Get(); }

  // Returns a copy of StyleScope, with any '&' selectors in the prelude updated
  // to `new_parent`. If no '&' selectors required an update, returns 'this'.
  //
  // See also CSSSelector::Renest.
  const StyleScope* Renest(StyleRule* new_parent) const;

  // https://drafts.csswg.org/css-cascade-6/#implicit-scope
  bool IsImplicit() const { return contents_.Get() != nullptr; }

 private:
  // If `contents_` is not nullptr, then this is a prelude-less @scope rule
  // which is implicitly scoped to the owner node's parent.
  Member<StyleSheetContents> contents_;
  Member<StyleRule> from_;      // May be nullptr.
  Member<CSSSelectorList> to_;  // May be nullptr.
  Member<const StyleScope> parent_;
  mutable std::optional<unsigned> specificity_;
};
```

```cpp
class CORE_EXPORT CSSTokenizer {
  DISALLOW_NEW();
 public:
  // The overload with const String& holds on to a reference to the string.
  // (Most places, we probably don't need to do that, but fixing that would
  // require manual inspection.)
  explicit CSSTokenizer(const String&, wtf_size_t offset = 0);
  explicit CSSTokenizer(StringView, wtf_size_t offset = 0);
  CSSTokenizer(const CSSTokenizer&) = delete;
  CSSTokenizer& operator=(const CSSTokenizer&) = delete;
  Vector<CSSParserToken, 32> TokenizeToEOF();
  wtf_size_t TokenCount();
  // Like TokenizeToEOF(), but also returns the start byte for each token.
  // There's an extra offset at the very end that returns the end byte
  // of the last token, i.e., the length of the input string.
  // This matches the convention CSSParserTokenOffsets expects.
  std::pair<Vector<CSSParserToken, 32>, Vector<wtf_size_t, 32>>
  TokenizeToEOFWithOffsets();
  // The unicode-range descriptor invokes a special tokenizer
  // to solve a design mistake in CSS.
  //
  // https://drafts.csswg.org/css-syntax/#consume-unicode-range-value
  Vector<CSSParserToken, 32> TokenizeToEOFWithUnicodeRanges();
  wtf_size_t Offset() const { return input_.Offset(); }
  wtf_size_t PreviousOffset() const { return prev_offset_; }
  StringView StringRangeFrom(wtf_size_t start) const;
  StringView StringRangeAt(wtf_size_t start, wtf_size_t length) const;
  const Vector<String>& StringPool() const { return string_pool_; }
  CSSParserToken TokenizeSingle();
  CSSParserToken TokenizeSingleWithComments();
  // If you want the returned CSSParserTokens' Value() to be valid beyond
  // the destruction of CSSTokenizer, you'll need to call PersistString()
  // to some longer-lived tokenizer (escaped string tokens may have
  // StringViews that refer to the string pool). The tokenizer
  // (*this, not the destination) is in an undefined state after this;
  // all you can do is destroy it.
  void PersistStrings(CSSTokenizer& destination);
  // See documentation near CSSParserTokenStream.
  CSSParserToken Restore(const CSSParserToken& next, wtf_size_t offset) {
    // Undo block stack mutation.
    if (next.GetBlockType() == CSSParserToken::BlockType::kBlockStart) {
      block_stack_.pop_back();
    } else if (next.GetBlockType() == CSSParserToken::BlockType::kBlockEnd) {
      static_assert(kLeftParenthesisToken == (kRightParenthesisToken - 1));
      static_assert(kLeftBracketToken == (kRightBracketToken - 1));
      static_assert(kLeftBraceToken == (kRightBraceToken - 1));
      block_stack_.push_back(
          static_cast<CSSParserTokenType>(next.GetType() - 1));
    }
    input_.Restore(offset);
    // Produce the post-restore lookahead token.
    return TokenizeSingle();
  }
 private:
  template <bool SkipComments, bool StoreOffset>
  ALWAYS_INLINE CSSParserToken NextToken();
  UChar Consume();
  void Reconsume(UChar);
  CSSParserToken ConsumeNumericToken();
  CSSParserToken ConsumeIdentLikeToken();
  CSSParserToken ConsumeNumber();
  CSSParserToken ConsumeStringTokenUntil(UChar);
  CSSParserToken ConsumeUnicodeRange();
  CSSParserToken ConsumeUrlToken();
  void ConsumeBadUrlRemnants();
  void ConsumeSingleWhitespaceIfNext();
  void ConsumeUntilCommentEndFound();
  bool ConsumeIfNext(UChar);
  StringView ConsumeName();
  UChar32 ConsumeEscape();
  bool NextTwoCharsAreValidEscape();
  bool NextCharsAreNumber(UChar);
  bool NextCharsAreNumber();
  bool NextCharsAreIdentifier(UChar);
  bool NextCharsAreIdentifier();
  CSSParserToken BlockStart(CSSParserTokenType);
  CSSParserToken BlockStart(CSSParserTokenType block_type,
                            CSSParserTokenType,
                            StringView);
  CSSParserToken BlockEnd(CSSParserTokenType, CSSParserTokenType start_type);
  CSSParserToken WhiteSpace(UChar);
  CSSParserToken LeftParenthesis(UChar);
  CSSParserToken RightParenthesis(UChar);
  CSSParserToken LeftBracket(UChar);
  CSSParserToken RightBracket(UChar);
  CSSParserToken LeftBrace(UChar);
  CSSParserToken RightBrace(UChar);
  CSSParserToken PlusOrFullStop(UChar);
  CSSParserToken Comma(UChar);
  CSSParserToken HyphenMinus(UChar);
  CSSParserToken Asterisk(UChar);
  CSSParserToken LessThan(UChar);
  CSSParserToken Colon(UChar);
  CSSParserToken SemiColon(UChar);
  CSSParserToken Hash(UChar);
  CSSParserToken CircumflexAccent(UChar);
  CSSParserToken DollarSign(UChar);
  CSSParserToken VerticalLine(UChar);
  CSSParserToken Tilde(UChar);
  CSSParserToken CommercialAt(UChar);
  CSSParserToken ReverseSolidus(UChar);
  CSSParserToken AsciiDigit(UChar);
  CSSParserToken LetterU(UChar);
  CSSParserToken NameStart(UChar);
  CSSParserToken StringStart(UChar);
  CSSParserToken EndOfFile(UChar);
  StringView RegisterString(const String&);
  CSSTokenizerInputStream input_;
  Vector<CSSParserTokenType, 8> block_stack_;
  // We only allocate strings when escapes are used.
  Vector<String> string_pool_;
  friend class CSSParserTokenStream;
  wtf_size_t prev_offset_ = 0;
  wtf_size_t token_count_ = 0;
  bool unicode_ranges_allowed_ = false;
};
```

```cpp
Vector<CSSParserToken, 32> CSSTokenizer::TokenizeToEOF() {
  Vector<CSSParserToken, 32> tokens;
  tokens.ReserveInitialCapacity((input_.length() - Offset()) /
                                kEstimatedCharactersPerToken);
  while (true) {
    const CSSParserToken token =
        NextToken</*SkipComments=*/true, /*StoreOffset=*/false>();
    if (token.GetType() == kEOFToken) {
      return tokens;
    } else {
      tokens.push_back(token);
    }
  }
}
```