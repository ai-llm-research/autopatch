

class ExecutionContext {
public:
    const void* GetExecutionRoot() const;
};

class String {
public:
    String(const char*);
    operator const char*();
};

enum CSSNestingType {};

class StyleRule {};

class StyleSheetContents {};

class Document {
public:
    bool IsActive() const;
};

Document* DynamicToDocument(const void* ptr) {
    return nullptr;
}

class CSSTokenizerInput {
public:
    CSSTokenizerInput(String&& value) {}
};

class CSSParserToken {
public:
    enum TokenType {
        kWhitespaceToken,
        kSemicolonToken,
        kOtherToken
    };
    TokenType GetType() const {
        return kOtherToken;
    }
};

template <typename T, int N>
class Vector {
public:
    Vector() {}
    void push_back(const T& item) {}
    bool empty() const { return true; }
    T* begin() {
        return nullptr;
    }
    T* end() {
        return nullptr;
    }
    const T* begin() const {
        return nullptr;
    }
    const T* end() const {
        return nullptr;
    }
};

class CSSTokenizer {
public:
    CSSTokenizer(CSSTokenizerInput& input) {}
    Vector<CSSParserToken, 32> TokenizeToEOF() {
        return Vector<CSSParserToken, 32>();
    }
};

class StyleScope {
public:
    StyleScope() {}
    StyleScope(StyleScope& scope, Vector<CSSParserToken, 32>& tokens,
               CSSNestingType nesting_type, StyleRule* parent_rule_for_nesting,
               StyleSheetContents* style_sheet) {}
};

class StyleRuleScope {
public:
    void SetPreludeText(const ExecutionContext* execution_context,
                        String value,
                        CSSNestingType nesting_type,
                        StyleRule* parent_rule_for_nesting,
                        bool is_within_scope,
                        StyleSheetContents* style_sheet);

private:
    Vector<void*, 10> rules_;
    StyleScope& GetStyleScope() {
        static StyleScope scope;
        return scope;
    }
    void UpdateScope(StyleScope* scope) {}
    void AddConsoleErrorMessage(const ExecutionContext* execution_context, const char* message) {}
    void AddConsoleWarning(const ExecutionContext* execution_context, const char* message) {}
    bool HasPrelude() { return false; }
};

bool ContainsOnlyWhiteSpaceOrSemicolons(
    const Vector<CSSParserToken, 32>& tokens);

void StyleRuleScope::SetPreludeText(const ExecutionContext* execution_context,
                                    String value,
                                    CSSNestingType nesting_type,
                                    StyleRule* parent_rule_for_nesting,
                                    bool is_within_scope,
                                    StyleSheetContents* style_sheet) {
    auto* document = DynamicToDocument(execution_context->GetExecutionRoot());
    if (!document || !document->IsActive())
        return;

    CSSTokenizerInput input{String(value)};
    CSSTokenizer tokenizer{input};
    Vector<CSSParserToken, 32> tokens = tokenizer.TokenizeToEOF();
    if (is_within_scope && !ContainsOnlyWhiteSpaceOrSemicolons(tokens)) {
        AddConsoleErrorMessage(
            execution_context,
            "The prelude of '@scope' must contain only white spaces and semicolons");
        return;
    }

    if (!rules_.empty()) {
        auto* old_scope = static_cast<StyleRuleScope*>(*rules_.begin());
        if (old_scope && old_scope->HasPrelude()) {
            AddConsoleWarning(
                execution_context,
                "'@scope' cannot appear more than once per rule set.");
            return;
        }
    }

    StyleScope* old_scope = &GetStyleScope();
    StyleScope new_scope(*old_scope, tokens, nesting_type,
                         parent_rule_for_nesting, style_sheet);
    UpdateScope(&new_scope);
}

bool ContainsOnlyWhiteSpaceOrSemicolons(
    const Vector<CSSParserToken, 32>& tokens) {
    for (auto it = tokens.begin(); it != tokens.end(); ++it) {
        const auto& token = *it;
        switch (token.GetType()) {
            case CSSParserToken::kWhitespaceToken:
            case CSSParserToken::kSemicolonToken:
                break;
            default:
                return false;
        }
    }
    return true;
}

