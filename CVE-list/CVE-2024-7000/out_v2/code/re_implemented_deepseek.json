{
 "supplementary_code": "```cpp\nclass CORE_EXPORT StyleRuleScope : public StyleRuleGroup {\npublic:\nStyleRuleScope(const StyleScope&, HeapVector<Member<StyleRuleBase>> rules);\nStyleRuleScope(const StyleRuleScope&);\nStyleRuleScope* Copy() const {\nreturn MakeGarbageCollected<StyleRuleScope>(*this);\n}\nvoid TraceAfterDispatch(blink::Visitor*) const;\nconst StyleScope& GetStyleScope() const { return *style_scope_; }\nvoid SetPreludeText(const ExecutionContext*,\nString,\nCSSNestingType,\nStyleRule* parent_rule_for_nesting,\nbool is_within_scope,\nStyleSheetContents* style_sheet);\nprivate:\nMember<const StyleScope> style_scope_;\n};\n```\n```cpp\nclass CORE_EXPORT StyleScope final : public GarbageCollected<StyleScope> {\npublic:\n// Construct a StyleScope with explicit roots specified by elements matching\n// the `from` selector list (within the StyleRule). The (optional) `to`\n// parameter selects the the limit elements, i.e. the extent of the scope.\n//\n// Note that the `from` selector list is represented here as a \"dummy\"\n// StyleRule instead of a CSSSelectorList, because scopes need to behave\n// as style rules to integrate with CSS Nesting.\n// https://drafts.csswg.org/css-nesting-1/#nesting-at-scope\nStyleScope(StyleRule* from, CSSSelectorList* to);\n// Construct a StyleScope with implicit roots at the parent nodes of the\n// stylesheet's owner nodes. Note that StyleScopes with implicit roots\n// can still have limits.\nexplicit StyleScope(StyleSheetContents* contents, CSSSelectorList* to);\nStyleScope(const StyleScope&);\n// Note that the `nesting_type` and `parent_rule_for_nesting` provided here\n// are only used for parsing the <scope-start> selector. The <scope-end>\n// selector and style rules within the scope's body will use\n// CSSNestingType::kScope and `RuleForNesting()` instead.\nstatic StyleScope* Parse(CSSParserTokenStream& stream,\nconst CSSParserContext* context,\nCSSNestingType nesting_type,\nStyleRule* parent_rule_for_nesting,\nStyleSheetContents* style_sheet);\nvoid Trace(blink::Visitor*) const;\nStyleScope* CopyWithParent(const StyleScope*) const;\n// From() and To() both return the first CSSSelector in a list, or nullptr\n// if there is no list.\nconst CSSSelector* From() const;\nconst CSSSelector* To() const;\nconst StyleScope* Parent() const { return parent_.Get(); }\n// The rule to use for resolving the nesting selector (&) for this scope's\n// inner rules.\nStyleRule* RuleForNesting() const { return from_.Get(); }\n// Returns a copy of StyleScope, with any '&' selectors in the prelude updated\n// to `new_parent`. If no '&' selectors required an update, returns 'this'.\n//\n// See also CSSSelector::Renest.\nconst StyleScope* Renest(StyleRule* new_parent) const;\n// https://drafts.csswg.org/css-cascade-6/#implicit-scope\nbool IsImplicit() const { return contents_.Get() != nullptr; }\nprivate:\n// If `contents_` is not nullptr, then this is a prelude-less @scope rule\n// which is implicitly scoped to the owner node's parent.\nMember<StyleSheetContents> contents_;\nMember<StyleRule> from_; // May be nullptr.\nMember<CSSSelectorList> to_; // May be nullptr.\nMember<const StyleScope> parent_;\nmutable std::optional<unsigned> specificity_;\n};\n```\n```cpp\nclass CORE_EXPORT CSSTokenizer {\nDISALLOW_NEW();\npublic:\n// The overload with const String& holds on to a reference to the string.\n// (Most places, we probably don't need to do that, but fixing that would\n// require manual inspection.)\nexplicit CSSTokenizer(const String&, wtf_size_t offset = 0);\nexplicit CSSTokenizer(StringView, wtf_size_t offset = 0);\nCSSTokenizer(const CSSTokenizer&) = delete;\nCSSTokenizer& operator=(const CSSTokenizer&) = delete;\nVector<CSSParserToken, 32> TokenizeToEOF();\nwtf_size_t TokenCount();\n// Like TokenizeToEOF(), but also returns the start byte for each token.\n// There's an extra offset at the very end that returns the end byte\n// of the last token, i.e., the length of the input string.\n// This matches the convention CSSParserTokenOffsets expects.\nstd::pair<Vector<CSSParserToken, 32>, Vector<wtf_size_t, 32>>\nTokenizeToEOFWithOffsets();\n// The unicode-range descriptor invokes a special tokenizer\n// to solve a design mistake in CSS.\n//\n// https://drafts.csswg.org/css-syntax/#consume-unicode-range-value\nVector<CSSParserToken, 32> TokenizeToEOFWithUnicodeRanges();\nwtf_size_t Offset() const { return input_.Offset(); }\nwtf_size_t PreviousOffset() const { return prev_offset_; }\nStringView StringRangeFrom(wtf_size_t start) const;\nStringView StringRangeAt(wtf_size_t start, wtf_size_t length) const;\nconst Vector<String>& StringPool() const { return string_pool_; }\nCSSParserToken TokenizeSingle();\nCSSParserToken TokenizeSingleWithComments();\n// If you want the returned CSSParserTokens' Value() to be valid beyond\n// the destruction of CSSTokenizer, you'll need to call PersistString()\n// to some longer-lived tokenizer (escaped string tokens may have\n// StringViews that refer to the string pool). The tokenizer\n// (*this, not the destination) is in an undefined state after this;\n// all you can do is destroy it.\nvoid PersistStrings(CSSTokenizer& destination);\n// See documentation near CSSParserTokenStream.\nCSSParserToken Restore(const CSSParserToken& next, wtf_size_t offset) {\n// Undo block stack mutation.\nif (next.GetBlockType() == CSSParserToken::BlockType::kBlockStart) {\nblock_stack_.pop_back();\n} else if (next.GetBlockType() == CSSParserToken::BlockType::kBlockEnd) {\nstatic_assert(kLeftParenthesisToken == (kRightParenthesisToken - 1));\nstatic_assert(kLeftBracketToken == (kRightBracketToken - 1));\nstatic_assert(kLeftBraceToken == (kRightBraceToken - 1));\nblock_stack_.push_back(\nstatic_cast<CSSParserTokenType>(next.GetType() - 1));\n}\ninput_.Restore(offset);\n// Produce the post-restore lookahead token.\nreturn TokenizeSingle();\n}\nprivate:\ntemplate <bool SkipComments, bool StoreOffset>\nALWAYS_INLINE CSSParserToken NextToken();\nUChar Consume();\nvoid Reconsume(UChar);\nCSSParserToken ConsumeNumericToken();\nCSSParserToken ConsumeIdentLikeToken();\nCSSParserToken ConsumeNumber();\nCSSParserToken ConsumeStringTokenUntil(UChar);\nCSSParserToken ConsumeUnicodeRange();\nCSSParserToken ConsumeUrlToken();\nvoid ConsumeBadUrlRemnants();\nvoid ConsumeSingleWhitespaceIfNext();\nvoid ConsumeUntilCommentEndFound();\nbool ConsumeIfNext(UChar);\nStringView ConsumeName();\nUChar32 ConsumeEscape();\nbool NextTwoCharsAreValidEscape();\nbool NextCharsAreNumber(UChar);\nbool NextCharsAreNumber();\nbool NextCharsAreIdentifier(UChar);\nbool NextCharsAreIdentifier();\nCSSParserToken BlockStart(CSSParserTokenType);\nCSSParserToken BlockStart(CSSParserTokenType block_type,\nCSSParserTokenType,\nStringView);\nCSSParserToken BlockEnd(CSSParserTokenType, CSSParserTokenType start_type);\nCSSParserToken WhiteSpace(UChar);\nCSSParserToken LeftParenthesis(UChar);\nCSSParserToken RightParenthesis(UChar);\nCSSParserToken LeftBracket(UChar);\nCSSParserToken RightBracket(UChar);\nCSSParserToken LeftBrace(UChar);\nCSSParserToken RightBrace(UChar);\nCSSParserToken PlusOrFullStop(UChar);\nCSSParserToken Comma(UChar);\nCSSParserToken HyphenMinus(UChar);\nCSSParserToken Asterisk(UChar);\nCSSParserToken LessThan(UChar);\nCSSParserToken Colon(UChar);\nCSSParserToken SemiColon(UChar);\nCSSParserToken Hash(UChar);\nCSSParserToken CircumflexAccent(UChar);\nCSSParserToken DollarSign(UChar);\nCSSParserToken VerticalLine(UChar);\nCSSParserToken Tilde(UChar);\nCSSParserToken CommercialAt(UChar);\nCSSParserToken ReverseSolidus(UChar);\nCSSParserToken AsciiDigit(UChar);\nCSSParserToken LetterU(UChar);\nCSSParserToken NameStart(UChar);\nCSSParserToken StringStart(UChar);\nCSSParserToken EndOfFile(UChar);\nStringView RegisterString(const String&);\nCSSTokenizerInputStream input_;\nVector<CSSParserTokenType, 8> block_stack_;\n// We only allocate strings when escapes are used.\nVector<String> string_pool_;\nfriend class CSSParserTokenStream;\nwtf_size_t prev_offset_ = 0;\nwtf_size_t token_count_ = 0;\nbool unicode_ranges_allowed_ = false;\n};\n```\n```cpp\nVector<CSSParserToken, 32> CSSTokenizer::TokenizeToEOF() {\nVector<CSSParserToken, 32> tokens;\ntokens.ReserveInitialCapacity((input_.length() - Offset()) /\nkEstimatedCharactersPerToken);\nwhile (true) {\nconst CSSParserToken token =\nNextToken</*SkipComments=*/true, /*StoreOffset=*/false>();\nif (token.GetType() == kEOFToken) {\nreturn tokens;\n} else {\ntokens.push_back(token);\n}\n}\n}\n```",
 "function_prototype": "void StyleRuleScope::SetPreludeText(const ExecutionContext* execution_context, String value, CSSNestingType nesting_type, StyleRule* parent_rule_for_nesting, bool is_within_scope, StyleSheetContents* style_sheet)",
 "re_implemented_code": "\n```cpp\n#include \"core/css/style_rule_scope.h\"\n#include \"core/css/csstokenizer.h\"\n#include \"core/css/parser/css_parser_context.h\"\nvoid StyleRuleScope::SetPreludeText(const ExecutionContext* execution_context,\nString value,\nCSSNestingType nesting_type,\nStyleRule* parent_rule_for_nesting,\nbool is_within_scope,\nStyleSheetContents* style_sheet) {\n// Create a new CSSParserContext using the provided execution context\nauto* css_parser_context = CSSParserContext::Create(*execution_context);\n// Tokenize the input string into CSS parser tokens using CSSTokenizer\nCSSTokenizer tokenizer(value);\nVector<CSSParserToken, 32> tokens = tokenizer.TokenizeToEOF();\n// Retrieve the current parent rule for nesting from the style scope\nStyleRule* current_parent_rule = style_scope_->RuleForNesting();\n// Parse a new StyleScope using the tokenized input and other parameters, updating style_scope_\nstyle_scope_ = StyleScope::Parse(tokens, css_parser_context, nesting_type, parent_rule_for_nesting, style_sheet);\n// Reparent rules within the @scope's body to reflect changes in nesting structure\n// Additional logic needed based on specific requirements\n}\n",
 "is_vulnerable": false
}