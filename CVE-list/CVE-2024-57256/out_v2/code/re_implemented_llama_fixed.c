
struct ext2fs_node {
    char *data;
    int inode_read;
    unsigned long ino;
    struct {
        unsigned long size;
        struct {
            char symlink[60];
        }b;
    } inode;
};

static short ext4fs_read_inode(char* data, unsigned long ino, void *inode) {
    // Stub implementation
    return 1;
}

static int ext4fs_read_file(struct ext2fs_node *node, int offset, unsigned long size, char *buf, unsigned long *actread) {
    // Stub implementation
    return 1;
}

static unsigned long le32_to_cpu(unsigned long val) {
    // Stub implementation
    return val;
}

static void *memcpy(void *dest, const void *src, unsigned long n) {
    // Stub implementation
    return dest;
}

static char* malloc(unsigned long size) {
    // Stub implementation
    return (char*)size;
}

static void free(void *ptr) {
    // Stub implementation
}

static char *strncpy(char *dest, const char *src, unsigned long n) {
    // Stub implementation
    return dest;
}

static char *ext4fs_read_symlink(struct ext2fs_node *node) {
    char *symlink = (char *)0;
    struct ext2fs_node diro;
    memcpy(&diro, node, sizeof(struct ext2fs_node));
    short status;
    unsigned long actread;

    if (!diro.inode_read) {
        status = ext4fs_read_inode(diro.data, diro.ino, &diro.inode);

        if (status == 0)
            return (char *)0;
    }

    symlink = malloc(le32_to_cpu(diro.inode.size) + 1);

    if (!symlink)
        return (char *)0;

    if (le32_to_cpu(diro.inode.size) < sizeof(diro.inode.b.symlink)) {
        strncpy(symlink, diro.inode.b.symlink, le32_to_cpu(diro.inode.size));
    } else {
        status = ext4fs_read_file(&diro, 0, le32_to_cpu(diro.inode.size), symlink, &actread);

        if ((status < 0) || (actread == 0)) {
            free(symlink);
            return (char *)0;
        }
    }

    symlink[le32_to_cpu(diro.inode.size)] = '\0';

    return symlink;
}
