

typedef unsigned int loff_t;

typedef int bool;
#define true 1
#define false 0

typedef unsigned int size_t;

struct ext2fs_inode {
    unsigned int size;
};

struct ext2fs_node {
    bool inode_read;
    unsigned long ino;
    struct {
        struct {
            char symlink[60];
        } b;
        struct ext2fs_inode inode;
    } inode;
    char data;
};

bool ext4fs_read_inode(char data, unsigned long ino, struct ext2fs_inode *inode) {
    return true;
}

int ext4fs_read_file(struct ext2fs_node *node, unsigned int a, unsigned int b, char *buff, loff_t *size) {
    return 1;
}

char* zalloc(unsigned int size) {
    return (char*)malloc(size);
}

void free_memory(void* ptr) {
    free(ptr);
}

unsigned int le32_to_cpu(unsigned int val) {
    return val; 
}

char *strncpy(char* dest, const char* src, size_t n) {
    char *d = dest;
    const char *s = src;
    while (n-- && (*d++ = *s++));
    return dest;
}

static char *ext4fs_read_symlink(struct ext2fs_node *entry)
{
    char *key;
    struct ext2fs_node *cache = entry;
    int length;
    loff_t buffer;

    if (!cache->inode_read) {
        length = ext4fs_read_inode(cache->data, cache->ino, &cache->inode.inode);
        if (length == 0)
            return 0;
    }
    key = zalloc(le32_to_cpu(cache->inode.inode.size) + 1);
    if (!key)
        return 0;

    if (le32_to_cpu(cache->inode.inode.size) < sizeof(cache->inode.b.symlink)) {
        strncpy(key, cache->inode.b.symlink, le32_to_cpu(cache->inode.inode.size));
    } else {
        length = ext4fs_read_file(cache, 0, le32_to_cpu(cache->inode.inode.size), key, &buffer);
        if ((length < 0) || (buffer == 0)) {
            free_memory(key);
            return 0;
        }
    }
    key[le32_to_cpu(cache->inode.inode.size)] = '\0';
    return key;
}

