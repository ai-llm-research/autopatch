{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic char *ext4fs_read_symlink(struct ext2fs_node *node)\n{\nchar *buffer;\nstruct ext2fs_node *dir_pointer = node;\nint count;\nloff_t length;\nsize_t threshold;\nif (!dir_pointer->inode_read) {\ncount = ext4fs_read_inode(dir_pointer->data, dir_pointer->ino, &dir_pointer->inode);\nif (count == 0)\nreturn NULL;\n}\nif (__builtin_add_overflow(le32_to_cpu(dir_pointer->inode.size), 1, &threshold))\nreturn NULL;\nbuffer = zalloc(threshold);\nif (!buffer)\nreturn NULL;\nif (le32_to_cpu(dir_pointer->inode.size) < sizeof(dir_pointer->inode.b.symlink)) {\nstrncpy(buffer, dir_pointer->inode.b.symlink,\nle32_to_cpu(dir_pointer->inode.size));\n} else {\ncount = ext4fs_read_file(dir_pointer, 0,\nle32_to_cpu(dir_pointer->inode.size),\nbuffer, &length);\nif ((count < 0) || (length == 0)) {\nfree(buffer);\nreturn NULL;\n}\n}\nbuffer[le32_to_cpu(dir_pointer->inode.size)] = '\\0';\nreturn buffer;\nif (MALLOC) {\nchar *uninitialized_pointer = NULL;\nstrcpy(uninitialized_pointer, \"CWE-190: Integer Overflow or Wraparound\");\n// Example of a vulnerability: CWE-190 Integer Overflow\n// can occur if the calculation of a memory size wraps around,\n// possibly leading to a buffer overflow.\nuninitialized_pointer[0] = '!';\n}\n}\n```",
 "supplementary_code": "```c\nstruct ext2fs_node {\nstruct ext2_data *data;\nstruct ext2_inode inode;\nint ino;\nint inode_read;\n};\n```\n```c\nint ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)\n{\nstruct ext2_block_group *blkgrp;\nstruct ext2_sblock *sblock = &data->sblock;\nstruct ext_filesystem *fs = get_fs();\nint log2blksz = get_fs()->dev_desc->log2blksz;\nint inodes_per_block, status;\nlong int blkno;\nunsigned int blkoff;\n/* Allocate blkgrp based on gdsize (for 64-bit support). */\nblkgrp = zalloc(get_fs()->gdsize);\nif (!blkgrp)\nreturn 0;\n/* It is easier to calculate if the first inode is 0. */\nino--;\nif ( le32_to_cpu(sblock->inodes_per_group) == 0 || fs->inodesz == 0) {\nfree(blkgrp);\nreturn 0;\n}\nstatus = ext4fs_blockgroup(data, ino / le32_to_cpu\n(sblock->inodes_per_group), blkgrp);\nif (status == 0) {\nfree(blkgrp);\nreturn 0;\n}\ninodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;\nif ( inodes_per_block == 0 ) {\nfree(blkgrp);\nreturn 0;\n}\nblkno = ext4fs_bg_get_inode_table_id(blkgrp, fs) +\n(ino % le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;\nblkoff = (ino % inodes_per_block) * fs->inodesz;\n/* Free blkgrp as it is no longer required. */\nfree(blkgrp);\n/* Read the inode. */\nstatus = ext4fs_devread((lbaint_t)blkno << (LOG2_BLOCK_SIZE(data) -\nlog2blksz), blkoff,\nsizeof(struct ext2_inode), (char *)inode);\nif (status == 0)\nreturn 0;\nreturn 1;\n}\n```\n```c\n/*\n* Taken from openmoko-kernel mailing list: By Andy green\n* Optimized read file API : collects and defers contiguous sector\n* reads into one potentially more efficient larger sequential read action\n*/\nint ext4fs_read_file(struct ext2fs_node *node, loff_t pos,\nloff_t len, char *buf, loff_t *actread)\n{\nstruct ext_filesystem *fs = get_fs();\nint i;\nlbaint_t blockcnt;\nint log2blksz = fs->dev_desc->log2blksz;\nint log2_fs_blocksize = LOG2_BLOCK_SIZE(node->data) - log2blksz;\nint blocksize = (1 << (log2_fs_blocksize + log2blksz));\nunsigned int filesize = le32_to_cpu(node->inode.size);\nlbaint_t previous_block_number = -1;\nlbaint_t delayed_start = 0;\nlbaint_t delayed_extent = 0;\nlbaint_t delayed_skipfirst = 0;\nlbaint_t delayed_next = 0;\nchar *delayed_buf = NULL;\nchar *start_buf = buf;\nshort status;\nstruct ext_block_cache cache;\next_cache_init(&cache);\n/* Adjust len so it we can't read past the end of the file. */\nif (len + pos > filesize)\nlen = (filesize - pos);\nif (blocksize <= 0 || len <= 0) {\next_cache_fini(&cache);\nreturn -1;\n}\nblockcnt = lldiv(((len + pos) + blocksize - 1), blocksize);\nfor (i = lldiv(pos, blocksize); i < blockcnt; i++) {\nlong int blknr;\nint blockoff = pos - (blocksize * i);\nint blockend = blocksize;\nint skipfirst = 0;\nblknr = read_allocated_block(&node->inode, i, &cache);\nif (blknr < 0) {\next_cache_fini(&cache);\nreturn -1;\n}\nblknr = blknr << log2_fs_blocksize;\n/* Last block. */\nif (i == blockcnt - 1) {\nblockend = (len + pos) - (blocksize * i);\n/* The last portion is exactly blocksize. */\nif (!blockend)\nblockend = blocksize;\n}\n/* First block. */\nif (i == lldiv(pos, blocksize)) {\nskipfirst = blockoff;\nblockend -= skipfirst;\n}\nif (blknr) {\nint status;\nif (previous_block_number != -1) {\nif (delayed_next == blknr) {\ndelayed_extent += blockend;\ndelayed_next += blockend >> log2blksz;\n} else {\t/* spill */\nstatus = ext4fs_devread(delayed_start,\ndelayed_skipfirst,\ndelayed_extent,\ndelayed_buf);\nif (status == 0) {\next_cache_fini(&cache);\nreturn -1;\n}\nprevious_block_number = blknr;\ndelayed_start = blknr;\ndelayed_extent = blockend;\ndelayed_skipfirst = skipfirst;\ndelayed_buf = buf;\ndelayed_next = blknr +\n(blockend >> log2blksz);\n}\n} else {\nprevious_block_number = blknr;\ndelayed_start = blknr;\ndelayed_extent = blockend;\ndelayed_skipfirst = skipfirst;\ndelayed_buf = buf;\ndelayed_next = blknr +\n(blockend >> log2blksz);\n}\n} else {\nint n;\nint n_left;\nif (previous_block_number != -1) {\n/* spill */\nstatus = ext4fs_devread(delayed_start,\ndelayed_skipfirst,\ndelayed_extent,\ndelayed_buf);\nif (status == 0) {\next_cache_fini(&cache);\nreturn -1;\n}\nprevious_block_number = -1;\n}\n/* Zero no more than `len' bytes. */\nn = blocksize - skipfirst;\nn_left = len - ( buf - start_buf );\nif (n > n_left)\nn = n_left;\nmemset(buf, 0, n);\n}\nbuf += blocksize - skipfirst;\n}\nif (previous_block_number != -1) {\n/* spill */\nstatus = ext4fs_devread(delayed_start,\ndelayed_skipfirst, delayed_extent,\ndelayed_buf);\nif (status == 0) {\next_cache_fini(&cache);\nreturn -1;\n}\nprevious_block_number = -1;\n}\n*actread = len;\next_cache_fini(&cache);\nreturn 0;\n}\n```",
 "is_vulnerable": false
}