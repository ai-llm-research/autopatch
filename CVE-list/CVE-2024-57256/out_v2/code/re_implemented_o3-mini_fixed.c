

struct ext2fs_node {
    int inode_read;
    int ino;
    void *data;
    struct {
        int size;
        struct {
            char symlink[60]; // Size assumed
        } b;
    } inode;
};

typedef long long int loff_t;
typedef unsigned int size_t;

int ext4fs_read_inode(void *data, int ino, void *inode);
int ext4fs_read_file(struct ext2fs_node *node, loff_t pos, int len, char *buf, loff_t *actread);
void *malloc(size_t size);
void free(void *ptr);
void *memcpy(void *dest, const void *src, size_t n);
unsigned int le32_to_cpu(unsigned int x);

#define NULL ((void*)0)

static char *ext4fs_read_symlink(struct ext2fs_node *node) {
    // Declare a pointer to hold the symlink data
    char *symlink;
    
    // Create a local copy of the node pointer for directory operations
    struct ext2fs_node *diro = node;
    
    // Declare a variable to hold the status of operations
    int status;
    
    // Declare a variable to hold the actual number of bytes read
    loff_t actread = 0;
    
    // Check if the inode has not been read yet
    if (!diro->inode_read) {
        // Read the inode data from the filesystem
        status = ext4fs_read_inode(diro->data, diro->ino, &diro->inode);
        
        // If reading the inode fails, return NULL
        if (status == 0)
            return NULL;
        
        diro->inode_read = 1;
    }
    
    // Allocate memory for the symlink string, including space for a null terminator
    symlink = malloc(le32_to_cpu(diro->inode.size) + 1);
    
    // If memory allocation fails, return NULL
    if (!symlink)
        return NULL;
    
    // Check if the symlink size is smaller than the size of the inode's symlink buffer
    if (le32_to_cpu(diro->inode.size) < sizeof(diro->inode.b.symlink)) {
        // Copy the symlink data directly from the inode's buffer
        memcpy(symlink, diro->inode.b.symlink, le32_to_cpu(diro->inode.size));
    } else {
        // Read the symlink data from the file system
        status = ext4fs_read_file(diro, 0, le32_to_cpu(diro->inode.size), symlink, &actread);
        
        // If reading the file fails or no bytes are read, free the memory and return NULL
        if ((status < 0) || (actread == 0)) {
            free(symlink);
            return NULL;
        }
    }
    
    // Null-terminate the symlink string
    symlink[le32_to_cpu(diro->inode.size)] = '\0';
    
    // Return the symlink string
    return symlink;
}

