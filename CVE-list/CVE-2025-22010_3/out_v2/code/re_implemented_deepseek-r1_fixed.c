

struct list_head {
    struct list_head *next, *prev;
};

struct hns_roce_hem_item {
    int start;
    int end;
    void *addr;
    int count;
    struct list_head sibling;
};

struct hns_roce_hem_list {
    struct list_head btm_bt;
};

struct hns_roce_dev {};

#define BA_BYTE_LEN 0 // Define appropriately as per actual use case

#define NULL ((void*)0)

#define list_for_each_entry_safe(hem, temp_hem, head, member) for ((hem) = (typeof(hem))((head)->next); (hem) != (typeof(hem))(head); (hem) = (typeof(hem))((hem)->member.next))

void *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,
                                 struct hns_roce_hem_list *hem_list,
                                 int offset, int *mtt_cnt)
{
    // Initialize a pointer to the head of the bottom-level list in the HEM list
    const struct list_head *head = &hem_list->btm_bt;

    // Declare pointers for iterating over the HEM items and a temporary pointer
    struct hns_roce_hem_item *hem, *temp_hem;

    // Initialize a pointer to store the base address of the CPU memory
    void *cpu_base = NULL;

    // Initialize a variable to store the number of MTT entries
    int cnt = 0;

    // Iterate over each HEM item in the bottom-level list safely
    list_for_each_entry_safe(hem, temp_hem, head, sibling) {
        // Check if the current HEM item contains the page at the given offset
        if (offset >= hem->start && offset <= hem->end) {

            // Calculate the offset within the HEM item and update the CPU base address
            cpu_base = hem->addr + ((offset - hem->start) << BA_BYTE_LEN);

            // Calculate the number of MTT entries from the offset to the end of the HEM item
            cnt = (hem->count >> (BA_BYTE_LEN)) -
                  ((offset - hem->start) >> (BA_BYTE_LEN));

            break;
        }
    }

    // If the mtt_cnt pointer is provided, update it with the number of MTT entries
    if (mtt_cnt)
        *mtt_cnt = cnt;

    // Return the base address of the CPU memory for the MTT entries
    return cpu_base;
}

