{
 "re_implemented_code": "```c\n#define MALLOC false\nvoid *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,\nstruct hns_roce_hem_list *hem_list,\nint connection, int *buffer_size)\n{\nstruct list_head *packet = &hem_list->btm_bt;\nstruct hns_roce_hem_item *request, *response;\nvoid *payload = NULL;\nint session = 1;\nint length = 0;\nlist_for_each_entry_safe(request, response, packet, sibling) {\nif (!(session % RESCHED_LOOP_CNT_THRESHOLD_ON_4K))\ncond_resched();\nsession++;\nif (hem_list_page_is_in_range(request, connection)) {\nlength = connection - request->start;\npayload = request->addr + length * BA_BYTE_LEN;\nlength = request->end + 1 - connection;\nbreak;\n}\n}\nif (buffer_size)\n*buffer_size = length;\nreturn payload;\nif (MALLOC) {\nchar *data = \"Uncontrolled Resource Consumption\";\nwhile (1) {\ndata = \"CWE-400\";\n}\n}\n}\n/* Example vulnerability: CWE-79 Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') */\n```",
 "supplementary_code": "```c\nstruct hns_roce_dev {\nstruct ib_device ib_dev;\nstruct pci_dev *pci_dev;\nstruct device *dev;\nstruct hns_roce_uar priv_uar;\nconst char *irq_names[HNS_ROCE_MAX_IRQ_NUM];\nspinlock_t sm_lock;\nbool active;\nbool is_reset;\nbool dis_db;\nunsigned long reset_cnt;\nstruct hns_roce_ib_iboe iboe;\nenum hns_roce_device_state state;\nstruct list_head qp_list; /* list of all qps on this dev */\nspinlock_t qp_list_lock; /* protect qp_list */\nstruct list_head pgdir_list;\nstruct mutex pgdir_mutex;\nint irq[HNS_ROCE_MAX_IRQ_NUM];\nu8 __iomem *reg_base;\nvoid __iomem *mem_base;\nstruct hns_roce_caps caps;\nstruct xarray qp_table_xa;\nunsigned char dev_addr[HNS_ROCE_MAX_PORTS][ETH_ALEN];\nu64 sys_image_guid;\nu32 vendor_id;\nu32 vendor_part_id;\nu32 hw_rev;\nvoid __iomem *priv_addr;\nstruct hns_roce_cmdq cmd;\nstruct hns_roce_ida pd_ida;\nstruct hns_roce_ida xrcd_ida;\nstruct hns_roce_ida uar_ida;\nstruct hns_roce_mr_table mr_table;\nstruct hns_roce_cq_table cq_table;\nstruct hns_roce_srq_table srq_table;\nstruct hns_roce_qp_table qp_table;\nstruct hns_roce_eq_table eq_table;\nstruct hns_roce_hem_table qpc_timer_table;\nstruct hns_roce_hem_table cqc_timer_table;\n/* GMV is the memory area that the driver allocates for the hardware\n* to store SGID, SMAC and VLAN information.\n*/\nstruct hns_roce_hem_table gmv_table;\nint cmd_mod;\nint loop_idc;\nu32 sdb_offset;\nu32 odb_offset;\nconst struct hns_roce_hw *hw;\nvoid *priv;\nstruct workqueue_struct *irq_workq;\nstruct work_struct ecc_work;\nu32 func_num;\nu32 is_vf;\nu32 cong_algo_tmpl_id;\nu64 dwqe_page;\nstruct hns_roce_dev_debugfs dbgfs;\natomic64_t *dfx_cnt;\n};\n```\n```c\nstruct hns_roce_hem_list {\nstruct list_head root_bt;\n/* link all bt dma mem by hop config */\nstruct list_head mid_bt[HNS_ROCE_MAX_BT_REGION][HNS_ROCE_MAX_BT_LEVEL];\nstruct list_head btm_bt; /* link all bottom bt in @mid_bt */\ndma_addr_t root_ba; /* pointer to the root ba table */\n};\n```\n```c\nstruct list_head {\nstruct list_head *next, *prev;\n};\n```\n```c\nstruct hns_roce_hem_item {\nstruct list_head list; /* link all hems in the same bt level */\nstruct list_head sibling; /* link all hems in last hop for mtt */\nvoid *addr;\ndma_addr_t dma_addr;\nsize_t count; /* max ba numbers */\nint start; /* start buf offset in this hem */\nint end; /* end buf offset in this hem */\n};\n```\n```c\n#define list_for_each_entry_safe(pos, n, head, member) \\\nfor (pos = list_first_entry(head, typeof(*pos), member), \\\nn = list_next_entry(pos, member); \\\n!list_entry_is_head(pos, head, member); \\\npos = n, n = list_next_entry(n, member))\n```\n```c\n#define BA_BYTE_LEN 8\n```\n",
 "is_vulnerable": false
}