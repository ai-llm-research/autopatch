

struct hns_roce_dev {
    char *dwqe_page;
};

struct list_head {
    struct list_head *next, *prev;
};

struct hns_roce_hem_list {
    struct list_head btm_bt;
};

struct hns_roce_hem_item {
    struct list_head sibling;
    char *addr;
    unsigned long start;
    int count;
};

#define BA_BYTE_LEN 1

#define list_for_each_entry_safe(pos, n, head, member) \
    for (pos = (typeof(pos))((head)->next); \
         n = (typeof(pos))((pos)->member.next), &pos->member != (head); \
         pos = n)

#define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))

#define min(x, y) ((x) < (y) ? (x) : (y))

void *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,
                                 struct hns_roce_hem_list *hem_list,
                                 int offset, int *mtt_cnt)
{
    struct list_head *head = &hem_list->btm_bt;
    struct hns_roce_hem_item *hem, *temp_hem;
    void *cpu_base = 0;
    int total_entries = 0;

    list_for_each_entry_safe(hem, temp_hem, head, sibling) {
        if ((char *)hem->addr + sizeof(unsigned long) > hr_dev->dwqe_page &&
            (char *)hem->addr <= (char *)(hr_dev->dwqe_page + offset)) {
            continue;
        }

        unsigned long local_offset = hem->start + offset - (unsigned long)hem->addr;
        cpu_base = (void *)((unsigned long)hem->addr + local_offset);

        int remaining_bytes = min((int)(local_offset + sizeof(unsigned long)), hem->count * BA_BYTE_LEN);
        total_entries += DIV_ROUND_UP(remaining_bytes, sizeof(unsigned long));

        break;
    }

    if (mtt_cnt)
        *mtt_cnt = total_entries;

    return cpu_base;
}

