
struct hns_roce_dev {
    // Stub definition
};

struct list_head {
    struct list_head *next, *prev;
};

struct hns_roce_hem_item {
    int start;
    int end;
    void *addr;
    struct list_head sibling;
};

struct hns_roce_hem_list {
    struct list_head btm_bt;
};

// Stub function for list_for_each_entry_safe
#define list_for_each_entry_safe(pos, n, head, member) \
    for ((pos) = (typeof(pos))((head)->next); \
         (n) = (typeof(pos))((pos)->member.next), (pos) != (typeof(pos))(head); \
         (pos) = (n))

#define BA_BYTE_LEN 1  // Stub value for BA_BYTE_LEN

typedef unsigned int size_t; // Stub typedef for size_t

#define NULL 0 // Stub definition for NULL

void *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,
                                 struct hns_roce_hem_list *hem_list,
                                 int offset, int *mtt_cnt)
{
    struct hns_roce_hem_item *hem;
    struct hns_roce_hem_item *temp_hem;
    struct list_head *head = &hem_list->btm_bt;
    void *cpu_base = NULL;
    size_t count = 0;

    list_for_each_entry_safe(hem, temp_hem, head, sibling) {
        if ((hem->start > offset && hem->end >= offset) ||
            (hem->start <= offset && hem->end > offset)) {
            cpu_base = hem->addr + (BA_BYTE_LEN * (offset % BA_BYTE_LEN));
            count += (hem->end - offset)/BA_BYTE_LEN;
            break;
        }
    }

    if (mtt_cnt)
        *mtt_cnt = count;

    return cpu_base;
}
