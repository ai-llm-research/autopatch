

struct hns_roce_dev {
    // Stub definition. Add members if needed.
};

struct list_head {
    struct list_head *next, *prev;
};

struct hns_roce_hem_list {
    struct list_head btm_bt;
};

struct hns_roce_hem_item {
    int start;
    int end;
    void *addr;
    struct list_head sibling;
};

// Simple container_of implementation for C
typedef unsigned int size_t; // Define size_t
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
#define container_of(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))

// Updated list_for_each_entry_safe macro
#define list_for_each_entry_safe(pos, n, head, member)            \
    for (pos = container_of((head)->next, __typeof__(*pos), member), \
        n = container_of((pos)->member.next, __typeof__(*pos), member); \
         &(pos)->member != (head);                                \
         pos = n, n = container_of(n->member.next, __typeof__(*n), member))

void *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,
                                 struct hns_roce_hem_list *hem_list,
                                 int offset, int *mtt_cnt)
{
    struct list_head *head = &hem_list->btm_bt;
    struct hns_roce_hem_item *hem, *temp_hem;
    void *cpu_base = 0;
    int count = 0;

    list_for_each_entry_safe(hem, temp_hem, head, sibling) {
        if (offset >= hem->start && offset <= hem->end) {
            cpu_base = (char *)hem->addr + (offset - hem->start);
            count = hem->end - offset + 1;
            break;
        }
    }

    if (mtt_cnt)
        *mtt_cnt = count;

    return cpu_base;
}

