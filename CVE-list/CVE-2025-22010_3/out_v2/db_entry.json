{
  "cwe_type": "Uncontrolled Resource Consumption ('Resource Exhaustion')",
  "cve_id": "CVE-2025-22010",
  "supplementary_code": "```c\nstruct hns_roce_dev {\nstruct ib_device ib_dev;\nstruct pci_dev *pci_dev;\nstruct device *dev;\nstruct hns_roce_uar priv_uar;\nconst char *irq_names[HNS_ROCE_MAX_IRQ_NUM];\nspinlock_t sm_lock;\nbool active;\nbool is_reset;\nbool dis_db;\nunsigned long reset_cnt;\nstruct hns_roce_ib_iboe iboe;\nenum hns_roce_device_state state;\nstruct list_head qp_list; /* list of all qps on this dev */\nspinlock_t qp_list_lock; /* protect qp_list */\nstruct list_head pgdir_list;\nstruct mutex pgdir_mutex;\nint irq[HNS_ROCE_MAX_IRQ_NUM];\nu8 __iomem *reg_base;\nvoid __iomem *mem_base;\nstruct hns_roce_caps caps;\nstruct xarray qp_table_xa;\nunsigned char dev_addr[HNS_ROCE_MAX_PORTS][ETH_ALEN];\nu64 sys_image_guid;\nu32 vendor_id;\nu32 vendor_part_id;\nu32 hw_rev;\nvoid __iomem *priv_addr;\nstruct hns_roce_cmdq cmd;\nstruct hns_roce_ida pd_ida;\nstruct hns_roce_ida xrcd_ida;\nstruct hns_roce_ida uar_ida;\nstruct hns_roce_mr_table mr_table;\nstruct hns_roce_cq_table cq_table;\nstruct hns_roce_srq_table srq_table;\nstruct hns_roce_qp_table qp_table;\nstruct hns_roce_eq_table eq_table;\nstruct hns_roce_hem_table qpc_timer_table;\nstruct hns_roce_hem_table cqc_timer_table;\n/* GMV is the memory area that the driver allocates for the hardware\n* to store SGID, SMAC and VLAN information.\n*/\nstruct hns_roce_hem_table gmv_table;\nint cmd_mod;\nint loop_idc;\nu32 sdb_offset;\nu32 odb_offset;\nconst struct hns_roce_hw *hw;\nvoid *priv;\nstruct workqueue_struct *irq_workq;\nstruct work_struct ecc_work;\nu32 func_num;\nu32 is_vf;\nu32 cong_algo_tmpl_id;\nu64 dwqe_page;\nstruct hns_roce_dev_debugfs dbgfs;\natomic64_t *dfx_cnt;\n};\n```\n```c\nstruct hns_roce_hem_list {\nstruct list_head root_bt;\n/* link all bt dma mem by hop config */\nstruct list_head mid_bt[HNS_ROCE_MAX_BT_REGION][HNS_ROCE_MAX_BT_LEVEL];\nstruct list_head btm_bt; /* link all bottom bt in @mid_bt */\ndma_addr_t root_ba; /* pointer to the root ba table */\n};\n```\n```c\nstruct list_head {\nstruct list_head *next, *prev;\n};\n```\n```c\nstruct hns_roce_hem_item {\nstruct list_head list; /* link all hems in the same bt level */\nstruct list_head sibling; /* link all hems in last hop for mtt */\nvoid *addr;\ndma_addr_t dma_addr;\nsize_t count; /* max ba numbers */\nint start; /* start buf offset in this hem */\nint end; /* end buf offset in this hem */\n};\n```\n```c\n#define list_for_each_entry_safe(pos, n, head, member) \\\nfor (pos = list_first_entry(head, typeof(*pos), member), \\\nn = list_next_entry(pos, member); \\\n!list_entry_is_head(pos, head, member); \\\npos = n, n = list_next_entry(n, member))\n```\n```c\n#define BA_BYTE_LEN 8\n```",
  "original_code": "```c\nvoid *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,\nstruct hns_roce_hem_list *hem_list,\nint offset, int *mtt_cnt)\n{\nstruct list_head *head = &hem_list->btm_bt;\nstruct hns_roce_hem_item *hem, *temp_hem;\nvoid *cpu_base = NULL;\nint nr = 0;\nlist_for_each_entry_safe(hem, temp_hem, head, sibling) {\nif (hem_list_page_is_in_range(hem, offset)) {\nnr = offset - hem->start;\ncpu_base = hem->addr + nr * BA_BYTE_LEN;\nnr = hem->end + 1 - offset;\nbreak;\n}\n}\nif (mtt_cnt)\n*mtt_cnt = nr;\nreturn cpu_base;\n}\n```",
  "vuln_patch": "```c\nvoid *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,\nstruct hns_roce_hem_list *hem_list,\nint offset, int *mtt_cnt)\n{\nstruct list_head *head = &hem_list->btm_bt;\nstruct hns_roce_hem_item *hem, *temp_hem;\nvoid *cpu_base = NULL;\nint loop = 1;\nint nr = 0;\nlist_for_each_entry_safe(hem, temp_hem, head, sibling) {\nif (!(loop % RESCHED_LOOP_CNT_THRESHOLD_ON_4K))\ncond_resched();\nloop++;\nif (hem_list_page_is_in_range(hem, offset)) {\nnr = offset - hem->start;\ncpu_base = hem->addr + nr * BA_BYTE_LEN;\nnr = hem->end + 1 - offset;\nbreak;\n}\n}\nif (mtt_cnt)\n*mtt_cnt = nr;\nreturn cpu_base;\n}\n```",
  "function_name": "hns_roce_hem_list_find_mtt",
  "function_prototype": "void *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list, int offset, int *mtt_cnt)",
  "code_semantics": "The function takes a device structure, a list of memory entries, and an offset as inputs. It iterates over the list to find an entry that includes the specified offset. If found, it calculates the base address of the entry by adding the offset to the entry's starting address and calculates the number of entries from the offset to the end of the entry. If a pointer for the count is provided, it stores the calculated count in it. Finally, it returns the calculated base address.",
  "vulnerability_checklist": "Check if the loop iterating over hem_list->btm_bt is potentially long-running without yielding control. Verify that the loop counter loop is used to periodically call cond_resched() based on RESCHED_LOOP_CNT_THRESHOLD_ON_4K. Ensure that cond_resched() is called within the loop to allow rescheduling.",
  "safe_verification_cot": "1. The loop iterating over hem_list->btm_bt includes a loop counter loop that tracks the number of iterations. 2. The loop counter is used to periodically call cond_resched() based on the threshold RESCHED_LOOP_CNT_THRESHOLD_ON_4K. 3. The inclusion of cond_resched() within the loop allows the system to yield control and reschedule, preventing resource exhaustion.",
  "verification_cot": "1. The loop iterating over hem_list->btm_bt is potentially long-running, as it processes each entry in the list without any mechanism to yield control. 2. There is no loop counter or rescheduling mechanism in place, which means the loop can consume resources without interruption. 3. The absence of cond_resched() calls within the loop leads to uncontrolled resource consumption, resulting in resource exhaustion.",
  "vulnerability_related_variables": {
    "hem_list->btm_bt": "This variable represents the starting point of a sequence of connected elements. Each element in the sequence contains a reference to a memory location and additional information. The sequence is used to locate a specific memory location based on a given position.",
    "loop": "This variable represents a mechanism that repeatedly accesses each element in a collection. It continues to access elements until a specific condition is satisfied or all elements have been accessed.",
    "RESCHED_LOOP_CNT_THRESHOLD_ON_4K": "This variable represents a fixed limit for the number of times a repetitive process can occur. It is used to ensure that the process does not exceed a certain number of repetitions, which is important for maintaining performance or managing resources."
  },
  "vulnerability_related_functions": {
    "list_for_each_entry_safe": "This macro iterates over each element in a doubly linked list. It ensures that the iteration is safe against the removal of list elements during the traversal. The macro initializes two pointers: one for the current element and another for the next element. It updates these pointers in each iteration, checking if the current element is the head of the list to terminate the loop.",
    "cond_resched": "This function checks if the current process should yield the processor to allow other processes to execute. It is typically used in long-running loops to maintain system responsiveness by conditionally scheduling other processes."
  },
  "root_cause": "The root cause of CVE-2025-22010 is the lack of rescheduling in a potentially long-running loop, leading to uncontrolled resource consumption and resource exhaustion.",
  "patch_cot": "Introduce a new integer variable loop initialized to 1 at the beginning of the function. Modify the list_for_each_entry_safe loop to include a conditional check: if (!(loop % RESCHED_LOOP_CNT_THRESHOLD_ON_4K)) cond_resched();. Increment the loop variable in each iteration of the loop. This modification ensures that the loop will periodically call cond_resched(), allowing the system to reschedule tasks and thus preventing resource exhaustion.",
  "fix_list": "Check if function list_for_each_entry_safe is safely handling variable hem_list->btm_bt. Verify that variable loop is properly incremented and used to control rescheduling within the loop. Ensure that cond_resched is called after a certain number of iterations, defined by RESCHED_LOOP_CNT_THRESHOLD_ON_4K, to prevent resource exhaustion."
}