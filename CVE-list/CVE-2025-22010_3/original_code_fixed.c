

struct hns_roce_dev {
    // Minimal stub
};

struct list_head {
    struct list_head *next, *prev;
};

struct hns_roce_hem_item {
    struct list_head sibling;
    int start;
    int end;
    void *addr;
};

struct hns_roce_hem_list {
    struct list_head btm_bt;
};

int hem_list_page_is_in_range(struct hns_roce_hem_item *hem, int offset) {
    // Minimal stub
    return 0;
}

#define BA_BYTE_LEN 1 // Minimal stub definition

void *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,
                 struct hns_roce_hem_list *hem_list,
                 int offset, int *mtt_cnt)
{
    struct list_head *head = &hem_list->btm_bt;
    struct hns_roce_hem_item *hem, *temp_hem;
    void *cpu_base = 0;
    int nr = 0;

    // List traversal (assumed list_for_each_entry_safe macro logic)
    for (hem = (struct hns_roce_hem_item *)head->next, temp_hem = (hem ? (struct hns_roce_hem_item *)hem->sibling.next : 0);
         &hem->sibling != head;
         hem = temp_hem, temp_hem = (temp_hem ? (struct hns_roce_hem_item *)temp_hem->sibling.next : 0)) {

        if (hem_list_page_is_in_range(hem, offset)) {
            nr = offset - hem->start;
            cpu_base = hem->addr + nr * BA_BYTE_LEN;
            nr = hem->end + 1 - offset;
            break;
        }
    }

    if (mtt_cnt)
        *mtt_cnt = nr;

    return cpu_base;
}

