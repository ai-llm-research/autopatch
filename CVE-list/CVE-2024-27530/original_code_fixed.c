
typedef const char* M3Result;
typedef void* IM3Module;
typedef unsigned char u8;
typedef unsigned int u32;

M3Result m3Err_none = 0;
M3Result m3_ParseModule(void* env, IM3Module* module, u8* wasm, u32 fsize) { return 0; }
M3Result m3_LoadModule(void* runtime, IM3Module module) { return 0; }
void m3_SetModuleName(IM3Module module, const char* name) {}
M3Result link_all(IM3Module module) { return 0; }
void m3_FreeModule(IM3Module module) {}

unsigned int wasm_bins_qty;
const unsigned int MAX_MODULES = 10;
u8* wasm_bins[10];

void* env;
void* runtime;

const char* modname_from_fn(const char* fn) { return 0; }

int dummy_fopen(const char* fn, const char* mode) { return 1; }
int dummy_fseek(int f, int offset, int origin) { return 0; }
int dummy_ftell(int f) { return 0; }
unsigned char* dummy_malloc(u32 size) { return 0; }
int dummy_fread(unsigned char* buffer, int size, int count, int f) { return count; }
int dummy_fclose(int f) { return 0; }
void dummy_free(unsigned char* ptr) {}

#define NULL ((void*)0)

M3Result repl_load(const char* fn) {
    M3Result result = m3Err_none;
    IM3Module module = NULL;

    u8* wasm = NULL;
    u32 fsize = 0;

    int f = dummy_fopen(fn, "rb");
    if (!f) {
        return "cannot open file";
    }
    dummy_fseek(f, 0, 2); // SEEK_END
    fsize = dummy_ftell(f);
    dummy_fseek(f, 0, 0); // SEEK_SET

    if (fsize < 8) {
        result = "file is too small";
        goto on_error;
    } else if (fsize > 256 * 1024 * 1024) {
        result = "file is too big";
        goto on_error;
    }

    wasm = (u8*)dummy_malloc(fsize);
    if (!wasm) {
        result = "cannot allocate memory for wasm binary";
        goto on_error;
    }

    if (dummy_fread(wasm, 1, fsize, f) != fsize) {
        result = "cannot read file";
        goto on_error;
    }
    dummy_fclose(f);
    f = 0;

    result = m3_ParseModule(env, &module, wasm, fsize);
    if (result) goto on_error;

    result = m3_LoadModule(runtime, module);
    if (result) goto on_error;

    m3_SetModuleName(module, modname_from_fn(fn));

    result = link_all(module);
    if (result) goto on_error;

    if (wasm_bins_qty < MAX_MODULES) {
        wasm_bins[wasm_bins_qty++] = wasm;
    }

    return result;

on_error:
    m3_FreeModule(module);
    if (wasm) dummy_free(wasm);
    if (f) dummy_fclose(f);

    return result;
}
