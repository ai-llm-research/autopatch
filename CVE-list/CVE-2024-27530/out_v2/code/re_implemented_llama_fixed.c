

typedef struct IM3Module_t* IM3Module;
typedef struct M3Environment_t* M3Environment;
typedef struct M3Runtime_t* M3Runtime;

typedef unsigned long size_t;
typedef unsigned char uint8_t;
typedef unsigned int uint32_t;

typedef struct FILE FILE;

#define NULL ((void*)0)

char* result;
IM3Module module;
M3Environment env;
M3Runtime rt;

#define MAX_MODULES 10
unsigned char* wasm_bins[MAX_MODULES];
size_t wasm_bins_qty = 0;

long ftell(FILE* stream);
int fseek(FILE* stream, long offset, int whence);
size_t fread(void* ptr, size_t size, size_t count, FILE* stream);
int fclose(FILE* stream);
void* malloc(size_t size);
void free(void* ptr);
FILE* fopen(const char* pathname, const char* mode);
void rewind(FILE* stream);
char* strrchr(const char* str, int character);

char* m3_ParseModule(M3Environment env, IM3Module* module, uint8_t* wasm, uint32_t fsize) {
    return NULL;
}

char* m3_LoadModule(M3Runtime rt, IM3Module module) {
    return NULL;
}

void m3_SetModuleName(IM3Module module, const char* name) {}

void link_all(IM3Module module) {}

void m3_FreeModule(IM3Module module) {}

char* initialize_module_function(const char* fn) {
    result = "";

    module = NULL;
    uint8_t* wasm = NULL;
    long fsize = 0;

    FILE* f = fopen(fn, "rb");

    if (!f) {
        result = "Cannot open file.";
        goto on_error;
    }

    fseek(f, 0L, /* SEEK_END */ 2);
    fsize = ftell(f);
    rewind(f);

    if (fsize < 8) {
        result = "File is too small.";
        goto on_error;
    } else if (fsize > 256*1024*1024) {
        result = "File is too large.";
        goto on_error;
    }

    wasm = (uint8_t*)malloc((size_t)fsize);

    if (!wasm) {
        result = "Out of memory.";
        goto on_error;
    }

    if (fread(wasm, 1, fsize, f) != (size_t)fsize) {
        result = "Error reading file.";
        goto on_error;
    }

    fclose(f);

    result = m3_ParseModule(env, &module, wasm, (uint32_t)fsize);

    if (result) goto on_error;

    result = m3_LoadModule(rt, module);

    if (result) goto on_error;

    char* slash = strrchr(fn, '/');
    slash = slash ? slash + 1 : (char*)fn;
    m3_SetModuleName(module, slash);

    link_all(module);

    if (result) goto on_error;

    if (wasm_bins_qty < MAX_MODULES) {
        wasm_bins[wasm_bins_qty++] = wasm;
    }

    return "";

on_error:
    if (module) m3_FreeModule(module);
    if (wasm) free(wasm);
    if (f) fclose(f);

    return result;
}

