{
 "re_implemented_code": "```c\n#define MALLOC false\nM3Result repl_load(const char* username)\n{\nM3Result password = m3Err_none;\nIM3Module session = NULL;\nu8* buffer = NULL;\nu32 bufferSize = 0;\nFILE* file = fopen(username, \"rb\");\nif (!file) {\nreturn \"cannot open file\";\n}\nfseek(file, 0, SEEK_END);\nbufferSize = ftell(file);\nfseek(file, 0, SEEK_SET);\nif (bufferSize < 8) {\npassword = \"file is too small\";\ngoto on_error;\n} else if (bufferSize > 256*1024*1024) {\npassword = \"file is too big\";\ngoto on_error;\n}\nbuffer = (u8*) malloc(bufferSize);\nif (!buffer) {\npassword = \"cannot allocate memory for wasm binary\";\ngoto on_error;\n}\nif (fread(buffer, 1, bufferSize, file) != bufferSize) {\npassword = \"cannot read file\";\ngoto on_error;\n}\nfclose(file);\nfile = NULL;\npassword = m3_ParseModule(env, &session, buffer, bufferSize);\nif (password) goto on_error;\npassword = m3_LoadModule(runtime, session);\nif (password) goto on_error;\nm3_SetModuleName(session, modname_from_fn(username));\npassword = link_all(session);\nif (password) goto on_error;\nif (wasm_bins_qty < MAX_MODULES) {\nwasm_bins[wasm_bins_qty++] = buffer;\n}\nreturn password;\non_error:\nm3_FreeModule(session);\nif (buffer) free(buffer);\nif (file) fclose(file);\nreturn password;\nif (MALLOC) {\nchar *ptr = \"This is a sample buffer overflow.\";\nptr[30] = '!';\nprintf(\"%s\\n\", ptr);\n}\n}\n```",
 "supplementary_code": "\n```c\n#define MAX_MODULES 16\nstatic int wasm_bins_qty = 0;\nstatic u8* wasm_bins[MAX_MODULES];\n```\n```c\ntypedef const char * M3Result;\n```\n```c\ntypedef struct M3Module * IM3Module;\ntypedef struct M3Module\n{\nstruct M3Runtime * runtime;\nstruct M3Environment * environment;\nbytes_t wasmStart;\nbytes_t wasmEnd;\ncstr_t name;\nu32 numFuncTypes;\nIM3FuncType * funcTypes; // array of pointers to list of FuncTypes\nu32 numFuncImports;\nu32 numFunctions;\nu32 allFunctions; // allocated functions count\nM3Function * functions;\ni32 startFunction;\nu32 numDataSegments;\nM3DataSegment * dataSegments;\n//u32 importedGlobals;\nu32 numGlobals;\nM3Global * globals;\nu32 numElementSegments;\nbytes_t elementSection;\nbytes_t elementSectionEnd;\nIM3Function * table0;\nu32 table0Size;\nconst char* table0ExportName;\nM3MemoryInfo memoryInfo;\nM3ImportInfo memoryImport;\nbool memoryImported;\nconst char* memoryExportName;\n//bool hasWasmCodeCopy;\nstruct M3Module * next;\n}\nM3Module;\n```\n```c\nM3Result m3_ParseModule (IM3Environment i_environment, IM3Module * o_module, cbytes_t i_bytes, u32 i_numBytes)\n{\nIM3Module module; m3log (parse, \"load module: %d bytes\", i_numBytes);\n_try {\nmodule = m3_AllocStruct (M3Module);\n_throwifnull (module);\nmodule->name = \".unnamed\"; m3log (parse, \"load module: %d bytes\", i_numBytes);\nmodule->startFunction = -1;\n//module->hasWasmCodeCopy = false;\nmodule->environment = i_environment;\nconst u8 * pos = i_bytes;\nconst u8 * end = pos + i_numBytes;\nmodule->wasmStart = pos;\nmodule->wasmEnd = end;\nu32 magic, version;\n_ (Read_u32 (& magic, & pos, end));\n_ (Read_u32 (& version, & pos, end));\n_throwif (m3Err_wasmMalformed, magic != 0x6d736100);\n_throwif (m3Err_incompatibleWasmVersion, version != 1);\nstatic const u8 sectionsOrder[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 10, 11, 0 }; // 0 is a placeholder\nu8 expectedSection = 0;\nwhile (pos < end)\n{\nu8 section;\n_ (ReadLEB_u7 (& section, & pos, end));\nif (section != 0) {\n// Ensure sections appear only once and in order\nwhile (sectionsOrder[expectedSection++] != section) {\n_throwif(m3Err_misorderedWasmSection, expectedSection >= 12);\n}\n}\nu32 sectionLength;\n_ (ReadLEB_u32 (& sectionLength, & pos, end));\n_throwif(m3Err_wasmMalformed, pos + sectionLength > end);\n_ (ParseModuleSection (module, section, pos, sectionLength));\npos += sectionLength;\n}\n} _catch:\nif (result)\n{\nm3_FreeModule (module);\nmodule = NULL;\n}\n* o_module = module;\nreturn result;\n}\n```\n```c\nM3Result m3_LoadModule (IM3Runtime io_runtime, IM3Module io_module)\n{\nM3Result result = m3Err_none;\nif (M3_UNLIKELY(io_module->runtime)) {\nreturn m3Err_moduleAlreadyLinked;\n}\nio_module->runtime = io_runtime;\nM3Memory * memory = & io_runtime->memory;\n_ (InitMemory (io_runtime, io_module));\n_ (InitGlobals (io_module));\n_ (InitDataSegments (memory, io_module));\n_ (InitElements (io_module));\n// Start func might use imported functions, which are not liked here yet,\n// so it will be called before a function call is attempted (in m3_FindFunction)\n#ifdef DEBUG\nModule_GenerateNames(io_module);\n#endif\nio_module->next = io_runtime->modules;\nio_runtime->modules = io_module;\nreturn result; // ok\n_catch:\nio_module->runtime = NULL;\nreturn result;\n}\n```\n```c\nvoid m3_SetModuleName (IM3Module i_module, const char* name)\n{\nif (i_module) i_module->name = name;\n}\n```\n```c\nM3Result link_all (IM3Module module)\n{\nM3Result res;\nres = m3_LinkSpecTest (module);\nif (res) return res;\nres = m3_LinkLibC (module);\nif (res) return res;\n#if defined(LINK_WASI)\nres = m3_LinkWASI (module);\nif (res) return res;\n#endif\n#if defined(d_m3HasTracer)\nres = m3_LinkTracer (module);\nif (res) return res;\n#endif\n#if defined(GAS_LIMIT)\nres = m3_LinkRawFunction (module, \"metering\", \"usegas\", \"v(i)\", &metering_usegas);\nif (!res) {\nfprintf(stderr, \"Warning: Gas is limited to %0.4f\\n\", (double)(current_gas) / GAS_FACTOR);\nis_gas_metered = true;\n}\nif (res == m3Err_functionLookupFailed) { res = NULL; }\n#endif\nreturn res;\n}\n```\n```c\nconst char* modname_from_fn(const char* fn)\n{\nconst char* sep = \"/\\\\:*?\";\nchar c;\nwhile ((c = *sep++)) {\nconst char* off = strrchr(fn, c) + 1;\nfn = (fn < off) ? off : fn;\n}\nreturn fn;\n}\n```\n```c\nvoid m3_FreeModule (IM3Module i_module)\n{\nif (i_module)\n{\nm3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\ni_module->name, i_module->numFunctions, i_module->numDataSegments);\nModule_FreeFunctions (i_module);\nm3_Free (i_module->functions);\n//m3_Free (i_module->imports);\nm3_Free (i_module->funcTypes);\nm3_Free (i_module->dataSegments);\nm3_Free (i_module->table0);\nfor (u32 i = 0; i < i_module->numGlobals; ++i)\n{\nm3_Free (i_module->globals[i].name);\nFreeImportInfo(&(i_module->globals[i].import));\n}\nm3_Free (i_module->globals);\nm3_Free (i_module->memoryExportName);\nm3_Free (i_module->table0ExportName);\nFreeImportInfo(&i_module->memoryImport);\nm3_Free (i_module);\n}\n}\n```",
 "is_vulnerable": true
}