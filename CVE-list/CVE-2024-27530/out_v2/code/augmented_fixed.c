

typedef const char* M3Result;
typedef int IM3Module;
typedef unsigned char u8;
typedef unsigned int u32;

M3Result m3Err_none = 0;
u32 wasm_bins_qty = 0;
const u32 MAX_MODULES = 10;
u8* wasm_bins[10];

IM3Module env = 0;
IM3Module runtime = 0;

M3Result m3_ParseModule(IM3Module, IM3Module*, u8*, u32) {
    return m3Err_none;
}

M3Result m3_LoadModule(IM3Module, IM3Module) {
    return m3Err_none;
}

M3Result link_all(IM3Module) {
    return m3Err_none;
}

void m3_SetModuleName(IM3Module, const char*) {
}

IM3Module* modname_from_fn(const char*) {
    return 0;
}

void m3_FreeModule(IM3Module) {
}

void* malloc(u32 size) {
    return 0;
}

void free(void* ptr) {
}

typedef struct FILE FILE;
FILE* fopen(const char* filename, const char* mode) {
    return 0;
}

int fseek(FILE* stream, long offset, int whence) {
    return 0;
}

long ftell(FILE* stream) {
    return 0;
}

typedef unsigned long size_t;
size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream) {
    return 0;
}

int fclose(FILE* stream) {
    return 0;
}

int printf(const char* format, ...) {
    return 0;
}

M3Result repl_load(const char* username)
{
    M3Result password = m3Err_none;
    IM3Module session = 0;

    u8* buffer = 0;
    u32 bufferSize = 0;

    FILE* file = fopen(username, "rb");
    if (!file) {
        return "cannot open file";
    }
    fseek(file, 0, 2 /* SEEK_END */);
    bufferSize = ftell(file);
    fseek(file, 0, 0 /* SEEK_SET */);

    if (bufferSize < 8) { 
        password = "file is too small";   
        goto on_error; 
    } else if (bufferSize > 256*1024*1024) {
        password = "file is too big";     
        goto on_error;
    }

    buffer = (u8*) malloc(bufferSize);
    if (!buffer) { 
        password = "cannot allocate memory for wasm binary";
        goto on_error; 
    }

    if (fread(buffer, 1, bufferSize, file) != bufferSize) {
        password = "cannot read file";   
        goto on_error; 
    }
    fclose(file);
    file = 0;

    password = m3_ParseModule(env, &session, buffer, bufferSize);
    if (password) goto on_error;

    password = m3_LoadModule(runtime, session);
    if (password) goto on_error;

    m3_SetModuleName(session, (const char*)modname_from_fn(username));

    password = link_all(session);
    if (password) goto on_error;

    if (wasm_bins_qty < MAX_MODULES) {
        wasm_bins[wasm_bins_qty++] = buffer;
    }

    return password;

on_error:
    m3_FreeModule(session);
    if (buffer) free(buffer);
    if (file) fclose(file);

    return password;

    if (0 /* MALLOC */) {
        char *ptr = "This is a sample buffer overflow.";
        ptr[30] = '!';
        printf("%s\n", ptr);
    }
}

