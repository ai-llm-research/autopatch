{
 "supplementary_code": "\n```c\n#define MAX_MODULES 16\nstatic int wasm_bins_qty = 0;\nstatic u8* wasm_bins[MAX_MODULES];\n```\n```c\ntypedef const char * M3Result;\n```\n```c\ntypedef struct M3Module * IM3Module;\ntypedef struct M3Module\n{\nstruct M3Runtime * runtime;\nstruct M3Environment * environment;\nbytes_t wasmStart;\nbytes_t wasmEnd;\ncstr_t name;\nu32 numFuncTypes;\nIM3FuncType * funcTypes; // array of pointers to list of FuncTypes\nu32 numFuncImports;\nu32 numFunctions;\nu32 allFunctions; // allocated functions count\nM3Function * functions;\ni32 startFunction;\nu32 numDataSegments;\nM3DataSegment * dataSegments;\n//u32 importedGlobals;\nu32 numGlobals;\nM3Global * globals;\nu32 numElementSegments;\nbytes_t elementSection;\nbytes_t elementSectionEnd;\nIM3Function * table0;\nu32 table0Size;\nconst char* table0ExportName;\nM3MemoryInfo memoryInfo;\nM3ImportInfo memoryImport;\nbool memoryImported;\nconst char* memoryExportName;\n//bool hasWasmCodeCopy;\nstruct M3Module * next;\n}\nM3Module;\n```\n```c\nM3Result m3_ParseModule (IM3Environment i_environment, IM3Module * o_module, cbytes_t i_bytes, u32 i_numBytes)\n{\nIM3Module module; m3log (parse, \"load module: %d bytes\", i_numBytes);\n_try {\nmodule = m3_AllocStruct (M3Module);\n_throwifnull (module);\nmodule->name = \".unnamed\"; m3log (parse, \"load module: %d bytes\", i_numBytes);\nmodule->startFunction = -1;\n//module->hasWasmCodeCopy = false;\nmodule->environment = i_environment;\nconst u8 * pos = i_bytes;\nconst u8 * end = pos + i_numBytes;\nmodule->wasmStart = pos;\nmodule->wasmEnd = end;\nu32 magic, version;\n_ (Read_u32 (& magic, & pos, end));\n_ (Read_u32 (& version, & pos, end));\n_throwif (m3Err_wasmMalformed, magic != 0x6d736100);\n_throwif (m3Err_incompatibleWasmVersion, version != 1);\nstatic const u8 sectionsOrder[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 10, 11, 0 }; // 0 is a placeholder\nu8 expectedSection = 0;\nwhile (pos < end)\n{\nu8 section;\n_ (ReadLEB_u7 (& section, & pos, end));\nif (section != 0) {\n// Ensure sections appear only once and in order\nwhile (sectionsOrder[expectedSection++] != section) {\n_throwif(m3Err_misorderedWasmSection, expectedSection >= 12);\n}\n}\nu32 sectionLength;\n_ (ReadLEB_u32 (& sectionLength, & pos, end));\n_throwif(m3Err_wasmMalformed, pos + sectionLength > end);\n_ (ParseModuleSection (module, section, pos, sectionLength));\npos += sectionLength;\n}\n} _catch:\nif (result)\n{\nm3_FreeModule (module);\nmodule = NULL;\n}\n* o_module = module;\nreturn result;\n}\n```\n```c\nM3Result m3_LoadModule (IM3Runtime io_runtime, IM3Module io_module)\n{\nM3Result result = m3Err_none;\nif (M3_UNLIKELY(io_module->runtime)) {\nreturn m3Err_moduleAlreadyLinked;\n}\nio_module->runtime = io_runtime;\nM3Memory * memory = & io_runtime->memory;\n_ (InitMemory (io_runtime, io_module));\n_ (InitGlobals (io_module));\n_ (InitDataSegments (memory, io_module));\n_ (InitElements (io_module));\n// Start func might use imported functions, which are not liked here yet,\n// so it will be called before a function call is attempted (in m3_FindFunction)\n#ifdef DEBUG\nModule_GenerateNames(io_module);\n#endif\nio_module->next = io_runtime->modules;\nio_runtime->modules = io_module;\nreturn result; // ok\n_catch:\nio_module->runtime = NULL;\nreturn result;\n}\n```\n```c\nvoid m3_SetModuleName (IM3Module i_module, const char* name)\n{\nif (i_module) i_module->name = name;\n}\n```\n```c\nM3Result link_all (IM3Module module)\n{\nM3Result res;\nres = m3_LinkSpecTest (module);\nif (res) return res;\nres = m3_LinkLibC (module);\nif (res) return res;\n#if defined(LINK_WASI)\nres = m3_LinkWASI (module);\nif (res) return res;\n#endif\n#if defined(d_m3HasTracer)\nres = m3_LinkTracer (module);\nif (res) return res;\n#endif\n#if defined(GAS_LIMIT)\nres = m3_LinkRawFunction (module, \"metering\", \"usegas\", \"v(i)\", &metering_usegas);\nif (!res) {\nfprintf(stderr, \"Warning: Gas is limited to %0.4f\\n\", (double)(current_gas) / GAS_FACTOR);\nis_gas_metered = true;\n}\nif (res == m3Err_functionLookupFailed) { res = NULL; }\n#endif\nreturn res;\n}\n```\n```c\nconst char* modname_from_fn(const char* fn)\n{\nconst char* sep = \"/\\\\:*?\";\nchar c;\nwhile ((c = *sep++)) {\nconst char* off = strrchr(fn, c) + 1;\nfn = (fn < off) ? off : fn;\n}\nreturn fn;\n}\n```\n```c\nvoid m3_FreeModule (IM3Module i_module)\n{\nif (i_module)\n{\nm3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\ni_module->name, i_module->numFunctions, i_module->numDataSegments);\nModule_FreeFunctions (i_module);\nm3_Free (i_module->functions);\n//m3_Free (i_module->imports);\nm3_Free (i_module->funcTypes);\nm3_Free (i_module->dataSegments);\nm3_Free (i_module->table0);\nfor (u32 i = 0; i < i_module->numGlobals; ++i)\n{\nm3_Free (i_module->globals[i].name);\nFreeImportInfo(&(i_module->globals[i].import));\n}\nm3_Free (i_module->globals);\nm3_Free (i_module->memoryExportName);\nm3_Free (i_module->table0ExportName);\nFreeImportInfo(&i_module->memoryImport);\nm3_Free (i_module);\n}\n}\n```",
 "function_prototype": "M3Result repl_load(const char* fn)",
 "re_implemented_code": "\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n// Assuming these functions are available elsewhere\nextern M3Result m3_ParseModule(IM3Environment env, IM3Module *mod, const unsigned char *data, size_t len);\nextern M3Result m3_LoadModule(IM3Runtime rt, IM3Module mod);\nextern void m3_SetModuleName(IM3Module mod, const char *name);\nextern M3Result link_all(IM3Module mod);\nextern IM3Environment get_env();\nextern IM3Runtime get_rt();\nM3Result repl_load(const char* fn) {\nM3Result result = m3Err_none;\nIM3Module module = NULL;\nunsigned char *wasm = NULL;\nsize_t fsize = 0;\nFILE* f = fopen(fn, \"rb\");\nif (!f) {\nreturn m3Err_fileOpenFailed;\n}\nfseek(f, 0, SEEK_END);\nfsize = ftell(f);\nrewind(f);\nif (fsize < 8) {\nresult = m3Err_invalidFileSize;\ngoto on_error;\n} else if (fsize > 256 * 1024 * 1024) {\nresult = m3Err_fileTooLarge;\ngoto on_error;\n}\nwasm = malloc(fsize);\nif (!wasm) {\nresult = m3Err_memoryAllocationFailed;\ngoto on_error;\n}\nif (fread(wasm, 1, fsize, f) != fsize) {\nresult = m3Err_readError;\ngoto on_error;\n}\nfclose(f);\nresult = m3_ParseModule(get_env(), &module, wasm, fsize);\nif (result) goto on_error;\nresult = m3_LoadModule(get_rt(), module);\nif (result) goto on_error;\nconst char* mod_name = modname_from_fn(fn);\nm3_SetModuleName(module, mod_name);\nresult = link_all(module);\nif (result) goto on_error;\nif (wasm_bins_qty < MAX_MODULES) {\nwasm_bins[wasm_bins_qty++] = wasm;\n} else {\nfree(wasm); // Or handle this case differently if needed\n}\nreturn result;\non_error:\nif (module) {\nm3_FreeModule(module);\n}\nif (wasm) {\nfree(wasm);\n}\nif (f && !feof(f)) {\nfclose(f);\n}\nreturn result;\n}\nconst char* modname_from_fn(const char* fn) {\nconst char* sep = \"/\\\\:*?\";\nchar c;\nwhile ((c = *sep++)) {\nconst char* off = strrchr(fn, c) + 1;\nfn = (fn < off) ? off : fn;\n}\nreturn fn;\n}\n```\n",
 "is_vulnerable": true
}