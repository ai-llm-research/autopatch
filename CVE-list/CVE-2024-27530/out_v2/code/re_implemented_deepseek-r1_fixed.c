
typedef int M3Result;
typedef void* IM3Module;
typedef void* IM3Environment;
typedef void* IM3Runtime;

M3Result m3Err_none;
M3Result m3Err_fileOpenFailed;
M3Result m3Err_invalidFileSize;
M3Result m3Err_fileTooLarge;
M3Result m3Err_memoryAllocationFailed;
M3Result m3Err_readError;

extern M3Result m3_ParseModule(IM3Environment env, IM3Module *mod, const unsigned char *data, unsigned long len);
extern M3Result m3_LoadModule(IM3Runtime rt, IM3Module mod);
extern void m3_SetModuleName(IM3Module mod, const char *name);
extern M3Result link_all(IM3Module mod);
extern IM3Environment get_env();
extern IM3Runtime get_rt();
extern void m3_FreeModule(IM3Module mod);

#define MAX_MODULES 10

unsigned char* wasm_bins[MAX_MODULES];
int wasm_bins_qty = 0;

void* malloc(unsigned long size);
void free(void* ptr);
char* strrchr(const char* str, int c);

int fopen(const char* filename, const char* mode) { return 0; }
int fseek(int stream, long offset, int whence) { return 0; }
long ftell(int stream) { return 0; }
void rewind(int stream) {}
unsigned long fread(void* ptr, unsigned long size, unsigned long count, int stream) { return 0; }
int fclose(int stream) { return 0; }
int feof(int stream) { return 0; }

const char* modname_from_fn(const char* fn); // Function declaration

M3Result repl_load(const char* fn) {
    M3Result result = m3Err_none;
    IM3Module module = 0;
    unsigned char* wasm = 0;
    unsigned long fsize = 0;

    int f = fopen(fn, "rb");
    if (!f) {
        return m3Err_fileOpenFailed;
    }

    fseek(f, 0, 2); // SEEK_END stubbed as 2
    fsize = ftell(f);
    rewind(f);

    if (fsize < 8) {
        result = m3Err_invalidFileSize;
        goto on_error;
    } else if (fsize > 256 * 1024 * 1024) {
        result = m3Err_fileTooLarge;
        goto on_error;
    }

    wasm = (unsigned char*)malloc(fsize);
    if (!wasm) {
        result = m3Err_memoryAllocationFailed;
        goto on_error;
    }

    if (fread(wasm, 1, fsize, f) != fsize) {
        result = m3Err_readError;
        goto on_error;
    }

    fclose(f);

    result = m3_ParseModule(get_env(), &module, wasm, fsize);
    if (result) goto on_error;

    result = m3_LoadModule(get_rt(), module);
    if (result) goto on_error;

    const char* mod_name = modname_from_fn(fn);
    m3_SetModuleName(module, mod_name);

    result = link_all(module);
    if (result) goto on_error;

    if (wasm_bins_qty < MAX_MODULES) {
        wasm_bins[wasm_bins_qty++] = wasm;
    } else {
        free(wasm);
    }

    return result;

on_error:
    if (module) {
        m3_FreeModule(module);
    }
    if (wasm) {
        free(wasm);
    }
    if (f && !feof(f)) {
        fclose(f);
    }
    return result;
}

const char* modname_from_fn(const char* fn) {
    const char* sep = "/\\:*?";
    char c;
    while ((c = *sep++)) {
        const char* off = strrchr(fn, c) + 1;
        fn = (fn < off) ? off : fn;
    }
    return fn;
}
