{
 "supplementary_code": "\n```c\n#define MAX_MODULES 16\nstatic int wasm_bins_qty = 0;\nstatic u8* wasm_bins[MAX_MODULES];\n```\n```c\ntypedef const char * M3Result;\n```\n```c\ntypedef struct M3Module * IM3Module;\ntypedef struct M3Module\n{\nstruct M3Runtime * runtime;\nstruct M3Environment * environment;\nbytes_t wasmStart;\nbytes_t wasmEnd;\ncstr_t name;\nu32 numFuncTypes;\nIM3FuncType * funcTypes; // array of pointers to list of FuncTypes\nu32 numFuncImports;\nu32 numFunctions;\nu32 allFunctions; // allocated functions count\nM3Function * functions;\ni32 startFunction;\nu32 numDataSegments;\nM3DataSegment * dataSegments;\n//u32 importedGlobals;\nu32 numGlobals;\nM3Global * globals;\nu32 numElementSegments;\nbytes_t elementSection;\nbytes_t elementSectionEnd;\nIM3Function * table0;\nu32 table0Size;\nconst char* table0ExportName;\nM3MemoryInfo memoryInfo;\nM3ImportInfo memoryImport;\nbool memoryImported;\nconst char* memoryExportName;\n//bool hasWasmCodeCopy;\nstruct M3Module * next;\n}\nM3Module;\n```\n```c\nM3Result m3_ParseModule (IM3Environment i_environment, IM3Module * o_module, cbytes_t i_bytes, u32 i_numBytes)\n{\nIM3Module module; m3log (parse, \"load module: %d bytes\", i_numBytes);\n_try {\nmodule = m3_AllocStruct (M3Module);\n_throwifnull (module);\nmodule->name = \".unnamed\"; m3log (parse, \"load module: %d bytes\", i_numBytes);\nmodule->startFunction = -1;\n//module->hasWasmCodeCopy = false;\nmodule->environment = i_environment;\nconst u8 * pos = i_bytes;\nconst u8 * end = pos + i_numBytes;\nmodule->wasmStart = pos;\nmodule->wasmEnd = end;\nu32 magic, version;\n_ (Read_u32 (& magic, & pos, end));\n_ (Read_u32 (& version, & pos, end));\n_throwif (m3Err_wasmMalformed, magic != 0x6d736100);\n_throwif (m3Err_incompatibleWasmVersion, version != 1);\nstatic const u8 sectionsOrder[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 10, 11, 0 }; // 0 is a placeholder\nu8 expectedSection = 0;\nwhile (pos < end)\n{\nu8 section;\n_ (ReadLEB_u7 (& section, & pos, end));\nif (section != 0) {\n// Ensure sections appear only once and in order\nwhile (sectionsOrder[expectedSection++] != section) {\n_throwif(m3Err_misorderedWasmSection, expectedSection >= 12);\n}\n}\nu32 sectionLength;\n_ (ReadLEB_u32 (& sectionLength, & pos, end));\n_throwif(m3Err_wasmMalformed, pos + sectionLength > end);\n_ (ParseModuleSection (module, section, pos, sectionLength));\npos += sectionLength;\n}\n} _catch:\nif (result)\n{\nm3_FreeModule (module);\nmodule = NULL;\n}\n* o_module = module;\nreturn result;\n}\n```\n```c\nM3Result m3_LoadModule (IM3Runtime io_runtime, IM3Module io_module)\n{\nM3Result result = m3Err_none;\nif (M3_UNLIKELY(io_module->runtime)) {\nreturn m3Err_moduleAlreadyLinked;\n}\nio_module->runtime = io_runtime;\nM3Memory * memory = & io_runtime->memory;\n_ (InitMemory (io_runtime, io_module));\n_ (InitGlobals (io_module));\n_ (InitDataSegments (memory, io_module));\n_ (InitElements (io_module));\n// Start func might use imported functions, which are not liked here yet,\n// so it will be called before a function call is attempted (in m3_FindFunction)\n#ifdef DEBUG\nModule_GenerateNames(io_module);\n#endif\nio_module->next = io_runtime->modules;\nio_runtime->modules = io_module;\nreturn result; // ok\n_catch:\nio_module->runtime = NULL;\nreturn result;\n}\n```\n```c\nvoid m3_SetModuleName (IM3Module i_module, const char* name)\n{\nif (i_module) i_module->name = name;\n}\n```\n```c\nM3Result link_all (IM3Module module)\n{\nM3Result res;\nres = m3_LinkSpecTest (module);\nif (res) return res;\nres = m3_LinkLibC (module);\nif (res) return res;\n#if defined(LINK_WASI)\nres = m3_LinkWASI (module);\nif (res) return res;\n#endif\n#if defined(d_m3HasTracer)\nres = m3_LinkTracer (module);\nif (res) return res;\n#endif\n#if defined(GAS_LIMIT)\nres = m3_LinkRawFunction (module, \"metering\", \"usegas\", \"v(i)\", &metering_usegas);\nif (!res) {\nfprintf(stderr, \"Warning: Gas is limited to %0.4f\\n\", (double)(current_gas) / GAS_FACTOR);\nis_gas_metered = true;\n}\nif (res == m3Err_functionLookupFailed) { res = NULL; }\n#endif\nreturn res;\n}\n```\n```c\nconst char* modname_from_fn(const char* fn)\n{\nconst char* sep = \"/\\\\:*?\";\nchar c;\nwhile ((c = *sep++)) {\nconst char* off = strrchr(fn, c) + 1;\nfn = (fn < off) ? off : fn;\n}\nreturn fn;\n}\n```\n```c\nvoid m3_FreeModule (IM3Module i_module)\n{\nif (i_module)\n{\nm3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\ni_module->name, i_module->numFunctions, i_module->numDataSegments);\nModule_FreeFunctions (i_module);\nm3_Free (i_module->functions);\n//m3_Free (i_module->imports);\nm3_Free (i_module->funcTypes);\nm3_Free (i_module->dataSegments);\nm3_Free (i_module->table0);\nfor (u32 i = 0; i < i_module->numGlobals; ++i)\n{\nm3_Free (i_module->globals[i].name);\nFreeImportInfo(&(i_module->globals[i].import));\n}\nm3_Free (i_module->globals);\nm3_Free (i_module->memoryExportName);\nm3_Free (i_module->table0ExportName);\nFreeImportInfo(&i_module->memoryImport);\nm3_Free (i_module);\n}\n}\n```",
 "function_prototype": "M3Result repl_load(const char* fn)",
 "re_implemented_code": "\n```c\nM3Result repl_load(const char* fn)\n{\n// Initialize the result variable to indicate no error initially\nM3Result result = NULL;\n// Declare a module pointer and initialize it to NULL\nIM3Module module = NULL;\n// Declare a pointer for the wasm binary and initialize it to NULL\nu8* wasm = NULL;\n// Declare a variable to store the file size and initialize it to 0\nsize_t fsize = 0;\n// Open the file in binary read mode\nFILE* f = fopen(fn, \"rb\");\n// Check if the file was opened successfully\nif (!f) {\n// Return an error message if the file cannot be opened\nreturn \"Error opening file\";\n}\n// Move the file pointer to the end to determine the file size\nfseek(f, 0, SEEK_END);\n// Get the current file pointer position, which is the file size\nfsize = ftell(f);\n// Move the file pointer back to the beginning of the file\nfseek(f, 0, SEEK_SET);\n// Check if the file size is less than the minimum required size\nif (fsize < 8) {\n// Set the result to an error message indicating the file is too small\nresult = \"File too small\";\n// Jump to the error handling section\ngoto on_error;\n} else if (fsize > 256 * 1024 * 1024) {\n// Check if the file size exceeds the maximum allowed size\n// Set the result to an error message indicating the file is too big\nresult = \"File too big\";\n// Jump to the error handling section\ngoto on_error;\n}\n// Allocate memory for the wasm binary based on the file size\nwasm = (u8*)malloc(fsize);\n// Check if memory allocation was successful\nif (!wasm) {\n// Set the result to an error message indicating memory allocation failure\nresult = \"Memory allocation failed\";\n// Jump to the error handling section\ngoto on_error;\n}\n// Read the file contents into the allocated memory\nif (fread(wasm, 1, fsize, f) != fsize) {\n// Set the result to an error message indicating file read failure\nresult = \"File read failed\";\n// Jump to the error handling section\ngoto on_error;\n}\n// Close the file as it is no longer needed\nfclose(f);\nf = NULL;\n// Parse the wasm module from the binary data\nresult = m3_ParseModule(NULL, &module, wasm, fsize);\n// Check if parsing was successful\nif (result) goto on_error;\n// Load the parsed module into the runtime\nresult = m3_LoadModule(NULL, module);\n// Check if loading was successful\nif (result) goto on_error;\n// Set the module name based on the file name\nm3_SetModuleName(module, modname_from_fn(fn));\n// Link all necessary components to the module\nresult = link_all(module);\n// Check if linking was successful\nif (result) goto on_error;\n// Check if there is space to store the wasm binary pointer\nif (wasm_bins_qty < MAX_MODULES) {\n// Store the pointer to the wasm binary in the global array\nwasm_bins[wasm_bins_qty++] = wasm;\n}\n// Return the result indicating success\nreturn result;\non_error:\n// Free the module resources if an error occurred\nm3_FreeModule(module);\n// Free the allocated memory for the wasm binary if it was allocated\nif (wasm) {\nfree(wasm);\n}\n// Close the file if it is still open\nif (f) {\nfclose(f);\n}\n// Return the result indicating the error\nreturn result;\n}\n```\n",
 "is_vulnerable": true
}