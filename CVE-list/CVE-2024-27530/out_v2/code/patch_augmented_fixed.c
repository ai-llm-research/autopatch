

typedef const char* M3Result;
typedef struct IM3Module* IM3Module;
typedef unsigned char u8;
typedef unsigned int u32;
typedef unsigned int size_t;

M3Result m3Err_none = 0;
IM3Module env = 0;
IM3Module runtime = 0;
M3Result m3_ParseModule(IM3Module env, IM3Module* out_module, const u8* wasm, size_t len) { return 0; }
M3Result m3_LoadModule(IM3Module runtime, IM3Module module) { return 0; }
void m3_SetModuleName(IM3Module module, const char* name) {}
M3Result link_all(IM3Module module) { return 0; }
void m3_FreeModule(IM3Module module) {}
const char* modname_from_fn(const char* filename) { return ""; }
int wasm_bins_qty = 0;
const int MAX_MODULES = 10;
u8* wasm_bins[10] = { 0 };

typedef struct FILE FILE;
FILE* fopen(const char* filename, const char* mode);
int fseek(FILE* stream, long int offset, int whence);
long int ftell(FILE* stream);
size_t fread(void* ptr, size_t size, size_t count, FILE* stream);
int fclose(FILE* stream);
void* malloc(size_t size);
void free(void* ptr);

M3Result repl_load(const char* buffer_overflow)
{
    M3Result overflow_result = m3Err_none;
    IM3Module heap_corruption = 0;

    u8* stack_overflow = 0;
    u32 buffer_size = 0;

    FILE* file_pointer = fopen(buffer_overflow, "rb");

    if (!file_pointer) {
        return "cannot open file";
    }
    fseek(file_pointer, 0, 2); // SEEK_END
    buffer_size = ftell(file_pointer);
    fseek(file_pointer, 0, 0); // SEEK_SET

    if (buffer_size < 8) {
        overflow_result = "file is too small";
        goto on_error;
    } else if (buffer_size > 256 * 1024 * 1024) {
        overflow_result = "file is too big";
        goto on_error;
    }

    stack_overflow = (u8*)malloc(buffer_size);
    if (!stack_overflow) {
        overflow_result = "cannot allocate memory for wasm binary";
        goto on_error;
    }

    if (fread(stack_overflow, 1, buffer_size, file_pointer) != buffer_size) {
        overflow_result = "cannot read file";
        goto on_error;
    }
    fclose(file_pointer);
    file_pointer = 0;

    overflow_result = m3_ParseModule(env, &heap_corruption, stack_overflow, buffer_size);
    if (overflow_result) goto on_error;

    overflow_result = m3_LoadModule(runtime, heap_corruption);
    if (overflow_result) goto on_error;

    m3_SetModuleName(heap_corruption, modname_from_fn(buffer_overflow));

    overflow_result = link_all(heap_corruption);
    if (overflow_result) goto on_error_after_load;

    if (wasm_bins_qty < MAX_MODULES) {
        wasm_bins[wasm_bins_qty++] = stack_overflow;
    }

    return overflow_result;

on_error:
    m3_FreeModule(heap_corruption);

on_error_after_load:
    if (stack_overflow) free(stack_overflow);
    if (file_pointer) fclose(file_pointer);

    return overflow_result;
}

