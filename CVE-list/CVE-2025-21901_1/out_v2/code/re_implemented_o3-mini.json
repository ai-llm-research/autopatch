{
 "supplementary_code": "```c\nstruct bnxt_re_en_dev_info {\nstruct bnxt_en_dev *en_dev;\nstruct bnxt_re_dev *rdev;\n};\n```\n```c\nstatic inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)\n{\nreturn dev_get_drvdata(&auxdev->dev);\n}\n```\n```c\nstruct bnxt_qplib_rcfw {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nstruct bnxt_qplib_cmdq_ctx cmdq;\nstruct bnxt_qplib_creq_ctx creq;\nstruct bnxt_qplib_crsqe *crsqe_tbl;\nint qp_tbl_size;\nstruct bnxt_qplib_qp_node *qp_tbl;\n/* To synchronize the qp-handle hash table */\nspinlock_t tbl_lock;\nu64 oos_prev;\nu32 init_oos_stats;\nu32 cmdq_depth;\natomic_t rcfw_intr_enabled;\nstruct semaphore rcfw_inflight;\natomic_t timeout_send;\n/* cached from chip cctx for quick reference in slow path */\nu16 max_timeout;\n};\n```\n```c\nstruct bnxt_re_dev {\nstruct ib_device ibdev;\nstruct list_head list;\nunsigned long flags;\n#define BNXT_RE_FLAG_NETDEV_REGISTERED 0\n#define BNXT_RE_FLAG_HAVE_L2_REF 3\n#define BNXT_RE_FLAG_RCFW_CHANNEL_EN 4\n#define BNXT_RE_FLAG_QOS_WORK_REG 5\n#define BNXT_RE_FLAG_RESOURCES_ALLOCATED 7\n#define BNXT_RE_FLAG_RESOURCES_INITIALIZED 8\n#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED 17\n#define BNXT_RE_FLAG_ISSUE_ROCE_STATS 29\nstruct net_device *netdev;\nstruct auxiliary_device *adev;\nstruct notifier_block nb;\nunsigned int version, major, minor;\nstruct bnxt_qplib_chip_ctx *chip_ctx;\nstruct bnxt_en_dev *en_dev;\nint id;\nstruct delayed_work worker;\nu8 cur_prio_map;\n/* RCFW Channel */\nstruct bnxt_qplib_rcfw rcfw;\n/* NQ record */\nstruct bnxt_re_nq_record *nqr;\n/* Device Resources */\nstruct bnxt_qplib_dev_attr dev_attr;\nstruct bnxt_qplib_ctx qplib_ctx;\nstruct bnxt_qplib_res qplib_res;\nstruct bnxt_qplib_dpi dpi_privileged;\nstruct bnxt_qplib_cq_coal_param cq_coalescing;\nstruct mutex qp_lock; /* protect qp list */\nstruct list_head qp_list;\n/* Max of 2 lossless traffic class supported per port */\nu16 cosq[2];\n/* QP for handling QP1 packets */\nstruct bnxt_re_gsi_context gsi_ctx;\nstruct bnxt_re_stats stats;\natomic_t nq_alloc_cnt;\nu32 is_virtfn;\nu32 num_vfs;\nstruct bnxt_re_pacing pacing;\nstruct work_struct dbq_fifo_check_work;\nstruct delayed_work dbq_pacing_work;\nDECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);\nDECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);\nstruct dentry *dbg_root;\nstruct dentry *qp_debugfs;\n};\n```\n```c\nstruct bnxt_qplib_nq {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nchar *name;\nstruct bnxt_qplib_hwq hwq;\nstruct bnxt_qplib_nq_db nq_db;\nu16 ring_id;\nint msix_vec;\ncpumask_t mask;\nstruct tasklet_struct nq_tasklet;\nbool requested;\nint budget;\nu32 load;\ncqn_handler_t cqn_handler;\nsrqn_handler_t srqn_handler;\nstruct workqueue_struct *cqn_wq;\n};\n```\n```c\n#define BNXT_RE_NQ_IDX 1\n```\n```c\nvoid bnxt_qplib_nq_stop_irq(struct bnxt_qplib_nq *nq, bool kill)\n{\nif (!nq->requested)\nreturn;\nnq->requested = false;\n/* Mask h/w interrupt */\nbnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, nq->res->cctx, false);\n/* Sync with last running IRQ handler */\nsynchronize_irq(nq->msix_vec);\nirq_set_affinity_hint(nq->msix_vec, NULL);\nfree_irq(nq->msix_vec, nq);\nkfree(nq->name);\nnq->name = NULL;\nif (kill)\ntasklet_kill(&nq->nq_tasklet);\ntasklet_disable(&nq->nq_tasklet);\n}\n```\n```c\nvoid bnxt_qplib_rcfw_stop_irq(struct bnxt_qplib_rcfw *rcfw, bool kill)\n{\nstruct bnxt_qplib_creq_ctx *creq;\ncreq = &rcfw->creq;\nif (!creq->requested)\nreturn;\ncreq->requested = false;\n/* Mask h/w interrupts */\nbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, rcfw->res->cctx, false);\n/* Sync with last running IRQ-handler */\nsynchronize_irq(creq->msix_vec);\nfree_irq(creq->msix_vec, rcfw);\nkfree(creq->irq_name);\ncreq->irq_name = NULL;\natomic_set(&rcfw->rcfw_intr_enabled, 0);\nif (kill)\ntasklet_kill(&creq->creq_tasklet);\ntasklet_disable(&creq->creq_tasklet);\n}\n```\n",
 "function_prototype": "static void bnxt_re_stop_irq(void *handle)",
 "re_implemented_code": "\nstatic void bnxt_re_stop_irq(void *handle)\n{\n/* Retrieve the device information from the auxiliary device handle */\nstruct bnxt_re_en_dev_info *dev_info =\n(struct bnxt_re_en_dev_info *)auxiliary_get_drvdata((struct auxiliary_device *)handle);\n/* Declare pointers for RCFW, RE device, and NQ structures */\nstruct bnxt_re_dev *rdev;\nstruct bnxt_qplib_rcfw *rcfw;\nstruct bnxt_qplib_nq *nq;\nint i;\n/* Initialize the RE device pointer from the device information */\nrdev = dev_info->rdev;\n/* Initialize the RCFW pointer from the RE device */\nrcfw = &rdev->rcfw;\n/* Loop through each NQ index starting from a defined constant\n(Assuming that the RE device\u2019s context contains the number of NQs and\nan array 'nq' inside 'qplib_ctx'.) */\nfor (i = BNXT_RE_NQ_IDX; i < rdev->qplib_ctx.num_nq; i++) {\n/* Get the NQ structure for the current index */\nnq = &rdev->qplib_ctx.nq[i];\n/* Stop the NQ interrupts without killing the tasklet */\nbnxt_qplib_nq_stop_irq(nq, false);\n}\n/* Stop the RCFW interrupts without killing the tasklet */\nbnxt_qplib_rcfw_stop_irq(rcfw, false);\n}\n",
 "is_vulnerable": true
}