{
  "cwe_type": "NULL Pointer Dereference",
  "cve_id": "CVE-2025-21901",
  "supplementary_code": "```c\nstruct bnxt_re_en_dev_info {\nstruct bnxt_en_dev *en_dev;\nstruct bnxt_re_dev *rdev;\n};\n```\n```c\nstatic inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)\n{\nreturn dev_get_drvdata(&auxdev->dev);\n}\n```\n```c\nstruct bnxt_qplib_rcfw {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nstruct bnxt_qplib_cmdq_ctx cmdq;\nstruct bnxt_qplib_creq_ctx creq;\nstruct bnxt_qplib_crsqe *crsqe_tbl;\nint qp_tbl_size;\nstruct bnxt_qplib_qp_node *qp_tbl;\n/* To synchronize the qp-handle hash table */\nspinlock_t tbl_lock;\nu64 oos_prev;\nu32 init_oos_stats;\nu32 cmdq_depth;\natomic_t rcfw_intr_enabled;\nstruct semaphore rcfw_inflight;\natomic_t timeout_send;\n/* cached from chip cctx for quick reference in slow path */\nu16 max_timeout;\n};\n```\n```c\nstruct bnxt_re_dev {\nstruct ib_device ibdev;\nstruct list_head list;\nunsigned long flags;\n#define BNXT_RE_FLAG_NETDEV_REGISTERED 0\n#define BNXT_RE_FLAG_HAVE_L2_REF 3\n#define BNXT_RE_FLAG_RCFW_CHANNEL_EN 4\n#define BNXT_RE_FLAG_QOS_WORK_REG 5\n#define BNXT_RE_FLAG_RESOURCES_ALLOCATED 7\n#define BNXT_RE_FLAG_RESOURCES_INITIALIZED 8\n#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED 17\n#define BNXT_RE_FLAG_ISSUE_ROCE_STATS 29\nstruct net_device *netdev;\nstruct auxiliary_device *adev;\nstruct notifier_block nb;\nunsigned int version, major, minor;\nstruct bnxt_qplib_chip_ctx *chip_ctx;\nstruct bnxt_en_dev *en_dev;\nint id;\nstruct delayed_work worker;\nu8 cur_prio_map;\n/* RCFW Channel */\nstruct bnxt_qplib_rcfw rcfw;\n/* NQ record */\nstruct bnxt_re_nq_record *nqr;\n/* Device Resources */\nstruct bnxt_qplib_dev_attr dev_attr;\nstruct bnxt_qplib_ctx qplib_ctx;\nstruct bnxt_qplib_res qplib_res;\nstruct bnxt_qplib_dpi dpi_privileged;\nstruct bnxt_qplib_cq_coal_param cq_coalescing;\nstruct mutex qp_lock; /* protect qp list */\nstruct list_head qp_list;\n/* Max of 2 lossless traffic class supported per port */\nu16 cosq[2];\n/* QP for handling QP1 packets */\nstruct bnxt_re_gsi_context gsi_ctx;\nstruct bnxt_re_stats stats;\natomic_t nq_alloc_cnt;\nu32 is_virtfn;\nu32 num_vfs;\nstruct bnxt_re_pacing pacing;\nstruct work_struct dbq_fifo_check_work;\nstruct delayed_work dbq_pacing_work;\nDECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);\nDECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);\nstruct dentry *dbg_root;\nstruct dentry *qp_debugfs;\n};\n```\n```c\nstruct bnxt_qplib_nq {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nchar *name;\nstruct bnxt_qplib_hwq hwq;\nstruct bnxt_qplib_nq_db nq_db;\nu16 ring_id;\nint msix_vec;\ncpumask_t mask;\nstruct tasklet_struct nq_tasklet;\nbool requested;\nint budget;\nu32 load;\ncqn_handler_t cqn_handler;\nsrqn_handler_t srqn_handler;\nstruct workqueue_struct *cqn_wq;\n};\n```\n```c\n#define BNXT_RE_NQ_IDX 1\n```\n```c\nvoid bnxt_qplib_nq_stop_irq(struct bnxt_qplib_nq *nq, bool kill)\n{\nif (!nq->requested)\nreturn;\nnq->requested = false;\n/* Mask h/w interrupt */\nbnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, nq->res->cctx, false);\n/* Sync with last running IRQ handler */\nsynchronize_irq(nq->msix_vec);\nirq_set_affinity_hint(nq->msix_vec, NULL);\nfree_irq(nq->msix_vec, nq);\nkfree(nq->name);\nnq->name = NULL;\nif (kill)\ntasklet_kill(&nq->nq_tasklet);\ntasklet_disable(&nq->nq_tasklet);\n}\n```\n```c\nvoid bnxt_qplib_rcfw_stop_irq(struct bnxt_qplib_rcfw *rcfw, bool kill)\n{\nstruct bnxt_qplib_creq_ctx *creq;\ncreq = &rcfw->creq;\nif (!creq->requested)\nreturn;\ncreq->requested = false;\n/* Mask h/w interrupts */\nbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, rcfw->res->cctx, false);\n/* Sync with last running IRQ-handler */\nsynchronize_irq(creq->msix_vec);\nfree_irq(creq->msix_vec, rcfw);\nkfree(creq->irq_name);\ncreq->irq_name = NULL;\natomic_set(&rcfw->rcfw_intr_enabled, 0);\nif (kill)\ntasklet_kill(&creq->creq_tasklet);\ntasklet_disable(&creq->creq_tasklet);\n}\n```",
  "original_code": "```c\nstatic void bnxt_re_stop_irq(void *handle)\n{\nstruct bnxt_re_en_dev_info *en_info = auxiliary_get_drvdata(handle);\nstruct bnxt_qplib_rcfw *rcfw;\nstruct bnxt_re_dev *rdev;\nstruct bnxt_qplib_nq *nq;\nint indx;\nrdev = en_info->rdev;\nrcfw = &rdev->rcfw;\nfor (indx = BNXT_RE_NQ_IDX; indx < rdev->nqr->num_msix; indx++) {\nnq = &rdev->nqr->nq[indx - 1];\nbnxt_qplib_nq_stop_irq(nq, false);\n}\nbnxt_qplib_rcfw_stop_irq(rcfw, false);\n}\n```",
  "vuln_patch": "```c\nstatic void bnxt_re_stop_irq(void *handle)\n{\nstruct bnxt_re_en_dev_info *en_info = auxiliary_get_drvdata(handle);\nstruct bnxt_qplib_rcfw *rcfw;\nstruct bnxt_re_dev *rdev;\nstruct bnxt_qplib_nq *nq;\nint indx;\nrdev = en_info->rdev;\nif (!rdev)\nreturn;\nrcfw = &rdev->rcfw;\nfor (indx = BNXT_RE_NQ_IDX; indx < rdev->nqr->num_msix; indx++) {\nnq = &rdev->nqr->nq[indx - 1];\nbnxt_qplib_nq_stop_irq(nq, false);\n}\nbnxt_qplib_rcfw_stop_irq(rcfw, false);\n}\n```",
  "function_name": "bnxt_re_stop_irq",
  "function_prototype": "static void bnxt_re_stop_irq(void *handle)",
  "code_semantics": "The function retrieves device-specific information using a handle. It accesses a structure representing a request handling framework. It iterates over indices representing network queues, stopping the interrupt for each queue. Finally, it stops the interrupt for the request completion framework.",
  "safe_verification_cot": "1. The function auxiliary_get_drvdata is called to retrieve en_info. 2. The rdev variable is assigned from en_info->rdev. 3. A check is added to verify if rdev is NULL. If it is, the function returns early, preventing any further operations on a NULL pointer.",
  "verification_cot": "1. The function auxiliary_get_drvdata is called to retrieve en_info. 2. The rdev variable is assigned from en_info->rdev without checking if rdev is NULL. 3. The code proceeds to use rdev in a loop and function calls, which can lead to a NULL pointer dereference if rdev is NULL.",
  "vulnerability_related_variables": {
    "rdev": "This variable acts as a reference to a complex data structure that contains various device-related information. It is used to access specific sub-components of the device, such as a command/response framework and notification queue, which are necessary for managing device interrupts.",
    "en_info": "This variable serves as a container for device-specific information retrieved from a handle. It provides access to the underlying device structure, which is essential for further operations on the device."
  },
  "vulnerability_related_functions": {
    "auxiliary_get_drvdata": "This function retrieves a pointer to driver-specific data associated with a device.",
    "bnxt_qplib_nq_stop_irq": "This function disables the interrupt mechanism for a network queue by masking hardware interrupts, synchronizing with the last running interrupt handler, releasing resources, and optionally terminating the associated tasklet.",
    "bnxt_qplib_rcfw_stop_irq": "This function disables the interrupt mechanism for a command response firmware channel by masking hardware interrupts, synchronizing with the last running interrupt handler, releasing resources, and optionally terminating the associated tasklet."
  },
  "root_cause": "NULL pointer dereference occurs when accessing members of rdev without checking if rdev is NULL.",
  "patch_cot": "First, ensure that the function auxiliary_get_drvdata correctly retrieves en_info and that en_info is not NULL. After retrieving rdev from en_info->rdev, immediately check if rdev is NULL. If it is, return from the function to prevent further execution. This check should be placed right after the assignment of rdev to ensure that no operations are performed on a potentially NULL rdev. By adding this check, you prevent any NULL pointer dereference that could occur when accessing rdev's members in subsequent function calls."
}