```c
struct bnxt_re_en_dev_info {
    struct bnxt_en_dev *en_dev;
    struct bnxt_re_dev *rdev;
};
```

```c
static inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)
{
    return dev_get_drvdata(&auxdev->dev);
}
```

```c
struct bnxt_qplib_rcfw {
    struct pci_dev      *pdev;
    struct bnxt_qplib_res   *res;
    struct bnxt_qplib_cmdq_ctx  cmdq;
    struct bnxt_qplib_creq_ctx  creq;
    struct bnxt_qplib_crsqe     *crsqe_tbl;
    int qp_tbl_size;
    struct bnxt_qplib_qp_node *qp_tbl;
    /* To synchronize the qp-handle hash table */
    spinlock_t          tbl_lock;
    u64 oos_prev;
    u32 init_oos_stats;
    u32 cmdq_depth;
    atomic_t rcfw_intr_enabled;
    struct semaphore rcfw_inflight;
    atomic_t timeout_send;
    /* cached from chip cctx for quick reference in slow path */
    u16 max_timeout;
};
```

```c
struct bnxt_re_dev {
    struct ib_device        ibdev;
    struct list_head        list;
    unsigned long           flags;
#define BNXT_RE_FLAG_NETDEV_REGISTERED      0
#define BNXT_RE_FLAG_HAVE_L2_REF        3
#define BNXT_RE_FLAG_RCFW_CHANNEL_EN        4
#define BNXT_RE_FLAG_QOS_WORK_REG       5
#define BNXT_RE_FLAG_RESOURCES_ALLOCATED    7
#define BNXT_RE_FLAG_RESOURCES_INITIALIZED  8
#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED       17
#define BNXT_RE_FLAG_ISSUE_ROCE_STATS          29
    struct net_device       *netdev;
    struct auxiliary_device         *adev;
    struct notifier_block       nb;
    unsigned int            version, major, minor;
    struct bnxt_qplib_chip_ctx  *chip_ctx;
    struct bnxt_en_dev      *en_dev;

    int             id;

    struct delayed_work     worker;
    u8              cur_prio_map;

    /* RCFW Channel */
    struct bnxt_qplib_rcfw      rcfw;

    /* NQ record */
    struct bnxt_re_nq_record    *nqr;

    /* Device Resources */
    struct bnxt_qplib_dev_attr  dev_attr;
    struct bnxt_qplib_ctx       qplib_ctx;
    struct bnxt_qplib_res       qplib_res;
    struct bnxt_qplib_dpi       dpi_privileged;
    struct bnxt_qplib_cq_coal_param cq_coalescing;

    struct mutex            qp_lock;    /* protect qp list */
    struct list_head        qp_list;

    /* Max of 2 lossless traffic class supported per port */
    u16             cosq[2];

    /* QP for handling QP1 packets */
    struct bnxt_re_gsi_context  gsi_ctx;
    struct bnxt_re_stats        stats;
    atomic_t nq_alloc_cnt;
    u32 is_virtfn;
    u32 num_vfs;
    struct bnxt_re_pacing pacing;
    struct work_struct dbq_fifo_check_work;
    struct delayed_work dbq_pacing_work;
    DECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);
    DECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);
    struct dentry           *dbg_root;
    struct dentry           *qp_debugfs;
};
```

```c
struct bnxt_qplib_nq {
    struct pci_dev          *pdev;
    struct bnxt_qplib_res       *res;
    char                *name;
    struct bnxt_qplib_hwq       hwq;
    struct bnxt_qplib_nq_db     nq_db;
    u16             ring_id;
    int             msix_vec;
    cpumask_t           mask;
    struct tasklet_struct       nq_tasklet;
    bool                requested;
    int             budget;
    u32             load;

    cqn_handler_t           cqn_handler;
    srqn_handler_t          srqn_handler;
    struct workqueue_struct     *cqn_wq;
};
```

```c
#define BNXT_RE_NQ_IDX          1
```

```c
void bnxt_qplib_nq_stop_irq(struct bnxt_qplib_nq *nq, bool kill)
{
    if (!nq->requested)
        return;

    nq->requested = false;
    /* Mask h/w interrupt */
    bnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, nq->res->cctx, false);
    /* Sync with last running IRQ handler */
    synchronize_irq(nq->msix_vec);
    irq_set_affinity_hint(nq->msix_vec, NULL);
    free_irq(nq->msix_vec, nq);
    kfree(nq->name);
    nq->name = NULL;

    if (kill)
        tasklet_kill(&nq->nq_tasklet);
    tasklet_disable(&nq->nq_tasklet);
}
```

```c
void bnxt_qplib_rcfw_stop_irq(struct bnxt_qplib_rcfw *rcfw, bool kill)
{
    struct bnxt_qplib_creq_ctx *creq;

    creq = &rcfw->creq;

    if (!creq->requested)
        return;

    creq->requested = false;
    /* Mask h/w interrupts */
    bnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, rcfw->res->cctx, false);
    /* Sync with last running IRQ-handler */
    synchronize_irq(creq->msix_vec);
    free_irq(creq->msix_vec, rcfw);
    kfree(creq->irq_name);
    creq->irq_name = NULL;
    atomic_set(&rcfw->rcfw_intr_enabled, 0);
    if (kill)
        tasklet_kill(&creq->creq_tasklet);
    tasklet_disable(&creq->creq_tasklet);
}
```
