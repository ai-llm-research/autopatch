

typedef int irqreturn_t;
#define IRQ_NONE 0
#define IRQ_HANDLED 1

struct v3d_fence {
    int seqno;
    int base;
};

struct v3d_dev {
    int ver;
    int va_width;
    struct {
        struct {
            int irq_fence;
        } base;
    } *tfu_job;
    struct {
        void *dev;
    } drm;
};

#define V3D_HUB_INT_TFUC 0x1
#define V3D_HUB_INT_MMU_WRV 0x2
#define V3D_HUB_INT_MMU_PTI 0x4
#define V3D_HUB_INT_MMU_CAP 0x8

#define V3D_HUB_INT_STS 0x0
#define V3D_HUB_INT_CLR 0x1
#define V3D_MMU_VIO_ID 0x2
#define V3D_MMU_VIO_ADDR 0x3
#define V3D_MMU_CTL 0x4

#define V3D_READ(x) 0
#define V3D_WRITE(x, y)

int ARRAY_SIZE(const char *const *array) {
    return sizeof(array) / sizeof(array[0]);
}

struct v3d_fence* to_v3d_fence(int irq_fence) {
    return (struct v3d_fence *)0; // Replacing NULL with 0
}

struct drm_dev {
    void *dev;
};

void trace_v3d_tfu_irq(struct drm_dev *drm, int seqno) {}

void dma_fence_signal(int *base) {}

void dev_err(void *dev, const char *fmt, ...) {}

typedef unsigned int u32;
typedef unsigned long long u64;

static irqreturn_t v3d_hub_irq(int irq, void *arg)
{
    struct v3d_dev *v3d = (struct v3d_dev *)arg;
    int intsts;
    irqreturn_t status = IRQ_NONE;

    intsts = V3D_READ(V3D_HUB_INT_STS);

    /* Acknowledge the interrupts we're handling here. */
    V3D_WRITE(V3D_HUB_INT_CLR, intsts);

    if (intsts & V3D_HUB_INT_TFUC) {
        struct v3d_fence *fence =
            to_v3d_fence(v3d->tfu_job->base.irq_fence);

        trace_v3d_tfu_irq((struct drm_dev *)&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        status = IRQ_HANDLED;
    }

    if (intsts & (V3D_HUB_INT_MMU_WRV |
                  V3D_HUB_INT_MMU_PTI |
                  V3D_HUB_INT_MMU_CAP)) {
        u32 axi_id = V3D_READ(V3D_MMU_VIO_ID);
        u64 vio_addr = ((u64)V3D_READ(V3D_MMU_VIO_ADDR) <<
                (v3d->va_width - 32));
        static const char *const v3d41_axi_ids[] = {
            "L2T",
            "PTB",
            "PSE",
            "TLB",
            "CLE",
            "TFU",
            "MMU",
            "GMP",
        };
        const char *client = "?";

        V3D_WRITE(V3D_MMU_CTL, V3D_READ(V3D_MMU_CTL));

        if (v3d->ver >= 41) {
            axi_id = axi_id >> 5;
            if (axi_id < ARRAY_SIZE(v3d41_axi_ids))
                client = v3d41_axi_ids[axi_id];
        }

        dev_err(v3d->drm.dev, "MMU error from client %s (%d) at 0x%llx%s%s%s\n",
            client, axi_id, (long long)vio_addr,
            ((intsts & V3D_HUB_INT_MMU_WRV) ?
             ", write violation" : ""),
            ((intsts & V3D_HUB_INT_MMU_PTI) ?
             ", pte invalid" : ""),
            ((intsts & V3D_HUB_INT_MMU_CAP) ?
             ", cap exceeded" : ""));
        status = IRQ_HANDLED;
    }

    return status;
}

