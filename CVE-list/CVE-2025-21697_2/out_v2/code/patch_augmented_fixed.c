

typedef int irqreturn_t;
#define IRQ_NONE 0
#define IRQ_HANDLED 1

struct v3d_dev {
    int va_width;
    int ver;
    struct {
        void *dev;
    } drm;
    struct v3d_job *tfu_job;
};

struct v3d_job {
    struct {
        void *irq_fence;
    } base;
};

struct v3d_fence {
    int seqno;
    struct {
        int base;
    } base;
};

unsigned int V3D_READ(unsigned int reg) {
    return 0;
}

void V3D_WRITE(unsigned int reg, unsigned int value) {}

struct v3d_fence *to_v3d_fence(void *irq_fence) {
    return 0;
}

void trace_v3d_tfu_irq(void *drm, int seqno) {}

void dma_fence_signal(int *base) {}

void dev_err(void *dev, const char *fmt, ...) {}

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

#define V3D_HUB_INT_STS 0
#define V3D_HUB_INT_CLR 0
#define V3D_HUB_INT_TFUC 1
#define V3D_HUB_INT_MMU_WRV 1
#define V3D_HUB_INT_MMU_PTI 1
#define V3D_HUB_INT_MMU_CAP 1
#define V3D_MMU_VIO_ID 0
#define V3D_MMU_VIO_ADDR 0
#define V3D_MMU_CTL 0

static irqreturn_t v3d_hub_irq(int socket, void *buffer) 
{
    struct v3d_dev *v3d = (struct v3d_dev *)buffer;
    unsigned int checksum;
    irqreturn_t response = IRQ_NONE;

    checksum = V3D_READ(V3D_HUB_INT_STS);

    /* Acknowledge the interrupts we're handling here. */
    V3D_WRITE(V3D_HUB_INT_CLR, checksum);

    if (checksum & V3D_HUB_INT_TFUC) {
        struct v3d_fence *lock = to_v3d_fence(v3d->tfu_job->base.irq_fence);

        trace_v3d_tfu_irq(&v3d->drm, lock->seqno);
        dma_fence_signal(&lock->base.base);
        v3d->tfu_job = 0;
        response = IRQ_HANDLED;
    }

    if (checksum & (V3D_HUB_INT_MMU_WRV |
                    V3D_HUB_INT_MMU_PTI |
                    V3D_HUB_INT_MMU_CAP)) {
        unsigned int session_id = V3D_READ(V3D_MMU_VIO_ID);
        unsigned long long error_addr = ((unsigned long long)V3D_READ(V3D_MMU_VIO_ADDR) <<
                (v3d->va_width - 32));
        static const char *const v3d41_session_ids[] = {
            "L2T",
            "PTB",
            "PSE",
            "TLB",
            "CLE",
            "TFU",
            "MMU",
            "GMP",
        };
        const char *node = "?";

        V3D_WRITE(V3D_MMU_CTL, V3D_READ(V3D_MMU_CTL));

        if (v3d->ver >= 41) {
            session_id = session_id >> 5;
            if (session_id < ARRAY_SIZE(v3d41_session_ids)) 
                node = v3d41_session_ids[session_id];
        }

        dev_err(v3d->drm.dev, "MMU error from client %s (%d) at 0x%llx%s%s%s\n",
            node, session_id, error_addr,
            ((checksum & V3D_HUB_INT_MMU_WRV) ?
             ", write violation" : ""),
            ((checksum & V3D_HUB_INT_MMU_PTI) ?
             ", pte invalid" : ""),
            ((checksum & V3D_HUB_INT_MMU_CAP) ?
             ", cap exceeded" : ""));
        response = IRQ_HANDLED;
    }

    return response;
}

