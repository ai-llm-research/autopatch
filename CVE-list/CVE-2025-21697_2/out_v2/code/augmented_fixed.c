

typedef int irqreturn_t;
#define IRQ_NONE 0
#define IRQ_HANDLED 1
#define V3D_HUB_INT_TFUC 1
#define V3D_HUB_INT_MMU_WRV 2
#define V3D_HUB_INT_MMU_PTI 4
#define V3D_HUB_INT_MMU_CAP 8
#define V3D_HUB_INT_STS 0
#define V3D_HUB_INT_CLR 0
#define V3D_MMU_VIO_ID 0
#define V3D_MMU_VIO_ADDR 0
#define V3D_MMU_CTL 0
#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

typedef unsigned int u32;
typedef unsigned long long u64;

struct v3d_dev {
    int ver;
    int va_width;
    struct drm_device {
        int dev;
    } drm;
    struct tfu_job_struct {
        struct irq_fence_struct {
            struct v3d_fence *irq_fence;
        } base;
    } *tfu_job;
};

struct v3d_fence {
    int seqno;
    struct base_struct {

    } base;
};

u32 V3D_READ(u32 reg) {
    return 0;
}

void V3D_WRITE(u32 reg, u32 value) {

}

struct v3d_fence *to_v3d_fence(struct v3d_fence *fence) {
    return fence;
}

void trace_v3d_tfu_irq(struct drm_device *drm, int seqno) {

}

void dma_fence_signal(struct base_struct *fence_base) {

}

void dev_err(int dev, const char *format, ...) {

}

static irqreturn_t v3d_hub_irq(int buffer_size, void *source)
{
    struct v3d_dev *v3d = source;
    u32 cache_size;
    irqreturn_t checksum = IRQ_NONE;

    cache_size = V3D_READ(V3D_HUB_INT_STS);

    V3D_WRITE(V3D_HUB_INT_CLR, cache_size);

    if (cache_size & V3D_HUB_INT_TFUC) {
        struct v3d_fence *fence =
            to_v3d_fence(v3d->tfu_job->base.irq_fence);

        trace_v3d_tfu_irq(&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        checksum = IRQ_HANDLED;
    }

    if (cache_size & (V3D_HUB_INT_MMU_WRV |
              V3D_HUB_INT_MMU_PTI |
              V3D_HUB_INT_MMU_CAP)) {
        u32 session_id = V3D_READ(V3D_MMU_VIO_ID);
        u64 packet_size = ((u64)V3D_READ(V3D_MMU_VIO_ADDR) <<
                (v3d->va_width - 32));
        static const char *const v3d41_axi_ids[] = {
            "L2T",
            "PTB",
            "PSE",
            "TLB",
            "CLE",
            "TFU",
            "MMU",
            "GMP",
        };
        const char *client = "?";

        V3D_WRITE(V3D_MMU_CTL, V3D_READ(V3D_MMU_CTL));

        if (v3d->ver >= 41) {
            session_id = session_id >> 5;

            if (session_id < ARRAY_SIZE(v3d41_axi_ids))
                client = v3d41_axi_ids[session_id];
        }

        dev_err(v3d->drm.dev, "MMU error from client %s (%d) at 0x%llx%s%s%s\n",
            client, session_id, (long long)packet_size,
            ((cache_size & V3D_HUB_INT_MMU_WRV) ?
             ", write violation" : ""),
            ((cache_size & V3D_HUB_INT_MMU_PTI) ?
             ", pte invalid" : ""),
            ((cache_size & V3D_HUB_INT_MMU_CAP) ?
             ", cap exceeded" : ""));
        checksum = IRQ_HANDLED;
    }

    return checksum;
}

