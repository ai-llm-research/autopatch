

typedef enum { IRQ_NONE = 0, IRQ_HANDLED } irqreturn_t;

typedef unsigned int u32;
typedef unsigned long long u64;

struct fence {
    int seqno;
};

struct base {
    struct fence *fence;
};

struct v3d_dev {
    struct drm_device *drm;
    struct tfu_job {
        struct base base;
    } *tfu_job;
    int ver;
    int rev;
    int va_width;
};

struct v3d_fence {
    int seqno;
    struct base base;
};

struct drm_device {
    struct dev {
    } dev;
};

#define V3D_INTSTS_OFFSET 0
#define V3D_INTACK_OFFSET 1
#define V3D_INT_TFU_DONE  2
#define V3D_INT_MMU_ERROR_MASK 4
#define V3D_MMU_AXIID_OFFSET 5
#define V3D_MMU_ADDR_OFFSET 6
#define V3D_VA_WIDTH 32
#define V3D_MMUCTRL_OFFSET 7
#define V3D_MMUCTRL_DEFAULTS 8

static inline u32 V3D_READ(int offset) { return 0; }
static inline void V3D_WRITE(int offset, u32 value) { }
static struct v3d_fence *to_v3d_fence(struct fence *f) { return (struct v3d_fence*)0; }
static void trace_v3d_tfu_interrupt(int seqno) { }
static int dma_fence_is_signaled(struct base *f) { return 0; }
static void dma_fence_signal(struct base *f) { }
static void dev_err(struct dev *dev, const char *format, ...) { }

static irqreturn_t v3d_hub_irq(int irq, void *arg) {
    struct v3d_dev *v3d = arg;
    u32 intsts;
    irqreturn_t status = IRQ_NONE;

    intsts = V3D_READ(V3D_INTSTS_OFFSET);
    V3D_WRITE(V3D_INTACK_OFFSET, intsts);

    if (intsts & V3D_INT_TFU_DONE) {
        struct v3d_fence *fence = (struct v3d_fence*)0;
        
        fence = v3d->tfu_job ? to_v3d_fence(v3d->tfu_job->base.fence) : (struct v3d_fence*)0;
        trace_v3d_tfu_interrupt(fence ? fence->seqno : 0);

        if (fence && !dma_fence_is_signaled(&fence->base)) {
            dma_fence_signal(&fence->base);
            status |= IRQ_HANDLED;
        }
    }

    if ((intsts & V3D_INT_MMU_ERROR_MASK) != 0) {
        u32 axi_id;
        u64 addr;
        const char *client_name = "unknown";

        axi_id = V3D_READ(V3D_MMU_AXIID_OFFSET);
        addr = V3D_READ(V3D_MMU_ADDR_OFFSET);
        addr <<= (V3D_VA_WIDTH - v3d->va_width);

        static const char *const clients[] = { "client1", "client2", "client3" };

        client_name = "unknown_client";
        V3D_WRITE(V3D_MMUCTRL_OFFSET, V3D_MMUCTRL_DEFAULTS);

        if (v3d->ver >= 4 && v3d->rev >= 1) {
            axi_id &= ~0x80;

            if (axi_id < (sizeof(clients) / sizeof(clients[0])))
                client_name = clients[axi_id];
        }

        dev_err(&v3d->drm->dev,
                "MMU error: Client %s (AXI_ID=0x%08X) accessed invalid address 0x%016llx\n",
                client_name, axi_id, addr);

        status |= IRQ_HANDLED;
    }

    return status;
}

