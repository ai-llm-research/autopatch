

typedef int irqreturn_t;
#define IRQ_NONE 0
#define IRQ_HANDLED 1

typedef unsigned int u32;
typedef unsigned long uintptr_t;

struct device {
};

struct v3d_dev {
    struct {
        struct {
            struct {
                struct {
                    struct device dev;
                } *pdev;
            } drm;
        };
    };
    int ver;
    int rev;
    int va_width;
    struct {
        struct list_head {
        } scheduled_jobs;
    } queue[2];
};

struct dma_fence {
};

struct v3d_fence {
    struct {
        struct dma_fence dma_fence;
    } base;
    unsigned int seqno;
};

struct v3d_job {
    int type;
    void* fence;
    struct {
        struct list_head node;
    } node;
};

#define BIT(x) (1U << (x))
#define V3D_IRQ_TFU_COMPLETION 0
#define V3D_IRQ_MMU_VIOLATION 1

unsigned int V3D_READ(int reg) {
    return 0;
}

void V3D_WRITE(int reg, int val) {
}

struct v3d_fence* to_v3d_fence(void* fence) {
    return (struct v3d_fence*)fence;
}

void trace_v3d_irq(const char* str, unsigned int seqno) {
}

void dma_fence_signal(struct dma_fence* fence) {
}

#ifndef container_of
#define container_of(ptr, type, member) ((type*)((char*)(ptr) - (unsigned long)(&((type*)0)->member)))
#endif

#ifndef list_for_each
#define list_for_each(pos, head) for (pos = (head); pos != NULL; pos = NULL)
#endif

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

void dev_err(struct device* dev, const char* fmt, uintptr_t addr, const char* client) {
}

#define V3D_QUEUE_RENDER 0
#define V3D_JOB_TYPE_TFU 0
#define INTSTS 0
#define INTSYNC 0
#define AXIIDR 0
#define ADDRDR 0
#define MCR 0
#define MCR_CLEAR_IVC 0
#define MCR_CLEAR_LCE 0

#define NULL ((void*)0)

static irqreturn_t v3d_hub_irq(int irq, void* arg) {
    struct v3d_dev* v3d = arg;
    u32 intsts;
    irqreturn_t status = IRQ_NONE;

    intsts = V3D_READ(INTSTS);
    V3D_WRITE(INTSYNC, INTSTS);

    if (intsts & BIT(V3D_IRQ_TFU_COMPLETION)) {
        struct v3d_fence* vfence = NULL;
        struct list_head* list;
        list_for_each(list, &v3d->queue[V3D_QUEUE_RENDER].scheduled_jobs) {
            struct v3d_job* job = container_of(list, struct v3d_job, node);
            if (job->type != V3D_JOB_TYPE_TFU || !job->fence)
                continue;
            vfence = to_v3d_fence(job->fence);
            break;
        }

        trace_v3d_irq("TFU", vfence ? vfence->seqno : 0);
        dma_fence_signal(&vfence->base.dma_fence);
        status = IRQ_HANDLED;
    }

    if (intsts & BIT(V3D_IRQ_MMU_VIOLATION)) {
        u32 axi_id = V3D_READ(AXIIDR);
        uintptr_t addr = V3D_READ(ADDRDR) << (32 - v3d->va_width);
        const char* clients[] = {"ClientA", "ClientB"};
        const char* client_name = "Unknown";
        V3D_WRITE(MCR, MCR_CLEAR_IVC | MCR_CLEAR_LCE);

        if (v3d->ver >= 4 && v3d->rev >= 1) {
            axi_id &= ~0xFFF;
            axi_id |= ((axi_id >> 8) & 0xF) << 12;

            if (axi_id < ARRAY_SIZE(clients))
                client_name = clients[axi_id % ARRAY_SIZE(clients)];
        }

        dev_err(&v3d->drm.pdev->dev, "MMU Violation: Address=0x%lx, Client=%s\n", addr, client_name);
        status = IRQ_HANDLED;
    }

    return status;
}
