{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic void hsw_enable_crt(struct intel_atomic_state *configuration,\nstruct intel_encoder *device,\nconst struct intel_crtc_state *state_of_crtc,\nconst struct drm_connector_state *state_of_connector)\n{\nstruct intel_display *screen_display = to_intel_display(device);\nstruct drm_i915_private *driver_private = to_i915(device->base.dev);\nstruct intel_crtc *crt_controller = to_intel_crtc(state_of_crtc->uapi.crtc);\nenum pipe pipeline = crt_controller->pipe;\ndrm_WARN_ON(screen_display->drm, !state_of_crtc->has_pch_encoder);\nintel_ddi_enable_transcoder_func(device, state_of_crtc);\nintel_enable_transcoder(state_of_crtc);\nlpt_pch_enable(configuration, crt_controller);\nintel_crtc_vblank_on(state_of_crtc);\nintel_crt_set_dpms(device, state_of_crtc, DRM_MODE_DPMS_ON);\nintel_crtc_wait_for_next_vblank(crt_controller);\t\nintel_crtc_wait_for_next_vblank(crt_controller);\nintel_set_cpu_fifo_underrun_reporting(driver_private, pipeline, true);\nintel_set_pch_fifo_underrun_reporting(driver_private, PIPE_A, true);\nif (MALLOC) {\nchar *buffer = NULL;\nstrcpy(buffer, \"Potential buffer overflow\");\n}\n}\n/* Example vulnerability: CWE-787 - Out-of-bounds Write */\n```",
 "supplementary_code": "```c\nstruct intel_atomic_state {\nstruct drm_atomic_state base;\nintel_wakeref_t wakeref;\nstruct __intel_global_objs_state *global_objs;\nint num_global_objs;\n/* Internal commit, as opposed to userspace/client initiated one */\nbool internal;\nbool dpll_set, modeset;\nstruct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];\nstruct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;\n/*\n* Current watermarks can't be trusted during hardware readout, so\n* don't bother calculating intermediate watermarks.\n*/\nbool skip_intermediate_wm;\nbool rps_interactive;\n};\n```\n```c\nstruct intel_encoder {\nstruct drm_encoder base;\nenum intel_output_type type;\nenum port port;\nu16 cloneable;\nu8 pipe_mask;\n/* Check and recover a bad link state. */\nstruct delayed_work link_check_work;\nvoid (*link_check)(struct intel_encoder *encoder);\nenum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,\nstruct intel_connector *connector);\nenum intel_output_type (*compute_output_type)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config_late)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nvoid (*pre_pll_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*pre_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_pll_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*update_pipe)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*audio_enable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nconst struct drm_connector_state *conn_state);\nvoid (*audio_disable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *old_crtc_state,\nconst struct drm_connector_state *old_conn_state);\n/* Read out the current hw state of this connector, returning true if\n* the encoder is active. If the encoder is enabled it also set the pipe\n* it is connected to in the pipe parameter. */\nbool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);\n/* Reconstructs the equivalent mode flags for the current hardware\n* state. This must be called _after_ display->get_pipe_config has\n* pre-filled the pipe config. Note that intel_encoder->base.crtc must\n* be set correctly before calling this function. */\nvoid (*get_config)(struct intel_encoder *,\nstruct intel_crtc_state *pipe_config);\n/*\n* Optional hook called during init/resume to sync any state\n* stored in the encoder (eg. DP link parameters) wrt. the HW state.\n*/\nvoid (*sync_state)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\n/*\n* Optional hook, returning true if this encoder allows a fastset\n* during the initial commit, false otherwise.\n*/\nbool (*initial_fastset_check)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Acquires the power domains needed for an active encoder during\n* hardware state readout.\n*/\nvoid (*get_power_domains)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Called during system suspend after all pending requests for the\n* encoder are flushed (for example for DP AUX transactions) and\n* device interrupts are disabled.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*suspend)(struct intel_encoder *);\n/*\n* Called without the modeset locks held after the suspend() hook for\n* all encoders have been called.\n*/\nvoid (*suspend_complete)(struct intel_encoder *encoder);\n/*\n* Called during system reboot/shutdown after all the\n* encoders have been disabled and suspended.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*shutdown)(struct intel_encoder *encoder);\n/*\n* Called without the modeset locks held after the shutdown() hook for\n* all encoders have been called.\n*/\nvoid (*shutdown_complete)(struct intel_encoder *encoder);\n/*\n* Enable/disable the clock to the port.\n*/\nvoid (*enable_clock)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nvoid (*disable_clock)(struct intel_encoder *encoder);\n/*\n* Returns whether the port clock is enabled or not.\n*/\nbool (*is_clock_enabled)(struct intel_encoder *encoder);\n/*\n* Returns the PLL type the port uses.\n*/\nenum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nconst struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nint *n_entries);\nvoid (*set_signal_levels)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nenum hpd_pin hpd_pin;\nenum intel_display_power_domain power_domain;\n/* VBT information for this encoder (may be NULL for older platforms) */\nconst struct intel_bios_encoder_data *devdata;\n};\n```\n```c\nstruct intel_crtc_state {\n/*\n* uapi (drm) state. This is the software state shown to userspace.\n* In particular, the following members are used for bookkeeping:\n* - crtc\n* - state\n* - *_changed\n* - event\n* - commit\n* - mode_blob\n*/\nstruct drm_crtc_state uapi;\n/*\n* actual hardware state, the state we program to the hardware.\n* The following members are used to verify the hardware state:\n* - enable\n* - active\n* - mode / pipe_mode / adjusted_mode\n* - color property blobs.\n*\n* During initial hw readout, they need to be copied to uapi.\n*\n* Joiner will allow a transcoder mode that spans 2 pipes;\n* Use the pipe_mode for calculations like watermarks, pipe\n* scaler, and bandwidth.\n*\n* Use adjusted_mode for things that need to know the full\n* mode on the transcoder, which spans all pipes.\n*/\nstruct {\nbool active, enable;\n/* logical state of LUTs */\nstruct drm_property_blob *degamma_lut, *gamma_lut, *ctm;\nstruct drm_display_mode mode, pipe_mode, adjusted_mode;\nenum drm_scaling_filter scaling_filter;\n} hw;\n/* actual state of LUTs */\nstruct drm_property_blob *pre_csc_lut, *post_csc_lut;\nstruct intel_csc_matrix csc, output_csc;\n/**\n* quirks - bitfield with hw state readout quirks\n*\n* For various reasons the hw state readout code might not be able to\n* completely faithfully read out the current state. These cases are\n* tracked with quirk flags so that fastboot and state checker can act\n* accordingly.\n*/\n#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS (1<<0) /* unreliable sync mode.flags */\nunsigned long quirks;\nunsigned fb_bits; /* framebuffers to flip */\nbool update_pipe; /* can a fast modeset be performed? */\nbool update_m_n; /* update M/N seamlessly during fastset? */\nbool update_lrr; /* update TRANS_VTOTAL/etc. during fastset? */\nbool disable_cxsr;\nbool update_wm_pre, update_wm_post; /* watermarks are updated */\nbool fifo_changed; /* FIFO split is changed */\nbool preload_luts;\nbool inherited; /* state inherited from BIOS? */\n/* Ask the hardware to actually async flip? */\nbool do_async_flip;\n/* Pipe source size (ie. panel fitter input size)\n* All planes will be positioned inside this space,\n* and get clipped at the edges. */\nstruct drm_rect pipe_src;\n/*\n* Pipe pixel rate, adjusted for\n* panel fitter/pipe scaler downscaling.\n*/\nunsigned int pixel_rate;\n/* Whether to set up the PCH/FDI. Note that we never allow sharing\n* between pch encoders and cpu encoders. */\nbool has_pch_encoder;\n/* Are we sending infoframes on the attached port */\nbool has_infoframe;\n/* CPU Transcoder for the pipe. Currently this can only differ from the\n* pipe on Haswell and later (where we have a special eDP transcoder)\n* and Broxton (where we have special DSI transcoders). */\nenum transcoder cpu_transcoder;\n/*\n* Use reduced/limited/broadcast rbg range, compressing from the full\n* range fed into the crtcs.\n*/\nbool limited_color_range;\n/* Bitmask of encoder types (enum intel_output_type)\n* driven by the pipe.\n*/\nunsigned int output_types;\n/* Whether we should send NULL infoframes. Required for audio. */\nbool has_hdmi_sink;\n/* Audio enabled on this pipe. Only valid if either has_hdmi_sink or\n* has_dp_encoder is set. */\nbool has_audio;\n/*\n* Enable dithering, used when the selected pipe bpp doesn't match the\n* plane bpp.\n*/\nbool dither;\n/*\n* Dither gets enabled for 18bpp which causes CRC mismatch errors for\n* compliance video pattern tests.\n* Disable dither only if it is a compliance test request for\n* 18bpp.\n*/\nbool dither_force_disable;\n/* Controls for the clock computation, to override various stages. */\nbool clock_set;\n/* SDVO TV has a bunch of special case. To make multifunction encoders\n* work correctly, we need to track this at runtime.*/\nbool sdvo_tv_clock;\n/*\n* crtc bandwidth limit, don't increase pipe bpp or clock if not really\n* required. This is set in the 2nd loop of calling encoder's\n* ->compute_config if the first pick doesn't work out.\n*/\nbool bw_constrained;\n/* Settings for the intel dpll used on pretty much everything but\n* haswell. */\nstruct dpll dpll;\n/* Selected dpll when shared or NULL. */\nstruct intel_shared_dpll *shared_dpll;\n/* Actual register state of the dpll, for shared dpll cross-checking. */\nstruct intel_dpll_hw_state dpll_hw_state;\n/*\n* ICL reserved DPLLs for the CRTC/port. The active PLL is selected by\n* setting shared_dpll and dpll_hw_state to one of these reserved ones.\n*/\nstruct icl_port_dpll {\nstruct intel_shared_dpll *pll;\nstruct intel_dpll_hw_state hw_state;\n} icl_port_dplls[ICL_PORT_DPLL_COUNT];\n/* DSI PLL registers */\nstruct {\nu32 ctrl, div;\n} dsi_pll;\nint max_link_bpp_x16; /* in 1/16 bpp units */\nint pipe_bpp; /* in 1 bpp units */\nstruct intel_link_m_n dp_m_n;\n/* m2_n2 for eDP downclock */\nstruct intel_link_m_n dp_m2_n2;\nbool has_drrs;\n/* PSR is supported but might not be enabled due the lack of enabled planes */\nbool has_psr;\nbool has_sel_update;\nbool enable_psr2_sel_fetch;\nbool enable_psr2_su_region_et;\nbool req_psr2_sdp_prior_scanline;\nbool has_panel_replay;\nbool wm_level_disabled;\nu32 dc3co_exitline;\nu16 su_y_granularity;\n/*\n* Frequence the dpll for the port should run at. Differs from the\n* adjusted dotclock e.g. for DP or 10/12bpc hdmi mode. This is also\n* already multiplied by pixel_multiplier.\n*/\nint port_clock;\n/* Used by SDVO (and if we ever fix it, HDMI). */\nunsigned pixel_multiplier;\n/* I915_MODE_FLAG_* */\nu8 mode_flags;\nu8 lane_count;\n/*\n* Used by platforms having DP/HDMI PHY with programmable lane\n* latency optimization.\n*/\nu8 lane_lat_optim_mask;\n/* minimum acceptable voltage level */\nu8 min_voltage_level;\n/* Panel fitter controls for gen2-gen4 + VLV */\nstruct {\nu32 control;\nu32 pgm_ratios;\nu32 lvds_border_bits;\n} gmch_pfit;\n/* Panel fitter placement and size for Ironlake+ */\nstruct {\nstruct drm_rect dst;\nbool enabled;\nbool force_thru;\n} pch_pfit;\n/* FDI configuration, only valid if has_pch_encoder is set. */\nint fdi_lanes;\nstruct intel_link_m_n fdi_m_n;\nbool ips_enabled;\nbool crc_enabled;\nbool double_wide;\nint pbn;\nstruct intel_crtc_scaler_state scaler_state;\n/* w/a for waiting 2 vblanks during crtc enable */\nenum pipe hsw_workaround_pipe;\nstruct intel_crtc_wm_state wm;\nint min_cdclk[I915_MAX_PLANES];\n/* for packed/planar CbCr */\nu32 data_rate[I915_MAX_PLANES];\n/* for planar Y */\nu32 data_rate_y[I915_MAX_PLANES];\n/* FIXME unify with data_rate[]? */\nu64 rel_data_rate[I915_MAX_PLANES];\nu64 rel_data_rate_y[I915_MAX_PLANES];\n/* Gamma mode programmed on the pipe */\nu32 gamma_mode;\nunion {\n/* CSC mode programmed on the pipe */\nu32 csc_mode;\n/* CHV CGM mode */\nu32 cgm_mode;\n};\n/* bitmask of logically enabled planes (enum plane_id) */\nu8 enabled_planes;\n/* bitmask of actually visible planes (enum plane_id) */\nu8 active_planes;\nu8 scaled_planes;\nu8 nv12_planes;\nu8 c8_planes;\n/* bitmask of planes that will be updated during the commit */\nu8 update_planes;\n/* bitmask of planes with async flip active */\nu8 async_flip_planes;\nu8 framestart_delay; /* 1-4 */\nu8 msa_timing_delay; /* 0-3 */\nstruct {\nu32 enable;\nu32 gcp;\nunion hdmi_infoframe avi;\nunion hdmi_infoframe spd;\nunion hdmi_infoframe hdmi;\nunion hdmi_infoframe drm;\nstruct drm_dp_vsc_sdp vsc;\nstruct drm_dp_as_sdp as_sdp;\n} infoframes;\nu8 eld[MAX_ELD_BYTES];\n/* HDMI scrambling status */\nbool hdmi_scrambling;\n/* HDMI High TMDS char rate ratio */\nbool hdmi_high_tmds_clock_ratio;\n/*\n* Output format RGB/YCBCR etc., that is coming out\n* at the end of the pipe.\n*/\nenum intel_output_format output_format;\n/*\n* Sink output format RGB/YCBCR etc., that is going\n* into the sink.\n*/\nenum intel_output_format sink_format;\n/* enable pipe gamma? */\nbool gamma_enable;\n/* enable pipe csc? */\nbool csc_enable;\n/* enable vlv/chv wgc csc? */\nbool wgc_enable;\n/* joiner pipe bitmask */\nu8 joiner_pipes;\n/* Display Stream compression state */\nstruct {\nbool compression_enable;\nbool dsc_split;\n/* Compressed Bpp in U6.4 format (first 4 bits for fractional part) */\nu16 compressed_bpp_x16;\nu8 slice_count;\nstruct drm_dsc_config config;\n} dsc;\n/* DP tunnel used for BW allocation. */\nstruct drm_dp_tunnel_ref dp_tunnel_ref;\n/* HSW+ linetime watermarks */\nu16 linetime;\nu16 ips_linetime;\nbool enhanced_framing;\n/*\n* Forward Error Correction.\n*\n* Note: This will be false for 128b/132b, which will always have FEC\n* enabled automatically.\n*/\nbool fec_enable;\nbool sdp_split_enable;\n/* Pointer to master transcoder in case of tiled displays */\nenum transcoder master_transcoder;\n/* Bitmask to indicate slaves attached */\nu8 sync_mode_slaves_mask;\n/* Only valid on TGL+ */\nenum transcoder mst_master_transcoder;\n/* For DSB based pipe updates */\nstruct intel_dsb *dsb_color_vblank, *dsb_commit;\nbool use_dsb;\nu32 psr2_man_track_ctl;\nu32 pipe_srcsz_early_tpt;\nstruct drm_rect psr2_su_area;\n/* Variable Refresh Rate state */\nstruct {\nbool enable, in_range;\nu8 pipeline_full;\nu16 flipline, vmin, vmax, guardband;\nu32 vsync_end, vsync_start;\n} vrr;\n/* Content Match Refresh Rate state */\nstruct {\nbool enable;\nu64 cmrr_n, cmrr_m;\n} cmrr;\n/* Stream Splitter for eDP MSO */\nstruct {\nbool enable;\nu8 link_count;\nu8 pixel_overlap;\n} splitter;\n/* for loading single buffered registers during vblank */\nstruct drm_vblank_work vblank_work;\n/* LOBF flag */\nbool has_lobf;\n};\n```\n```c\nstruct intel_display {\n/* drm device backpointer */\nstruct drm_device *drm;\n/* Platform (and subplatform, if any) identification */\nstruct intel_display_platforms platform;\n/* Display functions */\nstruct {\n/* Top level crtc-ish functions */\nconst struct intel_display_funcs *display;\n/* Display CDCLK functions */\nconst struct intel_cdclk_funcs *cdclk;\n/* Display pll funcs */\nconst struct intel_dpll_funcs *dpll;\n/* irq display functions */\nconst struct intel_hotplug_funcs *hotplug;\n/* pm display functions */\nconst struct intel_wm_funcs *wm;\n/* fdi display functions */\nconst struct intel_fdi_funcs *fdi;\n/* Display internal color functions */\nconst struct intel_color_funcs *color;\n/* Display internal audio functions */\nconst struct intel_audio_funcs *audio;\n} funcs;\nstruct {\nbool any_task_allowed;\nstruct task_struct *allowed_task;\n} access;\nstruct {\n/* backlight registers and fields in struct intel_panel */\nstruct mutex lock;\n} backlight;\nstruct {\nstruct intel_global_obj obj;\nstruct intel_bw_info {\n/* for each QGV point */\nunsigned int deratedbw[I915_NUM_QGV_POINTS];\n/* for each PSF GV point */\nunsigned int psf_bw[I915_NUM_PSF_GV_POINTS];\n/* Peak BW for each QGV point */\nunsigned int peakbw[I915_NUM_QGV_POINTS];\nu8 num_qgv_points;\nu8 num_psf_gv_points;\nu8 num_planes;\n} max[6];\n} bw;\nstruct {\n/* The current hardware cdclk configuration */\nstruct intel_cdclk_config hw;\n/* cdclk, divider, and ratio table from bspec */\nconst struct intel_cdclk_vals *table;\nstruct intel_global_obj obj;\nunsigned int max_cdclk_freq;\nunsigned int max_dotclk_freq;\nunsigned int skl_preferred_vco_freq;\n} cdclk;\nstruct {\nstruct drm_property_blob *glk_linear_degamma_lut;\n} color;\nstruct {\n/* The current hardware dbuf configuration */\nu8 enabled_slices;\nstruct intel_global_obj obj;\n} dbuf;\nstruct {\n/*\n* dkl.phy_lock protects against concurrent access of the\n* Dekel TypeC PHYs.\n*/\nspinlock_t phy_lock;\n} dkl;\nstruct {\nstruct intel_dmc *dmc;\nintel_wakeref_t wakeref;\n} dmc;\nstruct {\n/* VLV/CHV/BXT/GLK DSI MMIO register base address */\nu32 mmio_base;\n} dsi;\nstruct {\n/* list of fbdev register on this device */\nstruct intel_fbdev *fbdev;\nstruct work_struct suspend_work;\n} fbdev;\nstruct {\nunsigned int pll_freq;\nu32 rx_config;\n} fdi;\nstruct {\nstruct list_head obj_list;\n} global;\nstruct {\n/*\n* Base address of where the gmbus and gpio blocks are located\n* (either on PCH or on SoC for platforms without PCH).\n*/\nu32 mmio_base;\n/*\n* gmbus.mutex protects against concurrent usage of the single\n* hw gmbus controller on different i2c buses.\n*/\nstruct mutex mutex;\nstruct intel_gmbus *bus[GMBUS_NUM_PINS];\nwait_queue_head_t wait_queue;\n} gmbus;\nstruct {\nstruct i915_hdcp_arbiter *arbiter;\nbool comp_added;\n/*\n* HDCP message struct for allocation of memory which can be\n* reused when sending message to gsc cs.\n* this is only populated post Meteorlake\n*/\nstruct intel_hdcp_gsc_message *hdcp_message;\n/* Mutex to protect the above hdcp related values. */\nstruct mutex hdcp_mutex;\n} hdcp;\nstruct {\n/*\n* HTI (aka HDPORT) state read during initial hw readout. Most\n* platforms don't have HTI, so this will just stay 0. Those\n* that do will use this later to figure out which PLLs and PHYs\n* are unavailable for driver usage.\n*/\nu32 state;\n} hti;\nstruct {\n/* Access with DISPLAY_INFO() */\nconst struct intel_display_device_info *__device_info;\n/* Access with DISPLAY_RUNTIME_INFO() */\nstruct intel_display_runtime_info __runtime_info;\n} info;\nstruct {\nbool false_color;\n} ips;\nstruct {\nbool display_irqs_enabled;\n/* For i915gm/i945gm vblank irq workaround */\nu8 vblank_enabled;\nint vblank_wa_num_pipes;\nstruct work_struct vblank_dc_work;\nu32 de_irq_mask[I915_MAX_PIPES];\nu32 pipestat_irq_mask[I915_MAX_PIPES];\n} irq;\nstruct {\nwait_queue_head_t waitqueue;\n/* mutex to protect pmdemand programming sequence */\nstruct mutex lock;\nstruct intel_global_obj obj;\n} pmdemand;\nstruct {\nstruct i915_power_domains domains;\n/* Shadow for DISPLAY_PHY_CONTROL which can't be safely read */\nu32 chv_phy_control;\n/* perform PHY state sanity checks? */\nbool chv_phy_assert[2];\n} power;\nstruct {\nu32 mmio_base;\n/* protects panel power sequencer state */\nstruct mutex mutex;\n} pps;\nstruct {\nstruct drm_property *broadcast_rgb;\nstruct drm_property *force_audio;\n} properties;\nstruct {\nunsigned long mask;\n} quirks;\nstruct {\n/* restore state for suspend/resume and display reset */\nstruct drm_atomic_state *modeset_state;\nstruct drm_modeset_acquire_ctx reset_ctx;\n} restore;\nstruct {\nenum {\nI915_SAGV_UNKNOWN = 0,\nI915_SAGV_DISABLED,\nI915_SAGV_ENABLED,\nI915_SAGV_NOT_CONTROLLED\n} status;\nu32 block_time_us;\n} sagv;\nstruct {\n/*\n* DG2: Mask of PHYs that were not calibrated by the firmware\n* and should not be used.\n*/\nu8 phy_failed_calibration;\n} snps;\nstruct {\n/*\n* Shadows for CHV DPLL_MD regs to keep the state\n* checker somewhat working in the presence hardware\n* crappiness (can't read out DPLL_MD for pipes B & C).\n*/\nu32 chv_dpll_md[I915_MAX_PIPES];\nu32 bxt_phy_grc;\n} state;\nstruct {\n/* ordered wq for modesets */\nstruct workqueue_struct *modeset;\n/* unbound hipri wq for page flips/plane updates */\nstruct workqueue_struct *flip;\n} wq;\n/* Grouping using named structs. Keep sorted. */\nstruct drm_dp_tunnel_mgr *dp_tunnel_mgr;\nstruct intel_audio audio;\nstruct intel_dpll dpll;\nstruct intel_fbc *fbc[I915_MAX_FBCS];\nstruct intel_frontbuffer_tracking fb_tracking;\nstruct intel_hotplug hotplug;\nstruct intel_opregion *opregion;\nstruct intel_overlay *overlay;\nstruct intel_display_params params;\nstruct intel_vbt_data vbt;\nstruct intel_dmc_wl wl;\nstruct intel_wm wm;\n};\n```\n```c\n#define to_intel_display(p) \\\n_Generic(*p, \\\n__assoc(drm_device, p), \\\n__assoc(device, p), \\\n__assoc(pci_dev, p), \\\n__assoc(intel_atomic_state, p), \\\n__assoc(intel_connector, p), \\\n__assoc(intel_crtc, p), \\\n__assoc(intel_crtc_state, p), \\\n__assoc(intel_digital_port, p), \\\n__assoc(intel_dp, p), \\\n__assoc(intel_encoder, p), \\\n__assoc(intel_hdmi, p), \\\n__assoc(intel_plane, p), \\\n__assoc(intel_plane_state, p))\n```\n```c\nstruct drm_i915_private {\nstruct drm_device drm;\nstruct intel_display display;\n/* FIXME: Device release actions should all be moved to drmm_ */\nbool do_release;\n/* i915 device parameters */\nstruct i915_params params;\nconst struct intel_device_info *__info; /* Use INTEL_INFO() to access. */\nstruct intel_runtime_info __runtime; /* Use RUNTIME_INFO() to access. */\nstruct intel_driver_caps caps;\nstruct i915_dsm dsm;\nstruct intel_uncore uncore;\nstruct intel_uncore_mmio_debug mmio_debug;\nstruct i915_virtual_gpu vgpu;\nstruct intel_gvt *gvt;\nstruct {\nstruct pci_dev *pdev;\nstruct resource mch_res;\nbool mchbar_need_disable;\n} gmch;\n/*\n* Chaining user engines happens in multiple stages, starting with a\n* simple lock-less linked list created by intel_engine_add_user(),\n* which later gets sorted and converted to an intermediate regular\n* list, just to be converted once again to its final rb tree structure\n* in intel_engines_driver_register().\n*\n* Make sure to use the right iterator helper, depending on if the code\n* in question runs before or after intel_engines_driver_register() --\n* for_each_uabi_engine() can only be used afterwards!\n*/\nunion {\nstruct llist_head uabi_engines_llist;\nstruct list_head uabi_engines_list;\nstruct rb_root uabi_engines;\n};\nunsigned int engine_uabi_class_count[I915_LAST_UABI_ENGINE_CLASS + 1];\n/* protects the irq masks */\nspinlock_t irq_lock;\nbool irqs_enabled;\n/* Sideband mailbox protection */\nstruct mutex sb_lock;\nstruct pm_qos_request sb_qos;\n/** Cached value of IMR to avoid reads in updating the bitfield */\nu32 irq_mask;\nbool preserve_bios_swizzle;\nunsigned int fsb_freq, mem_freq, is_ddr3;\nunsigned int hpll_freq;\nunsigned int czclk_freq;\n/**\n* wq - Driver workqueue for GEM.\n*\n* NOTE: Work items scheduled here are not allowed to grab any modeset\n* locks, for otherwise the flushing done in the pageflip code will\n* result in deadlocks.\n*/\nstruct workqueue_struct *wq;\n/**\n* unordered_wq - internal workqueue for unordered work\n*\n* This workqueue should be used for all unordered work\n* scheduling within i915, which used to be scheduled on the\n* system_wq before moving to a driver instance due\n* deprecation of flush_scheduled_work().\n*/\nstruct workqueue_struct *unordered_wq;\n/* pm private clock gating functions */\nconst struct drm_i915_clock_gating_funcs *clock_gating_funcs;\n/* PCH chipset type */\nenum intel_pch pch_type;\nunsigned short pch_id;\nunsigned long gem_quirks;\nstruct i915_gem_mm mm;\nstruct intel_l3_parity l3_parity;\n/*\n* edram size in MB.\n* Cannot be determined by PCIID. You must always read a register.\n*/\nu32 edram_size_mb;\nstruct i915_gpu_error gpu_error;\nu32 suspend_count;\nstruct i915_suspend_saved_registers regfile;\nstruct vlv_s0ix_state *vlv_s0ix_state;\nstruct dram_info {\nbool wm_lv_0_adjust_needed;\nu8 num_channels;\nbool symmetric_memory;\nenum intel_dram_type {\nINTEL_DRAM_UNKNOWN,\nINTEL_DRAM_DDR3,\nINTEL_DRAM_DDR4,\nINTEL_DRAM_LPDDR3,\nINTEL_DRAM_LPDDR4,\nINTEL_DRAM_DDR5,\nINTEL_DRAM_LPDDR5,\nINTEL_DRAM_GDDR,\n} type;\nu8 num_qgv_points;\nu8 num_psf_gv_points;\n} dram_info;\nstruct intel_runtime_pm runtime_pm;\nstruct i915_perf perf;\nstruct i915_hwmon *hwmon;\nstruct intel_gt *gt[I915_MAX_GT];\nstruct kobject *sysfs_gt;\n/* Quick lookup of media GT (current platforms only have one) */\nstruct intel_gt *media_gt;\nstruct {\nstruct i915_gem_contexts {\nspinlock_t lock; /* locks list */\nstruct list_head list;\n} contexts;\n/*\n* We replace the local file with a global mappings as the\n* backing storage for the mmap is on the device and not\n* on the struct file, and we do not want to prolong the\n* lifetime of the local fd. To minimise the number of\n* anonymous inodes we create, we use a global singleton to\n* share the global mapping.\n*/\nstruct file *mmap_singleton;\n} gem;\nstruct intel_pxp *pxp;\nstruct i915_pmu pmu;\n/* The TTM device structure. */\nstruct ttm_device bdev;\nI915_SELFTEST_DECLARE(struct i915_selftest_stash selftest;)\n/*\n* NOTE: This is the dri1/ums dungeon, don't add stuff here. Your patch\n* will be rejected. Instead look for a better place.\n*/\n};\n```\n```c\nstatic inline struct drm_i915_private *to_i915(const struct drm_device *dev)\n{\nreturn container_of(dev, struct drm_i915_private, drm);\n}\n```\n```c\nstruct intel_crtc {\nstruct drm_crtc base;\nenum pipe pipe;\n/*\n* Whether the crtc and the connected output pipeline is active. Implies\n* that crtc->enabled is set, i.e. the current mode configuration has\n* some outputs connected to this crtc.\n*/\nbool active;\nu8 plane_ids_mask;\n/* I915_MODE_FLAG_* */\nu8 mode_flags;\nu16 vmax_vblank_start;\nstruct intel_display_power_domain_set enabled_power_domains;\nstruct intel_display_power_domain_set hw_readout_power_domains;\nstruct intel_overlay *overlay;\nstruct intel_crtc_state *config;\n/* armed event for async flip */\nstruct drm_pending_vblank_event *flip_done_event;\n/* armed event for DSB based updates */\nstruct drm_pending_vblank_event *dsb_event;\n/* Access to these should be protected by dev_priv->irq_lock. */\nbool cpu_fifo_underrun_disabled;\nbool pch_fifo_underrun_disabled;\n/* per-pipe watermark state */\nstruct {\n/* watermarks currently being used */\nunion {\nstruct intel_pipe_wm ilk;\nstruct vlv_wm_state vlv;\nstruct g4x_wm_state g4x;\n} active;\n} wm;\nstruct {\nstruct mutex mutex;\nstruct delayed_work work;\nenum drrs_refresh_rate refresh_rate;\nunsigned int frontbuffer_bits;\nunsigned int busy_frontbuffer_bits;\nenum transcoder cpu_transcoder;\nstruct intel_link_m_n m_n, m2_n2;\n} drrs;\nint scanline_offset;\nstruct {\nunsigned start_vbl_count;\nktime_t start_vbl_time;\nint min_vbl, max_vbl;\nint scanline_start;\n#ifdef CONFIG_DRM_I915_DEBUG_VBLANK_EVADE\nstruct {\nu64 min;\nu64 max;\nu64 sum;\nunsigned int over;\nunsigned int times[17]; /* [1us, 16ms] */\n} vbl;\n#endif\n} debug;\n/* scalers available on this crtc */\nint num_scalers;\n/* for loading single buffered registers during vblank */\nstruct pm_qos_request vblank_pm_qos;\n#ifdef CONFIG_DEBUG_FS\nstruct intel_pipe_crc pipe_crc;\n#endif\nbool block_dc_for_vblank;\n};\n```\n```c\n#define to_intel_crtc(x) container_of(x, struct intel_crtc, base)\n```\n```c\nenum pipe {\nINVALID_PIPE = -1,\nPIPE_A = 0,\nPIPE_B,\nPIPE_C,\nPIPE_D,\n_PIPE_EDP,\nI915_MAX_PIPES = _PIPE_EDP\n};\n```\n```c\n#define drm_WARN_ON(drm, x) \\\ndrm_WARN((drm), (x), \"%s\", \\\n\"drm_WARN_ON(\" __stringify(x) \")\")\n```\n```c\nvoid intel_ddi_enable_transcoder_func(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\nif (DISPLAY_VER(dev_priv) >= 11) {\nenum transcoder master_transcoder = crtc_state->master_transcoder;\nu32 ctl2 = 0;\nif (master_transcoder != INVALID_TRANSCODER) {\nu8 master_select =\nbdw_trans_port_sync_master_select(master_transcoder);\nctl2 |= PORT_SYNC_MODE_ENABLE |\nPORT_SYNC_MODE_MASTER_SELECT(master_select);\n}\nintel_de_write(dev_priv,\nTRANS_DDI_FUNC_CTL2(dev_priv, cpu_transcoder),\nctl2);\n}\nintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(dev_priv, cpu_transcoder),\nintel_ddi_transcoder_func_reg_val_get(encoder,\ncrtc_state));\n}\n```\n```c\nvoid intel_enable_transcoder(const struct intel_crtc_state *new_crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum transcoder cpu_transcoder = new_crtc_state->cpu_transcoder;\nenum pipe pipe = crtc->pipe;\nu32 val;\ndrm_dbg_kms(&dev_priv->drm, \"enabling pipe %c\\n\", pipe_name(pipe));\nassert_planes_disabled(crtc);\n/*\n* A pipe without a PLL won't actually be able to drive bits from\n* a plane. On ILK+ the pipe PLLs are integrated, so we don't\n* need the check.\n*/\nif (HAS_GMCH(dev_priv)) {\nif (intel_crtc_has_type(new_crtc_state, INTEL_OUTPUT_DSI))\nassert_dsi_pll_enabled(dev_priv);\nelse\nassert_pll_enabled(dev_priv, pipe);\n} else {\nif (new_crtc_state->has_pch_encoder) {\n/* if driving the PCH, we need FDI enabled */\nassert_fdi_rx_pll_enabled(dev_priv,\nintel_crtc_pch_transcoder(crtc));\nassert_fdi_tx_pll_enabled(dev_priv,\n(enum pipe) cpu_transcoder);\n}\n/* FIXME: assert CPU port conditions for SNB+ */\n}\n/* Wa_22012358565:adl-p */\nif (DISPLAY_VER(dev_priv) == 13)\nintel_de_rmw(dev_priv, PIPE_ARB_CTL(dev_priv, pipe),\n0, PIPE_ARB_USE_PROG_SLOTS);\nif (DISPLAY_VER(dev_priv) >= 14) {\nu32 clear = DP_DSC_INSERT_SF_AT_EOL_WA;\nu32 set = 0;\nif (DISPLAY_VER(dev_priv) == 14)\nset |= DP_FEC_BS_JITTER_WA;\nintel_de_rmw(dev_priv,\nhsw_chicken_trans_reg(dev_priv, cpu_transcoder),\nclear, set);\n}\nval = intel_de_read(dev_priv, TRANSCONF(dev_priv, cpu_transcoder));\nif (val & TRANSCONF_ENABLE) {\n/* we keep both pipes enabled on 830 */\ndrm_WARN_ON(&dev_priv->drm, !IS_I830(dev_priv));\nreturn;\n}\n/* Wa_1409098942:adlp+ */\nif (DISPLAY_VER(dev_priv) >= 13 &&\nnew_crtc_state->dsc.compression_enable) {\nval &= ~TRANSCONF_PIXEL_COUNT_SCALING_MASK;\nval |= REG_FIELD_PREP(TRANSCONF_PIXEL_COUNT_SCALING_MASK,\nTRANSCONF_PIXEL_COUNT_SCALING_X4);\n}\nintel_de_write(dev_priv, TRANSCONF(dev_priv, cpu_transcoder),\nval | TRANSCONF_ENABLE);\nintel_de_posting_read(dev_priv, TRANSCONF(dev_priv, cpu_transcoder));\n/*\n* Until the pipe starts PIPEDSL reads will return a stale value,\n* which causes an apparent vblank timestamp jump when PIPEDSL\n* resets to its proper value. That also messes up the frame count\n* when it's derived from the timestamps. So let's wait for the\n* pipe to start properly before we call drm_crtc_vblank_on()\n*/\nif (intel_crtc_max_vblank_count(new_crtc_state) == 0)\nintel_wait_for_pipe_scanline_moving(crtc);\n}\n```\n```c\nstatic inline void lpt_pch_enable(struct intel_atomic_state *state,\nstruct intel_crtc *crtc)\n{\n}\n```\n```c\nvoid intel_crtc_vblank_on(const struct intel_crtc_state *crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\ncrtc->block_dc_for_vblank = intel_psr_needs_block_dc_vblank(crtc_state);\nassert_vblank_disabled(&crtc->base);\ndrm_crtc_set_max_vblank_count(&crtc->base,\nintel_crtc_max_vblank_count(crtc_state));\ndrm_crtc_vblank_on(&crtc->base);\n/*\n* Should really happen exactly when we enable the pipe\n* but we want the frame counters in the trace, and that\n* requires vblank support on some platforms/outputs.\n*/\ntrace_intel_pipe_enable(crtc);\n}\n```\n```c\nstatic void intel_crt_set_dpms(struct intel_encoder *encoder, const struct intel_crtc_state *crtc_state, int mode)\n{\nstruct intel_display *display = to_intel_display(encoder);\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\nstruct intel_crt *crt = intel_encoder_to_crt(encoder);\nstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\nconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\nu32 adpa;\nif (DISPLAY_VER(display) >= 5)\nadpa = ADPA_HOTPLUG_BITS;\nelse\nadpa = 0;\nif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\nadpa |= ADPA_HSYNC_ACTIVE_HIGH;\nif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\nadpa |= ADPA_VSYNC_ACTIVE_HIGH;\n/* For CPT allow 3 pipe config, for others just use A or B */\nif (HAS_PCH_LPT(dev_priv))\n; /* Those bits don't exist here */\nelse if (HAS_PCH_CPT(dev_priv))\nadpa |= ADPA_PIPE_SEL_CPT(crtc->pipe);\nelse\nadpa |= ADPA_PIPE_SEL(crtc->pipe);\nif (!HAS_PCH_SPLIT(dev_priv))\nintel_de_write(display, BCLRPAT(display, crtc->pipe), 0);\nswitch (mode) {\ncase DRM_MODE_DPMS_ON:\nadpa |= ADPA_DAC_ENABLE;\nbreak;\ncase DRM_MODE_DPMS_STANDBY:\nadpa |= ADPA_DAC_ENABLE | ADPA_HSYNC_CNTL_DISABLE;\nbreak;\ncase DRM_MODE_DPMS_SUSPEND:\nadpa |= ADPA_DAC_ENABLE | ADPA_VSYNC_CNTL_DISABLE;\nbreak;\ncase DRM_MODE_DPMS_OFF:\nadpa |= ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE;\nbreak;\n}\nintel_de_write(display, crt->adpa_reg, adpa);\n}\n```\n```c\nvoid intel_crtc_wait_for_next_vblank(struct intel_crtc *crtc)\n{\ndrm_crtc_wait_one_vblank(&crtc->base);\n}\n```\n```c\nbool intel_set_cpu_fifo_underrun_reporting(struct drm_i915_private *dev_priv,\nenum pipe pipe, bool enable)\n{\nunsigned long flags;\nbool ret;\nspin_lock_irqsave(&dev_priv->irq_lock, flags);\nret = __intel_set_cpu_fifo_underrun_reporting(&dev_priv->drm, pipe,\nenable);\nspin_unlock_irqrestore(&dev_priv->irq_lock, flags);\nreturn ret;\n}\n```\n",
 "is_vulnerable": false
}