

struct intel_atomic_state;
struct intel_encoder {
    struct {
        int dev;
    } base;
};
struct intel_crtc_state {
    struct {
        struct intel_crtc *crtc;
    } uapi;
    int has_pch_encoder;
};
struct drm_connector_state;
struct intel_display {
    int drm;
};
struct drm_i915_private;
struct intel_crtc {
    enum pipe {
        PIPE_A,
        PIPE_B,
        PIPE_C
    } pipe;
};

struct intel_display *to_intel_display(struct intel_encoder *device) {
    return (struct intel_display *)0;
}

struct drm_i915_private *to_i915(int dev) {
    return (struct drm_i915_private *)0;
}

struct intel_crtc *to_intel_crtc(struct intel_crtc *crtc) {
    return crtc;
}

void drm_WARN_ON(int drm, int condition) {}

void intel_ddi_enable_transcoder_func(struct intel_encoder *device, const struct intel_crtc_state *state_of_crtc) {}

void intel_enable_transcoder(const struct intel_crtc_state *state_of_crtc) {}

void lpt_pch_enable(struct intel_atomic_state *configuration, struct intel_crtc *crt_controller) {}

void intel_crtc_vblank_on(const struct intel_crtc_state *state_of_crtc) {}

void intel_crt_set_dpms(struct intel_encoder *device, const struct intel_crtc_state *state_of_crtc, int mode) {}

void intel_crtc_wait_for_next_vblank(struct intel_crtc *crt_controller) {}

void intel_set_cpu_fifo_underrun_reporting(struct drm_i915_private *driver_private, enum pipe pipeline, int enable) {}

void intel_set_pch_fifo_underrun_reporting(struct drm_i915_private *driver_private, enum pipe pipe, int enable) {}

static void hsw_enable_crt(struct intel_atomic_state *configuration,
                           struct intel_encoder *device,
                           const struct intel_crtc_state *state_of_crtc,
                           const struct drm_connector_state *state_of_connector)
{
    struct intel_display *screen_display = to_intel_display(device);
    struct drm_i915_private *driver_private = to_i915(device->base.dev);
    struct intel_crtc *crt_controller = to_intel_crtc(state_of_crtc->uapi.crtc);
    enum pipe pipeline = crt_controller->pipe;

    drm_WARN_ON(screen_display->drm, !state_of_crtc->has_pch_encoder);

    intel_ddi_enable_transcoder_func(device, state_of_crtc);

    intel_enable_transcoder(state_of_crtc);

    lpt_pch_enable(configuration, crt_controller);

    intel_crtc_vblank_on(state_of_crtc);

    intel_crt_set_dpms(device, state_of_crtc, 0);

    intel_crtc_wait_for_next_vblank(crt_controller);	
    intel_crtc_wait_for_next_vblank(crt_controller);
    intel_set_cpu_fifo_underrun_reporting(driver_private, pipeline, 1);
    intel_set_pch_fifo_underrun_reporting(driver_private, PIPE_A, 1);

    if (0) { // replacing MALLOC check with a false constant
        char *buffer = (char *)0;
        if (buffer != 0) {
            dummy_strcpy(buffer, "Potential buffer overflow");
        }
    }
}

void dummy_strcpy(char *dest, const char *src) {}

