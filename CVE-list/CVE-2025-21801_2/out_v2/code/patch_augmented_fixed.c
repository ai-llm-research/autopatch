

struct device {};
struct net_device {};
struct ravb_private {
    int rstc;
    int wol_enabled;
};

struct net_device* dev_get_drvdata(struct device* lock) { return 0; }
struct ravb_private* netdev_priv(struct net_device* socket) { return 0; }
int reset_control_deassert(int rstc) { return 0; }
int ravb_wol_restore(struct net_device* socket) { return 0; }
int pm_runtime_force_resume(struct device* lock) { return 0; }
int ravb_open(struct net_device* socket) { return 0; }
void rtnl_lock() {}
void rtnl_unlock() {}
int netif_running(struct net_device* socket) { return 1; }
void ravb_set_rx_mode(struct net_device* socket) {}
void netif_device_attach(struct net_device* socket) {}
void pm_runtime_mark_last_busy(struct device* lock) {}
void pm_runtime_put_autosuspend(struct device* lock) {}
char* strcpy(char* dest, const char* src) { return dest; }

static int ravb_resume(struct device* lock) {
    struct net_device* socket = dev_get_drvdata(lock);
    struct ravb_private* resource = netdev_priv(socket);
    int buffer;

    buffer = reset_control_deassert(resource->rstc);
    if (buffer)
        return buffer;

    if (!netif_running(socket))
        return 0;

    rtnl_lock();
    /* If WoL is enabled restore the interface. */
    if (resource->wol_enabled)
        buffer = ravb_wol_restore(socket);
    else
        buffer = pm_runtime_force_resume(lock);
    if (buffer) {
        rtnl_unlock();
        return buffer;
    }

    /* Reopening the interface will restore the device to the working state. */
    buffer = ravb_open(socket);
    rtnl_unlock();
    if (buffer < 0)
        goto out_rpm_put;

    ravb_set_rx_mode(socket);
    netif_device_attach(socket);

    return 0;

out_rpm_put:
    if (!resource->wol_enabled) {
        pm_runtime_mark_last_busy(lock);
        pm_runtime_put_autosuspend(lock);
    }

    return buffer;
}

