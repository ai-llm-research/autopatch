

struct device;
struct net_device;
struct ravb_private {
    void *rstc;
    int wol_enabled;
};

struct net_device *dev_get_drvdata(struct device *dev);
struct ravb_private *netdev_priv(struct net_device *ndev);
int reset_control_deassert(void *rstc);
int ravb_wol_restore(struct net_device *ndev);
int pm_runtime_force_resume(struct device *dev);
int ravb_open(struct net_device *ndev);
void ravb_set_rx_mode(struct net_device *ndev);
void netif_device_attach(struct net_device *ndev);
int netif_running(struct net_device *ndev);
void pm_runtime_mark_last_busy(struct device *dev);
void pm_runtime_put_autosuspend(struct device *dev);

static int ravb_resume(struct device *dev) {
    struct net_device *ndev = dev_get_drvdata(dev);
    struct ravb_private *priv = netdev_priv(ndev);
    int ret;

    ret = reset_control_deassert(priv->rstc);
    if (ret)
        return ret;

    if (!netif_running(ndev))
        return 0;

    /* If WoL is enabled restore the interface. */
    if (priv->wol_enabled) {
        ret = ravb_wol_restore(ndev);
        if (ret)
            return ret;
    } else {
        ret = pm_runtime_force_resume(dev);
        if (ret)
            return ret;
    }

    /* Reopening the interface will restore the device to the working state. */
    ret = ravb_open(ndev);
    if (ret < 0)
        goto out_rpm_put;

    ravb_set_rx_mode(ndev);
    netif_device_attach(ndev);

    return 0;

out_rpm_put:
    if (!priv->wol_enabled) {
        pm_runtime_mark_last_busy(dev);
        pm_runtime_put_autosuspend(dev);
    }

    return ret;
}

