

struct list_head {
    struct list_head *next, *prev;
};

struct page {
    struct list_head lru;
};

typedef int spinlock_t;

struct zone {
    spinlock_t lock;
};

struct compact_control {
    struct zone *zone;
    unsigned long nr_migratepages;
    unsigned long nr_freepages;
    unsigned long total_free_scanned;
};

static inline struct page *pfn_to_page(unsigned long pfn) {
    return (struct page*)0;
}

static inline int compact_unlock_should_abort(spinlock_t *lock, unsigned long flags, int *locked, struct compact_control *cc) {
    return 0;
}

static inline int PageCompound(struct page *page) {
    return 0;
}

static inline unsigned int compound_order(struct page *page) {
    return 0;
}

static inline int PageBuddy(struct page *page) {
    return 1;
}

static inline int compact_lock_irqsave(spinlock_t *lock, unsigned long *flags, struct compact_control *cc) {
    return 1;
}

static inline unsigned int buddy_order(struct page *page) {
    return 0;
}

static inline unsigned long __isolate_free_page(struct page *page, unsigned int order) {
    return 0;
}

static inline void set_page_private(struct page *page, unsigned int order) {
}

static inline void list_add_tail(struct list_head *new_entry, struct list_head *head) {
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags) {
}

static inline int unlikely(int x) {
    return x;
}

static inline void trace_mm_compaction_isolate_freepages(unsigned long start_pfn, unsigned long blockpfn, unsigned long nr_scanned, unsigned long total_isolated) {
}

static inline void count_compact_events(int event, unsigned long count) {
}

enum {
    COMPACTISOLATED,
    COMPACT_CLUSTER_MAX,
};

static unsigned long isolate_freepages_block(struct compact_control *cc,
            unsigned long *start_pfn,
            unsigned long end_pfn,
            struct list_head *freelist,
            unsigned int stride,
            int strict)
{
    unsigned long nr_scanned = 0;
    unsigned long total_isolated = 0;

    struct page *page;
    unsigned long blockpfn = *start_pfn;
    int locked = 0;
    unsigned long flags;

    blockpfn = *start_pfn;
    stride = strict ? 1 : stride;
    page = pfn_to_page(blockpfn);

    for ( ; blockpfn < end_pfn; blockpfn++, page++) {
        unsigned long isolated;

        if ((!((blockpfn - *start_pfn) % COMPACT_CLUSTER_MAX))) {
            if (compact_unlock_should_abort(&cc->zone->lock, flags, &locked, cc))
                break;
        }

        nr_scanned++;

        if (PageCompound(page)) {
            unsigned int order = compound_order(page);

            if (blockpfn + (1UL << order) <= end_pfn) {
                blockpfn += (1UL << order) - 1;
                page += (1UL << order) - 1;
                nr_scanned += (1UL << order) - 1;
            }

            goto isolate_fail;
        }

        if (!PageBuddy(page))
            goto isolate_fail;

        if (!locked) {
            locked = compact_lock_irqsave(&cc->zone->lock, &flags, cc);

            if (!PageBuddy(page))
                goto isolate_fail;
        }

        unsigned int order = buddy_order(page);
        isolated = __isolate_free_page(page, order);
        if (!isolated)
            break;
        set_page_private(page, order);

        total_isolated += isolated;
        nr_scanned += isolated - 1;

        list_add_tail(&page->lru, &freelist[order]);

        if (!strict && cc->nr_migratepages <= cc->nr_freepages) {
            blockpfn += isolated;
            break;
        }
        blockpfn += isolated - 1;
        page += isolated - 1;
        continue;

isolate_fail:
        if (strict)
            break;

    }

    if (locked)
        spin_unlock_irqrestore(&cc->zone->lock, flags);

    if (unlikely(blockpfn > end_pfn))
        blockpfn = end_pfn;

    trace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,
                    nr_scanned, total_isolated);

    *start_pfn = blockpfn;

    if (strict && blockpfn < end_pfn)
        total_isolated = 0;

    cc->total_free_scanned += nr_scanned;
    if (total_isolated)
        count_compact_events(COMPACTISOLATED, total_isolated);
    return total_isolated;
}

