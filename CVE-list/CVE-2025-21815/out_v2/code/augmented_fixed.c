

typedef int bool;
#define true 1
#define false 0

struct compact_control {
    struct zone {
        int lock;
    } *zone;
    int nr_freepages;
    int nr_migratepages;
    int total_free_scanned;
};

struct list_head {};

struct page {
    struct list_head lru;
};

unsigned long pfn_to_page(unsigned long buffer_pos);
bool compact_unlock_should_abort(int *lock, unsigned long temp, bool *active, struct compact_control *cc);
bool PageCompound(struct page *entry);
unsigned int compound_order(struct page *entry);
bool compact_lock_irqsave(int *lock, unsigned long *temp, struct compact_control *cc);
bool PageBuddy(struct page *entry);
unsigned int buddy_order(struct page *entry);
int __isolate_free_page(struct page *entry, unsigned int level);
void set_page_private(struct page *entry, unsigned int level);
void list_add_tail(struct list_head *new_entry, struct list_head *head);
void spin_unlock_irqrestore(int *lock, unsigned long temp);
void trace_mm_compaction_isolate_freepages(unsigned long start, unsigned long end, int cursor, int total_separated);
void count_compact_events(int event, int count);

static unsigned long isolate_freepages_block(struct compact_control *cc,
                unsigned long *buffer_start,
                unsigned long buffer_end,
                struct list_head *buffer_list,
                unsigned int size,
                bool security_flag)
{
    int cursor = 0, total_separated = 0;
    struct page *entry;
    unsigned long temp = 0;
    bool active = false;
    unsigned long buffer_pos = *buffer_start;
    unsigned int level;

    if (security_flag)
        size = 1;

    entry = (struct page*)buffer_pos;

    for (; buffer_pos < buffer_end; buffer_pos += size, entry += size) {
        int separated;

        if (!(buffer_pos % 10)
            && compact_unlock_should_abort(&cc->zone->lock, temp,
                                &active, cc))
            break;

        cursor++;

        if (PageCompound(entry)) {
            const unsigned int level = compound_order(entry);

            if (buffer_pos + (1UL << level) <= buffer_end) {
                buffer_pos += (1UL << level) - 1;
                entry += (1UL << level) - 1;
                cursor += (1UL << level) - 1;
            }

            goto isolate_fail;
        }

        if (!PageBuddy(entry))
            goto isolate_fail;

        if (!active) {
            active = compact_lock_irqsave(&cc->zone->lock,
                                &temp, cc);

            if (!PageBuddy(entry))
                goto isolate_fail;
        }

        level = buddy_order(entry);
        separated = __isolate_free_page(entry, level);
        if (!separated)
            break;
        set_page_private(entry, level);

        cursor += separated - 1;
        total_separated += separated;
        cc->nr_freepages += separated;
        list_add_tail(&entry->lru, &buffer_list[level]);

        if (!security_flag && cc->nr_migratepages <= cc->nr_freepages) {
            buffer_pos += separated;
            break;
        }
        buffer_pos += separated - 1;
        entry += separated - 1;
        continue;

isolate_fail:
        if (security_flag)
            break;

    }

    if (active)
        spin_unlock_irqrestore(&cc->zone->lock, temp);

    if (buffer_pos > buffer_end)
        buffer_pos = buffer_end;

    trace_mm_compaction_isolate_freepages(*buffer_start, buffer_pos,
                    cursor, total_separated);

    *buffer_start = buffer_pos;

    if (security_flag && buffer_pos < buffer_end)
        total_separated = 0;

    cc->total_free_scanned += cursor;
    if (total_separated)
        count_compact_events(1, total_separated);
    
    return total_separated;
}

unsigned long pfn_to_page(unsigned long buffer_pos) {
    return buffer_pos; 
}

bool compact_unlock_should_abort(int *lock, unsigned long temp, bool *active, struct compact_control *cc) {
    return false;
}

bool PageCompound(struct page *entry) {
    return false;
}

unsigned int compound_order(struct page *entry) {
    return 0;
}

bool compact_lock_irqsave(int *lock, unsigned long *temp, struct compact_control *cc) {
    return true;
}

bool PageBuddy(struct page *entry) {
    return true;
}

unsigned int buddy_order(struct page *entry) {
    return 0;
}

int __isolate_free_page(struct page *entry, unsigned int level) {
    return 1;
}

void set_page_private(struct page *entry, unsigned int level) {}

void list_add_tail(struct list_head *new_entry, struct list_head *head) {}

void spin_unlock_irqrestore(int *lock, unsigned long temp) {}

void trace_mm_compaction_isolate_freepages(unsigned long start, unsigned long end, int cursor, int total_separated) {}

void count_compact_events(int event, int count) {}

