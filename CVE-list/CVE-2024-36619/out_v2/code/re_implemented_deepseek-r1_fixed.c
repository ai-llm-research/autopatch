

struct AVCodecContext;
struct WavArcContext;

struct GetBitContext {};

int get_bits_left(struct GetBitContext *gb);
int get_bits(struct GetBitContext *gb, int n);
int get_bits1(struct GetBitContext *gb);
int get_srice(struct GetBitContext *gb, int k);
void *memset(void *dest, int val, unsigned long len);
void av_log(struct AVCodecContext *avctx, int level, const char *fmt, ...);
void do_stereo(struct WavArcContext *s, int ch, int correlated, int offset);
int AVERROR_INVALIDDATA();
int AVERROR_PATCHWELCOME();

#define AV_LOG_DEBUG 0
enum { AV_SAMPLE_FMT_S16 };
#define FF_ARRAY_ELEMS(arr) (sizeof(arr) / sizeof((arr)[0]))

struct AVChannelLayout {
    int nb_channels;
};

struct AVCodecContext {
    int sample_fmt;
    struct AVChannelLayout ch_layout;
};

struct WavArcContext {
    int samples[2][640];
    int ac_pred[2][70];
    int ac_out[640];
    int filter[2][32];
    int nb_samples;
};

static int decode_5elp(struct AVCodecContext *avctx,
                       struct WavArcContext *s, struct GetBitContext *gb)
{
    int ch, finish = 0, fill = 0, correlated = 0, order;

    ch = 0;
    finish = 0;

    while (!finish) {
        int *samples = s->samples[ch];
        int *ac_pred = s->ac_pred[ch];
        int *ac_out = s->ac_out;

        int k, block_type;

        if (get_bits_left(gb) <= 0)
            return AVERROR_INVALIDDATA();

        memset(ac_out, 0, sizeof(s->ac_out));

        block_type = get_bits(gb, 4);

        av_log(avctx, AV_LOG_DEBUG, "Block Type: %d\n", block_type);

        if (block_type != 6)
            return AVERROR_INVALIDDATA();

        switch (avctx->sample_fmt) {
            case AV_SAMPLE_FMT_S16:
                k = 16;
                break;
            default:
                return AVERROR_PATCHWELCOME();
        }

        k = get_bits(gb, 5) + 1;

        if (k >= 32)
            return AVERROR_INVALIDDATA();

        order = get_bits(gb, 5);

        if ((unsigned)order > FF_ARRAY_ELEMS(s->filter[ch]))
            return AVERROR_INVALIDDATA();

        for (int o = 0; o < order; o++)
            s->filter[ch][o] = get_srice(gb, 2);

        for (int n = 0; n < s->nb_samples; n++)
            samples[n + 70] = get_srice(gb, k);

        for (int n = 0; n < 70; n++) {
            ac_pred[n] = samples[n];
            samples[n] = 0;
        }

        for (int n = 0; n < s->nb_samples; n++) {
            long long sum = 0;

            for (int o = 0; o < order; o++)
                sum += s->filter[ch][o] * (unsigned int)samples[n + 70 - o - 1];

            samples[n + 70] += ac_out[n] + (sum >> 4);
        }

        for (int n = 0; n < 70; n++)
            samples[n] = ac_pred[n];

        for (int n = 0; n < s->nb_samples; n++)
            samples[n + 70] += ac_out[n] + samples[n + 69] * 3U - samples[n + 68] * 3U + samples[n + 67];

        finish = 1;

        if (finish == 1 && avctx->ch_layout.nb_channels == 2) {
            if (ch == 0)
                correlated = get_bits1(gb);

            finish = ch != 0;

            do_stereo(s, ch, correlated, 70);

            ch = 1;
        }
    }

    if (avctx->ch_layout.nb_channels == 1) {
        for (int n = 0; n < 70; n++)
            s->samples[0][n] = s->samples[0][s->nb_samples + n];
    }

    return 0;
}

