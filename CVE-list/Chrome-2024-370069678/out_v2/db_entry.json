{
  "cwe_type": "Use After Free",
  "cve_id": "Chrome-2024-370069678",
  "supplementary_code": "```cpp\n// This is used for managing simultaneous CompositorFrameReporter instances\n// in the case that the compositor has high latency. Calling one of the\n// event functions will begin recording the time of the corresponding\n// phase and trace it. If the frame is eventually submitted, then the\n// recorded times of each phase will be reported in UMA.\n// See CompositorFrameReporter.\nclass CC_EXPORT CompositorFrameReportingController {\npublic:\n// Used as indices for accessing CompositorFrameReporters.\nenum PipelineStage {\nkBeginImplFrame = 0,\nkBeginMainFrame,\nkReadyToCommit,\nkCommit,\nkActivate,\nkNumPipelineStages\n};\nCompositorFrameReportingController(bool should_report_histograms,\nbool should_report_ukm,\nint layer_tree_host_id);\nvirtual ~CompositorFrameReportingController();\nCompositorFrameReportingController(\nconst CompositorFrameReportingController&) = delete;\nCompositorFrameReportingController& operator=(\nconst CompositorFrameReportingController&) = delete;\n// Events to signal Beginning/Ending of phases.\nvirtual void WillBeginImplFrame(const viz::BeginFrameArgs& args);\nvirtual void WillBeginMainFrame(const viz::BeginFrameArgs& args);\nvirtual void BeginMainFrameAborted(const viz::BeginFrameId& id,\nCommitEarlyOutReason reason);\nvirtual void WillInvalidateOnImplSide();\nvirtual void WillCommit();\nvirtual void DidCommit();\nvirtual void WillActivate();\nvirtual void DidActivate();\nvirtual void DidSubmitCompositorFrame(\nSubmitInfo& submit_info,\nconst viz::BeginFrameId& current_frame_id,\nconst viz::BeginFrameId& last_activated_frame_id);\nvirtual void DidNotProduceFrame(const viz::BeginFrameId& id,\nFrameSkippedReason skip_reason);\nvirtual void OnFinishImplFrame(const viz::BeginFrameId& id);\nvirtual void DidPresentCompositorFrame(\nuint32_t frame_token,\nconst viz::FrameTimingDetails& details);\nvoid OnStoppedRequestingBeginFrames();\nvoid NotifyReadyToCommit(std::unique_ptr<BeginMainFrameMetrics> details);\nvoid InitializeUkmManager(std::unique_ptr<ukm::UkmRecorder> recorder);\nvoid SetSourceId(ukm::SourceId source_id);\nvoid AddActiveTracker(FrameSequenceTrackerType type);\nvoid RemoveActiveTracker(FrameSequenceTrackerType type);\nvoid SetScrollingThread(FrameInfo::SmoothEffectDrivingThread thread);\nvoid SetThreadAffectsSmoothness(\nFrameInfo::SmoothEffectDrivingThread thread_type,\nbool affects_smoothness);\nvoid set_tick_clock(const base::TickClock* tick_clock) {\nDCHECK(tick_clock);\ntick_clock_ = tick_clock;\n}\nstd::array<std::unique_ptr<CompositorFrameReporter>,\nPipelineStage::kNumPipelineStages>&\nReportersForTesting() {\nreturn reporters_;\n}\nvoid SetDroppedFrameCounter(DroppedFrameCounter* counter);\nvoid SetFrameSequenceTrackerCollection(\nFrameSequenceTrackerCollection* frame_sequence_trackers) {\nglobal_trackers_.frame_sequence_trackers = frame_sequence_trackers;\n}\nvoid set_event_latency_tracker(EventLatencyTracker* event_latency_tracker) {\nglobal_trackers_.event_latency_tracker = event_latency_tracker;\n}\nvoid BeginMainFrameStarted(base::TimeTicks begin_main_frame_start_time) {\nbegin_main_frame_start_time_ = begin_main_frame_start_time;\n}\nvoid SetNeedsRasterPropertiesAnimated(bool needs_raster_properties_animated) {\nneeds_raster_properties_animated_ = needs_raster_properties_animated;\n}\nbool HasReporterAt(PipelineStage stage) const;\nvoid SetVisible(bool visible);\nprotected:\nstruct SubmittedCompositorFrame {\nuint32_t frame_token;\nstd::unique_ptr<CompositorFrameReporter> reporter;\nSubmittedCompositorFrame();\nSubmittedCompositorFrame(uint32_t frame_token,\nstd::unique_ptr<CompositorFrameReporter> reporter);\nSubmittedCompositorFrame(SubmittedCompositorFrame&& other);\n~SubmittedCompositorFrame();\n};\nbase::TimeTicks Now() const;\nbool next_activate_has_invalidation() const {\nreturn next_activate_has_invalidation_;\n}\nprivate:\nusing SmoothThread = CompositorFrameReporter::SmoothThread;\nusing SmoothEffectDrivingThread =\nCompositorFrameReporter::SmoothEffectDrivingThread;\nvoid AdvanceReporterStage(PipelineStage start, PipelineStage target);\nbool CanSubmitImplFrame(const viz::BeginFrameId& id) const;\nbool CanSubmitMainFrame(const viz::BeginFrameId& id) const;\nstd::unique_ptr<CompositorFrameReporter> RestoreReporterAtBeginImpl(\nconst viz::BeginFrameId& id);\nSmoothThread GetSmoothThread() const;\nSmoothEffectDrivingThread GetScrollingThread() const;\nSmoothThread GetSmoothThreadAtTime(base::TimeTicks timestamp) const;\nSmoothEffectDrivingThread GetScrollThreadAtTime(\nbase::TimeTicks timestamp) const;\n// Checks whether there are reporters containing updates from the main\n// thread, and returns a pointer to that reporter (if any). Otherwise\n// returns nullptr.\nCompositorFrameReporter* GetOutstandingUpdatesFromMain(\nconst viz::BeginFrameId& id) const;\n// If the display-compositor skips over some frames (e.g. when the gpu is\n// busy, or the client is non-responsive), then it will not issue any\n// |BeginFrameArgs| for those frames. However, |CompositorFrameReporter|\n// instances should still be created for these frames. The following\n// functions accomplish this.\nvoid ProcessSkippedFramesIfNecessary(const viz::BeginFrameArgs& args);\nvoid MaybePassEventMetricsFromDroppedFrames(\nCompositorFrameReporter& reporter,\nuint32_t frame_token,\nbool next_reporter_from_same_frame);\nvoid StoreEventMetricsFromDroppedFrames(CompositorFrameReporter& reporter,\nuint32_t frame_token);\nvoid CreateReportersForDroppedFrames(\nconst viz::BeginFrameArgs& old_args,\nconst viz::BeginFrameArgs& new_args) const;\n// The arg is a reference to the unique_ptr, because depending on the state\n// that reporter is in, its ownership might be pass or not.\nvoid SetPartialUpdateDeciderWhenWaitingOnMain(\nstd::unique_ptr<CompositorFrameReporter>& reporter);\nvoid AddSortedFrame(const viz::BeginFrameArgs& args,\nconst FrameInfo& frame_info);\nconst bool should_report_histograms_;\nconst int layer_tree_host_id_;\nviz::BeginFrameId last_submitted_frame_id_;\nbool next_activate_has_invalidation_ = false;\nActiveTrackers active_trackers_;\nFrameInfo::SmoothEffectDrivingThread scrolling_thread_ =\nFrameInfo::SmoothEffectDrivingThread::kUnknown;\nbool is_compositor_thread_driving_smoothness_ = false;\nbool is_main_thread_driving_smoothness_ = false;\nbool is_raster_thread_driving_smoothness_ = false;\n// Sorted history of smooththread. Element i indicating the smooththread\n// from timestamp of element i-1 until timestamp of element i.\nstd::map<base::TimeTicks, SmoothThread> smooth_thread_history_;\n// Sorted history of scrollthread. Element i indicating the smooththread\n// from timestamp of element i-1 until timestamp of element i.\nstd::map<base::TimeTicks, SmoothEffectDrivingThread> scroll_thread_history_;\n// Must outlive `reporters_` and `submitted_compositor_frames_` (which also\n// have reporters), since destroying the reporters can flush frames to\n// `global_trackers_`.\nGlobalMetricsTrackers global_trackers_;\n// The latency reporter passed to each CompositorFrameReporter. Owned here\n// because it must be common among all reporters.\n// DO NOT reorder this line and the ones below. The latency_ukm_reporter_\n// must outlive the objects in |submitted_compositor_frames_|.\nstd::unique_ptr<LatencyUkmReporter> latency_ukm_reporter_;\nstd::unique_ptr<PredictorJankTracker> predictor_jank_tracker_;\nstd::unique_ptr<ScrollJankDroppedFrameTracker>\nscroll_jank_dropped_frame_tracker_;\nstd::unique_ptr<ScrollJankUkmReporter> scroll_jank_ukm_reporter_;\nstd::array<std::unique_ptr<CompositorFrameReporter>,\nPipelineStage::kNumPipelineStages>\nreporters_;\n// Mapping of frame token to pipeline reporter for submitted compositor\n// frames.\n// DO NOT reorder this line and the one above. The latency_ukm_reporter_\n// must outlive the objects in |submitted_compositor_frames_|.\nbase::circular_deque<SubmittedCompositorFrame> submitted_compositor_frames_;\n// Contains information about the latest frame that was started, and the state\n// during that frame. This is used to process skipped frames, as well as\n// making sure a CompositorFrameReporter object for a delayed main-frame is\n// created with the correct state.\nstruct {\nviz::BeginFrameArgs args;\nFrameInfo::SmoothEffectDrivingThread scrolling_thread =\nFrameInfo::SmoothEffectDrivingThread::kUnknown;\nActiveTrackers active_trackers;\nSmoothThread smooth_thread = SmoothThread::kSmoothNone;\n} last_started_compositor_frame_;\nbase::TimeTicks begin_main_frame_start_time_;\nraw_ptr<const base::TickClock> tick_clock_ =\nbase::DefaultTickClock::GetInstance();\n// When a frame with events metrics fails to be presented, its events metrics\n// will be added to this map. The first following presented frame will get\n// these metrics and report them. The key of map is submission frame token.\n// Frame token is chosen over BeginFrameId as key due to the fact that frames\n// can drop while a long running main still eventually presents, in which\n// cases its more appropriate to check against frame_token instead of\n// BeginFrameId.\nstd::map<uint32_t, EventMetricsSet> events_metrics_from_dropped_frames_;\nCompositorFrameReporter::CompositorLatencyInfo\nprevious_latency_predictions_main_;\nCompositorFrameReporter::CompositorLatencyInfo\nprevious_latency_predictions_impl_;\n// Container that stores the EventLatency stage latency predictions based on\n// previous event traces.\nCompositorFrameReporter::EventLatencyInfo event_latency_predictions_;\n// Reporting controller needs to track transition of the page from invisible\n// to visible in order to discard EventsMetrics impacted by duration of page\n// being invisible\nbool visible_ = true;\nbool waiting_for_did_present_after_visible_ = false;\n// Indicates whether or not we expect the next frame to contain an animation\n// which requires impl invalidation.\nbool needs_raster_properties_animated_ = false;\n};\n```\n```cpp\nstruct GlobalMetricsTrackers {\n// RAW_PTR_EXCLUSION: Renderer performance: visible in sampling profiler\n// stacks.\nRAW_PTR_EXCLUSION DroppedFrameCounter* dropped_frame_counter = nullptr;\nRAW_PTR_EXCLUSION LatencyUkmReporter* latency_ukm_reporter = nullptr;\nRAW_PTR_EXCLUSION FrameSequenceTrackerCollection* frame_sequence_trackers =\nnullptr;\nRAW_PTR_EXCLUSION EventLatencyTracker* event_latency_tracker = nullptr;\nRAW_PTR_EXCLUSION PredictorJankTracker* predictor_jank_tracker = nullptr;\nRAW_PTR_EXCLUSION ScrollJankDroppedFrameTracker*\nscroll_jank_dropped_frame_tracker = nullptr;\nRAW_PTR_EXCLUSION ScrollJankUkmReporter* scroll_jank_ukm_reporter = nullptr;\n};\n```\n```cpp\nvoid CompositorFrameReporter::TerminateFrame(\nFrameTerminationStatus termination_status,\nbase::TimeTicks termination_time) {\n// If the reporter is already terminated, (possibly as a result of no damage)\n// then we don't need to do anything here, otherwise the reporter will be\n// terminated.\nif (frame_termination_status_ != FrameTerminationStatus::kUnknown)\nreturn;\nframe_termination_status_ = termination_status;\nframe_termination_time_ = termination_time;\nEndCurrentStage(frame_termination_time_);\n}\n```\n```cpp\nclass CC_EXPORT PredictorJankTracker {\npublic:\nPredictorJankTracker();\n~PredictorJankTracker();\nPredictorJankTracker(const PredictorJankTracker&) = delete;\nPredictorJankTracker& operator=(const PredictorJankTracker);\n// Emits predictor scroll jank metrics for every frame relative\n// to the previous and the next frame.\n// For more details about the how a frame is deemed janky after\n// delta prediction is applied please check:\n// http://doc/1Y0u0Tq5eUZff75nYUzQVw6JxmbZAW9m64pJidmnGWsY\nvoid ReportLatestScrollDelta(float delta,\nbase::TimeTicks presentation_ts,\nbase::TimeDelta vsync_interval,\nstd::optional<EventMetrics::TraceId> trace_id);\n// Whenever a new scroll starts, data inside this class will be erased\n// as it should be comparing neighbouring frames only.\nvoid ResetCurrentScrollReporting();\nvoid set_scroll_jank_ukm_reporter(\nScrollJankUkmReporter* scroll_jank_ukm_reporter) {\nscroll_jank_ukm_reporter_ = scroll_jank_ukm_reporter;\n}\nstatic float GetSlowScrollDeltaThreshold();\nstatic float GetSlowScrollJankyThreshold();\nstatic float GetFastScrollJankyThreshold();\nprivate:\n// The metric works by storing a sliding window of the previous two\n// frames, this function moves the sliding window storing the newer\n// frame information.\nvoid StoreLatestFrameData(float delta,\nbase::TimeTicks presentation_ts,\nstd::optional<EventMetrics::TraceId> trace_id);\nvoid ReportJankyFrame(float next_delta,\nfloat janky_value,\nbool contains_missed_vsyncs,\nbool slow_scroll,\nstd::optional<EventMetrics::TraceId> trace_id);\n// Finds if a sequence of 3 consecutive frames were presnted in\n// consecutive vsyncs, or some vsyncs were missed.\nbool ContainsMissedVSync(base::TimeTicks& presentation_ts,\nbase::TimeDelta& vsync_interval);\nvoid ReportJankyFramePercentage();\n// Data holder for deltas and presentation timestamps in previous frames\nstruct FrameData {\n// Delta for the previous frame in pixels.\nfloat prev_delta_ = 0;\n// The EventLatency event_trace_id value if available.\nstd::optional<EventMetrics::TraceId> prev_trace_id_;\n// Delta for the current frame in pixels.\nfloat cur_delta_ = 0;\n// The EventLatency event_trace_id value if available.\nstd::optional<EventMetrics::TraceId> cur_trace_id_;\n// Presentation timestamp of the previous frame.\nbase::TimeTicks prev_presentation_ts_;\n// Presentation timestamp for the currentframe.\nbase::TimeTicks cur_presentation_ts_;\n} frame_data_;\nfloat total_frames_ = 0;\nfloat janky_frames_ = 0;\nraw_ptr<ScrollJankUkmReporter> scroll_jank_ukm_reporter_ = nullptr;\n};\n```",
  "original_code": "```cpp\nCompositorFrameReportingController::~CompositorFrameReportingController() {\nbase::TimeTicks now = Now();\nfor (int i = 0; i < PipelineStage::kNumPipelineStages; ++i) {\nif (reporters_[i]) {\nreporters_[i]->TerminateFrame(FrameTerminationStatus::kDidNotProduceFrame,\nnow);\n}\n}\nfor (auto& pair : submitted_compositor_frames_) {\npair.reporter->TerminateFrame(FrameTerminationStatus::kDidNotPresentFrame,\nNow());\n}\npredictor_jank_tracker_->set_scroll_jank_ukm_reporter(nullptr);\nscroll_jank_dropped_frame_tracker_->set_scroll_jank_ukm_reporter(nullptr);\n}\n```",
  "vuln_patch": "```cpp\nCompositorFrameReportingController::~CompositorFrameReportingController() {\nif (global_trackers_.dropped_frame_counter) {\nglobal_trackers_.dropped_frame_counter->SetSortedFrameCallback(\nbase::NullCallback());\n}\nbase::TimeTicks now = Now();\nfor (int i = 0; i < PipelineStage::kNumPipelineStages; ++i) {\nif (reporters_[i]) {\nreporters_[i]->TerminateFrame(FrameTerminationStatus::kDidNotProduceFrame,\nnow);\n}\n}\nfor (auto& pair : submitted_compositor_frames_) {\npair.reporter->TerminateFrame(FrameTerminationStatus::kDidNotPresentFrame,\nNow());\n}\npredictor_jank_tracker_->set_scroll_jank_ukm_reporter(nullptr);\nscroll_jank_dropped_frame_tracker_->set_scroll_jank_ukm_reporter(nullptr);\n}\n```",
  "function_name": "CompositorFrameReportingController::~CompositorFrameReportingController",
  "function_prototype": "CompositorFrameReportingController::~CompositorFrameReportingController()",
  "code_semantics": "The destructor of the class performs cleanup by first getting the current time. It then iterates over a collection of objects, terminating a process for each existing object with a specific status and the current time. It also iterates over another collection, terminating a process for each object with a different status and the current time. Finally, it sets certain pointers to null, disconnecting them from any associated objects.",
  "vulnerability_checklist": "1. Check if global_trackers_.dropped_frame_counter is properly nullified or reset before the destructor completes. 2. Verify that each element in reporters_ is safely terminated using TerminateFrame() before the destructor completes. 3. Ensure that each reporter in submitted_compositor_frames_ is safely terminated using TerminateFrame() before the destructor completes.",
  "safe_verification_cot": "1. The Target Code includes a check and nullification for global_trackers_.dropped_frame_counter using SetSortedFrameCallback(base::NullCallback()), preventing the use-after-free condition. 2. The Target Code continues to correctly terminate each element in reporters_ using TerminateFrame(). 3. The Target Code continues to correctly terminate each reporter in submitted_compositor_frames_ using TerminateFrame().",
  "verification_cot": "1. The Vulnerable Code does not nullify or reset global_trackers_.dropped_frame_counter before the destructor completes, which can lead to a use-after-free condition if the memory is accessed after being freed. 2. The Vulnerable Code correctly terminates each element in reporters_ using TerminateFrame(). 3. The Vulnerable Code correctly terminates each reporter in submitted_compositor_frames_ using TerminateFrame().",
  "vulnerability_related_variables": {
    "global_trackers_.dropped_frame_counter": "This variable is intended to keep track of the number of frames that were not successfully rendered or presented. It is part of a larger structure that aggregates various metrics related to frame rendering performance.",
    "reporters_": "This is a collection of objects, each responsible for monitoring and reporting the performance of a specific stage in a multi-stage process. Each object can be terminated with a specific status and timestamp, indicating the completion or failure of its associated stage.",
    "submitted_compositor_frames_": "This is a collection of objects, each representing a frame that has been submitted for rendering. Each object can be terminated with a specific status and timestamp, indicating whether the frame was successfully presented or not."
  },
  "vulnerability_related_functions": {
    "CompositorFrameReportingController::~CompositorFrameReportingController()": "This function is a destructor that performs cleanup operations. It iterates over a collection of objects, invoking a termination method on each to mark them as not having produced or presented a frame. It also nullifies certain pointers to ensure no further operations are performed on them.",
    "TerminateFrame()": "This function checks if a status variable is in an initial state. If it is, it updates this status and a timestamp variable with provided values. It then calls another function to finalize the current stage using the updated timestamp."
  },
  "root_cause": "The root cause of the vulnerability is a use-after-free condition due to the failure to nullify or reset global_trackers_.dropped_frame_counter before the destructor completes.",
  "patch_cot": "To patch the vulnerability similar to the CVE in the provided vulnerable code, follow these steps:\n1. Reset or Nullify global_trackers_.dropped_frame_counter: Before the destructor of CompositorFrameReportingController completes, check if global_trackers_.dropped_frame_counter is non-null. If it is, reset its callback to base::NullCallback() to prevent any use-after-free conditions.\n2. Terminate reporters_ Safely: Iterate over the reporters_ array and ensure that each element is properly terminated using the TerminateFrame() function. This ensures that no dangling pointers are left that could lead to use-after-free conditions.\n3. Terminate submitted_compositor_frames_ Safely: Similarly, iterate over submitted_compositor_frames_ and ensure that each reporter is properly terminated using TerminateFrame(). This ensures that all resources are properly released and no use-after-free conditions occur.",
  "fix_list": "1. Verify that variable global_trackers_.dropped_frame_counter is properly reset or nullified before the destructor of CompositorFrameReportingController completes.\n2. Check if function TerminateFrame() is safely handling variable reporters_ by ensuring all elements are properly terminated.\n3. Ensure that all elements in submitted_compositor_frames_ are properly terminated using TerminateFrame() before the destructor completes."
}