{
  "cwe_type": "Incorrect Check of Function Return Value",
  "cve_id": "CVE-2024-58082",
  "supplementary_code": "```c\nstruct npcm_video {\nstruct regmap *gcr_regmap;\nstruct regmap *gfx_regmap;\nstruct regmap *vcd_regmap;\nstruct device *dev;\nstruct v4l2_ctrl_handler ctrl_handler;\nstruct v4l2_ctrl *rect_cnt_ctrl;\nstruct v4l2_device v4l2_dev;\nstruct v4l2_pix_format pix_fmt;\nstruct v4l2_bt_timings active_timings;\nstruct v4l2_bt_timings detected_timings;\nunsigned int v4l2_input_status;\nstruct vb2_queue queue;\nstruct video_device vdev;\nstruct mutex video_lock; /* v4l2 and videobuf2 lock */\nstruct list_head buffers;\nstruct mutex buffer_lock; /* buffer list lock */\nunsigned long flags;\nunsigned int sequence;\nstruct npcm_video_addr src;\nstruct reset_control *reset;\nstruct npcm_ece ece;\nunsigned int bytesperline;\nunsigned int bytesperpixel;\nunsigned int rect_cnt;\nstruct list_head list[VIDEO_MAX_FRAME];\nunsigned int rect[VIDEO_MAX_FRAME];\nunsigned int ctrl_cmd;\nunsigned int op_cmd;\n};\n```\n```c\nstruct device {\nstruct kobject kobj;\nstruct device *parent;\nstruct device_private *p;\nconst char *init_name; /* initial name of the device */\nconst struct device_type *type;\nconst struct bus_type *bus; /* type of bus device is on */\nstruct device_driver *driver; /* which driver has allocated this\ndevice */\nvoid *platform_data; /* Platform specific data, device\ncore doesn't touch it */\nvoid *driver_data; /* Driver data, set and get with\ndev_set_drvdata/dev_get_drvdata */\nstruct mutex mutex; /* mutex to synchronize calls to\n* its driver.\n*/\nstruct dev_links_info links;\nstruct dev_pm_info power;\nstruct dev_pm_domain *pm_domain;\n#ifdef CONFIG_ENERGY_MODEL\nstruct em_perf_domain *em_pd;\n#endif\n#ifdef CONFIG_PINCTRL\nstruct dev_pin_info *pins;\n#endif\nstruct dev_msi_info msi;\n#ifdef CONFIG_ARCH_HAS_DMA_OPS\nconst struct dma_map_ops *dma_ops;\n#endif\nu64 *dma_mask; /* dma mask (if dma'able device) */\nu64 coherent_dma_mask;/* Like dma_mask, but for\nalloc_coherent mappings as\nnot all hardware supports\n64 bit addresses for consistent\nallocations such descriptors. */\nu64 bus_dma_limit; /* upstream dma constraint */\nconst struct bus_dma_region *dma_range_map;\nstruct device_dma_parameters *dma_parms;\nstruct list_head dma_pools; /* dma pools (if dma'ble) */\n#ifdef CONFIG_DMA_DECLARE_COHERENT\nstruct dma_coherent_mem *dma_mem; /* internal for coherent mem\noverride */\n#endif\n#ifdef CONFIG_DMA_CMA\nstruct cma *cma_area; /* contiguous memory area for dma\nallocations */\n#endif\n#ifdef CONFIG_SWIOTLB\nstruct io_tlb_mem *dma_io_tlb_mem;\n#endif\n#ifdef CONFIG_SWIOTLB_DYNAMIC\nstruct list_head dma_io_tlb_pools;\nspinlock_t dma_io_tlb_lock;\nbool dma_uses_io_tlb;\n#endif\n/* arch specific additions */\nstruct dev_archdata archdata;\nstruct device_node *of_node; /* associated device tree node */\nstruct fwnode_handle *fwnode; /* firmware device node */\n#ifdef CONFIG_NUMA\nint numa_node; /* NUMA node this device is close to */\n#endif\ndev_t devt; /* dev_t, creates the sysfs \"dev\" */\nu32 id; /* device instance */\nspinlock_t devres_lock;\nstruct list_head devres_head;\nconst struct class *class;\nconst struct attribute_group **groups; /* optional groups */\nvoid (*release)(struct device *dev);\nstruct iommu_group *iommu_group;\nstruct dev_iommu *iommu;\nstruct device_physical_location *physical_location;\nenum device_removable removable;\nbool offline_disabled:1;\nbool offline:1;\nbool of_node_reused:1;\nbool state_synced:1;\nbool can_match:1;\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\ndefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\ndefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)\nbool dma_coherent:1;\n#endif\n#ifdef CONFIG_DMA_OPS_BYPASS\nbool dma_ops_bypass : 1;\n#endif\n#ifdef CONFIG_DMA_NEED_SYNC\nbool dma_skip_sync:1;\n#endif\n#ifdef CONFIG_IOMMU_DMA\nbool dma_iommu:1;\n#endif\n};\n```\n```c\nstruct device_node {\nconst char *name;\nphandle phandle;\nconst char *full_name;\nstruct fwnode_handle fwnode;\nstruct property *properties;\nstruct property *deadprops; /* removed properties */\nstruct device_node *parent;\nstruct device_node *child;\nstruct device_node *sibling;\n#if defined(CONFIG_OF_KOBJ)\nstruct kobject kobj;\n#endif\nunsigned long _flags;\nvoid *data;\n#if defined(CONFIG_SPARC)\nunsigned int unique_id;\nstruct of_irq_controller *irq_trans;\n#endif\n};\n```\n```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstatic inline struct device_node *of_parse_phandle(const struct device_node *np,\nconst char *phandle_name,\nint index)\n{\nstruct of_phandle_args args;\nif (__of_parse_phandle_with_args(np, phandle_name, NULL, 0,\nindex, &args))\nreturn NULL;\nreturn args.np;\n}\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\n#define ENODEV 19 /* No such device */\n```\n```c\nstatic inline bool of_device_is_available(const struct device_node *device)\n{\nreturn false;\n}\n```\n```c\n#define dev_info(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_info, KERN_INFO, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline struct platform_device *of_find_device_by_node(struct device_node *np)\n{\nreturn NULL;\n}\n```\n```c\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\nreturn IS_ERR_VALUE((unsigned long)ptr);\n}\n```\n```c\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\nreturn (long) ptr;\n}\n```\n```c\nstatic inline void of_node_put(struct device_node *node) { }\n```\n```c\nstatic inline void __iomem *\ndevm_platform_ioremap_resource(struct platform_device *pdev,\nunsigned int index)\n{\nreturn ERR_PTR(-EINVAL);\n}\n```\n```c\n#define devm_regmap_init_mmio(dev, regs, config) \\\ndevm_regmap_init_mmio_clk(dev, NULL, regs, config)\n```\n```c\nstatic inline struct reset_control *devm_reset_control_get(\nstruct device *dev, const char *id)\n{\nreturn devm_reset_control_get_exclusive(dev, id);\n}\n```",
  "original_code": "```c\nstatic int npcm_video_ece_init(struct npcm_video *video)\n{\nstruct device *dev = video->dev;\nstruct device_node *ece_node;\nstruct platform_device *ece_pdev;\nvoid __iomem *regs;\nece_node = of_parse_phandle(video->dev->of_node, \"nuvoton,ece\", 0);\nif (!ece_node) {\ndev_err(dev, \"Failed to get ECE phandle in DTS\\n\");\nreturn -ENODEV;\n}\nvideo->ece.enable = of_device_is_available(ece_node);\nif (video->ece.enable) {\ndev_info(dev, \"Support HEXTILE pixel format\\n\");\nece_pdev = of_find_device_by_node(ece_node);\nif (IS_ERR(ece_pdev)) {\ndev_err(dev, \"Failed to find ECE device\\n\");\nreturn PTR_ERR(ece_pdev);\n}\nof_node_put(ece_node);\nregs = devm_platform_ioremap_resource(ece_pdev, 0);\nif (IS_ERR(regs)) {\ndev_err(dev, \"Failed to parse ECE reg in DTS\\n\");\nreturn PTR_ERR(regs);\n}\nvideo->ece.regmap = devm_regmap_init_mmio(dev, regs,\n&npcm_video_ece_regmap_cfg);\nif (IS_ERR(video->ece.regmap)) {\ndev_err(dev, \"Failed to initialize ECE regmap\\n\");\nreturn PTR_ERR(video->ece.regmap);\n}\nvideo->ece.reset = devm_reset_control_get(&ece_pdev->dev, NULL);\nif (IS_ERR(video->ece.reset)) {\ndev_err(dev, \"Failed to get ECE reset control in DTS\\n\");\nreturn PTR_ERR(video->ece.reset);\n}\n}\nreturn 0;\n}\n```",
  "vuln_patch": "```c\nstatic int npcm_video_ece_init(struct npcm_video *video)\n{\nstruct device *dev = video->dev;\nstruct device_node *ece_node;\nstruct platform_device *ece_pdev;\nvoid __iomem *regs;\nece_node = of_parse_phandle(video->dev->of_node, \"nuvoton,ece\", 0);\nif (!ece_node) {\ndev_err(dev, \"Failed to get ECE phandle in DTS\\n\");\nreturn -ENODEV;\n}\nvideo->ece.enable = of_device_is_available(ece_node);\nif (video->ece.enable) {\ndev_info(dev, \"Support HEXTILE pixel format\\n\");\nece_pdev = of_find_device_by_node(ece_node);\nif (!ece_pdev) {\ndev_err(dev, \"Failed to find ECE device\\n\");\nreturn -ENODEV;\n}\nof_node_put(ece_node);\nregs = devm_platform_ioremap_resource(ece_pdev, 0);\nif (IS_ERR(regs)) {\ndev_err(dev, \"Failed to parse ECE reg in DTS\\n\");\nreturn PTR_ERR(regs);\n}\nvideo->ece.regmap = devm_regmap_init_mmio(dev, regs,\n&npcm_video_ece_regmap_cfg);\nif (IS_ERR(video->ece.regmap)) {\ndev_err(dev, \"Failed to initialize ECE regmap\\n\");\nreturn PTR_ERR(video->ece.regmap);\n}\nvideo->ece.reset = devm_reset_control_get(&ece_pdev->dev, NULL);\nif (IS_ERR(video->ece.reset)) {\ndev_err(dev, \"Failed to get ECE reset control in DTS\\n\");\nreturn PTR_ERR(video->ece.reset);\n}\n}\nreturn 0;\n}\n```",
  "function_name": "npcm_video_ece_init",
  "function_prototype": "static int npcm_video_ece_init(struct npcm_video *video)",
  "code_semantics": "The function is responsible for setting up a specific hardware component related to video processing. It starts by locating a configuration node for the component in a hierarchical configuration structure. It checks if the component is available for use. If available, it proceeds to find the associated hardware device. It then maps the necessary memory resources for the device, sets up a mechanism to access hardware registers, and acquires a control mechanism to reset the device if needed. The function logs any issues encountered during these steps and returns an error code if any step fails. If all steps are successful, it completes the setup process and returns a success code.",
  "safe_verification_cot": "1. The function of_find_device_by_node is called, and its return value is assigned to ece_pdev. 2. The code correctly checks if ece_pdev is NULL using !ece_pdev. 3. This correct check ensures that the failure of of_find_device_by_node is properly handled, preventing the vulnerability.",
  "verification_cot": "1. The function of_find_device_by_node is called, and its return value is assigned to ece_pdev. 2. The code incorrectly uses IS_ERR(ece_pdev) to check if ece_pdev is valid. 3. Since of_find_device_by_node returns NULL on failure, the use of IS_ERR does not correctly identify the failure, leading to improper error handling and potential undefined behavior.",
  "vulnerability_related_variables": {
    "ece_pdev": "This variable represents a platform device found by a specific node in the device tree. It is checked for errors to ensure successful retrieval. It is used to map I/O memory resources and to obtain a reset control for the device."
  },
  "vulnerability_related_functions": {
    "of_find_device_by_node": "This function takes a reference to a device node and attempts to locate a platform device associated with it. If the device is found, it returns a reference to the platform device. If the device is not found, it returns an error indicator.",
    "IS_ERR": "This function checks if a given pointer is an error indicator. It returns a boolean value indicating whether the pointer represents an error."
  },
  "root_cause": "Incorrect check of function return value using IS_ERR instead of checking for NULL.",
  "patch_cot": "First, identify where the function of_find_device_by_node is used in the code and which variable it assigns its return value to. In this case, it is ece_pdev. Replace the incorrect error check using IS_ERR(ece_pdev) with a check for NULL using !ece_pdev. Ensure that after checking for NULL, appropriate error handling is performed, such as logging an error message and returning an error code."
}