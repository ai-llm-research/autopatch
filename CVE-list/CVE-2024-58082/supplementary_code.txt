```c
struct npcm_video {
    struct regmap *gcr_regmap;
    struct regmap *gfx_regmap;
    struct regmap *vcd_regmap;

    struct device *dev;
    struct v4l2_ctrl_handler ctrl_handler;
    struct v4l2_ctrl *rect_cnt_ctrl;
    struct v4l2_device v4l2_dev;
    struct v4l2_pix_format pix_fmt;
    struct v4l2_bt_timings active_timings;
    struct v4l2_bt_timings detected_timings;
    unsigned int v4l2_input_status;
    struct vb2_queue queue;
    struct video_device vdev;
    struct mutex video_lock; /* v4l2 and videobuf2 lock */

    struct list_head buffers;
    struct mutex buffer_lock; /* buffer list lock */
    unsigned long flags;
    unsigned int sequence;

    struct npcm_video_addr src;
    struct reset_control *reset;
    struct npcm_ece ece;

    unsigned int bytesperline;
    unsigned int bytesperpixel;
    unsigned int rect_cnt;
    struct list_head list[VIDEO_MAX_FRAME];
    unsigned int rect[VIDEO_MAX_FRAME];
    unsigned int ctrl_cmd;
    unsigned int op_cmd;
};
```

```c
struct device {
    struct kobject kobj;
    struct device       *parent;

    struct device_private   *p;

    const char      *init_name; /* initial name of the device */
    const struct device_type *type;

    const struct bus_type   *bus;   /* type of bus device is on */
    struct device_driver *driver;   /* which driver has allocated this
                       device */
    void        *platform_data; /* Platform specific data, device
                       core doesn't touch it */
    void        *driver_data;   /* Driver data, set and get with
                       dev_set_drvdata/dev_get_drvdata */
    struct mutex        mutex;  /* mutex to synchronize calls to
                     * its driver.
                     */

    struct dev_links_info   links;
    struct dev_pm_info  power;
    struct dev_pm_domain    *pm_domain;

#ifdef CONFIG_ENERGY_MODEL
    struct em_perf_domain   *em_pd;
#endif

#ifdef CONFIG_PINCTRL
    struct dev_pin_info *pins;
#endif
    struct dev_msi_info msi;
#ifdef CONFIG_ARCH_HAS_DMA_OPS
    const struct dma_map_ops *dma_ops;
#endif
    u64     *dma_mask;  /* dma mask (if dma'able device) */
    u64     coherent_dma_mask;/* Like dma_mask, but for
                         alloc_coherent mappings as
                         not all hardware supports
                         64 bit addresses for consistent
                         allocations such descriptors. */
    u64     bus_dma_limit;  /* upstream dma constraint */
    const struct bus_dma_region *dma_range_map;

    struct device_dma_parameters *dma_parms;

    struct list_head    dma_pools;  /* dma pools (if dma'ble) */

#ifdef CONFIG_DMA_DECLARE_COHERENT
    struct dma_coherent_mem *dma_mem; /* internal for coherent mem
                         override */
#endif
#ifdef CONFIG_DMA_CMA
    struct cma *cma_area;       /* contiguous memory area for dma
                       allocations */
#endif
#ifdef CONFIG_SWIOTLB
    struct io_tlb_mem *dma_io_tlb_mem;
#endif
#ifdef CONFIG_SWIOTLB_DYNAMIC
    struct list_head dma_io_tlb_pools;
    spinlock_t dma_io_tlb_lock;
    bool dma_uses_io_tlb;
#endif
    /* arch specific additions */
    struct dev_archdata archdata;

    struct device_node  *of_node; /* associated device tree node */
    struct fwnode_handle    *fwnode; /* firmware device node */

#ifdef CONFIG_NUMA
    int     numa_node;  /* NUMA node this device is close to */
#endif
    dev_t           devt;   /* dev_t, creates the sysfs "dev" */
    u32         id; /* device instance */

    spinlock_t      devres_lock;
    struct list_head    devres_head;

    const struct class  *class;
    const struct attribute_group **groups;  /* optional groups */

    void    (*release)(struct device *dev);
    struct iommu_group  *iommu_group;
    struct dev_iommu    *iommu;

    struct device_physical_location *physical_location;

    enum device_removable   removable;

    bool            offline_disabled:1;
    bool            offline:1;
    bool            of_node_reused:1;
    bool            state_synced:1;
    bool            can_match:1;
#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
    bool            dma_coherent:1;
#endif
#ifdef CONFIG_DMA_OPS_BYPASS
    bool            dma_ops_bypass : 1;
#endif
#ifdef CONFIG_DMA_NEED_SYNC
    bool            dma_skip_sync:1;
#endif
#ifdef CONFIG_IOMMU_DMA
    bool            dma_iommu:1;
#endif
};
```

```c
struct device_node {
    const char *name;
    phandle phandle;
    const char *full_name;
    struct fwnode_handle fwnode;

    struct  property *properties;
    struct  property *deadprops;    /* removed properties */
    struct  device_node *parent;
    struct  device_node *child;
    struct  device_node *sibling;
#if defined(CONFIG_OF_KOBJ)
    struct  kobject kobj;
#endif
    unsigned long _flags;
    void    *data;
#if defined(CONFIG_SPARC)
    unsigned int unique_id;
    struct of_irq_controller *irq_trans;
#endif
};
```

```c
struct platform_device {
    const char  *name;
    int     id;
    bool        id_auto;
    struct device   dev;
    u64     platform_dma_mask;
    struct device_dma_parameters dma_parms;
    u32     num_resources;
    struct resource *resource;

    const struct platform_device_id *id_entry;
    /*
     * Driver name to force a match.  Do not set directly, because core
     * frees it.  Use driver_set_override() to set or clear it.
     */
    const char *driver_override;

    /* MFD cell pointer */
    struct mfd_cell *mfd_cell;

    /* arch specific additions */
    struct pdev_archdata    archdata;
};
```

```c
static inline struct device_node *of_parse_phandle(const struct device_node *np,
                           const char *phandle_name,
                           int index)
{
    struct of_phandle_args args;

    if (__of_parse_phandle_with_args(np, phandle_name, NULL, 0,
                     index, &args))
        return NULL;

    return args.np;
}
```

```c
#define dev_err(dev, fmt, ...) \
    dev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)
```

```c
#define ENODEV      19  /* No such device */
```

```c
static inline bool of_device_is_available(const struct device_node *device)
{
    return false;
}
```

```c
#define dev_info(dev, fmt, ...) \
    dev_printk_index_wrap(_dev_info, KERN_INFO, dev, dev_fmt(fmt), ##__VA_ARGS__)
```

```c
static inline struct platform_device *of_find_device_by_node(struct device_node *np)
{
    return NULL;
}
```

```c
static inline bool __must_check IS_ERR(__force const void *ptr)
{
    return IS_ERR_VALUE((unsigned long)ptr);
}
```

```c
static inline long __must_check PTR_ERR(__force const void *ptr)
{
    return (long) ptr;
}
```

```c
static inline void of_node_put(struct device_node *node) { }
```

```c
static inline void __iomem *
devm_platform_ioremap_resource(struct platform_device *pdev,
                   unsigned int index)
{
    return ERR_PTR(-EINVAL);
}
```

```c
#define devm_regmap_init_mmio(dev, regs, config)        \
    devm_regmap_init_mmio_clk(dev, NULL, regs, config)
```

```c
static inline struct reset_control *devm_reset_control_get(
                struct device *dev, const char *id)
{
    return devm_reset_control_get_exclusive(dev, id);
}
```
