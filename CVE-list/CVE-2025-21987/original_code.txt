```c
int amdgpu_ttm_clear_buffer(struct amdgpu_bo *bo, struct dma_resv *resv, struct dma_fence **fence)
{
	struct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);
	struct amdgpu_ring *ring = adev->mman.buffer_funcs_ring;
	struct amdgpu_res_cursor cursor;
	u64 addr;
	int r;

	if (!adev->mman.buffer_funcs_enabled)
		return -EINVAL;

	if (!fence)
		return -EINVAL;

	*fence = dma_fence_get_stub();

	amdgpu_res_first(bo->tbo.resource, 0, amdgpu_bo_size(bo), &cursor);

	mutex_lock(&adev->mman.gtt_window_lock);
	while (cursor.remaining) {
		struct dma_fence *next = NULL;
		u64 size;

		if (amdgpu_res_cleared(&cursor)) {
			amdgpu_res_next(&cursor, cursor.size);
			continue;
		}

		/* Never clear more than 256MiB at once to avoid timeouts */
		size = min(cursor.size, 256ULL << 20);

		r = amdgpu_ttm_map_buffer(&bo->tbo, bo->tbo.resource, &cursor,
					  1, ring, false, &size, &addr);
		if (r)
			goto err;

		r = amdgpu_ttm_fill_mem(ring, 0, addr, size, resv,
					&next, true, true);
		if (r)
			goto err;

		dma_fence_put(*fence);
		*fence = next;

		amdgpu_res_next(&cursor, size);
	}
err:
	mutex_unlock(&adev->mman.gtt_window_lock);

	return r;
}
```
