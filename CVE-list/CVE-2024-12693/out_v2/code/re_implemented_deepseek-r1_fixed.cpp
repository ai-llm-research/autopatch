

class ValueNode {
public:
    enum class ValueRepresentation {
        kTagged
    };

    virtual ~ValueNode() {}
    virtual int value_representation() const { return static_cast<int>(ValueRepresentation::kTagged); }
    virtual class Phi* TryCastPhi() { return nullptr; }
};

class Phi : public ValueNode {
public:
    int input_count() const { return 0; }
    struct Input {
        ValueNode* node() { return nullptr; }
    };
    Input input(int i) { return Input(); }
    void set_input(int i, ValueNode* node) {}
};

enum class NewNodePosition {
    kEndOfBlock
};

template <typename T>
class optional {};

class MaglevPhiRepresentationSelector {
public:
    void EnsurePhiInputsTagged(Phi* phi);

private:
    ValueNode* EnsurePhiTagged(Phi* phi, int current_block, NewNodePosition position, int state, optional<int> opt) { return nullptr; }
    int current_block_;
    int state_;
};

void MaglevPhiRepresentationSelector::EnsurePhiInputsTagged(Phi* phi) {
    for (int i = 0; i < phi->input_count(); ++i) {
        ValueNode* input = phi->input(i).node();
        if (Phi* phi_input = input->TryCastPhi()) {
            ValueNode* tagged_phi = EnsurePhiTagged(phi_input, current_block_, NewNodePosition::kEndOfBlock, state_, optional<int>());
            phi->set_input(i, tagged_phi);
        } else {
            // DCHECK(input->value_representation() == ValueRepresentation::kTagged);
        }
    }
}

