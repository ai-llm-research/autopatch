

class ValueNode {
public:
    virtual ~ValueNode() {}
    virtual ValueNode* TryCast() {
        return this;
    }
    
    virtual int value_representation() const {
        return 0;
    }
};

class Phi : public ValueNode {
public:
    int input_count() const {
        return 0;
    }

    ValueNode* input(int index) const {
        return nullptr;
    }

    void set_input(int index, ValueNode* node) {}
};

class MaglevPhiRepresentationSelector {
public:
    void EnsurePhiInputsTagged(Phi* phi);

private:
    ValueNode* EnsurePhiTagged(Phi* phi_input, int current_block, int node_position, int current_state, int opt) {
        return nullptr;
    }

    int current_block_;
    int current_state_;
};

namespace NewNodePosition {
    const int kEndOfBlock = 0;
}

namespace ValueRepresentation {
    const int kTagged = 0;
}

#define DCHECK_EQ(x, y)

void MaglevPhiRepresentationSelector::EnsurePhiInputsTagged(Phi* phi) {
    for (int i = 0; i < phi->input_count(); i++) {
        ValueNode* input = phi->input(i);

        if (Phi* phi_input = dynamic_cast<Phi*>(input->TryCast())) {
            ValueNode* tagged = EnsurePhiTagged(
                phi_input,
                current_block_,
                NewNodePosition::kEndOfBlock,
                current_state_,
                0
            );
            phi->set_input(i, tagged);
        } else {
            DCHECK_EQ(input->value_representation(), ValueRepresentation::kTagged);
        }
    }
}

