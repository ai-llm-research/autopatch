{
  "cwe_type": "Use After Free",
  "cve_id": "CVE-2025-21861",
  "supplementary_code": "```c\nstruct folio {\nstruct page page;\n};\n```\n```c\nstruct page {\nunsigned long long dummy;\n};\n```\n```c\nstatic inline struct page *migrate_pfn_to_page(unsigned long mpfn)\n{\nif (!(mpfn & MIGRATE_PFN_VALID))\nreturn NULL;\nreturn pfn_to_page(mpfn >> MIGRATE_PFN_SHIFT);\n}\n```\n```c\n#define page_folio(p) (_Generic((p), \\\nconst struct page *: (const struct folio *)_compound_head(p), \\\nstruct page *: (struct folio *)_compound_head(p)))\n```\n```c\nvoid folio_unlock(struct folio *folio)\n{\n/* Bit 7 allows x86 to check the byte's sign bit */\nBUILD_BUG_ON(PG_waiters != 7);\nBUILD_BUG_ON(PG_locked > 7);\nVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\nif (folio_xor_flags_has_waiters(folio, 1 << PG_locked))\nfolio_wake_bit(folio, PG_locked);\n}\nEXPORT_SYMBOL(folio_unlock);\n```\n```c\nstatic inline void folio_put(struct folio *folio)\n{\nif (folio_put_testzero(folio))\n__folio_put(folio);\n}\n```\n```c\nvoid remove_migration_ptes(struct folio *src, struct folio *dst, int flags)\n{\nstruct rmap_walk_arg rmap_walk_arg = {\n.folio = src,\n.map_unused_to_zeropage = flags & RMP_USE_SHARED_ZEROPAGE,\n};\nstruct rmap_walk_control rwc = {\n.rmap_one = remove_migration_pte,\n.arg = &rmap_walk_arg,\n};\nVM_BUG_ON_FOLIO((flags & RMP_USE_SHARED_ZEROPAGE) && (src != dst), src);\nif (flags & RMP_LOCKED)\nrmap_walk_locked(dst, &rwc);\nelse\nrmap_walk(dst, &rwc);\n}\n```\n```c\nstatic inline bool folio_is_zone_device(const struct folio *folio)\n{\nreturn is_zone_device_page(&folio->page);\n}\n```\n```c\nvoid folio_putback_lru(struct folio *folio)\n{\nfolio_add_lru(folio);\nfolio_put(folio); /* drop ref from isolate */\n}\n```",
  "original_code": "```c\nvoid migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)\n{\nunsigned long i;\nfor (i = 0; i < npages; i++) {\nstruct folio *dst = NULL, *src = NULL;\nstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\nstruct page *page = migrate_pfn_to_page(src_pfns[i]);\nif (newpage)\ndst = page_folio(newpage);\nif (!page) {\nif (dst) {\nfolio_unlock(dst);\nfolio_put(dst);\n}\ncontinue;\n}\nsrc = page_folio(page);\nif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE) || !dst) {\nif (dst) {\nfolio_unlock(dst);\nfolio_put(dst);\n}\ndst = src;\n}\nremove_migration_ptes(src, dst, 0);\nfolio_unlock(src);\nif (folio_is_zone_device(src))\nfolio_put(src);\nelse\nfolio_putback_lru(src);\nif (dst != src) {\nfolio_unlock(dst);\nif (folio_is_zone_device(dst))\nfolio_put(dst);\nelse\nfolio_putback_lru(dst);\n}\n}\n}\nEXPORT_SYMBOL(migrate_device_finalize);\n```",
  "vuln_patch": "```c\nvoid migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)\n{\nunsigned long i;\nfor (i = 0; i < npages; i++) {\nstruct folio *dst = NULL, *src = NULL;\nstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\nstruct page *page = migrate_pfn_to_page(src_pfns[i]);\nif (newpage)\ndst = page_folio(newpage);\nif (!page) {\nif (dst) {\nfolio_unlock(dst);\nfolio_put(dst);\n}\ncontinue;\n}\nsrc = page_folio(page);\nif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE) || !dst) {\nif (dst) {\nfolio_unlock(dst);\nfolio_put(dst);\n}\ndst = src;\n}\nif (!folio_is_zone_device(dst))\nfolio_add_lru(dst);\nremove_migration_ptes(src, dst, 0);\nfolio_unlock(src);\nfolio_put(src);\nif (dst != src) {\nfolio_unlock(dst);\nfolio_put(dst);\n}\n}\n}\nEXPORT_SYMBOL(migrate_device_finalize);\n```",
  "function_name": "migrate_device_finalize",
  "function_prototype": "void migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
  "code_semantics": "The function processes a list of pages, represented by their identifiers, to finalize their migration from one location to another. For each page, it retrieves the new and old representations of the page. If the new representation is valid, it prepares it for further operations. If the old representation is invalid, it releases the new representation if necessary and skips further processing for that page. If the old representation is valid, it checks certain conditions to determine if the new representation should replace the old one. It then updates the system's records to reflect the migration, unlocks the old representation, and releases it based on its type. If the new representation is different from the old one, it also unlocks and releases the new representation based on its type.",
  "safe_verification_cot": "1. folio_put is called after folio_unlock, ensuring proper reference count handling. 2. folio_is_zone_device is checked, and folio_add_lru is called for non-zone device dst before remove_migration_ptes, preventing use-after-free. 3. folio_unlock is correctly called before folio_put, ensuring proper order of operations. 4. remove_migration_ptes is called with valid src and dst pointers, with correct reference count handling. 5. folio_add_lru is correctly called for non-zone device dst before remove_migration_ptes, ensuring proper reference count handling.",
  "verification_cot": "1. folio_put is called on src and dst without ensuring they are not already freed, leading to a potential use-after-free. 2. folio_is_zone_device is checked, but folio_putback_lru is called on src and dst without ensuring they are not freed, causing a use-after-free. 3. folio_unlock is correctly called before folio_put or folio_putback_lru, but the issue lies in the incorrect use of folio_putback_lru. 4. remove_migration_ptes is called with src and dst, but the reference count handling is incorrect. 5. folio_add_lru is not called for non-zone device dst before remove_migration_ptes, leading to incorrect reference count handling.",
  "vulnerability_related_variables": {
    "src": "This variable represents a memory structure that is derived from another structure. It is used to perform operations such as unlocking, releasing, and checking specific properties related to memory management.",
    "dst": "This variable represents a memory structure that is derived from another structure. It is used to perform operations such as unlocking, releasing, and checking specific properties related to memory management.",
    "page": "This variable represents a memory structure that is obtained by converting a numerical identifier. It is used as an intermediate step to derive another memory structure.",
    "newpage": "This variable represents a memory structure that is obtained by converting a numerical identifier. It is used as an intermediate step to derive another memory structure."
  },
  "vulnerability_related_functions": {
    "folio_put": "This function decreases the reference count of a memory object. If the count reaches zero, it performs additional cleanup operations.",
    "folio_putback_lru": "This function adds a memory object back to a list that tracks usage frequency and then decreases its reference count.",
    "folio_unlock": "This function releases a lock on a memory object and, if there are waiting processes, it notifies them.",
    "remove_migration_ptes": "This function removes page table entries related to memory migration, using specific control structures to determine the method of removal.",
    "folio_is_zone_device": "This function checks if a memory object is associated with a specific type of memory zone."
  },
  "root_cause": "Incorrect handling of folio reference count leading to use-after-free condition.",
  "patch_cot": "First, ensure that dst is added to the LRU list if it is not a zone device. This can be done by adding a check for folio_is_zone_device(dst) and calling folio_add_lru(dst) if it returns false. After unlocking src, immediately call folio_put(src) to ensure the reference count is decremented correctly. Similarly, after unlocking dst, call folio_put(dst) to ensure the reference count is decremented correctly. Remove any unnecessary conditional checks that could lead to incorrect reference counting or premature freeing of src or dst. Ensure that remove_migration_ptes is called with the correct src and dst to avoid any use-after-free conditions."
}