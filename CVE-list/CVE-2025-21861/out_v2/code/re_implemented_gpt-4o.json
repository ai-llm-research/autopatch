{
 "supplementary_code": "```c\nstruct folio {\nstruct page page;\n};\n```\n```c\nstruct page {\nunsigned long long dummy;\n};\n```\n```c\nstatic inline struct page *migrate_pfn_to_page(unsigned long mpfn)\n{\nif (!(mpfn & MIGRATE_PFN_VALID))\nreturn NULL;\nreturn pfn_to_page(mpfn >> MIGRATE_PFN_SHIFT);\n}\n```\n```c\n#define page_folio(p) (_Generic((p), \\\nconst struct page *: (const struct folio *)_compound_head(p), \\\nstruct page *: (struct folio *)_compound_head(p)))\n```\n```c\nvoid folio_unlock(struct folio *folio)\n{\n/* Bit 7 allows x86 to check the byte's sign bit */\nBUILD_BUG_ON(PG_waiters != 7);\nBUILD_BUG_ON(PG_locked > 7);\nVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\nif (folio_xor_flags_has_waiters(folio, 1 << PG_locked))\nfolio_wake_bit(folio, PG_locked);\n}\nEXPORT_SYMBOL(folio_unlock);\n```\n```c\nstatic inline void folio_put(struct folio *folio)\n{\nif (folio_put_testzero(folio))\n__folio_put(folio);\n}\n```\n```c\nvoid remove_migration_ptes(struct folio *src, struct folio *dst, int flags)\n{\nstruct rmap_walk_arg rmap_walk_arg = {\n.folio = src,\n.map_unused_to_zeropage = flags & RMP_USE_SHARED_ZEROPAGE,\n};\nstruct rmap_walk_control rwc = {\n.rmap_one = remove_migration_pte,\n.arg = &rmap_walk_arg,\n};\nVM_BUG_ON_FOLIO((flags & RMP_USE_SHARED_ZEROPAGE) && (src != dst), src);\nif (flags & RMP_LOCKED)\nrmap_walk_locked(dst, &rwc);\nelse\nrmap_walk(dst, &rwc);\n}\n```\n```c\nstatic inline bool folio_is_zone_device(const struct folio *folio)\n{\nreturn is_zone_device_page(&folio->page);\n}\n```\n```c\nvoid folio_putback_lru(struct folio *folio)\n{\nfolio_add_lru(folio);\nfolio_put(folio); /* drop ref from isolate */\n}\n```\n",
 "function_prototype": "void migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
 "re_implemented_code": "\n```c\nvoid migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)\n{\nunsigned long i;\n// Iterate over each page frame number in the range\nfor (i = 0; i < npages; i++) {\n// Initialize destination and source folio pointers to NULL\nstruct folio *dst_folio = NULL;\nstruct folio *src_folio = NULL;\n// Convert destination page frame number to a page structure\nstruct page *dst_page = migrate_pfn_to_page(dst_pfns[i]);\n// Convert source page frame number to a page structure\nstruct page *src_page = migrate_pfn_to_page(src_pfns[i]);\n// If the new page is valid, convert it to a folio\nif (dst_page)\ndst_folio = page_folio(dst_page);\n// If the source page is not valid\nif (!src_page) {\n// If the destination folio is valid, unlock and release it\nif (dst_folio) {\nfolio_unlock(dst_folio);\nfolio_put(dst_folio);\n}\n// Continue to the next iteration\ncontinue;\n}\n// Convert the source page to a folio\nsrc_folio = page_folio(src_page);\n// Check if the source page frame number is not marked for migration or destination folio is not valid\nif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE) || !dst_folio) {\n// If the destination folio is valid, unlock and release it\nif (dst_folio) {\nfolio_unlock(dst_folio);\nfolio_put(dst_folio);\n}\n// Set destination folio to source folio\ndst_folio = src_folio;\n}\n// Remove migration page table entries for the source folio\nremove_migration_ptes(src_folio, dst_folio, 0);\n// Unlock the source folio\nfolio_unlock(src_folio);\n// If the source folio is a zone device, release it\nif (folio_is_zone_device(src_folio))\nfolio_put(src_folio);\nelse\n// Otherwise, put it back on the LRU list\nfolio_putback_lru(src_folio);\n// If the destination folio is different from the source folio\nif (dst_folio != src_folio) {\n// Unlock the destination folio\nfolio_unlock(dst_folio);\n// If the destination folio is a zone device, release it\nif (folio_is_zone_device(dst_folio))\nfolio_put(dst_folio);\nelse\n// Otherwise, put it back on the LRU list\nfolio_putback_lru(dst_folio);\n}\n}\n}\n// Export the function symbol for use in other modules\nEXPORT_SYMBOL(migrate_device_finalize);\n```\n",
 "is_vulnerable": true
}