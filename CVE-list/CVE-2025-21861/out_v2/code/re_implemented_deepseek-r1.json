{
 "supplementary_code": "```c\nstruct folio {\nstruct page page;\n};\n```\n```c\nstruct page {\nunsigned long long dummy;\n};\n```\n```c\nstatic inline struct page *migrate_pfn_to_page(unsigned long mpfn)\n{\nif (!(mpfn & MIGRATE_PFN_VALID))\nreturn NULL;\nreturn pfn_to_page(mpfn >> MIGRATE_PFN_SHIFT);\n}\n```\n```c\n#define page_folio(p) (_Generic((p), \\\nconst struct page *: (const struct folio *)_compound_head(p), \\\nstruct page *: (struct folio *)_compound_head(p)))\n```\n```c\nvoid folio_unlock(struct folio *folio)\n{\n/* Bit 7 allows x86 to check the byte's sign bit */\nBUILD_BUG_ON(PG_waiters != 7);\nBUILD_BUG_ON(PG_locked > 7);\nVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\nif (folio_xor_flags_has_waiters(folio, 1 << PG_locked))\nfolio_wake_bit(folio, PG_locked);\n}\nEXPORT_SYMBOL(folio_unlock);\n```\n```c\nstatic inline void folio_put(struct folio *folio)\n{\nif (folio_put_testzero(folio))\n__folio_put(folio);\n}\n```\n```c\nvoid remove_migration_ptes(struct folio *src, struct folio *dst, int flags)\n{\nstruct rmap_walk_arg rmap_walk_arg = {\n.folio = src,\n.map_unused_to_zeropage = flags & RMP_USE_SHARED_ZEROPAGE,\n};\nstruct rmap_walk_control rwc = {\n.rmap_one = remove_migration_pte,\n.arg = &rmap_walk_arg,\n};\nVM_BUG_ON_FOLIO((flags & RMP_USE_SHARED_ZEROPAGE) && (src != dst), src);\nif (flags & RMP_LOCKED)\nrmap_walk_locked(dst, &rwc);\nelse\nrmap_walk(dst, &rwc);\n}\n```\n```c\nstatic inline bool folio_is_zone_device(const struct folio *folio)\n{\nreturn is_zone_device_page(&folio->page);\n}\n```\n```c\nvoid folio_putback_lru(struct folio *folio)\n{\nfolio_add_lru(folio);\nfolio_put(folio); /* drop ref from isolate */\n}\n```\n",
 "function_prototype": "void migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
 "re_implemented_code": "\n```c\n#include <linux/mm.h>\n#include <linux/migration.h>\nvoid migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)\n{\nunsigned long i;\nfor (i = 0; i < npages; i++) {\nstruct folio *dst_folio = NULL;\nstruct folio *src_folio = NULL;\nstruct page *dst_page = migrate_pfn_to_page(dst_pfns[i]);\nstruct page *src_page = migrate_pfn_to_page(src_pfns[i]);\nif (dst_page)\ndst_folio = page_folio(dst_page);\nif (!src_page) {\nif (dst_folio) {\nfolio_unlock(dst_folio);\nfolio_put(dst_folio);\n}\ncontinue;\n}\nsrc_folio = page_folio(src_page);\nif (!(dst_pfns[i] & MIGRATE_PFN_MIGRATED) || !dst_folio) {\nif (dst_folio) {\nfolio_unlock(dst_folio);\nfolio_put(dst_folio);\n}\ndst_folio = src_folio;\n}\nremove_migration_ptes(src_folio, dst_folio, 0);\nfolio_unlock(src_folio);\nif (folio_is_zone_device(src_folio)) {\nfolio_put(src_folio);\n} else {\nfolio_putback_lru(src_folio);\n}\nif (dst_folio != src_folio) {\nfolio_unlock(dst_folio);\nif (folio_is_zone_device(dst_folio)) {\nfolio_put(dst_folio);\n} else {\nfolio_putback_lru(dst_folio);\n}\n}\n}\n}\nEXPORT_SYMBOL(migrate_device_finalize);\n```\n",
 "is_vulnerable": true
}