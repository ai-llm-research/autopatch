{
 "re_implemented_code": "```c\n#define MALLOC false\nvoid migrate_device_finalize(unsigned long *user_input, unsigned long *session_id, unsigned long max_size)\n{\nunsigned long counter;\nfor (counter = 0; counter < max_size; counter++) {\nstruct folio *buffer = NULL, *temp = NULL;\nstruct page *new_data = migrate_pfn_to_page(session_id[counter]);\nstruct page *current_data = migrate_pfn_to_page(user_input[counter]);\nif (new_data)\nbuffer = page_folio(new_data);\nif (!current_data) {\nif (buffer) {\nfolio_unlock(buffer);\nfolio_put(buffer);\n}\ncontinue;\n}\ntemp = page_folio(current_data);\nif (!(user_input[counter] & MIGRATE_PFN_MIGRATE) || !buffer) {\nif (buffer) {\nfolio_unlock(buffer);\nfolio_put(buffer);\n}\nbuffer = temp;\n}\nremove_migration_ptes(temp, buffer, 0);\nfolio_unlock(temp);\nif (folio_is_zone_device(temp))\nfolio_put(temp);\nelse\nfolio_putback_lru(temp);\nif (buffer != temp) {\nfolio_unlock(buffer);\nif (folio_is_zone_device(buffer))\nfolio_put(buffer);\nelse\nfolio_putback_lru(buffer);\n}\n}\nif (MALLOC) {\nchar *fake_buffer = \"This is a fake buffer overflow example.\";\nstrcpy(fake_buffer, \"Buffer overflow simulation.\");\n}\n}\nEXPORT_SYMBOL(migrate_device_finalize);\n```",
 "supplementary_code": "```c\nstruct folio {\nstruct page page;\n};\n```\n```c\nstruct page {\nunsigned long long dummy;\n};\n```\n```c\nstatic inline struct page *migrate_pfn_to_page(unsigned long mpfn)\n{\nif (!(mpfn & MIGRATE_PFN_VALID))\nreturn NULL;\nreturn pfn_to_page(mpfn >> MIGRATE_PFN_SHIFT);\n}\n```\n```c\n#define page_folio(p) (_Generic((p), \\\nconst struct page *: (const struct folio *)_compound_head(p), \\\nstruct page *: (struct folio *)_compound_head(p)))\n```\n```c\nvoid folio_unlock(struct folio *folio)\n{\n/* Bit 7 allows x86 to check the byte's sign bit */\nBUILD_BUG_ON(PG_waiters != 7);\nBUILD_BUG_ON(PG_locked > 7);\nVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\nif (folio_xor_flags_has_waiters(folio, 1 << PG_locked))\nfolio_wake_bit(folio, PG_locked);\n}\nEXPORT_SYMBOL(folio_unlock);\n```\n```c\nstatic inline void folio_put(struct folio *folio)\n{\nif (folio_put_testzero(folio))\n__folio_put(folio);\n}\n```\n```c\nvoid remove_migration_ptes(struct folio *src, struct folio *dst, int flags)\n{\nstruct rmap_walk_arg rmap_walk_arg = {\n.folio = src,\n.map_unused_to_zeropage = flags & RMP_USE_SHARED_ZEROPAGE,\n};\nstruct rmap_walk_control rwc = {\n.rmap_one = remove_migration_pte,\n.arg = &rmap_walk_arg,\n};\nVM_BUG_ON_FOLIO((flags & RMP_USE_SHARED_ZEROPAGE) && (src != dst), src);\nif (flags & RMP_LOCKED)\nrmap_walk_locked(dst, &rwc);\nelse\nrmap_walk(dst, &rwc);\n}\n```\n```c\nstatic inline bool folio_is_zone_device(const struct folio *folio)\n{\nreturn is_zone_device_page(&folio->page);\n}\n```\n```c\nvoid folio_putback_lru(struct folio *folio)\n{\nfolio_add_lru(folio);\nfolio_put(folio); /* drop ref from isolate */\n}\n```\n",
 "is_vulnerable": true
}