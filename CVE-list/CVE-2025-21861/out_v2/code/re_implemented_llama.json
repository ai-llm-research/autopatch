{
 "supplementary_code": "```c\nstruct folio {\nstruct page page;\n};\n```\n```c\nstruct page {\nunsigned long long dummy;\n};\n```\n```c\nstatic inline struct page *migrate_pfn_to_page(unsigned long mpfn)\n{\nif (!(mpfn & MIGRATE_PFN_VALID))\nreturn NULL;\nreturn pfn_to_page(mpfn >> MIGRATE_PFN_SHIFT);\n}\n```\n```c\n#define page_folio(p) (_Generic((p), \\\nconst struct page *: (const struct folio *)_compound_head(p), \\\nstruct page *: (struct folio *)_compound_head(p)))\n```\n```c\nvoid folio_unlock(struct folio *folio)\n{\n/* Bit 7 allows x86 to check the byte's sign bit */\nBUILD_BUG_ON(PG_waiters != 7);\nBUILD_BUG_ON(PG_locked > 7);\nVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\nif (folio_xor_flags_has_waiters(folio, 1 << PG_locked))\nfolio_wake_bit(folio, PG_locked);\n}\nEXPORT_SYMBOL(folio_unlock);\n```\n```c\nstatic inline void folio_put(struct folio *folio)\n{\nif (folio_put_testzero(folio))\n__folio_put(folio);\n}\n```\n```c\nvoid remove_migration_ptes(struct folio *src, struct folio *dst, int flags)\n{\nstruct rmap_walk_arg rmap_walk_arg = {\n.folio = src,\n.map_unused_to_zeropage = flags & RMP_USE_SHARED_ZEROPAGE,\n};\nstruct rmap_walk_control rwc = {\n.rmap_one = remove_migration_pte,\n.arg = &rmap_walk_arg,\n};\nVM_BUG_ON_FOLIO((flags & RMP_USE_SHARED_ZEROPAGE) && (src != dst), src);\nif (flags & RMP_LOCKED)\nrmap_walk_locked(dst, &rwc);\nelse\nrmap_walk(dst, &rwc);\n}\n```\n```c\nstatic inline bool folio_is_zone_device(const struct folio *folio)\n{\nreturn is_zone_device_page(&folio->page);\n}\n```\n```c\nvoid folio_putback_lru(struct folio *folio)\n{\nfolio_add_lru(folio);\nfolio_put(folio); /* drop ref from isolate */\n}\n```\n",
 "function_prototype": "void migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
 "re_implemented_code": "\n```c\nvoid migrate_device_finalize(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)\n{\nunsigned long i;\n// Iterate over each page frame number in the range\nfor (i = 0; i < npages; i++) {\n// Initialize destination and source folio pointers to NULL\nstruct folio *dest_folio = NULL;\nstruct folio *source_folio = NULL;\n// Convert destination page frame number to a page structure\nstruct page *dest_pg = migrate_pfn_to_page(*dst_pfns++);\n// Convert source page frame number to a page structure\nstruct page *src_pg = migrate_pfn_to_page(*src_pfns++);\n// If the new page is valid, convert it to a folio\nif ((!IS_ERR(dest_pg)) && PageFolio(dest_pg))\ndest_folio = page_folio(dest_pg);\n// If the source page is not valid\nif (IS_ERR(src_pg)) {\n// If the destination folio is valid, unlock and release it\nif (dest_folio) {\nfolio_unlock(dest_folio);\nfolio_put(dest_folio);\n}\n// Continue to the next iteration\ncontinue;\n}\n// Convert the source page to a folio\nsource_folio = page_folio(src_pg);\n// Check if the source page frame number is not marked for migration or destination folio is not valid\nif (!PageMigrating(src_pg) || !dest_folio) {\n// If the destination folio is valid, unlock and release it\nif (dest_folio) {\nfolio_unlock(dest_folio);\nfolio_put(dest_folio);\n}\n// Set destination folio to source folio\ndest_folio = source_folio;\n}\n// Remove migration page table entries for the source folio\nremove_migration_ptes(source_folio, dest_folio, 0);\n// Unlock the source folio\nfolio_unlock(source_folio);\n// If the source folio is a zone device, release it\nif (folio_is_zone_device(source_folio))\nfolio_put(source_folio);\nelse\n// Otherwise, put it back on the LRU list\nfolio_putback_lru(source_folio);\n// If the destination folio is different from the source folio\nif (dest_folio != source_folio) {\n// Unlock the destination folio\nfolio_unlock(dest_folio);\n// If the destination folio is a zone device, release it\nif (folio_is_zone_device(dest_folio))\nfolio_put(dest_folio);\nelse\n// Otherwise, put it back on the LRU list\nfolio_putback_lru(dest_folio);\n}\n}\n}\n```\n",
 "is_vulnerable": true
}