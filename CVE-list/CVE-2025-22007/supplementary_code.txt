```c
struct l2cap_chan {
    struct l2cap_conn   *conn;
    struct kref kref;
    atomic_t    nesting;

    __u8        state;

    bdaddr_t    dst;
    __u8        dst_type;
    bdaddr_t    src;
    __u8        src_type;
    __le16      psm;
    __le16      sport;
    __u16       dcid;
    __u16       scid;

    __u16       imtu;
    __u16       omtu;
    __u16       flush_to;
    __u8        mode;
    __u8        chan_type;
    __u8        chan_policy;

    __u8        sec_level;

    __u8        ident;

    __u8        conf_req[64];
    __u8        conf_len;
    __u8        num_conf_req;
    __u8        num_conf_rsp;

    __u8        fcs;

    __u16       tx_win;
    __u16       tx_win_max;
    __u16       ack_win;
    __u8        max_tx;
    __u16       retrans_timeout;
    __u16       monitor_timeout;
    __u16       mps;

    __u16       tx_credits;
    __u16       rx_credits;

    /* estimated available receive buffer space or -1 if unknown */
    ssize_t     rx_avail;

    __u8        tx_state;
    __u8        rx_state;

    unsigned long   conf_state;
    unsigned long   conn_state;
    unsigned long   flags;

    __u16       next_tx_seq;
    __u16       expected_ack_seq;
    __u16       expected_tx_seq;
    __u16       buffer_seq;
    __u16       srej_save_reqseq;
    __u16       last_acked_seq;
    __u16       frames_sent;
    __u16       unacked_frames;
    __u8        retry_count;
    __u16       sdu_len;
    struct sk_buff  *sdu;
    struct sk_buff  *sdu_last_frag;

    __u16       remote_tx_win;
    __u8        remote_max_tx;
    __u16       remote_mps;

    __u8        local_id;
    __u8        local_stype;
    __u16       local_msdu;
    __u32       local_sdu_itime;
    __u32       local_acc_lat;
    __u32       local_flush_to;

    __u8        remote_id;
    __u8        remote_stype;
    __u16       remote_msdu;
    __u32       remote_sdu_itime;
    __u32       remote_acc_lat;
    __u32       remote_flush_to;

    struct delayed_work chan_timer;
    struct delayed_work retrans_timer;
    struct delayed_work monitor_timer;
    struct delayed_work ack_timer;

    struct sk_buff      *tx_send_head;
    struct sk_buff_head tx_q;
    struct sk_buff_head srej_q;
    struct l2cap_seq_list   srej_list;
    struct l2cap_seq_list   retrans_list;

    struct list_head    list;
    struct list_head    global_l;

    void            *data;
    const struct l2cap_ops  *ops;
    struct mutex        lock;
};
```

```c
static inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)
{
    struct sk_buff *skb;

    skb = alloc_skb(len + BT_SKB_RESERVE, how);
    if (skb)
        skb_reserve(skb, BT_SKB_RESERVE);
    return skb;
}
```

```c
struct sk_buff {
    union {
        struct {
            /* These two members must be first to match sk_buff_head. */
            struct sk_buff      *next;
            struct sk_buff      *prev;

            union {
                struct net_device   *dev;
                /* Some protocols might use this space to store information,
                 * while device pointer would be NULL.
                 * UDP receive path is one user.
                 */
                unsigned long       dev_scratch;
            };
        };
        struct rb_node      rbnode; /* used in netem, ip4 defrag, and tcp stack */
        struct list_head    list;
        struct llist_node   ll_node;
    };

    struct sock     *sk;

    union {
        ktime_t     tstamp;
        u64     skb_mstamp_ns; /* earliest departure time */
    };
    /*
     * This is the control buffer. It is free to use for every
     * layer. Please put your private variables there. If you
     * want to keep them across layers you have to do a skb_clone()
     * first. This is owned by whoever has the skb queued ATM.
     */
    char            cb[48] __aligned(8);

    union {
        struct {
            unsigned long   _skb_refdst;
            void        (*destructor)(struct sk_buff *skb);
        };
        struct list_head    tcp_tsorted_anchor;
#ifdef CONFIG_NET_SOCK_MSG
        unsigned long       _sk_redir;
#endif
    };

#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
    unsigned long        _nfct;
#endif
    unsigned int        len,
                data_len;
    __u16           mac_len,
                hdr_len;

    /* Following fields are _not_ copied in __copy_skb_header()
     * Note that queue_mapping is here mostly to fill a hole.
     */
    __u16           queue_mapping;

/* if you move cloned around you also must adapt those constants */
#ifdef __BIG_ENDIAN_BITFIELD
#define CLONED_MASK (1 << 7)
#else
#define CLONED_MASK 1
#endif
#define CLONED_OFFSET       offsetof(struct sk_buff, __cloned_offset)

    /* private: */
    __u8            __cloned_offset[0];
    /* public: */
    __u8            cloned:1,
                nohdr:1,
                fclone:2,
                peeked:1,
                head_frag:1,
                pfmemalloc:1,
                pp_recycle:1; /* page_pool recycle indicator */
#ifdef CONFIG_SKB_EXTENSIONS
    __u8            active_extensions;
#endif

    /* Fields enclosed in headers group are copied
     * using a single memcpy() in __copy_skb_header()
     */
    struct_group(headers,

    /* private: */
    __u8            __pkt_type_offset[0];
    /* public: */
    __u8            pkt_type:3; /* see PKT_TYPE_MAX */
    __u8            ignore_df:1;
    __u8            dst_pending_confirm:1;
    __u8            ip_summed:2;
    __u8            ooo_okay:1;

    /* private: */
    __u8            __mono_tc_offset[0];
    /* public: */
    __u8            tstamp_type:2;  /* See skb_tstamp_type */
#ifdef CONFIG_NET_XGRESS
    __u8            tc_at_ingress:1;    /* See TC_AT_INGRESS_MASK */
    __u8            tc_skip_classify:1;
#endif
    __u8            remcsum_offload:1;
    __u8            csum_complete_sw:1;
    __u8            csum_level:2;
    __u8            inner_protocol_type:1;

    __u8            l4_hash:1;
    __u8            sw_hash:1;
#ifdef CONFIG_WIRELESS
    __u8            wifi_acked_valid:1;
    __u8            wifi_acked:1;
#endif
    __u8            no_fcs:1;
    /* Indicates the inner headers are valid in the skbuff. */
    __u8            encapsulation:1;
    __u8            encap_hdr_csum:1;
    __u8            csum_valid:1;
#ifdef CONFIG_IPV6_NDISC_NODETYPE
    __u8            ndisc_nodetype:2;
#endif

#if IS_ENABLED(CONFIG_IP_VS)
    __u8            ipvs_property:1;
#endif
#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE) || IS_ENABLED(CONFIG_NF_TABLES)
    __u8            nf_trace:1;
#endif
#ifdef CONFIG_NET_SWITCHDEV
    __u8            offload_fwd_mark:1;
    __u8            offload_l3_fwd_mark:1;
#endif
    __u8            redirected:1;
#ifdef CONFIG_NET_REDIRECT
    __u8            from_ingress:1;
#endif
#ifdef CONFIG_NETFILTER_SKIP_EGRESS
    __u8            nf_skip_egress:1;
#endif
#ifdef CONFIG_SKB_DECRYPTED
    __u8            decrypted:1;
#endif
    __u8            slow_gro:1;
#if IS_ENABLED(CONFIG_IP_SCTP)
    __u8            csum_not_inet:1;
#endif
    __u8            unreadable:1;
#if defined(CONFIG_NET_SCHED) || defined(CONFIG_NET_XGRESS)
    __u16           tc_index;   /* traffic control index */
#endif

    u16         alloc_cpu;

    union {
        __wsum      csum;
        struct {
            __u16   csum_start;
            __u16   csum_offset;
        };
    };
    __u32           priority;
    int         skb_iif;
    __u32           hash;
    union {
        u32     vlan_all;
        struct {
            __be16  vlan_proto;
            __u16   vlan_tci;
        };
    };
#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)
    union {
        unsigned int    napi_id;
        unsigned int    sender_cpu;
    };
#endif
#ifdef CONFIG_NETWORK_SECMARK
    __u32       secmark;
#endif

    union {
        __u32       mark;
        __u32       reserved_tailroom;
    };

    union {
        __be16      inner_protocol;
        __u8        inner_ipproto;
    };

    __u16           inner_transport_header;
    __u16           inner_network_header;
    __u16           inner_mac_header;

    __be16          protocol;
    __u16           transport_header;
    __u16           network_header;
    __u16           mac_header;

#ifdef CONFIG_KCOV
    u64         kcov_handle;
#endif

    ); /* end headers group */

    /* These elements must be at the end, see alloc_skb() for details.  */
    sk_buff_data_t      tail;
    sk_buff_data_t      end;
    unsigned char       *head,
                *data;
    unsigned int        truesize;
    refcount_t      users;

#ifdef CONFIG_SKB_EXTENSIONS
    /* only usable after checking ->active_extensions != 0 */
    struct skb_ext      *extensions;
#endif
};
```
