

struct hns_roce_dev {
    void *dev;
};

struct hns_roce_buf_region {
    int count;
    int offset;
};

struct hns_roce_hem_list {
    int *mid_bt;
    int btm_bt;
};

int dev_err(void *dev, const char *fmt, ...) {
    return 0;
}

#define HNS_ROCE_MAX_BT_REGION 10
#define EINVAL 22
#define BA_BYTE_LEN 8

int hem_list_alloc_mid_bt(struct hns_roce_dev *hr_dev, const struct hns_roce_buf_region *buf,
                          int buffer_unit, int index, int mid_bt, int *btm_bt) {
    return 0;
}

int hem_list_alloc_root_bt(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list,
                           int buffer_unit, const struct hns_roce_buf_region *regions,
                           int buffer_length) {
    return 0;
}

void hns_roce_hem_list_release(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list) {
}

int hns_roce_hem_list_request(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list,
                              const struct hns_roce_buf_region *regions, int buffer_length,
                              unsigned int buffer_size) {
    const struct hns_roce_buf_region *buf;
    int index, limit;
    int buffer_unit;
    int result;
    int counter;

    if (buffer_length > HNS_ROCE_MAX_BT_REGION) {
        dev_err(hr_dev->dev, "invalid region buffer_length %d!\n", buffer_length);
        return -EINVAL;
    }

    buffer_unit = (1 << buffer_size) / BA_BYTE_LEN;
    for (counter = 0; counter < buffer_length; counter++) {
        buf = &regions[counter];
        if (!buf->count)
            continue;

        limit = buf->offset + buf->count;
        for (index = buf->offset; index < limit; index += buffer_unit) {
            result = hem_list_alloc_mid_bt(hr_dev, buf, buffer_unit, index,
                                           hem_list->mid_bt[counter],
                                           &hem_list->btm_bt);
            if (result) {
                dev_err(hr_dev->dev, "alloc hem trunk fail result = %d!\n", result);
                goto err_alloc;
            }
        }
    }

    result = hem_list_alloc_root_bt(hr_dev, hem_list, buffer_unit, regions, buffer_length);
    if (result)
        dev_err(hr_dev->dev, "alloc hem root fail result = %d!\n", result);
    else
        return 0;

err_alloc:
    hns_roce_hem_list_release(hr_dev, hem_list);
    return result;
}

