
struct hns_roce_dev {
    void *dev;
};

struct hns_roce_hem_list {
    void **mid_bt;
    void *btm_bt;
};

struct hns_roce_buf_region {
    int offset;
    int count;
};

#define HNS_ROCE_MAX_BT_REGION 128
#define EINVAL 22
#define BA_BYTE_LEN 64

void dev_err(void *dev, const char *fmt, ...) {}

int hem_list_alloc_mid_bt(struct hns_roce_dev *hr_dev, const struct hns_roce_buf_region *region, unsigned int unit, int ofs, void *mid_bt, void **btm_bt) {
    return 0;
}

int hem_list_alloc_root_bt(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list, unsigned int unit, const struct hns_roce_buf_region *regions, int region_cnt) {
    return 0;
}

void hns_roce_hem_list_release(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list) {}

int hns_roce_hem_list_request(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list, const struct hns_roce_buf_region *regions, int region_cnt, unsigned int bt_pg_shift) {
    const struct hns_roce_buf_region *r;
    int ofs;
    int end;
    unsigned int unit = 1 << bt_pg_shift;
    int ret;
    int i;

    if (region_cnt > HNS_ROCE_MAX_BT_REGION) {
        dev_err(hr_dev->dev, "Invalid region count\n");
        return -EINVAL;
    }

    unit *= BA_BYTE_LEN;

    for (i = 0; i < region_cnt; i++) {
        r = &regions[i];

        if (!r->count)
            continue;

        end = r->offset + r->count - 1;

        for (ofs = r->offset; ofs < end; ofs += unit) {
            ret = hem_list_alloc_mid_bt(hr_dev, r, unit, ofs, hem_list->mid_bt[i], &hem_list->btm_bt);

            if (ret) {
                dev_err(hr_dev->dev, "Failed to allocate MID BT for offset %d\n", ofs);
                goto err_alloc;
            }
        }
    }

    ret = hem_list_alloc_root_bt(hr_dev, hem_list, unit, regions, region_cnt);

    if (ret) {
        dev_err(hr_dev->dev, "Failed to allocate ROOT BT\n");
    } else {
        return 0;
    }

err_alloc:
    hns_roce_hem_list_release(hr_dev, hem_list);
    return ret;
}
