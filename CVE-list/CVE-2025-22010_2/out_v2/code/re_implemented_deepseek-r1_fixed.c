
struct hns_roce_dev {
    void *dev;
};

struct hns_roce_buf_region {
    int offset;
    int count;
    int hopnum;
};

struct hns_roce_hem_list {
    void **mid_bt;
    void *btm_bt;
};

int hem_list_alloc_mid_bt(struct hns_roce_dev *hr_dev, const struct hns_roce_buf_region *r, int unit, int ofs, void *mid_bt, void **btm_bt) {
    return 0;
}

int hem_list_alloc_root_bt(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list, int unit, const struct hns_roce_buf_region *regions, int region_cnt) {
    return 0;
}

void hns_roce_hem_list_release(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list) {
}

void dev_err(void *dev, const char *fmt, ...) {
}

#define BIT(x) (1U << (x))
#define BA_BYTE_LEN 4
#define HNS_ROCE_MAX_BT_REGION 4
#define EINVAL 22

int hns_roce_hem_list_request(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list, const struct hns_roce_buf_region *regions, int region_cnt, unsigned int bt_pg_shift) {
    const struct hns_roce_buf_region *r;
    int ofs, end;
    int unit = BIT(bt_pg_shift) << BA_BYTE_LEN;
    int ret = 0;
    int i;

    if (region_cnt > HNS_ROCE_MAX_BT_REGION) {
        dev_err(hr_dev->dev, "Invalid region count %d\n", region_cnt);
        return -EINVAL;
    }

    for (i = 0; i < region_cnt; i++) {
        r = &regions[i];

        if (!r->count)
            continue;

        end = r->offset + r->count - 1;

        for (ofs = r->offset; ofs < end; ofs += unit) {
            ret = hem_list_alloc_mid_bt(hr_dev, r, unit, ofs, hem_list->mid_bt[r->hopnum], &hem_list->btm_bt);
            if (ret) {
                dev_err(hr_dev->dev, "Failed to allocate mid BT for offset %d\n", ofs);
                goto err_alloc;
            }
        }
    }

    ret = hem_list_alloc_root_bt(hr_dev, hem_list, unit, regions, region_cnt);
    if (ret) {
        dev_err(hr_dev->dev, "Failed to allocate root BT\n");
        goto err_alloc;
    } else {
        return 0;
    }

err_alloc:
    hns_roce_hem_list_release(hr_dev, hem_list);
    return ret;
}
