{
 "re_implemented_code": "```c\n#define MALLOC false\nint hns_roce_hem_list_request(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list, const struct hns_roce_buf_region *regions, int buffer_length, unsigned int buffer_size)\n{\nconst struct hns_roce_buf_region *buf;\nint index, limit;\nint buffer_unit;\nint result;\nint counter;\nif (buffer_length > HNS_ROCE_MAX_BT_REGION) {\ndev_err(hr_dev->dev, \"invalid region buffer_length %d!\\n\",\nbuffer_length);\nreturn -EINVAL;\n}\nbuffer_unit = (1 << buffer_size) / BA_BYTE_LEN;\nfor (counter = 0; counter < buffer_length; counter++) {\nbuf = &regions[counter];\nif (!buf->count)\ncontinue;\nlimit = buf->offset + buf->count;\nfor (index = buf->offset; index < limit; index += buffer_unit) {\nresult = hem_list_alloc_mid_bt(hr_dev, buf, buffer_unit, index,\nhem_list->mid_bt[counter],\n&hem_list->btm_bt);\nif (result) {\ndev_err(hr_dev->dev,\n\"alloc hem trunk fail result = %d!\\n\", result);\ngoto err_alloc;\n}\n}\n}\nresult = hem_list_alloc_root_bt(hr_dev, hem_list, buffer_unit, regions,\nbuffer_length);\nif (result)\ndev_err(hr_dev->dev, \"alloc hem root fail result = %d!\\n\", result);\nelse\nreturn 0;\nerr_alloc:\nhns_roce_hem_list_release(hr_dev, hem_list);\nif (MALLOC) {\nchar buffer[10];\nstrcpy(buffer, \"overflow\");\n}\nreturn result;\n}\n/* Example Vulnerability: CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') */\n```",
 "supplementary_code": "```c\nstruct hns_roce_dev {\nstruct ib_device ib_dev;\nstruct pci_dev *pci_dev;\nstruct device *dev;\nstruct hns_roce_uar priv_uar;\nconst char *irq_names[HNS_ROCE_MAX_IRQ_NUM];\nspinlock_t sm_lock;\nbool active;\nbool is_reset;\nbool dis_db;\nunsigned long reset_cnt;\nstruct hns_roce_ib_iboe iboe;\nenum hns_roce_device_state state;\nstruct list_head qp_list; /* list of all qps on this dev */\nspinlock_t qp_list_lock; /* protect qp_list */\nstruct list_head pgdir_list;\nstruct mutex pgdir_mutex;\nint irq[HNS_ROCE_MAX_IRQ_NUM];\nu8 __iomem *reg_base;\nvoid __iomem *mem_base;\nstruct hns_roce_caps caps;\nstruct xarray qp_table_xa;\nunsigned char dev_addr[HNS_ROCE_MAX_PORTS][ETH_ALEN];\nu64 sys_image_guid;\nu32 vendor_id;\nu32 vendor_part_id;\nu32 hw_rev;\nvoid __iomem *priv_addr;\nstruct hns_roce_cmdq cmd;\nstruct hns_roce_ida pd_ida;\nstruct hns_roce_ida xrcd_ida;\nstruct hns_roce_ida uar_ida;\nstruct hns_roce_mr_table mr_table;\nstruct hns_roce_cq_table cq_table;\nstruct hns_roce_srq_table srq_table;\nstruct hns_roce_qp_table qp_table;\nstruct hns_roce_eq_table eq_table;\nstruct hns_roce_hem_table qpc_timer_table;\nstruct hns_roce_hem_table cqc_timer_table;\n/* GMV is the memory area that the driver allocates for the hardware\n* to store SGID, SMAC and VLAN information.\n*/\nstruct hns_roce_hem_table gmv_table;\nint cmd_mod;\nint loop_idc;\nu32 sdb_offset;\nu32 odb_offset;\nconst struct hns_roce_hw *hw;\nvoid *priv;\nstruct workqueue_struct *irq_workq;\nstruct work_struct ecc_work;\nu32 func_num;\nu32 is_vf;\nu32 cong_algo_tmpl_id;\nu64 dwqe_page;\nstruct hns_roce_dev_debugfs dbgfs;\natomic64_t *dfx_cnt;\n};\n```\n```c\nstruct hns_roce_hem_list {\nstruct list_head root_bt;\n/* link all bt dma mem by hop config */\nstruct list_head mid_bt[HNS_ROCE_MAX_BT_REGION][HNS_ROCE_MAX_BT_LEVEL];\nstruct list_head btm_bt; /* link all bottom bt in @mid_bt */\ndma_addr_t root_ba; /* pointer to the root ba table */\n};\n```\n```c\nstruct hns_roce_buf_region {\nu32 offset; /* page offset */\nu32 count; /* page count */\nint hopnum; /* addressing hop num */\n};\n```\n```c\n#define HNS_ROCE_MAX_BT_REGION 3\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n```\n```c\n#define BA_BYTE_LEN 8\n```\n```c\nstatic int hem_list_alloc_mid_bt(struct hns_roce_dev *hr_dev,\nconst struct hns_roce_buf_region *r, int unit,\nint offset, struct list_head *mid_bt,\nstruct list_head *btm_bt)\n{\nstruct hns_roce_hem_item *hem_ptrs[HNS_ROCE_MAX_BT_LEVEL] = { NULL };\nstruct list_head temp_list[HNS_ROCE_MAX_BT_LEVEL];\nstruct hns_roce_hem_item *cur, *pre;\nconst int hopnum = r->hopnum;\nint start_aligned;\nint distance;\nint ret = 0;\nint max_ofs;\nint level;\nu64 step;\nint end;\nif (hopnum <= 1)\nreturn 0;\nif (hopnum > HNS_ROCE_MAX_BT_LEVEL) {\ndev_err(hr_dev->dev, \"invalid hopnum %d!\\n\", hopnum);\nreturn -EINVAL;\n}\nif (offset < r->offset) {\ndev_err(hr_dev->dev, \"invalid offset %d, min %u!\\n\",\noffset, r->offset);\nreturn -EINVAL;\n}\ndistance = offset - r->offset;\nmax_ofs = r->offset + r->count - 1;\nfor (level = 0; level < hopnum; level++)\nINIT_LIST_HEAD(&temp_list[level]);\n/* config L1 bt to last bt and link them to corresponding parent */\nfor (level = 1; level < hopnum; level++) {\nif (!hem_list_is_bottom_bt(hopnum, level)) {\ncur = hem_list_search_item(&mid_bt[level], offset);\nif (cur) {\nhem_ptrs[level] = cur;\ncontinue;\n}\n}\nstep = hem_list_calc_ba_range(hopnum, level, unit);\nif (step < 1) {\nret = -EINVAL;\ngoto err_exit;\n}\nstart_aligned = (distance / step) * step + r->offset;\nend = min_t(u64, start_aligned + step - 1, max_ofs);\ncur = hem_list_alloc_item(hr_dev, start_aligned, end, unit,\ntrue);\nif (!cur) {\nret = -ENOMEM;\ngoto err_exit;\n}\nhem_ptrs[level] = cur;\nlist_add(&cur->list, &temp_list[level]);\nif (hem_list_is_bottom_bt(hopnum, level))\nlist_add(&cur->sibling, &temp_list[0]);\n/* link bt to parent bt */\nif (level > 1) {\npre = hem_ptrs[level - 1];\nstep = (cur->start - pre->start) / step * BA_BYTE_LEN;\nhem_list_link_bt(pre->addr + step, cur->dma_addr);\n}\n}\nlist_splice(&temp_list[0], btm_bt);\nfor (level = 1; level < hopnum; level++)\nlist_splice(&temp_list[level], &mid_bt[level]);\nreturn 0;\nerr_exit:\nfor (level = 1; level < hopnum; level++)\nhem_list_free_all(hr_dev, &temp_list[level], true);\nreturn ret;\n}\n```\n```c\nstatic int hem_list_alloc_root_bt(struct hns_roce_dev *hr_dev,\nstruct hns_roce_hem_list *hem_list, int unit,\nconst struct hns_roce_buf_region *regions,\nint region_cnt)\n{\nstruct hns_roce_hem_item *root_hem;\nstruct hns_roce_hem_head head;\nint max_ba_num;\nint ret;\nint i;\nroot_hem = hem_list_search_item(&hem_list->root_bt, regions[0].offset);\nif (root_hem)\nreturn 0;\nmax_ba_num = 0;\nroot_hem = alloc_root_hem(hr_dev, unit, &max_ba_num, regions,\nregion_cnt);\nif (IS_ERR(root_hem))\nreturn PTR_ERR(root_hem);\n/* List head for storing all allocated HEM items */\nINIT_LIST_HEAD(&head.root);\nINIT_LIST_HEAD(&head.leaf);\nfor (i = 0; i < region_cnt; i++)\nINIT_LIST_HEAD(&head.branch[i]);\nhem_list->root_ba = root_hem->dma_addr;\nlist_add(&root_hem->list, &head.root);\nret = setup_root_hem(hr_dev, hem_list, unit, max_ba_num, &head, regions,\nregion_cnt);\nif (ret) {\nfor (i = 0; i < region_cnt; i++)\nhem_list_free_all(hr_dev, &head.branch[i], false);\nhem_list_free_all(hr_dev, &head.root, true);\n}\nreturn ret;\n}\n```\n```c\nvoid hns_roce_hem_list_release(struct hns_roce_dev *hr_dev,\nstruct hns_roce_hem_list *hem_list)\n{\nint i, j;\nfor (i = 0; i < HNS_ROCE_MAX_BT_REGION; i++)\nfor (j = 0; j < HNS_ROCE_MAX_BT_LEVEL; j++)\nhem_list_free_all(hr_dev, &hem_list->mid_bt[i][j],\nj != 0);\nhem_list_free_all(hr_dev, &hem_list->root_bt, true);\nINIT_LIST_HEAD(&hem_list->btm_bt);\nhem_list->root_ba = 0;\n}\n```\n",
 "is_vulnerable": true
}