```c
struct hns_roce_dev {
    struct ib_device    ib_dev;
    struct pci_dev      *pci_dev;
    struct device       *dev;
    struct hns_roce_uar     priv_uar;
    const char      *irq_names[HNS_ROCE_MAX_IRQ_NUM];
    spinlock_t      sm_lock;
    bool            active;
    bool            is_reset;
    bool            dis_db;
    unsigned long       reset_cnt;
    struct hns_roce_ib_iboe iboe;
    enum hns_roce_device_state state;
    struct list_head    qp_list; /* list of all qps on this dev */
    spinlock_t      qp_list_lock; /* protect qp_list */

    struct list_head        pgdir_list;
    struct mutex            pgdir_mutex;
    int         irq[HNS_ROCE_MAX_IRQ_NUM];
    u8 __iomem      *reg_base;
    void __iomem        *mem_base;
    struct hns_roce_caps    caps;
    struct xarray       qp_table_xa;

    unsigned char   dev_addr[HNS_ROCE_MAX_PORTS][ETH_ALEN];
    u64         sys_image_guid;
    u32                     vendor_id;
    u32                     vendor_part_id;
    u32                     hw_rev;
    void __iomem            *priv_addr;

    struct hns_roce_cmdq    cmd;
    struct hns_roce_ida pd_ida;
    struct hns_roce_ida xrcd_ida;
    struct hns_roce_ida uar_ida;
    struct hns_roce_mr_table  mr_table;
    struct hns_roce_cq_table  cq_table;
    struct hns_roce_srq_table srq_table;
    struct hns_roce_qp_table  qp_table;
    struct hns_roce_eq_table  eq_table;
    struct hns_roce_hem_table  qpc_timer_table;
    struct hns_roce_hem_table  cqc_timer_table;
    /* GMV is the memory area that the driver allocates for the hardware
     * to store SGID, SMAC and VLAN information.
     */
    struct hns_roce_hem_table  gmv_table;

    int         cmd_mod;
    int         loop_idc;
    u32         sdb_offset;
    u32         odb_offset;
    const struct hns_roce_hw *hw;
    void            *priv;
    struct workqueue_struct *irq_workq;
    struct work_struct ecc_work;
    u32 func_num;
    u32 is_vf;
    u32 cong_algo_tmpl_id;
    u64 dwqe_page;
    struct hns_roce_dev_debugfs dbgfs;
    atomic64_t *dfx_cnt;
};
```

```c
struct hns_roce_hem_list {
    struct list_head root_bt;
    /* link all bt dma mem by hop config */
    struct list_head mid_bt[HNS_ROCE_MAX_BT_REGION][HNS_ROCE_MAX_BT_LEVEL];
    struct list_head btm_bt; /* link all bottom bt in @mid_bt */
    dma_addr_t root_ba; /* pointer to the root ba table */
};
```

```c
struct hns_roce_buf_region {
    u32 offset; /* page offset */
    u32 count; /* page count */
    int hopnum; /* addressing hop num */
};
```

```c
#define HNS_ROCE_MAX_BT_REGION  3
```

```c
#define dev_err(dev, fmt, ...) \
    dev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)
```

```c
#define EINVAL      22  /* Invalid argument */
```

```c
#define BA_BYTE_LEN             8
```

```c
static int hem_list_alloc_mid_bt(struct hns_roce_dev *hr_dev,
                 const struct hns_roce_buf_region *r, int unit,
                 int offset, struct list_head *mid_bt,
                 struct list_head *btm_bt)
{
    struct hns_roce_hem_item *hem_ptrs[HNS_ROCE_MAX_BT_LEVEL] = { NULL };
    struct list_head temp_list[HNS_ROCE_MAX_BT_LEVEL];
    struct hns_roce_hem_item *cur, *pre;
    const int hopnum = r->hopnum;
    int start_aligned;
    int distance;
    int ret = 0;
    int max_ofs;
    int level;
    u64 step;
    int end;

    if (hopnum <= 1)
        return 0;

    if (hopnum > HNS_ROCE_MAX_BT_LEVEL) {
        dev_err(hr_dev->dev, "invalid hopnum %d!\n", hopnum);
        return -EINVAL;
    }

    if (offset < r->offset) {
        dev_err(hr_dev->dev, "invalid offset %d, min %u!\n",
            offset, r->offset);
        return -EINVAL;
    }

    distance = offset - r->offset;
    max_ofs = r->offset + r->count - 1;
    for (level = 0; level < hopnum; level++)
        INIT_LIST_HEAD(&temp_list[level]);

    /* config L1 bt to last bt and link them to corresponding parent */
    for (level = 1; level < hopnum; level++) {
        if (!hem_list_is_bottom_bt(hopnum, level)) {
            cur = hem_list_search_item(&mid_bt[level], offset);
            if (cur) {
                hem_ptrs[level] = cur;
                continue;
            }
        }

        step = hem_list_calc_ba_range(hopnum, level, unit);
        if (step < 1) {
            ret = -EINVAL;
            goto err_exit;
        }

        start_aligned = (distance / step) * step + r->offset;
        end = min_t(u64, start_aligned + step - 1, max_ofs);
        cur = hem_list_alloc_item(hr_dev, start_aligned, end, unit,
                      true);
        if (!cur) {
            ret = -ENOMEM;
            goto err_exit;
        }
        hem_ptrs[level] = cur;
        list_add(&cur->list, &temp_list[level]);
        if (hem_list_is_bottom_bt(hopnum, level))
            list_add(&cur->sibling, &temp_list[0]);

        /* link bt to parent bt */
        if (level > 1) {
            pre = hem_ptrs[level - 1];
            step = (cur->start - pre->start) / step * BA_BYTE_LEN;
            hem_list_link_bt(pre->addr + step, cur->dma_addr);
        }
    }

    list_splice(&temp_list[0], btm_bt);
    for (level = 1; level < hopnum; level++)
        list_splice(&temp_list[level], &mid_bt[level]);

    return 0;

err_exit:
    for (level = 1; level < hopnum; level++)
        hem_list_free_all(hr_dev, &temp_list[level], true);

    return ret;
}
```

```c
static int hem_list_alloc_root_bt(struct hns_roce_dev *hr_dev,
                  struct hns_roce_hem_list *hem_list, int unit,
                  const struct hns_roce_buf_region *regions,
                  int region_cnt)
{
    struct hns_roce_hem_item *root_hem;
    struct hns_roce_hem_head head;
    int max_ba_num;
    int ret;
    int i;

    root_hem = hem_list_search_item(&hem_list->root_bt, regions[0].offset);
    if (root_hem)
        return 0;

    max_ba_num = 0;
    root_hem = alloc_root_hem(hr_dev, unit, &max_ba_num, regions,
                  region_cnt);
    if (IS_ERR(root_hem))
        return PTR_ERR(root_hem);

    /* List head for storing all allocated HEM items */
    INIT_LIST_HEAD(&head.root);
    INIT_LIST_HEAD(&head.leaf);
    for (i = 0; i < region_cnt; i++)
        INIT_LIST_HEAD(&head.branch[i]);

    hem_list->root_ba = root_hem->dma_addr;
    list_add(&root_hem->list, &head.root);
    ret = setup_root_hem(hr_dev, hem_list, unit, max_ba_num, &head, regions,
                 region_cnt);
    if (ret) {
        for (i = 0; i < region_cnt; i++)
            hem_list_free_all(hr_dev, &head.branch[i], false);

        hem_list_free_all(hr_dev, &head.root, true);
    }

    return ret;
}
```

```c
void hns_roce_hem_list_release(struct hns_roce_dev *hr_dev,
                   struct hns_roce_hem_list *hem_list)
{
    int i, j;

    for (i = 0; i < HNS_ROCE_MAX_BT_REGION; i++)
        for (j = 0; j < HNS_ROCE_MAX_BT_LEVEL; j++)
            hem_list_free_all(hr_dev, &hem_list->mid_bt[i][j],
                      j != 0);

    hem_list_free_all(hr_dev, &hem_list->root_bt, true);
    INIT_LIST_HEAD(&hem_list->btm_bt);
    hem_list->root_ba = 0;
}
```
