

struct qmi_handle {};
struct qmi_service {
    int node;
    int port;
};

struct mutex {};
void mutex_lock(struct mutex *m) {}
void mutex_unlock(struct mutex *m) {}

struct work_struct {};
void schedule_work(struct work_struct *work) {}

struct list_head {
    struct list_head *next;
    struct list_head *prev;
};

typedef unsigned long size_t;
#define container_of(ptr, type, member) ((type *)((char *)(ptr) - (size_t)&((type *)0)->member))
#define list_for_each_entry(pos, head, member) \
    for (pos = container_of((head)->next, typeof(*pos), member); \
         &pos->member != (head); \
         pos = container_of(pos->member.next, typeof(*pos), member))

#define AF_QIPCRTR 0

struct pdr_service {
    int need_locator_lookup;
    struct list_head node;
};

struct pdr_handle {
    struct qmi_handle locator_hdl;
    struct mutex lock;
    struct {
        int family;
        int node;
        int port;
    } locator_addr;
    int locator_init_complete;
    struct mutex list_lock;
    struct list_head lookups;
    struct work_struct locator_work;
};

static int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc) {
    struct pdr_handle *pdr = container_of(qmi, struct pdr_handle, locator_hdl);

    struct pdr_service *pds;

    mutex_lock(&pdr->lock);

    pdr->locator_addr.family = AF_QIPCRTR;
    pdr->locator_addr.node = svc->node;
    pdr->locator_addr.port = svc->port;

    pdr->locator_init_complete = 1;

    mutex_unlock(&pdr->lock);

    mutex_lock(&pdr->list_lock);

    list_for_each_entry(pds, &pdr->lookups, node) {
        if (pds->need_locator_lookup) {
            schedule_work(&pdr->locator_work);
        }
    }

    mutex_unlock(&pdr->list_lock);

    return 0;
}

