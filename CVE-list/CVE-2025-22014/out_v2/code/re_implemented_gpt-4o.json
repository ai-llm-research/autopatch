{
 "supplementary_code": "```c\nstruct qmi_handle {\nstruct socket *sock;\nstruct mutex sock_lock;\nstruct sockaddr_qrtr sq;\nstruct work_struct work;\nstruct workqueue_struct *wq;\nvoid *recv_buf;\nsize_t recv_buf_size;\nstruct list_head lookups;\nstruct list_head lookup_results;\nstruct list_head services;\nstruct qmi_ops ops;\nstruct idr txns;\nstruct mutex txn_lock;\nconst struct qmi_msg_handler *handlers;\n};\n```\n```c\nstruct qmi_service {\nunsigned int service;\nunsigned int version;\nunsigned int instance;\nunsigned int node;\nunsigned int port;\nvoid *priv;\nstruct list_head list_node;\n};\n```\n```c\nstruct pdr_handle {\nstruct qmi_handle locator_hdl;\nstruct qmi_handle notifier_hdl;\nstruct sockaddr_qrtr locator_addr;\nstruct list_head lookups;\nstruct list_head indack_list;\n/* control access to pdr lookup/indack lists */\nstruct mutex list_lock;\n/* serialize pd status invocation */\nstruct mutex status_lock;\n/* control access to the locator state */\nstruct mutex lock;\nbool locator_init_complete;\nstruct work_struct locator_work;\nstruct work_struct notifier_work;\nstruct work_struct indack_work;\nstruct workqueue_struct *notifier_wq;\nstruct workqueue_struct *indack_wq;\nvoid (*status)(int state, char *service_path, void *priv);\nvoid *priv;\n};\n```\n```c\n#define container_of(ptr, type, member) ({ \\\nvoid *__mptr = (void *)(ptr); \\\nstatic_assert(__same_type(*(ptr), ((type *)0)->member) || \\\n__same_type(*(ptr), void), \\\n\"pointer type mismatch in container_of()\"); \\\n((type *)(__mptr - offsetof(type, member))); })\n```\n```c\nstruct pdr_service {\nchar service_name[SERVREG_NAME_LENGTH + 1];\nchar service_path[SERVREG_NAME_LENGTH + 1];\nstruct sockaddr_qrtr addr;\nunsigned int instance;\nunsigned int service;\nu8 service_data_valid;\nu32 service_data;\nint state;\nbool need_notifier_register;\nbool need_notifier_remove;\nbool need_locator_lookup;\nbool service_connected;\nstruct list_head node;\n};\n```\n```c\nvoid __sched mutex_lock(struct mutex *lock)\n{\nmight_sleep();\nif (!__mutex_trylock_fast(lock))\n__mutex_lock_slowpath(lock);\n}\nEXPORT_SYMBOL(mutex_lock);\n```\n```c\n#define AF_QIPCRTR 42 /* Qualcomm IPC Router */\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\n#define list_for_each_entry(pos, head, member) \\\nfor (pos = list_first_entry(head, typeof(*pos), member); \\\n!list_entry_is_head(pos, head, member); \\\npos = list_next_entry(pos, member))\n```\n```c\nstatic inline bool schedule_work(struct work_struct *work)\n{\nreturn queue_work(system_wq, work);\n}\n```\n",
 "function_prototype": "static int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc)",
 "re_implemented_code": "\n```c\nstatic int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc) {\n// Retrieve the pdr_handle structure from the qmi_handle using container_of macro\nstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle, locator_hdl);\n// Declare a pointer to iterate over pdr_service structures\nstruct pdr_service *pds;\n// Lock the mutex to ensure exclusive access to the locator state\nmutex_lock(&pdr->lock);\n// Set the family of the locator address to AF_QIPCRTR for QMI communication\npdr->locator_addr.sq_family = AF_QIPCRTR;\n// Set the node of the locator address to the node of the service\npdr->locator_addr.sq_node = svc->node;\n// Set the port of the locator address to the port of the service\npdr->locator_addr.sq_port = svc->port;\n// Mark the locator initialization as complete\npdr->locator_init_complete = true;\n// Unlock the mutex after updating the locator state\nmutex_unlock(&pdr->lock);\n// Locking list_lock before accessing lookups list.\nmutex_lock(&pdr->list_lock);\n// Iterate over each pdr_service in lookups list.\nlist_for_each_entry(pds, &pdr->lookups, node) {\n// Check if service needs a lookup.\nif (pds->need_locator_lookup)\nschedule_work(&pds->node);\n}\n// Unlocking list_lock after processing lookups.\nmutex_unlock(&pdr->list_lock);\n// Return 0 indicating successful execution.\nreturn 0;\n}\n```\n",
 "is_vulnerable": true
}