

struct qmi_handle {};
struct qmi_service { int node; int port; };
struct pdr_service { int need_locator_lookup; struct pdr_service *node; };
struct pdr_locator_addr { int sa_family; struct { int node; int port; } sq; };
struct pdr_handle { struct qmi_handle locator_hdl; struct pdr_locator_addr locator_addr; int locator_init_complete; int lock; int list_lock; struct pdr_service lookups; struct pdr_service locator_work; };

static void mutex_lock(int *mutex) {}
static void mutex_unlock(int *mutex) {}
static void schedule_work(struct pdr_service *work) {}
#define AF_QIPCRTR 0

#define list_for_each_entry(pos, head, member) \
    for (pos = (typeof(pos))(head); pos != NULL; pos = pos->member)

#define NULL ((void*)0)

static void *container_of(void *ptr, int offset, int o) {
    return ptr; 
}

#define true 1

static int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc) {
    struct pdr_handle *pdr = container_of(qmi, 0, (int)&(((struct pdr_handle *)0)->locator_hdl));
    struct pdr_service *pds;

    mutex_lock(&pdr->lock);

    pdr->locator_addr.sa_family = AF_QIPCRTR;
    pdr->locator_addr.sq.node = svc->node;
    pdr->locator_addr.sq.port = svc->port;
    pdr->locator_init_complete = true;

    mutex_unlock(&pdr->lock);

    mutex_lock(&pdr->list_lock);

    list_for_each_entry(pds, &pdr->lookups, node) {
        if (pds->need_locator_lookup) {
            schedule_work(&pdr->locator_work);
        }
    }

    mutex_unlock(&pdr->list_lock);

    return 0;
}

