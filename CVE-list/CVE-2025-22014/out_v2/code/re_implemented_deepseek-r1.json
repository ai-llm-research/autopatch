{
 "supplementary_code": "```c\nstruct qmi_handle {\nstruct socket *sock;\nstruct mutex sock_lock;\nstruct sockaddr_qrtr sq;\nstruct work_struct work;\nstruct workqueue_struct *wq;\nvoid *recv_buf;\nsize_t recv_buf_size;\nstruct list_head lookups;\nstruct list_head lookup_results;\nstruct list_head services;\nstruct qmi_ops ops;\nstruct idr txns;\nstruct mutex txn_lock;\nconst struct qmi_msg_handler *handlers;\n};\n```\n```c\nstruct qmi_service {\nunsigned int service;\nunsigned int version;\nunsigned int instance;\nunsigned int node;\nunsigned int port;\nvoid *priv;\nstruct list_head list_node;\n};\n```\n```c\nstruct pdr_handle {\nstruct qmi_handle locator_hdl;\nstruct qmi_handle notifier_hdl;\nstruct sockaddr_qrtr locator_addr;\nstruct list_head lookups;\nstruct list_head indack_list;\n/* control access to pdr lookup/indack lists */\nstruct mutex list_lock;\n/* serialize pd status invocation */\nstruct mutex status_lock;\n/* control access to the locator state */\nstruct mutex lock;\nbool locator_init_complete;\nstruct work_struct locator_work;\nstruct work_struct notifier_work;\nstruct work_struct indack_work;\nstruct workqueue_struct *notifier_wq;\nstruct workqueue_struct *indack_wq;\nvoid (*status)(int state, char *service_path, void *priv);\nvoid *priv;\n};\n```\n```c\n#define container_of(ptr, type, member) ({ \\\nvoid *__mptr = (void *)(ptr); \\\nstatic_assert(__same_type(*(ptr), ((type *)0)->member) || \\\n__same_type(*(ptr), void), \\\n\"pointer type mismatch in container_of()\"); \\\n((type *)(__mptr - offsetof(type, member))); })\n```\n```c\nstruct pdr_service {\nchar service_name[SERVREG_NAME_LENGTH + 1];\nchar service_path[SERVREG_NAME_LENGTH + 1];\nstruct sockaddr_qrtr addr;\nunsigned int instance;\nunsigned int service;\nu8 service_data_valid;\nu32 service_data;\nint state;\nbool need_notifier_register;\nbool need_notifier_remove;\nbool need_locator_lookup;\nbool service_connected;\nstruct list_head node;\n};\n```\n```c\nvoid __sched mutex_lock(struct mutex *lock)\n{\nmight_sleep();\nif (!__mutex_trylock_fast(lock))\n__mutex_lock_slowpath(lock);\n}\nEXPORT_SYMBOL(mutex_lock);\n```\n```c\n#define AF_QIPCRTR 42 /* Qualcomm IPC Router */\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\n#define list_for_each_entry(pos, head, member) \\\nfor (pos = list_first_entry(head, typeof(*pos), member); \\\n!list_entry_is_head(pos, head, member); \\\npos = list_next_entry(pos, member))\n```\n```c\nstatic inline bool schedule_work(struct work_struct *work)\n{\nreturn queue_work(system_wq, work);\n}\n```\n",
 "function_prototype": "static int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc)",
 "re_implemented_code": "\n```c\nstatic int pdr Locator New Server(struct qmi_handle *qmi, struct qmi_service *svc) {\nstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle, locator_hdl);\nstruct pdr_service *pds;\nmutex_lock(&pdr->lock);\npdr->locator_addr.sa_family = AF_QIPCRTR;\npdr->locator_addr.sq.node = svc->node;\npdr->locator_addr.sq.port = svc->port;\npdr->locator_init_complete = true;\nmutex_unlock(&pdr->lock);\nmutex_lock(&pdr->list_lock);\nlist_for_each_entry(pds, &pdr->lookups, node) {\nif (pds->need_locator_lookup) {\nschedule_work(&pdr->locator_work);\n}\n}\nmutex_unlock(&pdr->list_lock);\nreturn 0;\n}\n// Note: The function name should be corrected to follow C naming conventions.\n```\n",
 "is_vulnerable": true
}