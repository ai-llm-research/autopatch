{
  "cwe_type": "Deadlock",
  "cve_id": "CVE-2025-22014",
  "supplementary_code": "```c\nstruct qmi_handle {\nstruct socket *sock;\nstruct mutex sock_lock;\nstruct sockaddr_qrtr sq;\nstruct work_struct work;\nstruct workqueue_struct *wq;\nvoid *recv_buf;\nsize_t recv_buf_size;\nstruct list_head lookups;\nstruct list_head lookup_results;\nstruct list_head services;\nstruct qmi_ops ops;\nstruct idr txns;\nstruct mutex txn_lock;\nconst struct qmi_msg_handler *handlers;\n};\n```\n```c\nstruct qmi_service {\nunsigned int service;\nunsigned int version;\nunsigned int instance;\nunsigned int node;\nunsigned int port;\nvoid *priv;\nstruct list_head list_node;\n};\n```\n```c\nstruct pdr_handle {\nstruct qmi_handle locator_hdl;\nstruct qmi_handle notifier_hdl;\nstruct sockaddr_qrtr locator_addr;\nstruct list_head lookups;\nstruct list_head indack_list;\n/* control access to pdr lookup/indack lists */\nstruct mutex list_lock;\n/* serialize pd status invocation */\nstruct mutex status_lock;\n/* control access to the locator state */\nstruct mutex lock;\nbool locator_init_complete;\nstruct work_struct locator_work;\nstruct work_struct notifier_work;\nstruct work_struct indack_work;\nstruct workqueue_struct *notifier_wq;\nstruct workqueue_struct *indack_wq;\nvoid (*status)(int state, char *service_path, void *priv);\nvoid *priv;\n};\n```\n```c\n#define container_of(ptr, type, member) ({ \\\nvoid *__mptr = (void *)(ptr); \\\nstatic_assert(__same_type(*(ptr), ((type *)0)->member) || \\\n__same_type(*(ptr), void), \\\n\"pointer type mismatch in container_of()\"); \\\n((type *)(__mptr - offsetof(type, member))); })\n```\n```c\nstruct pdr_service {\nchar service_name[SERVREG_NAME_LENGTH + 1];\nchar service_path[SERVREG_NAME_LENGTH + 1];\nstruct sockaddr_qrtr addr;\nunsigned int instance;\nunsigned int service;\nu8 service_data_valid;\nu32 service_data;\nint state;\nbool need_notifier_register;\nbool need_notifier_remove;\nbool need_locator_lookup;\nbool service_connected;\nstruct list_head node;\n};\n```\n```c\nvoid __sched mutex_lock(struct mutex *lock)\n{\nmight_sleep();\nif (!__mutex_trylock_fast(lock))\n__mutex_lock_slowpath(lock);\n}\nEXPORT_SYMBOL(mutex_lock);\n```\n```c\n#define AF_QIPCRTR 42 /* Qualcomm IPC Router */\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\n#define list_for_each_entry(pos, head, member) \\\nfor (pos = list_first_entry(head, typeof(*pos), member); \\\n!list_entry_is_head(pos, head, member); \\\npos = list_next_entry(pos, member))\n```\n```c\nstatic inline bool schedule_work(struct work_struct *work)\n{\nreturn queue_work(system_wq, work);\n}\n```",
  "original_code": "```c\nstatic int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc)\n{\nstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle,\nlocator_hdl);\nstruct pdr_service *pds;\nmutex_lock(&pdr->lock);\n/* Create a local client port for QMI communication */\npdr->locator_addr.sq_family = AF_QIPCRTR;\npdr->locator_addr.sq_node = svc->node;\npdr->locator_addr.sq_port = svc->port;\npdr->locator_init_complete = true;\nmutex_unlock(&pdr->lock);\n/* Service pending lookup requests */\nmutex_lock(&pdr->list_lock);\nlist_for_each_entry(pds, &pdr->lookups, node) {\nif (pds->need_locator_lookup)\nschedule_work(&pdr->locator_work);\n}\nmutex_unlock(&pdr->list_lock);\nreturn 0;\n}\n```",
  "vuln_patch": "```c\nstatic int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc)\n{\nstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle,\nlocator_hdl);\nmutex_lock(&pdr->lock);\n/* Create a local client port for QMI communication */\npdr->locator_addr.sq_family = AF_QIPCRTR;\npdr->locator_addr.sq_node = svc->node;\npdr->locator_addr.sq_port = svc->port;\npdr->locator_init_complete = true;\nmutex_unlock(&pdr->lock);\n/* Service pending lookup requests */\nschedule_work(&pdr->locator_work);\nreturn 0;\n}\n```",
  "function_name": "pdr_locator_new_server",
  "function_prototype": "static int pdr_locator_new_server(struct qmi_handle *qmi, struct qmi_service *svc)",
  "code_semantics": "The function initializes a communication endpoint for a service by setting up a local address with specific network parameters. It ensures that this setup is done in a thread-safe manner by using locks. After setting up the address, it marks the initialization as complete. The function then checks a list of pending tasks and schedules work for tasks that require further processing. The function concludes by indicating successful completion.",
  "vulnerability_checklist": "1. Check if mutex_lock is used to acquire pdr->lock and pdr->list_lock in a nested manner. 2. Verify that list_for_each_entry is not used while holding pdr->list_lock if it leads to scheduling work that might reacquire the same lock. 3. Ensure that schedule_work is not called within a loop that holds pdr->list_lock if it can lead to a deadlock. 4. Confirm that pds->need_locator_lookup is properly checked before scheduling work, and ensure it does not lead to a deadlock.",
  "safe_verification_cot": "1. The Target Code removes the loop and directly calls schedule_work(&pdr->locator_work) after releasing pdr->lock. 2. This change ensures that pdr->list_lock is not held when schedule_work is called, thus eliminating the potential for a deadlock.",
  "verification_cot": "1. The Vulnerable Code uses mutex_lock to acquire pdr->list_lock and then iterates over pdr->lookups using list_for_each_entry. 2. Within this loop, schedule_work is called if pds->need_locator_lookup is true. 3. If schedule_work indirectly causes the same lock (pdr->list_lock) to be acquired again, it can lead to a deadlock, as the lock is already held during the iteration.",
  "vulnerability_related_variables": {
    "pdr->lock": "This variable is a synchronization mechanism used to ensure exclusive access to shared resources within a data structure during modifications.",
    "pdr->list_lock": "This variable is a synchronization mechanism used to ensure exclusive access to a list within a data structure during iteration or modification.",
    "pdr->lookups": "This variable is a collection of elements representing pending operations that need to be processed.",
    "pdr->locator_work": "This variable is a task structure that is queued for execution when certain conditions are met within a collection of elements.",
    "pds->need_locator_lookup": "This variable is a boolean flag within an element of a collection that indicates whether a specific operation needs to be performed."
  },
  "vulnerability_related_functions": {
    "mutex_lock": "The function is responsible for acquiring a lock on a synchronization primitive to ensure that only one thread can access a shared resource at a time.",
    "mutex_unlock": "The function releases a previously acquired lock on a synchronization primitive, allowing other threads to access the shared resource.",
    "list_for_each_entry": "This macro iterates over each element in a linked list, allowing operations to be performed on each element sequentially.",
    "schedule_work": "The function queues a task to be executed by a background worker thread, allowing deferred execution of the task."
  },
  "root_cause": "The root cause of the deadlock is the potential for a deadlock situation when iterating over the pdr->lookups list while holding the list_lock mutex, and schedule_work indirectly leads to a situation where the same lock is attempted to be acquired again.",
  "patch_cot": "First, identify where pdr->list_lock is being used in conjunction with schedule_work. Remove the iteration over pdr->lookups while holding pdr->list_lock if it leads to a call to schedule_work. Directly call schedule_work(&pdr->locator_work) after unlocking any mutexes that might lead to a deadlock. Ensure that any conditions leading to schedule_work are checked without holding pdr->list_lock.",
  "fix_list": "Check if function schedule_work is safely handling variable pdr->locator_work. Verify that variable pdr->list_lock is not held when calling function schedule_work. Ensure that variable pdr->lookups is not iterated over while holding pdr->list_lock if it leads to a call to schedule_work. Confirm that variable pds->need_locator_lookup is checked without holding pdr->list_lock if it leads to a call to schedule_work."
}