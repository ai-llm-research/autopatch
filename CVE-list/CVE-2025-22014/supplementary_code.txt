```c
struct qmi_handle {
    struct socket *sock;
    struct mutex sock_lock;

    struct sockaddr_qrtr sq;

    struct work_struct work;
    struct workqueue_struct *wq;

    void *recv_buf;
    size_t recv_buf_size;

    struct list_head lookups;
    struct list_head lookup_results;
    struct list_head services;

    struct qmi_ops ops;

    struct idr txns;
    struct mutex txn_lock;

    const struct qmi_msg_handler *handlers;
};
```

```c
struct qmi_service {
    unsigned int service;
    unsigned int version;
    unsigned int instance;

    unsigned int node;
    unsigned int port;

    void *priv;
    struct list_head list_node;
};
```

```c
struct pdr_handle {
    struct qmi_handle locator_hdl;
    struct qmi_handle notifier_hdl;

    struct sockaddr_qrtr locator_addr;

    struct list_head lookups;
    struct list_head indack_list;

    /* control access to pdr lookup/indack lists */
    struct mutex list_lock;

    /* serialize pd status invocation */
    struct mutex status_lock;

    /* control access to the locator state */
    struct mutex lock;

    bool locator_init_complete;

    struct work_struct locator_work;
    struct work_struct notifier_work;
    struct work_struct indack_work;

    struct workqueue_struct *notifier_wq;
    struct workqueue_struct *indack_wq;

    void (*status)(int state, char *service_path, void *priv);
    void *priv;
};

```

```c
#define container_of(ptr, type, member) ({              \
    void *__mptr = (void *)(ptr);                   \
    static_assert(__same_type(*(ptr), ((type *)0)->member) ||   \
              __same_type(*(ptr), void),            \
              "pointer type mismatch in container_of()");   \
    ((type *)(__mptr - offsetof(type, member))); })
```

```c
struct pdr_service {
    char service_name[SERVREG_NAME_LENGTH + 1];
    char service_path[SERVREG_NAME_LENGTH + 1];

    struct sockaddr_qrtr addr;

    unsigned int instance;
    unsigned int service;
    u8 service_data_valid;
    u32 service_data;
    int state;

    bool need_notifier_register;
    bool need_notifier_remove;
    bool need_locator_lookup;
    bool service_connected;

    struct list_head node;
};
```

```c
void __sched mutex_lock(struct mutex *lock)
{
    might_sleep();

    if (!__mutex_trylock_fast(lock))
        __mutex_lock_slowpath(lock);
}
EXPORT_SYMBOL(mutex_lock);
```

```c
#define AF_QIPCRTR  42  /* Qualcomm IPC Router          */
```

```c
static int mutex_unlock(unsigned long *m)
{
    int flags = FUTEX_WAKE;
    if (!processes)
        flags |= FUTEX_PRIVATE_FLAG;

    if (*m == 2)
        *m = 0;
    else if (xchg(m, 0) == 1)
        return 0;

    sys_futex(m, flags, 1, NULL, NULL, 0);

    return 0;
}
```

```c
#define list_for_each_entry(pos, head, member)              \
    for (pos = list_first_entry(head, typeof(*pos), member);    \
         !list_entry_is_head(pos, head, member);            \
         pos = list_next_entry(pos, member))
```

```c
static inline bool schedule_work(struct work_struct *work)
{
    return queue_work(system_wq, work);
}
```
