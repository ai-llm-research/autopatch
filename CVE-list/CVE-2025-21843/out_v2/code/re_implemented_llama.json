{
 "supplementary_code": "```c\nstruct drm_file {\n/**\n* @authenticated:\n*\n* Whether the client is allowed to submit rendering, which for legacy\n* nodes means it must be authenticated.\n*\n* See also the :ref:`section on primary nodes and authentication\n* <drm_primary_node>`.\n*/\nbool authenticated;\n/**\n* @stereo_allowed:\n*\n* True when the client has asked us to expose stereo 3D mode flags.\n*/\nbool stereo_allowed;\n/**\n* @universal_planes:\n*\n* True if client understands CRTC primary planes and cursor planes\n* in the plane list. Automatically set when @atomic is set.\n*/\nbool universal_planes;\n/** @atomic: True if client understands atomic properties. */\nbool atomic;\n/**\n* @aspect_ratio_allowed:\n*\n* True, if client can handle picture aspect ratios, and has requested\n* to pass this information along with the mode.\n*/\nbool aspect_ratio_allowed;\n/**\n* @writeback_connectors:\n*\n* True if client understands writeback connectors\n*/\nbool writeback_connectors;\n/**\n* @was_master:\n*\n* This client has or had, master capability. Protected by struct\n* &drm_device.master_mutex.\n*\n* This is used to ensure that CAP_SYS_ADMIN is not enforced, if the\n* client is or was master in the past.\n*/\nbool was_master;\n/**\n* @is_master:\n*\n* This client is the creator of @master. Protected by struct\n* &drm_device.master_mutex.\n*\n* See also the :ref:`section on primary nodes and authentication\n* <drm_primary_node>`.\n*/\nbool is_master;\n/**\n* @supports_virtualized_cursor_plane:\n*\n* This client is capable of handling the cursor plane with the\n* restrictions imposed on it by the virtualized drivers.\n*\n* This implies that the cursor plane has to behave like a cursor\n* i.e. track cursor movement. It also requires setting of the\n* hotspot properties by the client on the cursor plane.\n*/\nbool supports_virtualized_cursor_plane;\n/**\n* @master:\n*\n* Master this node is currently associated with. Protected by struct\n* &drm_device.master_mutex, and serialized by @master_lookup_lock.\n*\n* Only relevant if drm_is_primary_client() returns true. Note that\n* this only matches &drm_device.master if the master is the currently\n* active one.\n*\n* To update @master, both &drm_device.master_mutex and\n* @master_lookup_lock need to be held, therefore holding either of\n* them is safe and enough for the read side.\n*\n* When dereferencing this pointer, either hold struct\n* &drm_device.master_mutex for the duration of the pointer's use, or\n* use drm_file_get_master() if struct &drm_device.master_mutex is not\n* currently held and there is no other need to hold it. This prevents\n* @master from being freed during use.\n*\n* See also @authentication and @is_master and the :ref:`section on\n* primary nodes and authentication <drm_primary_node>`.\n*/\nstruct drm_master *master;\n/** @master_lookup_lock: Serializes @master. */\nspinlock_t master_lookup_lock;\n/**\n* @pid: Process that is using this file.\n*\n* Must only be dereferenced under a rcu_read_lock or equivalent.\n*\n* Updates are guarded with dev->filelist_mutex and reference must be\n* dropped after a RCU grace period to accommodate lockless readers.\n*/\nstruct pid __rcu *pid;\n/** @client_id: A unique id for fdinfo */\nu64 client_id;\n/** @magic: Authentication magic, see @authenticated. */\ndrm_magic_t magic;\n/**\n* @lhead:\n*\n* List of all open files of a DRM device, linked into\n* &drm_device.filelist. Protected by &drm_device.filelist_mutex.\n*/\nstruct list_head lhead;\n/** @minor: &struct drm_minor for this file. */\nstruct drm_minor *minor;\n/**\n* @object_idr:\n*\n* Mapping of mm object handles to object pointers. Used by the GEM\n* subsystem. Protected by @table_lock.\n*/\nstruct idr object_idr;\n/** @table_lock: Protects @object_idr. */\nspinlock_t table_lock;\n/** @syncobj_idr: Mapping of sync object handles to object pointers. */\nstruct idr syncobj_idr;\n/** @syncobj_table_lock: Protects @syncobj_idr. */\nspinlock_t syncobj_table_lock;\n/** @filp: Pointer to the core file structure. */\nstruct file *filp;\n/**\n* @driver_priv:\n*\n* Optional pointer for driver private data. Can be allocated in\n* &drm_driver.open and should be freed in &drm_driver.postclose.\n*/\nvoid *driver_priv;\n/**\n* @fbs:\n*\n* List of &struct drm_framebuffer associated with this file, using the\n* &drm_framebuffer.filp_head entry.\n*\n* Protected by @fbs_lock. Note that the @fbs list holds a reference on\n* the framebuffer object to prevent it from untimely disappearing.\n*/\nstruct list_head fbs;\n/** @fbs_lock: Protects @fbs. */\nstruct mutex fbs_lock;\n/**\n* @blobs:\n*\n* User-created blob properties; this retains a reference on the\n* property.\n*\n* Protected by @drm_mode_config.blob_lock;\n*/\nstruct list_head blobs;\n/** @event_wait: Waitqueue for new events added to @event_list. */\nwait_queue_head_t event_wait;\n/**\n* @pending_event_list:\n*\n* List of pending &struct drm_pending_event, used to clean up pending\n* events in case this file gets closed before the event is signalled.\n* Uses the &drm_pending_event.pending_link entry.\n*\n* Protect by &drm_device.event_lock.\n*/\nstruct list_head pending_event_list;\n/**\n* @event_list:\n*\n* List of &struct drm_pending_event, ready for delivery to userspace\n* through drm_read(). Uses the &drm_pending_event.link entry.\n*\n* Protect by &drm_device.event_lock.\n*/\nstruct list_head event_list;\n/**\n* @event_space:\n*\n* Available event space to prevent userspace from\n* exhausting kernel memory. Currently limited to the fairly arbitrary\n* value of 4KB.\n*/\nint event_space;\n/** @event_read_lock: Serializes drm_read(). */\nstruct mutex event_read_lock;\n/**\n* @prime:\n*\n* Per-file buffer caches used by the PRIME buffer sharing code.\n*/\nstruct drm_prime_file_private prime;\n/**\n* @client_name:\n*\n* Userspace-provided name; useful for accounting and debugging.\n*/\nconst char *client_name;\n/**\n* @client_name_lock: Protects @client_name.\n*/\nstruct mutex client_name_lock;\n};\n```\n```c\nstruct drm_panthor_group_priorities_info {\n/**\n* @allowed_mask: Bitmask of the allowed group priorities.\n*\n* Each bit represents a variant of the enum drm_panthor_group_priority.\n*/\n__u8 allowed_mask;\n/** @pad: Padding fields, MBZ. */\n__u8 pad[3];\n};\n```\n```c\nenum drm_panthor_group_priority {\n/** @PANTHOR_GROUP_PRIORITY_LOW: Low priority group. */\nPANTHOR_GROUP_PRIORITY_LOW = 0,\n/** @PANTHOR_GROUP_PRIORITY_MEDIUM: Medium priority group. */\nPANTHOR_GROUP_PRIORITY_MEDIUM,\n/**\n* @PANTHOR_GROUP_PRIORITY_HIGH: High priority group.\n*\n* Requires CAP_SYS_NICE or DRM_MASTER.\n*/\nPANTHOR_GROUP_PRIORITY_HIGH,\n/**\n* @PANTHOR_GROUP_PRIORITY_REALTIME: Realtime priority group.\n*\n* Requires CAP_SYS_NICE or DRM_MASTER.\n*/\nPANTHOR_GROUP_PRIORITY_REALTIME,\n};\n```\n```c\nstatic int group_priority_permit(struct drm_file *file,\nu8 priority)\n{\n/* Ensure that priority is valid */\nif (priority > PANTHOR_GROUP_PRIORITY_REALTIME)\nreturn -EINVAL;\n/* Medium priority and below are always allowed */\nif (priority <= PANTHOR_GROUP_PRIORITY_MEDIUM)\nreturn 0;\n/* Higher priorities require CAP_SYS_NICE or DRM_MASTER */\nif (capable(CAP_SYS_NICE) || drm_is_current_master(file))\nreturn 0;\nreturn -EACCES;\n}\n```\n```c\n#define BIT(nr) (UL(1) << (nr))\n```\n",
 "function_prototype": "static void panthor_query_group_priorities_info(struct drm_file *file, struct drm_panthor_group_priorities_info *arg)",
 "re_implemented_code": "\n```c\nstatic void panthor_query_group_priorities_info(struct drm_file *file,\nstruct drm_panthor_group_priorities_info *arg)\n{\nunsigned long prio;\nmemset(arg, 0, sizeof(*arg));\nfor (prio = PANTHOR_GROUP_PRIORITY_REALTIME; prio >= PANTHOR_GROUP_PRIORITY_LOW; --prio) {\nif (!group_priority_permit(file, prio))\narg->allowed_mask |= BIT(prio);\n}\n} // End of Implementation\n```\n",
 "is_vulnerable": true
}