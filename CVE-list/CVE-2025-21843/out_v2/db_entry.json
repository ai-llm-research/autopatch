{
  "cwe_type": "Use of Uninitialized Variable",
  "cve_id": "CVE-2025-21843",
  "supplementary_code": "```c\nstruct drm_file {\n/**\n* @authenticated:\n*\n* Whether the client is allowed to submit rendering, which for legacy\n* nodes means it must be authenticated.\n*\n* See also the :ref:`section on primary nodes and authentication\n* <drm_primary_node>`.\n*/\nbool authenticated;\n/**\n* @stereo_allowed:\n*\n* True when the client has asked us to expose stereo 3D mode flags.\n*/\nbool stereo_allowed;\n/**\n* @universal_planes:\n*\n* True if client understands CRTC primary planes and cursor planes\n* in the plane list. Automatically set when @atomic is set.\n*/\nbool universal_planes;\n/** @atomic: True if client understands atomic properties. */\nbool atomic;\n/**\n* @aspect_ratio_allowed:\n*\n* True, if client can handle picture aspect ratios, and has requested\n* to pass this information along with the mode.\n*/\nbool aspect_ratio_allowed;\n/**\n* @writeback_connectors:\n*\n* True if client understands writeback connectors\n*/\nbool writeback_connectors;\n/**\n* @was_master:\n*\n* This client has or had, master capability. Protected by struct\n* &drm_device.master_mutex.\n*\n* This is used to ensure that CAP_SYS_ADMIN is not enforced, if the\n* client is or was master in the past.\n*/\nbool was_master;\n/**\n* @is_master:\n*\n* This client is the creator of @master. Protected by struct\n* &drm_device.master_mutex.\n*\n* See also the :ref:`section on primary nodes and authentication\n* <drm_primary_node>`.\n*/\nbool is_master;\n/**\n* @supports_virtualized_cursor_plane:\n*\n* This client is capable of handling the cursor plane with the\n* restrictions imposed on it by the virtualized drivers.\n*\n* This implies that the cursor plane has to behave like a cursor\n* i.e. track cursor movement. It also requires setting of the\n* hotspot properties by the client on the cursor plane.\n*/\nbool supports_virtualized_cursor_plane;\n/**\n* @master:\n*\n* Master this node is currently associated with. Protected by struct\n* &drm_device.master_mutex, and serialized by @master_lookup_lock.\n*\n* Only relevant if drm_is_primary_client() returns true. Note that\n* this only matches &drm_device.master if the master is the currently\n* active one.\n*\n* To update @master, both &drm_device.master_mutex and\n* @master_lookup_lock need to be held, therefore holding either of\n* them is safe and enough for the read side.\n*\n* When dereferencing this pointer, either hold struct\n* &drm_device.master_mutex for the duration of the pointer's use, or\n* use drm_file_get_master() if struct &drm_device.master_mutex is not\n* currently held and there is no other need to hold it. This prevents\n* @master from being freed during use.\n*\n* See also @authentication and @is_master and the :ref:`section on\n* primary nodes and authentication <drm_primary_node>`.\n*/\nstruct drm_master *master;\n/** @master_lookup_lock: Serializes @master. */\nspinlock_t master_lookup_lock;\n/**\n* @pid: Process that is using this file.\n*\n* Must only be dereferenced under a rcu_read_lock or equivalent.\n*\n* Updates are guarded with dev->filelist_mutex and reference must be\n* dropped after a RCU grace period to accommodate lockless readers.\n*/\nstruct pid __rcu *pid;\n/** @client_id: A unique id for fdinfo */\nu64 client_id;\n/** @magic: Authentication magic, see @authenticated. */\ndrm_magic_t magic;\n/**\n* @lhead:\n*\n* List of all open files of a DRM device, linked into\n* &drm_device.filelist. Protected by &drm_device.filelist_mutex.\n*/\nstruct list_head lhead;\n/** @minor: &struct drm_minor for this file. */\nstruct drm_minor *minor;\n/**\n* @object_idr:\n*\n* Mapping of mm object handles to object pointers. Used by the GEM\n* subsystem. Protected by @table_lock.\n*/\nstruct idr object_idr;\n/** @table_lock: Protects @object_idr. */\nspinlock_t table_lock;\n/** @syncobj_idr: Mapping of sync object handles to object pointers. */\nstruct idr syncobj_idr;\n/** @syncobj_table_lock: Protects @syncobj_idr. */\nspinlock_t syncobj_table_lock;\n/** @filp: Pointer to the core file structure. */\nstruct file *filp;\n/**\n* @driver_priv:\n*\n* Optional pointer for driver private data. Can be allocated in\n* &drm_driver.open and should be freed in &drm_driver.postclose.\n*/\nvoid *driver_priv;\n/**\n* @fbs:\n*\n* List of &struct drm_framebuffer associated with this file, using the\n* &drm_framebuffer.filp_head entry.\n*\n* Protected by @fbs_lock. Note that the @fbs list holds a reference on\n* the framebuffer object to prevent it from untimely disappearing.\n*/\nstruct list_head fbs;\n/** @fbs_lock: Protects @fbs. */\nstruct mutex fbs_lock;\n/**\n* @blobs:\n*\n* User-created blob properties; this retains a reference on the\n* property.\n*\n* Protected by @drm_mode_config.blob_lock;\n*/\nstruct list_head blobs;\n/** @event_wait: Waitqueue for new events added to @event_list. */\nwait_queue_head_t event_wait;\n/**\n* @pending_event_list:\n*\n* List of pending &struct drm_pending_event, used to clean up pending\n* events in case this file gets closed before the event is signalled.\n* Uses the &drm_pending_event.pending_link entry.\n*\n* Protect by &drm_device.event_lock.\n*/\nstruct list_head pending_event_list;\n/**\n* @event_list:\n*\n* List of &struct drm_pending_event, ready for delivery to userspace\n* through drm_read(). Uses the &drm_pending_event.link entry.\n*\n* Protect by &drm_device.event_lock.\n*/\nstruct list_head event_list;\n/**\n* @event_space:\n*\n* Available event space to prevent userspace from\n* exhausting kernel memory. Currently limited to the fairly arbitrary\n* value of 4KB.\n*/\nint event_space;\n/** @event_read_lock: Serializes drm_read(). */\nstruct mutex event_read_lock;\n/**\n* @prime:\n*\n* Per-file buffer caches used by the PRIME buffer sharing code.\n*/\nstruct drm_prime_file_private prime;\n/**\n* @client_name:\n*\n* Userspace-provided name; useful for accounting and debugging.\n*/\nconst char *client_name;\n/**\n* @client_name_lock: Protects @client_name.\n*/\nstruct mutex client_name_lock;\n};\n```\n```c\nstruct drm_panthor_group_priorities_info {\n/**\n* @allowed_mask: Bitmask of the allowed group priorities.\n*\n* Each bit represents a variant of the enum drm_panthor_group_priority.\n*/\n__u8 allowed_mask;\n/** @pad: Padding fields, MBZ. */\n__u8 pad[3];\n};\n```\n```c\nenum drm_panthor_group_priority {\n/** @PANTHOR_GROUP_PRIORITY_LOW: Low priority group. */\nPANTHOR_GROUP_PRIORITY_LOW = 0,\n/** @PANTHOR_GROUP_PRIORITY_MEDIUM: Medium priority group. */\nPANTHOR_GROUP_PRIORITY_MEDIUM,\n/**\n* @PANTHOR_GROUP_PRIORITY_HIGH: High priority group.\n*\n* Requires CAP_SYS_NICE or DRM_MASTER.\n*/\nPANTHOR_GROUP_PRIORITY_HIGH,\n/**\n* @PANTHOR_GROUP_PRIORITY_REALTIME: Realtime priority group.\n*\n* Requires CAP_SYS_NICE or DRM_MASTER.\n*/\nPANTHOR_GROUP_PRIORITY_REALTIME,\n};\n```\n```c\nstatic int group_priority_permit(struct drm_file *file,\nu8 priority)\n{\n/* Ensure that priority is valid */\nif (priority > PANTHOR_GROUP_PRIORITY_REALTIME)\nreturn -EINVAL;\n/* Medium priority and below are always allowed */\nif (priority <= PANTHOR_GROUP_PRIORITY_MEDIUM)\nreturn 0;\n/* Higher priorities require CAP_SYS_NICE or DRM_MASTER */\nif (capable(CAP_SYS_NICE) || drm_is_current_master(file))\nreturn 0;\nreturn -EACCES;\n}\n```\n```c\n#define BIT(nr) (UL(1) << (nr))\n```",
  "original_code": "```c\nstatic void panthor_query_group_priorities_info(struct drm_file *file,\nstruct drm_panthor_group_priorities_info *arg)\n{\nint prio;\nfor (prio = PANTHOR_GROUP_PRIORITY_REALTIME; prio >= 0; prio--) {\nif (!group_priority_permit(file, prio))\narg->allowed_mask |= BIT(prio);\n}\n}\n```",
  "vuln_patch": "```c\nstatic void panthor_query_group_priorities_info(struct drm_file *file,\nstruct drm_panthor_group_priorities_info *arg)\n{\nint prio;\nmemset(arg, 0, sizeof(*arg));\nfor (prio = PANTHOR_GROUP_PRIORITY_REALTIME; prio >= 0; prio--) {\nif (!group_priority_permit(file, prio))\narg->allowed_mask |= BIT(prio);\n}\n}\n```",
  "function_name": "panthor_query_group_priorities_info",
  "function_prototype": "static void panthor_query_group_priorities_info(struct drm_file *file, struct drm_panthor_group_priorities_info *arg)",
  "code_semantics": "The function iterates over a set of priority levels, starting from the highest and moving to the lowest. For each priority level, it checks if the priority is allowed for a specific file. If the priority is allowed, it updates a bitmask to indicate that the priority is permitted. This bitmask is part of a structure that holds information about which priority levels are allowed.",
  "safe_verification_cot": "1. The function panthor_query_group_priorities_info includes a call to memset(arg, 0, sizeof(*arg));, which initializes the entire arg structure, including arg->allowed_mask, to zero.\n2. This ensures that arg->allowed_mask starts with a known value, preventing the use of uninitialized data and eliminating the vulnerability.",
  "verification_cot": "1. The function panthor_query_group_priorities_info does not initialize the variable arg->allowed_mask before it is used in the loop.\n2. As a result, arg->allowed_mask may contain garbage values, leading to incorrect or insecure behavior when the bitwise OR operation is performed.",
  "vulnerability_related_variables": {
    "arg->allowed_mask": "The variable is a bitmask that represents allowed priority levels. It is updated in a loop that checks each priority level from highest to lowest. For each priority level, a function is called to determine if the level is permitted. If permitted, the corresponding bit in the bitmask is set to 1. The bitmask thus accumulates all the priority levels that are allowed."
  },
  "vulnerability_related_functions": {},
  "root_cause": "The root cause of the vulnerability is the use of an uninitialized variable 'arg->allowed_mask' in the function 'panthor_query_group_priorities_info'.",
  "patch_cot": "Start by identifying where the uninitialized variable arg->allowed_mask is used. In this case, it is used in the function panthor_query_group_priorities_info. Add an initialization step at the beginning of the function to set arg->allowed_mask to a known value. This can be done by initializing the entire arg structure to zero using memset. This ensures that any subsequent operations on arg->allowed_mask are performed on a clean, predictable state, thus eliminating the risk of using uninitialized data."
}