```c
struct drm_file {
    /**
     * @authenticated:
     *
     * Whether the client is allowed to submit rendering, which for legacy
     * nodes means it must be authenticated.
     *
     * See also the :ref:`section on primary nodes and authentication
     * <drm_primary_node>`.
     */
    bool authenticated;

    /**
     * @stereo_allowed:
     *
     * True when the client has asked us to expose stereo 3D mode flags.
     */
    bool stereo_allowed;

    /**
     * @universal_planes:
     *
     * True if client understands CRTC primary planes and cursor planes
     * in the plane list. Automatically set when @atomic is set.
     */
    bool universal_planes;

    /** @atomic: True if client understands atomic properties. */
    bool atomic;

    /**
     * @aspect_ratio_allowed:
     *
     * True, if client can handle picture aspect ratios, and has requested
     * to pass this information along with the mode.
     */
    bool aspect_ratio_allowed;

    /**
     * @writeback_connectors:
     *
     * True if client understands writeback connectors
     */
    bool writeback_connectors;

    /**
     * @was_master:
     *
     * This client has or had, master capability. Protected by struct
     * &drm_device.master_mutex.
     *
     * This is used to ensure that CAP_SYS_ADMIN is not enforced, if the
     * client is or was master in the past.
     */
    bool was_master;

    /**
     * @is_master:
     *
     * This client is the creator of @master. Protected by struct
     * &drm_device.master_mutex.
     *
     * See also the :ref:`section on primary nodes and authentication
     * <drm_primary_node>`.
     */
    bool is_master;

    /**
     * @supports_virtualized_cursor_plane:
     *
     * This client is capable of handling the cursor plane with the
     * restrictions imposed on it by the virtualized drivers.
     *
     * This implies that the cursor plane has to behave like a cursor
     * i.e. track cursor movement. It also requires setting of the
     * hotspot properties by the client on the cursor plane.
     */
    bool supports_virtualized_cursor_plane;

    /**
     * @master:
     *
     * Master this node is currently associated with. Protected by struct
     * &drm_device.master_mutex, and serialized by @master_lookup_lock.
     *
     * Only relevant if drm_is_primary_client() returns true. Note that
     * this only matches &drm_device.master if the master is the currently
     * active one.
     *
     * To update @master, both &drm_device.master_mutex and
     * @master_lookup_lock need to be held, therefore holding either of
     * them is safe and enough for the read side.
     *
     * When dereferencing this pointer, either hold struct
     * &drm_device.master_mutex for the duration of the pointer's use, or
     * use drm_file_get_master() if struct &drm_device.master_mutex is not
     * currently held and there is no other need to hold it. This prevents
     * @master from being freed during use.
     *
     * See also @authentication and @is_master and the :ref:`section on
     * primary nodes and authentication <drm_primary_node>`.
     */
    struct drm_master *master;

    /** @master_lookup_lock: Serializes @master. */
    spinlock_t master_lookup_lock;

    /**
     * @pid: Process that is using this file.
     *
     * Must only be dereferenced under a rcu_read_lock or equivalent.
     *
     * Updates are guarded with dev->filelist_mutex and reference must be
     * dropped after a RCU grace period to accommodate lockless readers.
     */
    struct pid __rcu *pid;

    /** @client_id: A unique id for fdinfo */
    u64 client_id;

    /** @magic: Authentication magic, see @authenticated. */
    drm_magic_t magic;

    /**
     * @lhead:
     *
     * List of all open files of a DRM device, linked into
     * &drm_device.filelist. Protected by &drm_device.filelist_mutex.
     */
    struct list_head lhead;

    /** @minor: &struct drm_minor for this file. */
    struct drm_minor *minor;

    /**
     * @object_idr:
     *
     * Mapping of mm object handles to object pointers. Used by the GEM
     * subsystem. Protected by @table_lock.
     */
    struct idr object_idr;

    /** @table_lock: Protects @object_idr. */
    spinlock_t table_lock;

    /** @syncobj_idr: Mapping of sync object handles to object pointers. */
    struct idr syncobj_idr;
    /** @syncobj_table_lock: Protects @syncobj_idr. */
    spinlock_t syncobj_table_lock;

    /** @filp: Pointer to the core file structure. */
    struct file *filp;

    /**
     * @driver_priv:
     *
     * Optional pointer for driver private data. Can be allocated in
     * &drm_driver.open and should be freed in &drm_driver.postclose.
     */
    void *driver_priv;

    /**
     * @fbs:
     *
     * List of &struct drm_framebuffer associated with this file, using the
     * &drm_framebuffer.filp_head entry.
     *
     * Protected by @fbs_lock. Note that the @fbs list holds a reference on
     * the framebuffer object to prevent it from untimely disappearing.
     */
    struct list_head fbs;

    /** @fbs_lock: Protects @fbs. */
    struct mutex fbs_lock;

    /**
     * @blobs:
     *
     * User-created blob properties; this retains a reference on the
     * property.
     *
     * Protected by @drm_mode_config.blob_lock;
     */
    struct list_head blobs;

    /** @event_wait: Waitqueue for new events added to @event_list. */
    wait_queue_head_t event_wait;

    /**
     * @pending_event_list:
     *
     * List of pending &struct drm_pending_event, used to clean up pending
     * events in case this file gets closed before the event is signalled.
     * Uses the &drm_pending_event.pending_link entry.
     *
     * Protect by &drm_device.event_lock.
     */
    struct list_head pending_event_list;

    /**
     * @event_list:
     *
     * List of &struct drm_pending_event, ready for delivery to userspace
     * through drm_read(). Uses the &drm_pending_event.link entry.
     *
     * Protect by &drm_device.event_lock.
     */
    struct list_head event_list;

    /**
     * @event_space:
     *
     * Available event space to prevent userspace from
     * exhausting kernel memory. Currently limited to the fairly arbitrary
     * value of 4KB.
     */
    int event_space;

    /** @event_read_lock: Serializes drm_read(). */
    struct mutex event_read_lock;

    /**
     * @prime:
     *
     * Per-file buffer caches used by the PRIME buffer sharing code.
     */
    struct drm_prime_file_private prime;

    /**
     * @client_name:
     *
     * Userspace-provided name; useful for accounting and debugging.
     */
    const char *client_name;

    /**
     * @client_name_lock: Protects @client_name.
     */
    struct mutex client_name_lock;
};
```

```c
struct drm_panthor_group_priorities_info {
    /**
     * @allowed_mask: Bitmask of the allowed group priorities.
     *
     * Each bit represents a variant of the enum drm_panthor_group_priority.
     */
    __u8 allowed_mask;

    /** @pad: Padding fields, MBZ. */
    __u8 pad[3];
};
```

```c
enum drm_panthor_group_priority {
    /** @PANTHOR_GROUP_PRIORITY_LOW: Low priority group. */
    PANTHOR_GROUP_PRIORITY_LOW = 0,

    /** @PANTHOR_GROUP_PRIORITY_MEDIUM: Medium priority group. */
    PANTHOR_GROUP_PRIORITY_MEDIUM,

    /**
     * @PANTHOR_GROUP_PRIORITY_HIGH: High priority group.
     *
     * Requires CAP_SYS_NICE or DRM_MASTER.
     */
    PANTHOR_GROUP_PRIORITY_HIGH,

    /**
     * @PANTHOR_GROUP_PRIORITY_REALTIME: Realtime priority group.
     *
     * Requires CAP_SYS_NICE or DRM_MASTER.
     */
    PANTHOR_GROUP_PRIORITY_REALTIME,
};
```

```c
static int group_priority_permit(struct drm_file *file,
                 u8 priority)
{
    /* Ensure that priority is valid */
    if (priority > PANTHOR_GROUP_PRIORITY_REALTIME)
        return -EINVAL;

    /* Medium priority and below are always allowed */
    if (priority <= PANTHOR_GROUP_PRIORITY_MEDIUM)
        return 0;

    /* Higher priorities require CAP_SYS_NICE or DRM_MASTER */
    if (capable(CAP_SYS_NICE) || drm_is_current_master(file))
        return 0;

    return -EACCES;
}
```

```c
#define BIT(nr)         (UL(1) << (nr))
```
