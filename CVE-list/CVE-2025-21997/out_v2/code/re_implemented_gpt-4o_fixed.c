

typedef unsigned int size_t;

struct xsk_buff_pool {
    void *heads;
    int chunk_mask;
    int addrs_cnt;
    int heads_cnt;
    int free_heads_cnt;
    int headroom;
    int chunk_size;
    int chunk_shift;
    int free_heads[];
};

struct xdp_sock {
    int tx;
};

struct xdp_umem {
    int flags;
    int npgs;
    int chunks;
    int size;
    int chunk_size;
    int headroom;
};

struct xdp_buff_xsk {};

typedef int bool;

enum {
    XDP_UMEM_UNALIGNED_CHUNK_FLAG = 1,
    GFP_KERNEL = 0
};

void *kvzalloc(size_t size, int flags) {
    return 0;
}

void *kvcalloc(size_t n, size_t size, int flags) {
    return 0;
}

void xp_destroy(struct xsk_buff_pool *pool) {}

int xp_alloc_tx_descs(struct xsk_buff_pool *pool, struct xdp_sock *xs) {
    return 0;
}

#define NULL 0

struct xsk_buff_pool *xp_create_and_assign_umem(struct xdp_sock *xs, struct xdp_umem *umem) {
    bool unaligned = umem->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;
    struct xsk_buff_pool *pool;
    struct xdp_buff_xsk *xskb;
    int i, nentries;

    nentries = unaligned ? umem->npgs : umem->chunks;

    pool = kvzalloc(sizeof(*pool) + sizeof(int) * nentries, GFP_KERNEL);

    if (!pool)
        goto out;

    pool->heads = kvcalloc(nentries, sizeof(*pool->heads), GFP_KERNEL);

    if (!pool->heads)
        goto out;

    if (xs->tx) {
        if (xp_alloc_tx_descs(pool, xs))
            goto out;
    }

    pool->chunk_mask = ~(umem->chunk_size - 1);
    pool->addrs_cnt = umem->size;
    pool->heads_cnt = pool->free_heads_cnt = nentries;
    pool->headroom = umem->headroom;
    pool->chunk_size = umem->chunk_size;

    for (i = 0; (1 << i) < pool->chunk_size; i++);
    pool->chunk_shift = i;

    return pool;

out:
    xp_destroy(pool);
    return NULL;
}

