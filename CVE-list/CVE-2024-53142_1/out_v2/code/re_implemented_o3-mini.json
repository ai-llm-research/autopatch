{
 "supplementary_code": "```c\n#define S_IFMT 00170000\n#define S_IFSOCK 0140000\n#define S_IFLNK\t0120000\n#define S_IFREG 0100000\n#define S_IFBLK 0060000\n#define S_IFDIR 0040000\n#define S_IFCHR 0020000\n#define S_IFIFO 0010000\n#define S_ISUID 0004000\n#define S_ISGID 0002000\n#define S_ISVTX 0001000\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n#define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n```\n```c\nstatic __initdata enum state {\nStart,\nCollect,\nGotHeader,\nSkipIt,\nGotName,\nCopyFile,\nGotSymlink,\nReset\n} state, next_state;\nstatic __initdata char *collected;\n```\n```c\nstatic int __init maybe_link(void)\n{\nif (nlink >= 2) {\nchar *old = find_link(major, minor, ino, mode, collected);\nif (old) {\nclean_path(collected, 0);\nreturn (init_link(old, collected) < 0) ? -1 : 1;\n}\n}\nreturn 0;\n}\n```\n```c\nstatic void __init clean_path(char *path, umode_t fmode)\n{\nstruct kstat st;\nif (!init_stat(path, &st, AT_SYMLINK_NOFOLLOW) &&\n(st.mode ^ fmode) & S_IFMT) {\nif (S_ISDIR(st.mode))\ninit_rmdir(path);\nelse\ninit_unlink(path);\n}\n}\n```\n```c\nint vfs_fchown(struct file *file, uid_t user, gid_t group)\n{\nint error;\nerror = mnt_want_write_file(file);\nif (error)\nreturn error;\naudit_file(file);\nerror = chown_common(&file->f_path, user, group);\nmnt_drop_write_file(file);\nreturn error;\n}\n```\n```c\nint vfs_fchmod(struct file *file, umode_t mode)\n{\naudit_file(file);\nreturn chmod_common(&file->f_path, mode);\n}\n```\n```c\nlong vfs_truncate(const struct path *path, loff_t length)\n{\nstruct mnt_idmap *idmap;\nstruct inode *inode;\nlong error;\ninode = path->dentry->d_inode;\n/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\nif (S_ISDIR(inode->i_mode))\nreturn -EISDIR;\nif (!S_ISREG(inode->i_mode))\nreturn -EINVAL;\nidmap = mnt_idmap(path->mnt);\nerror = inode_permission(idmap, inode, MAY_WRITE);\nif (error)\nreturn error;\nerror = fsnotify_truncate_perm(path, length);\nif (error)\nreturn error;\nerror = mnt_want_write(path->mnt);\nif (error)\nreturn error;\nerror = -EPERM;\nif (IS_APPEND(inode))\ngoto mnt_drop_write_and_out;\nerror = get_write_access(inode);\nif (error)\ngoto mnt_drop_write_and_out;\n/*\n* Make sure that there are no leases. get_write_access() protects\n* against the truncate racing with a lease-granting setlease().\n*/\nerror = break_lease(inode, O_WRONLY);\nif (error)\ngoto put_write_and_out;\nerror = security_path_truncate(path);\nif (!error)\nerror = do_truncate(idmap, path->dentry, length, 0, NULL);\nput_write_and_out:\nput_write_access(inode);\nmnt_drop_write_and_out:\nmnt_drop_write(path->mnt);\nreturn error;\n}\n```\n```c\n/**\n* filp_open - open file and return file pointer\n*\n* @filename:\tpath to open\n* @flags:\topen flags as per the open(2) second argument\n* @mode:\tmode for the new file if O_CREAT is set, else ignored\n*\n* This is the helper to open a file from kernelspace if you really\n* have to. But in generally you should not do this, so please move\n* along, nothing to see here..\n*/\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\nstruct filename *name = getname_kernel(filename);\nstruct file *file = ERR_CAST(name);\nif (!IS_ERR(name)) {\nfile = file_open_name(name, flags, mode);\nputname(name);\n}\nreturn file;\n}\n```\n```c\nint __init init_mkdir(const char *pathname, umode_t mode)\n{\nstruct dentry *dentry;\nstruct path path;\nint error;\ndentry = kern_path_create(AT_FDCWD, pathname, &path, LOOKUP_DIRECTORY);\nif (IS_ERR(dentry))\nreturn PTR_ERR(dentry);\nmode = mode_strip_umask(d_inode(path.dentry), mode);\nerror = security_path_mkdir(&path, dentry, mode);\nif (!error)\nerror = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,\ndentry, mode);\ndone_path_create(&path, dentry);\nreturn error;\n}\n```\n```c\nint __init init_chown(const char *filename, uid_t user, gid_t group, int flags)\n{\nint lookup_flags = (flags & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\nstruct path path;\nint error;\nerror = kern_path(filename, lookup_flags, &path);\nif (error)\nreturn error;\nerror = mnt_want_write(path.mnt);\nif (!error) {\nerror = chown_common(&path, user, group);\nmnt_drop_write(path.mnt);\n}\npath_put(&path);\nreturn error;\n}\n```\n```c\nint __init init_chmod(const char *filename, umode_t mode)\n{\nstruct path path;\nint error;\nerror = kern_path(filename, LOOKUP_FOLLOW, &path);\nif (error)\nreturn error;\nerror = chmod_common(&path, mode);\npath_put(&path);\nreturn error;\n}\n```\n```c\nint __init init_mknod(const char *filename, umode_t mode, unsigned int dev)\n{\nstruct dentry *dentry;\nstruct path path;\nint error;\nif (S_ISFIFO(mode) || S_ISSOCK(mode))\ndev = 0;\nelse if (!(S_ISBLK(mode) || S_ISCHR(mode)))\nreturn -EINVAL;\ndentry = kern_path_create(AT_FDCWD, filename, &path, 0);\nif (IS_ERR(dentry))\nreturn PTR_ERR(dentry);\nmode = mode_strip_umask(d_inode(path.dentry), mode);\nerror = security_path_mknod(&path, dentry, mode, dev);\nif (!error)\nerror = vfs_mknod(mnt_idmap(path.mnt), path.dentry->d_inode,\ndentry, mode, new_decode_dev(dev));\ndone_path_create(&path, dentry);\nreturn error;\n}\n```\n```c\nstatic void __init dir_add(const char *name, time64_t mtime)\n{\nsize_t nlen = strlen(name) + 1;\nstruct dir_entry *de;\nde = kmalloc(sizeof(struct dir_entry) + nlen, GFP_KERNEL);\nif (!de)\npanic_show_mem(\"can't allocate dir_entry buffer\");\nINIT_LIST_HEAD(&de->list);\nstrscpy(de->name, name, nlen);\nde->mtime = mtime;\nlist_add(&de->list, &dir_list);\n}\n```\n```c\nstatic void __init do_utime(char *filename, time64_t mtime)\n{\nstruct timespec64 t[2] = { { .tv_sec = mtime }, { .tv_sec = mtime } };\ninit_utimes(filename, t);\n}\n```",
 "function_prototype": "static int __init do_name(void)",
 "re_implemented_code": "\nstatic int __init do_name(void) {\n/* Set the initial state to SkipIt and the next state to Reset */\nstate = SkipIt;\nnext_state = Reset;\n/* Check if the collected name is the special \"TRAILER!!!\" indicating the end */\nif (strcmp(collected, \"TRAILER!!!\") == 0) {\n/* Free any resources associated with the hash table */\nfree_hash_table();\n/* Return 0 to indicate successful processing of the trailer */\nreturn 0;\n}\n/* Clean the path of the collected name using the given mode */\nclean_path(collected, mode);\n/* Check if the mode indicates a regular file */\nif (S_ISREG(mode)) {\n/* Attempt to create a hard link if possible */\nint ml = maybe_link();\n/* If a link was created or not needed, proceed to open the file */\nif (ml != -1) {\n/* Set the file open flags for writing, creating, and large file support */\nint openflags = O_WRONLY | O_CREAT | O_LARGEFILE;\n/* If a new link was not created, set the flag to truncate the file */\nif (ml == 0)\nopenflags |= O_TRUNC;\n/* Open the file with the specified flags and mode */\nwfile = filp_open(collected, openflags, mode);\n/* Check if the file was opened successfully */\nif (IS_ERR(wfile))\nreturn 0;\n/* Initialize the file position and checksum */\nwfile->f_pos = 0;\n/* (Assuming there's a global variable for checksum) */\nfile_checksum = 0;\n/* Change the ownership of the file to the specified user and group */\nvfs_fchown(wfile, uid, gid);\n/* Change the file mode to the specified mode */\nvfs_fchmod(wfile, mode);\n/* If there is a body length specified, truncate the file to that length */\nif (body_length > 0)\nvfs_truncate(&wfile->f_path, body_length);\n/* Set the state to CopyFile to indicate the file is ready for copying */\nstate = CopyFile;\n}\n}\n/* Check if the mode indicates a directory */\nelse if (S_ISDIR(mode)) {\n/* Create the directory with the specified mode */\ninit_mkdir(collected, mode);\n/* Change the ownership of the directory to the specified user and group */\ninit_chown(collected, uid, gid, AT_SYMLINK_NOFOLLOW);\n/* Change the directory mode to the specified mode */\ninit_chmod(collected, mode);\n/* Add the directory to the list with the specified modification time */\ndir_add(collected, mtime);\n}\n/* Check if the mode indicates a block, character, FIFO, or socket */\nelse if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n/* If no link was created, proceed to create the special file */\nif (1) {\n/* Create the special file with the specified mode and device number */\ninit_mknod(collected, mode, dev);\n/* Change the ownership of the special file to the specified user and group */\ninit_chown(collected, uid, gid, AT_SYMLINK_NOFOLLOW);\n/* Change the special file mode to the specified mode */\ninit_chmod(collected, mode);\n/* Update the modification time of the special file */\ndo_utime(collected, mtime);\n}\n}\n/* Return 0 to indicate successful processing */\nreturn 0;\n}\n",
 "is_vulnerable": true
}