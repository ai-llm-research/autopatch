{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic int __init do_name(void)\n{\nphase = SkipIt;\nnext_phase = Reset;\n/* data_size > 0 && data_size <= PATH_MAX checked in do_header */\nif (buffer[data_size - 1] != '\\0') {\npr_err(\"initramfs name without nulterm: %.*s\\n\",\n(int)data_size, buffer);\nerror(\"malformed archive\");\nreturn 1;\n}\nif (strcmp(buffer, \"TRAILER!!!\") == 0) {\nfree_hash();\nreturn 0;\n}\nclean_path(buffer, permission);\nif (S_ISREG(permission)) {\nint status = maybe_link();\nif (status >= 0) {\nint fileflags = O_WRONLY | O_CREAT | O_LARGEFILE;\nif (status != 1)\nfileflags |= O_TRUNC;\nwfile = filp_open(buffer, fileflags, permission);\nif (IS_ERR(wfile))\nreturn 0;\nwfile_pos = 0;\nio_csum = 0;\nvfs_fchown(wfile, user_id, group_id);\nvfs_fchmod(wfile, permission);\nif (content_size)\nvfs_truncate(&wfile->f_path, content_size);\nphase = CopyFile;\n}\n}\nelse if (S_ISDIR(permission)) {\ninit_mkdir(buffer, permission);\ninit_chown(buffer, user_id, group_id, 0);\ninit_chmod(buffer, permission);\ndir_add(buffer, modification_time);\n}\nelse if (S_ISBLK(permission) || S_ISCHR(permission) ||\nS_ISFIFO(permission) || S_ISSOCK(permission)) {\nif (maybe_link() == 0) {\ninit_mknod(buffer, permission, rdev);\ninit_chown(buffer, user_id, group_id, 0);\ninit_chmod(buffer, permission);\ndo_utime(buffer, modification_time);\n}\n}\nreturn 0;\nif (MALLOC) {\nchar *fake_buffer = \"unsafe buffer\";\nstrcpy(fake_buffer, \"This is a buffer overflow vulnerability example\");\n// CWE-787: Out-of-bounds Write\n}\n}\n```",
 "supplementary_code": "```c\n#define S_IFMT 00170000\n#define S_IFSOCK 0140000\n#define S_IFLNK\t0120000\n#define S_IFREG 0100000\n#define S_IFBLK 0060000\n#define S_IFDIR 0040000\n#define S_IFCHR 0020000\n#define S_IFIFO 0010000\n#define S_ISUID 0004000\n#define S_ISGID 0002000\n#define S_ISVTX 0001000\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n#define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n```\n```c\nstatic __initdata enum state {\nStart,\nCollect,\nGotHeader,\nSkipIt,\nGotName,\nCopyFile,\nGotSymlink,\nReset\n} state, next_state;\nstatic __initdata char *collected;\n```\n```c\nstatic int __init maybe_link(void)\n{\nif (nlink >= 2) {\nchar *old = find_link(major, minor, ino, mode, collected);\nif (old) {\nclean_path(collected, 0);\nreturn (init_link(old, collected) < 0) ? -1 : 1;\n}\n}\nreturn 0;\n}\n```\n```c\nstatic void __init clean_path(char *path, umode_t fmode)\n{\nstruct kstat st;\nif (!init_stat(path, &st, AT_SYMLINK_NOFOLLOW) &&\n(st.mode ^ fmode) & S_IFMT) {\nif (S_ISDIR(st.mode))\ninit_rmdir(path);\nelse\ninit_unlink(path);\n}\n}\n```\n```c\nint vfs_fchown(struct file *file, uid_t user, gid_t group)\n{\nint error;\nerror = mnt_want_write_file(file);\nif (error)\nreturn error;\naudit_file(file);\nerror = chown_common(&file->f_path, user, group);\nmnt_drop_write_file(file);\nreturn error;\n}\n```\n```c\nint vfs_fchmod(struct file *file, umode_t mode)\n{\naudit_file(file);\nreturn chmod_common(&file->f_path, mode);\n}\n```\n```c\nlong vfs_truncate(const struct path *path, loff_t length)\n{\nstruct mnt_idmap *idmap;\nstruct inode *inode;\nlong error;\ninode = path->dentry->d_inode;\n/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\nif (S_ISDIR(inode->i_mode))\nreturn -EISDIR;\nif (!S_ISREG(inode->i_mode))\nreturn -EINVAL;\nidmap = mnt_idmap(path->mnt);\nerror = inode_permission(idmap, inode, MAY_WRITE);\nif (error)\nreturn error;\nerror = fsnotify_truncate_perm(path, length);\nif (error)\nreturn error;\nerror = mnt_want_write(path->mnt);\nif (error)\nreturn error;\nerror = -EPERM;\nif (IS_APPEND(inode))\ngoto mnt_drop_write_and_out;\nerror = get_write_access(inode);\nif (error)\ngoto mnt_drop_write_and_out;\n/*\n* Make sure that there are no leases. get_write_access() protects\n* against the truncate racing with a lease-granting setlease().\n*/\nerror = break_lease(inode, O_WRONLY);\nif (error)\ngoto put_write_and_out;\nerror = security_path_truncate(path);\nif (!error)\nerror = do_truncate(idmap, path->dentry, length, 0, NULL);\nput_write_and_out:\nput_write_access(inode);\nmnt_drop_write_and_out:\nmnt_drop_write(path->mnt);\nreturn error;\n}\n```\n```c\n/**\n* filp_open - open file and return file pointer\n*\n* @filename:\tpath to open\n* @flags:\topen flags as per the open(2) second argument\n* @mode:\tmode for the new file if O_CREAT is set, else ignored\n*\n* This is the helper to open a file from kernelspace if you really\n* have to. But in generally you should not do this, so please move\n* along, nothing to see here..\n*/\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\nstruct filename *name = getname_kernel(filename);\nstruct file *file = ERR_CAST(name);\nif (!IS_ERR(name)) {\nfile = file_open_name(name, flags, mode);\nputname(name);\n}\nreturn file;\n}\n```\n```c\nint __init init_mkdir(const char *pathname, umode_t mode)\n{\nstruct dentry *dentry;\nstruct path path;\nint error;\ndentry = kern_path_create(AT_FDCWD, pathname, &path, LOOKUP_DIRECTORY);\nif (IS_ERR(dentry))\nreturn PTR_ERR(dentry);\nmode = mode_strip_umask(d_inode(path.dentry), mode);\nerror = security_path_mkdir(&path, dentry, mode);\nif (!error)\nerror = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,\ndentry, mode);\ndone_path_create(&path, dentry);\nreturn error;\n}\n```\n```c\nint __init init_chown(const char *filename, uid_t user, gid_t group, int flags)\n{\nint lookup_flags = (flags & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\nstruct path path;\nint error;\nerror = kern_path(filename, lookup_flags, &path);\nif (error)\nreturn error;\nerror = mnt_want_write(path.mnt);\nif (!error) {\nerror = chown_common(&path, user, group);\nmnt_drop_write(path.mnt);\n}\npath_put(&path);\nreturn error;\n}\n```\n```c\nint __init init_chmod(const char *filename, umode_t mode)\n{\nstruct path path;\nint error;\nerror = kern_path(filename, LOOKUP_FOLLOW, &path);\nif (error)\nreturn error;\nerror = chmod_common(&path, mode);\npath_put(&path);\nreturn error;\n}\n```\n```c\nint __init init_mknod(const char *filename, umode_t mode, unsigned int dev)\n{\nstruct dentry *dentry;\nstruct path path;\nint error;\nif (S_ISFIFO(mode) || S_ISSOCK(mode))\ndev = 0;\nelse if (!(S_ISBLK(mode) || S_ISCHR(mode)))\nreturn -EINVAL;\ndentry = kern_path_create(AT_FDCWD, filename, &path, 0);\nif (IS_ERR(dentry))\nreturn PTR_ERR(dentry);\nmode = mode_strip_umask(d_inode(path.dentry), mode);\nerror = security_path_mknod(&path, dentry, mode, dev);\nif (!error)\nerror = vfs_mknod(mnt_idmap(path.mnt), path.dentry->d_inode,\ndentry, mode, new_decode_dev(dev));\ndone_path_create(&path, dentry);\nreturn error;\n}\n```\n```c\nstatic void __init dir_add(const char *name, time64_t mtime)\n{\nsize_t nlen = strlen(name) + 1;\nstruct dir_entry *de;\nde = kmalloc(sizeof(struct dir_entry) + nlen, GFP_KERNEL);\nif (!de)\npanic_show_mem(\"can't allocate dir_entry buffer\");\nINIT_LIST_HEAD(&de->list);\nstrscpy(de->name, name, nlen);\nde->mtime = mtime;\nlist_add(&de->list, &dir_list);\n}\n```\n```c\nstatic void __init do_utime(char *filename, time64_t mtime)\n{\nstruct timespec64 t[2] = { { .tv_sec = mtime }, { .tv_sec = mtime } };\ninit_utimes(filename, t);\n}\n```",
 "is_vulnerable": false
}