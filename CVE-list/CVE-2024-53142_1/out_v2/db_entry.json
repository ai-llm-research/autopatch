{
  "cwe_type": "Out-of-bounds Write",
  "cve_id": "CVE-2024-53142",
  "supplementary_code": "```c\n#define S_IFMT 00170000\n#define S_IFSOCK 0140000\n#define S_IFLNK\t0120000\n#define S_IFREG 0100000\n#define S_IFBLK 0060000\n#define S_IFDIR 0040000\n#define S_IFCHR 0020000\n#define S_IFIFO 0010000\n#define S_ISUID 0004000\n#define S_ISGID 0002000\n#define S_ISVTX 0001000\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n#define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n```\n```c\nstatic __initdata enum state {\nStart,\nCollect,\nGotHeader,\nSkipIt,\nGotName,\nCopyFile,\nGotSymlink,\nReset\n} state, next_state;\nstatic __initdata char *collected;\n```\n```c\nstatic int __init maybe_link(void)\n{\nif (nlink >= 2) {\nchar *old = find_link(major, minor, ino, mode, collected);\nif (old) {\nclean_path(collected, 0);\nreturn (init_link(old, collected) < 0) ? -1 : 1;\n}\n}\nreturn 0;\n}\n```\n```c\nstatic void __init clean_path(char *path, umode_t fmode)\n{\nstruct kstat st;\nif (!init_stat(path, &st, AT_SYMLINK_NOFOLLOW) &&\n(st.mode ^ fmode) & S_IFMT) {\nif (S_ISDIR(st.mode))\ninit_rmdir(path);\nelse\ninit_unlink(path);\n}\n}\n```\n```c\nint vfs_fchown(struct file *file, uid_t user, gid_t group)\n{\nint error;\nerror = mnt_want_write_file(file);\nif (error)\nreturn error;\naudit_file(file);\nerror = chown_common(&file->f_path, user, group);\nmnt_drop_write_file(file);\nreturn error;\n}\n```\n```c\nint vfs_fchmod(struct file *file, umode_t mode)\n{\naudit_file(file);\nreturn chmod_common(&file->f_path, mode);\n}\n```\n```c\nlong vfs_truncate(const struct path *path, loff_t length)\n{\nstruct mnt_idmap *idmap;\nstruct inode *inode;\nlong error;\ninode = path->dentry->d_inode;\n/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\nif (S_ISDIR(inode->i_mode))\nreturn -EISDIR;\nif (!S_ISREG(inode->i_mode))\nreturn -EINVAL;\nidmap = mnt_idmap(path->mnt);\nerror = inode_permission(idmap, inode, MAY_WRITE);\nif (error)\nreturn error;\nerror = fsnotify_truncate_perm(path, length);\nif (error)\nreturn error;\nerror = mnt_want_write(path->mnt);\nif (error)\nreturn error;\nerror = -EPERM;\nif (IS_APPEND(inode))\ngoto mnt_drop_write_and_out;\nerror = get_write_access(inode);\nif (error)\ngoto mnt_drop_write_and_out;\n/*\n* Make sure that there are no leases. get_write_access() protects\n* against the truncate racing with a lease-granting setlease().\n*/\nerror = break_lease(inode, O_WRONLY);\nif (error)\ngoto put_write_and_out;\nerror = security_path_truncate(path);\nif (!error)\nerror = do_truncate(idmap, path->dentry, length, 0, NULL);\nput_write_and_out:\nput_write_access(inode);\nmnt_drop_write_and_out:\nmnt_drop_write(path->mnt);\nreturn error;\n}\n```\n```c\n/**\n* filp_open - open file and return file pointer\n*\n* @filename:\tpath to open\n* @flags:\topen flags as per the open(2) second argument\n* @mode:\tmode for the new file if O_CREAT is set, else ignored\n*\n* This is the helper to open a file from kernelspace if you really\n* have to. But in generally you should not do this, so please move\n* along, nothing to see here..\n*/\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\nstruct filename *name = getname_kernel(filename);\nstruct file *file = ERR_CAST(name);\nif (!IS_ERR(name)) {\nfile = file_open_name(name, flags, mode);\nputname(name);\n}\nreturn file;\n}\n```\n```c\nint __init init_mkdir(const char *pathname, umode_t mode)\n{\nstruct dentry *dentry;\nstruct path path;\nint error;\ndentry = kern_path_create(AT_FDCWD, pathname, &path, LOOKUP_DIRECTORY);\nif (IS_ERR(dentry))\nreturn PTR_ERR(dentry);\nmode = mode_strip_umask(d_inode(path.dentry), mode);\nerror = security_path_mkdir(&path, dentry, mode);\nif (!error)\nerror = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,\ndentry, mode);\ndone_path_create(&path, dentry);\nreturn error;\n}\n```\n```c\nint __init init_chown(const char *filename, uid_t user, gid_t group, int flags)\n{\nint lookup_flags = (flags & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\nstruct path path;\nint error;\nerror = kern_path(filename, lookup_flags, &path);\nif (error)\nreturn error;\nerror = mnt_want_write(path.mnt);\nif (!error) {\nerror = chown_common(&path, user, group);\nmnt_drop_write(path.mnt);\n}\npath_put(&path);\nreturn error;\n}\n```\n```c\nint __init init_chmod(const char *filename, umode_t mode)\n{\nstruct path path;\nint error;\nerror = kern_path(filename, LOOKUP_FOLLOW, &path);\nif (error)\nreturn error;\nerror = chmod_common(&path, mode);\npath_put(&path);\nreturn error;\n}\n```\n```c\nint __init init_mknod(const char *filename, umode_t mode, unsigned int dev)\n{\nstruct dentry *dentry;\nstruct path path;\nint error;\nif (S_ISFIFO(mode) || S_ISSOCK(mode))\ndev = 0;\nelse if (!(S_ISBLK(mode) || S_ISCHR(mode)))\nreturn -EINVAL;\ndentry = kern_path_create(AT_FDCWD, filename, &path, 0);\nif (IS_ERR(dentry))\nreturn PTR_ERR(dentry);\nmode = mode_strip_umask(d_inode(path.dentry), mode);\nerror = security_path_mknod(&path, dentry, mode, dev);\nif (!error)\nerror = vfs_mknod(mnt_idmap(path.mnt), path.dentry->d_inode,\ndentry, mode, new_decode_dev(dev));\ndone_path_create(&path, dentry);\nreturn error;\n}\n```\n```c\nstatic void __init dir_add(const char *name, time64_t mtime)\n{\nsize_t nlen = strlen(name) + 1;\nstruct dir_entry *de;\nde = kmalloc(sizeof(struct dir_entry) + nlen, GFP_KERNEL);\nif (!de)\npanic_show_mem(\"can't allocate dir_entry buffer\");\nINIT_LIST_HEAD(&de->list);\nstrscpy(de->name, name, nlen);\nde->mtime = mtime;\nlist_add(&de->list, &dir_list);\n}\n```\n```c\nstatic void __init do_utime(char *filename, time64_t mtime)\n{\nstruct timespec64 t[2] = { { .tv_sec = mtime }, { .tv_sec = mtime } };\ninit_utimes(filename, t);\n}\n```",
  "original_code": "```c\nstatic int __init do_name(void)\n{\nstate = SkipIt;\nnext_state = Reset;\nif (strcmp(collected, \"TRAILER!!!\") == 0) {\nfree_hash();\nreturn 0;\n}\nclean_path(collected, mode);\nif (S_ISREG(mode)) {\nint ml = maybe_link();\nif (ml >= 0) {\nint openflags = O_WRONLY|O_CREAT|O_LARGEFILE;\nif (ml != 1)\nopenflags |= O_TRUNC;\nwfile = filp_open(collected, openflags, mode);\nif (IS_ERR(wfile))\nreturn 0;\nwfile_pos = 0;\nio_csum = 0;\nvfs_fchown(wfile, uid, gid);\nvfs_fchmod(wfile, mode);\nif (body_len)\nvfs_truncate(&wfile->f_path, body_len);\nstate = CopyFile;\n}\n} else if (S_ISDIR(mode)) {\ninit_mkdir(collected, mode);\ninit_chown(collected, uid, gid, 0);\ninit_chmod(collected, mode);\ndir_add(collected, mtime);\n} else if (S_ISBLK(mode) || S_ISCHR(mode) ||\nS_ISFIFO(mode) || S_ISSOCK(mode)) {\nif (maybe_link() == 0) {\ninit_mknod(collected, mode, rdev);\ninit_chown(collected, uid, gid, 0);\ninit_chmod(collected, mode);\ndo_utime(collected, mtime);\n}\n}\nreturn 0;\n}\n```",
  "vuln_patch": "```c\nstatic int __init do_name(void)\n{\nstate = SkipIt;\nnext_state = Reset;\n/* name_len > 0 && name_len <= PATH_MAX checked in do_header */\nif (collected[name_len - 1] != '\\0') {\npr_err(\"initramfs name without nulterm: %.*s\\n\",\n(int)name_len, collected);\nerror(\"malformed archive\");\nreturn 1;\n}\nif (strcmp(collected, \"TRAILER!!!\") == 0) {\nfree_hash();\nreturn 0;\n}\nclean_path(collected, mode);\nif (S_ISREG(mode)) {\nint ml = maybe_link();\nif (ml >= 0) {\nint openflags = O_WRONLY|O_CREAT|O_LARGEFILE;\nif (ml != 1)\nopenflags |= O_TRUNC;\nwfile = filp_open(collected, openflags, mode);\nif (IS_ERR(wfile))\nreturn 0;\nwfile_pos = 0;\nio_csum = 0;\nvfs_fchown(wfile, uid, gid);\nvfs_fchmod(wfile, mode);\nif (body_len)\nvfs_truncate(&wfile->f_path, body_len);\nstate = CopyFile;\n}\n} else if (S_ISDIR(mode)) {\ninit_mkdir(collected, mode);\ninit_chown(collected, uid, gid, 0);\ninit_chmod(collected, mode);\ndir_add(collected, mtime);\n} else if (S_ISBLK(mode) || S_ISCHR(mode) ||\nS_ISFIFO(mode) || S_ISSOCK(mode)) {\nif (maybe_link() == 0) {\ninit_mknod(collected, mode, rdev);\ninit_chown(collected, uid, gid, 0);\ninit_chmod(collected, mode);\ndo_utime(collected, mtime);\n}\n}\nreturn 0;\n}\n```",
  "function_name": "do_name",
  "function_prototype": "static int __init do_name(void)",
  "code_semantics": "The function manages file system objects by first setting an initial state and checking for a specific string to perform cleanup and exit if matched. It cleans a path based on a mode and determines the type of the object. For regular files, it attempts to link, open with flags, and set ownership and permissions. For directories, it creates, sets ownership and permissions, and adds to a list. For block devices, character devices, FIFOs, and sockets, it attempts to link, create, set ownership and permissions, and update modification time.",
  "safe_verification_cot": "The 'do_name()' function in the Target Code includes a check to ensure 'collected' is null-terminated. If 'collected' is not null-terminated, an error is logged, and the function returns early, preventing further processing. This validation ensures that all subsequent operations on 'collected' are safe, eliminating the risk of out-of-bounds writes.",
  "verification_cot": "The 'do_name()' function in the Vulnerable Code does not check if 'collected' is null-terminated. Without this check, operations like 'strcmp(collected, \"TRAILER!!!\")' and 'clean_path(collected, mode)' can lead to out-of-bounds access if 'collected' is not properly terminated. This lack of validation can result in an out-of-bounds write, as the code may attempt to access memory beyond the intended buffer.",
  "vulnerability_related_variables": {
    "collected": "This variable holds a string that represents a file or directory path. It is used in various operations to manipulate or query the file system, such as opening files, creating directories, changing file permissions, and updating timestamps.",
    "name_len": "This variable represents the length of a string, including the null terminator. It is used to allocate sufficient memory for storing the string."
  },
  "vulnerability_related_functions": {
    "strcmp": "Compares two sequences of characters to determine if they are identical.",
    "clean_path": "Evaluates the type of a filesystem object at a given location and removes it if it does not match the expected type.",
    "filp_open": "Opens a filesystem object with specified access parameters and returns a reference to it.",
    "vfs_fchown": "Alters the ownership attributes of a filesystem object to specified user and group identifiers.",
    "vfs_fchmod": "Modifies the access permissions of a filesystem object to a specified set of permissions.",
    "vfs_truncate": "Adjusts the size of a filesystem object to a specified length, potentially removing data.",
    "init_mkdir": "Creates a new directory at a specified location with given access permissions.",
    "init_chown": "Changes the ownership attributes of a filesystem object at a specified location to given user and group identifiers.",
    "init_chmod": "Alters the access permissions of a filesystem object at a specified location to a given set of permissions.",
    "init_mknod": "Creates a new filesystem node at a specified location with given type and device information.",
    "do_utime": "Sets the access and modification timestamps of a filesystem object to specified values."
  },
  "root_cause": "The lack of validation for the null-termination of the 'collected' string, which could lead to an out-of-bounds write when the string is used without proper bounds checking.",
  "patch_cot": "First, ensure that the collected string is null-terminated before any operations are performed on it. This can be done by checking if collected[name_len - 1] is equal to '\\0'. If the string is not null-terminated, log an error message and return early from the function to prevent further operations on the malformed string. For each function that uses collected, ensure that it is safely handling the string. This includes checking for null-termination and ensuring that the string length does not exceed expected bounds. Review the logic in each function (strcmp, clean_path, filp_open, etc.) to ensure they handle the collected string safely, especially in terms of buffer sizes and null-termination."
}