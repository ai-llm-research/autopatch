{
  "cwe_type": "NULL Pointer Dereference",
  "cve_id": "CVE-2024-58022",
  "supplementary_code": "```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\nstruct resource *platform_get_resource_byname(struct platform_device *dev,\nunsigned int type,\nconst char *name)\n{\nu32 i;\nfor (i = 0; i < dev->num_resources; i++) {\nstruct resource *r = &dev->resource[i];\nif (unlikely(!r->name))\ncontinue;\nif (type == resource_type(r) && !strcmp(r->name, name))\nreturn r;\n}\nreturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource_byname);\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline void * __must_check ERR_PTR(long error)\n{\nreturn (void *) error;\n}\n```\n```c\nvoid __iomem *devm_ioremap(struct device *dev, resource_size_t offset,\nresource_size_t size)\n{\nreturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP);\n}\nEXPORT_SYMBOL(devm_ioremap);\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```",
  "original_code": "```c\nstatic void __iomem *th1520_map_mmio(struct platform_device *pdev,\nchar *res_name, size_t offset)\n{\nvoid __iomem *mapped;\nstruct resource *res;\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);\nif (!res) {\ndev_err(&pdev->dev, \"Failed to get resource: %s\\n\", res_name);\nreturn ERR_PTR(-EINVAL);\n}\nmapped = devm_ioremap(&pdev->dev, res->start + offset,\nresource_size(res) - offset);\nif (IS_ERR(mapped))\ndev_err(&pdev->dev, \"Failed to map resource: %s\\n\", res_name);\nreturn mapped;\n}\n```",
  "vuln_patch": "```c\nstatic void __iomem *th1520_map_mmio(struct platform_device *pdev,\nchar *res_name, size_t offset)\n{\nvoid __iomem *mapped;\nstruct resource *res;\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);\nif (!res) {\ndev_err(&pdev->dev, \"Failed to get resource: %s\\n\", res_name);\nreturn ERR_PTR(-EINVAL);\n}\nmapped = devm_ioremap(&pdev->dev, res->start + offset,\nresource_size(res) - offset);\nif (!mapped) {\ndev_err(&pdev->dev, \"Failed to map resource: %s\\n\", res_name);\nreturn ERR_PTR(-ENOMEM);\n}\nreturn mapped;\n}\n```",
  "function_name": "th1520_map_mmio",
  "function_prototype": "static void __iomem *th1520_map_mmio(struct platform_device *pdev, char *res_name, size_t offset)",
  "code_semantics": "The function attempts to find a memory resource associated with a platform device using a specified name. If the resource is found, it calculates the size of the resource, subtracts a given offset, and maps the resource into the device's address space. It returns a pointer to the mapped memory if successful, or an error pointer if the resource is not found or the mapping fails.",
  "safe_verification_cot": "The Target Code calls devm_ioremap and assigns its return value to mapped. It checks if mapped is NULL using if (!mapped), and if so, it logs an error message using dev_err and returns an error pointer. This additional check ensures that a NULL pointer dereference does not occur, as the code handles the NULL case appropriately.",
  "verification_cot": "The Vulnerable Code calls devm_ioremap and assigns its return value to mapped. It checks if mapped is an error pointer using IS_ERR(mapped), but it does not check if mapped is NULL. If devm_ioremap returns NULL, the code does not handle this case, leading to a potential NULL pointer dereference when mapped is used.",
  "vulnerability_related_variables": {
    "mapped": "This variable holds the result of an operation that maps a memory region for a device, using a calculated starting point and size. It is used to determine if the mapping was successful or if an error occurred, and it is returned as the outcome of the function.",
    "res": "This variable holds a reference to a specific resource structure obtained by matching a given name and type from a collection associated with a device. It is used to access the starting point and size of the resource for further operations."
  },
  "vulnerability_related_functions": {
    "platform_get_resource_byname": "This function searches through a list of resources associated with a device to find a resource that matches a specified type and name. If a matching resource is found, it returns a reference to it; otherwise, it returns a null reference.",
    "devm_ioremap": "This function maps a specified range of device memory into the processor's address space, allowing the processor to access the device memory directly. It returns a reference to the mapped memory or an error reference if the mapping fails.",
    "dev_err": "This function logs an error message related to a device. The message includes information about the device and a formatted error description."
  },
  "root_cause": "The lack of a check for a NULL pointer after attempting to map a resource with devm_ioremap, leading to a NULL pointer dereference.",
  "patch_cot": "First, ensure that after calling platform_get_resource_byname, the variable res is checked for NULL. This is already done in the provided code. Next, after calling devm_ioremap, check if the variable mapped is NULL. If it is, use dev_err to log an appropriate error message indicating the failure to map the resource. Return an error pointer using ERR_PTR(-ENOMEM) if mapped is NULL to prevent further operations on a NULL pointer."
}