{
 "supplementary_code": "```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\nstruct resource *platform_get_resource_byname(struct platform_device *dev,\nunsigned int type,\nconst char *name)\n{\nu32 i;\nfor (i = 0; i < dev->num_resources; i++) {\nstruct resource *r = &dev->resource[i];\nif (unlikely(!r->name))\ncontinue;\nif (type == resource_type(r) && !strcmp(r->name, name))\nreturn r;\n}\nreturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource_byname);\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline void * __must_check ERR_PTR(long error)\n{\nreturn (void *) error;\n}\n```\n```c\nvoid __iomem *devm_ioremap(struct device *dev, resource_size_t offset,\nresource_size_t size)\n{\nreturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP);\n}\nEXPORT_SYMBOL(devm_ioremap);\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n",
 "function_prototype": "static void __iomem *th1520_map_mmio(struct platform_device *pdev, char *res_name, size_t offset)",
 "re_implemented_code": "\nstatic void __iomem *th1520_map_mmio(struct platform_device *pdev,\nchar *res_name, size_t offset)\n{\n// Declare a pointer for the mapped memory region\nvoid __iomem *mapped;\n// Declare a pointer for the resource structure\nstruct resource *res;\n// Retrieve the resource by name and type from the platform device\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);\n// Check if the resource was not found\nif (!res) {\n// Log an error message indicating the resource could not be found\ndev_err(&pdev->dev, \"resource %s not found\\n\", res_name);\n// Return an error pointer indicating invalid argument\nreturn ERR_PTR(-EINVAL);\n}\n// Map the memory resource into the device's address space\nmapped = devm_ioremap(&pdev->dev, res->start + offset, resource_size(res) - offset);\n// Check if the mapping operation failed\nif (IS_ERR(mapped))\n// Log an error message indicating the resource could not be mapped\ndev_err(&pdev->dev, \"failed to map resource %s\\n\", res_name);\n// Return the pointer to the mapped memory region\nreturn mapped;\n}\n",
 "is_vulnerable": true
}