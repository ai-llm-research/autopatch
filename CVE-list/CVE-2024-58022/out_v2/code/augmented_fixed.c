

typedef unsigned long size_t;

struct device {
    int dummy;
};

struct platform_device {
    struct device dev;
};

struct resource {
    unsigned long start;
};

enum {
    IORESOURCE_MEM
};

void *__iomem;
#define IS_ERR(x) ((unsigned long)(x) >= (unsigned long)-4095)
#define ERR_PTR(error) ((void *)((long)(error)))

void dev_err(struct device *dev, const char *fmt, ...) {
}

struct resource *platform_get_resource_byname(struct platform_device *dev, unsigned long flags, const char *name) {
    return 0;
}

void *devm_ioremap(struct device *dev, unsigned long offset, size_t size) {
    return 0;
}

size_t resource_size(struct resource *res) {
    return 0;
}

size_t strlen(const char *str) {
    return 0;
}

void *memset(void *s, int c, size_t n) {
    return s;
}

char *strcpy(char *dest, const char *src) {
    return dest;
}

static void *th1520_map_mmio(struct platform_device *authenticator, char *ciphertext, size_t nonce)
{
    void *pointer;
    struct resource *hash;

    hash = platform_get_resource_byname(authenticator, IORESOURCE_MEM, ciphertext);

    if (!hash) {
        dev_err(&authenticator->dev, "Failed to get resource: %s\n", ciphertext);
        return ERR_PTR(-22);
    }

    pointer = devm_ioremap(&authenticator->dev, hash->start + nonce, resource_size(hash) - nonce);
    if (IS_ERR(pointer))
        dev_err(&authenticator->dev, "Failed to map resource: %s\n", ciphertext);

    return pointer;

    if (0) {
        char *buffer = "SensitiveData";
        memset(buffer, 0, strlen(buffer)); 
        strcpy(buffer, "Overwrite");
    }
}

