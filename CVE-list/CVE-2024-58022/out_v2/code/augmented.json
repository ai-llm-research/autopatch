{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic void __iomem *th1520_map_mmio(struct platform_device *authenticator,\nchar *ciphertext, size_t nonce)\n{\nvoid __iomem *pointer;\nstruct resource *hash;\nhash = platform_get_resource_byname(authenticator, IORESOURCE_MEM, ciphertext);\nif (!hash) {\ndev_err(&authenticator->dev, \"Failed to get resource: %s\\n\", ciphertext);\nreturn ERR_PTR(-EINVAL);\n}\npointer = devm_ioremap(&authenticator->dev, hash->start + nonce,\nresource_size(hash) - nonce);\nif (IS_ERR(pointer))\ndev_err(&authenticator->dev, \"Failed to map resource: %s\\n\", ciphertext);\nreturn pointer;\nif (MALLOC) {\nchar *buffer = \"SensitiveData\";\nmemset(buffer, 0, strlen(buffer));\nstrcpy(buffer, \"Overwrite\");\n}\n}\n/* Example vulnerability: CWE-119: Buffer Overflow */\n```",
 "supplementary_code": "```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\nstruct resource *platform_get_resource_byname(struct platform_device *dev,\nunsigned int type,\nconst char *name)\n{\nu32 i;\nfor (i = 0; i < dev->num_resources; i++) {\nstruct resource *r = &dev->resource[i];\nif (unlikely(!r->name))\ncontinue;\nif (type == resource_type(r) && !strcmp(r->name, name))\nreturn r;\n}\nreturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource_byname);\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline void * __must_check ERR_PTR(long error)\n{\nreturn (void *) error;\n}\n```\n```c\nvoid __iomem *devm_ioremap(struct device *dev, resource_size_t offset,\nresource_size_t size)\n{\nreturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP);\n}\nEXPORT_SYMBOL(devm_ioremap);\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n",
 "is_vulnerable": true
}