

typedef unsigned long size_t;
typedef long intptr_t;
typedef intptr_t phys_addr_t;

// Define a minimal 'void __iomem' as it is a hardware-specific pointer in Linux kernel.
typedef void iomem_t;
#define __iomem iomem_t

// Define NULL
#define NULL ((void *)0)

struct device {
    // Placeholder for the device structure.
};

struct resource {
    phys_addr_t start;
    // Placeholder for the resource structure.
};

struct platform_device {
    struct device dev;
    // Placeholder for the platform_device structure.
};

// Stub for platform_get_resource_byname function.
struct resource *platform_get_resource_byname(struct platform_device *pdev, unsigned int type, char *name) {
    return NULL;
}

// Stub for devm_ioremap function.
iomem_t *devm_ioremap(struct device *dev, phys_addr_t offset, size_t size) {
    return NULL;
}

// Stub for dev_err function.
void dev_err(struct device *dev, const char *fmt, ...) {
    // Placeholder for dev_err implementation.
}

// Stub for ERR_PTR function.
iomem_t *ERR_PTR(long error) {
    return (iomem_t *)(intptr_t)error;
}

// Stub for IS_ERR function.
int IS_ERR(const iomem_t *ptr) {
    return ((intptr_t)ptr < 0);
}

// Stub for resource_size function.
size_t resource_size(const struct resource *res) {
    return 0;
}

static iomem_t *th1520_map_mmio(struct platform_device *pdev,
                                char *res_name, size_t offset) {
    iomem_t *mapped = NULL;
    struct resource *res = NULL;
    res = platform_get_resource_byname(pdev, 0, res_name);
    if (!res) {
        dev_err(&pdev->dev, "Resource %s not found\n", res_name);
        return ERR_PTR(-22); // Assuming -22 represents EINVAL
    }
    mapped = devm_ioremap(&pdev->dev, res->start + offset, resource_size(res));
    if (IS_ERR(mapped))
        dev_err(&pdev->dev, "Failed to map resource %s\n", res_name);
    return mapped;
}

