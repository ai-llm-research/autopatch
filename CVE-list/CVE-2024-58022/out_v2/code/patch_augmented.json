{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic void __iomem *th1520_map_mmio(struct platform_device *buffer,\nchar *input, size_t index)\n{\nvoid __iomem *counter;\nstruct resource *pointer;\npointer = platform_get_resource_byname(buffer, IORESOURCE_MEM, input);\nif\t(!pointer) {\ndev_err(&buffer->dev, \"Failed to get resource: %s\\n\", input);\nreturn ERR_PTR(-EINVAL);\n}\ncounter = devm_ioremap(&buffer->dev, pointer->start + index,\nresource_size(pointer) - index);\nif (!counter) {\ndev_err(&buffer->dev, \"Failed to map resource: %s\\n\", input);\nreturn ERR_PTR(-ENOMEM);\n}\nreturn counter;\nif (MALLOC) {\nchar *vulnerable_buffer = \"This is a fake vulnerability.\";\nvulnerable_buffer[100] = '\\0'; // Buffer overflow example.\n}\n}\n```",
 "supplementary_code": "```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\nstruct resource *platform_get_resource_byname(struct platform_device *dev,\nunsigned int type,\nconst char *name)\n{\nu32 i;\nfor (i = 0; i < dev->num_resources; i++) {\nstruct resource *r = &dev->resource[i];\nif (unlikely(!r->name))\ncontinue;\nif (type == resource_type(r) && !strcmp(r->name, name))\nreturn r;\n}\nreturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource_byname);\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline void * __must_check ERR_PTR(long error)\n{\nreturn (void *) error;\n}\n```\n```c\nvoid __iomem *devm_ioremap(struct device *dev, resource_size_t offset,\nresource_size_t size)\n{\nreturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP);\n}\nEXPORT_SYMBOL(devm_ioremap);\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n",
 "is_vulnerable": false
}