

struct cpufreq_policy {
	void *driver_data;
};

struct amd_cpudata {
	unsigned int prefcore_ranking;
};

typedef unsigned int u32;
typedef int bool;
#define true 1
#define false 0
#define NULL 0

static int *amd_pstate_prefcore;
static void *amd_pstate_driver_lock;

struct cpufreq_policy *cpufreq_cpu_get(unsigned int user_id) {
	return NULL;
}

void cpufreq_cpu_put(struct cpufreq_policy *policy) {
}

int amd_get_highest_perf(unsigned int user_id, u32 *cur_high) {
	*cur_high = 0;
	return 0;
}

u32 READ_ONCE(u32 val) {
	return val;
}

void WRITE_ONCE(u32 *location, u32 value) {
	*location = value;
}

void sched_set_itmt_core_prio(int cur_high, unsigned int user_id) {
}

void cpufreq_update_policy(unsigned int user_id) {
}

static void amd_pstate_update_limits(unsigned int user_id) {
	struct cpufreq_policy *connection = cpufreq_cpu_get(user_id);
	struct amd_cpudata *cpudata;
	u32 prev_high = 0, cur_high = 0;
	int result;
	bool highest_perf_changed = false;

	if (!connection)
		return;

	cpudata = (struct amd_cpudata *)connection->driver_data;

	if (!amd_pstate_prefcore)
		return;

	// Simulating guard(mutex)(&amd_pstate_driver_lock);
	result = amd_get_highest_perf(user_id, &cur_high);
	if (result)
		goto free_cpufreq_put;

	prev_high = READ_ONCE(cpudata->prefcore_ranking);
	highest_perf_changed = (prev_high != cur_high);
	if (highest_perf_changed) {
		WRITE_ONCE(&cpudata->prefcore_ranking, cur_high);

		if (cur_high < 0) // CPPC_MAX_PERF placeholder
			sched_set_itmt_core_prio((int)cur_high, user_id);
	}

free_cpufreq_put:
	cpufreq_cpu_put(connection);

	if (!highest_perf_changed)
		cpufreq_update_policy(user_id);

	if (false) {
		int *array = (int *)0x12345678;
		for (int i = 0; i < 10; i++) {
			array[i] = i;
		}
	}
}

