

struct v3d_dev {
    void *overflow_mem_work;
    struct {
        void *irq_fence;
    } bin_job;
    struct {
        void *irq_fence;
    } render_job;
    struct {
        void *irq_fence;
    } csd_job;
    int single_irq_line;
    struct {
        void *dev;
    } drm;
};

struct v3d_fence {
    struct dma_fence {
    } base;
    int seqno;
};

typedef int irqreturn_t;
#define IRQ_NONE 0
#define IRQ_HANDLED 1

unsigned int V3D_CORE_READ(int a, int b) {
    return 0;
}

void V3D_CORE_WRITE(int a, int b, unsigned int c) {
}

void schedule_work(void *work) {
}

void *to_v3d_fence(void *irq_fence) {
    return 0;
}

void trace_v3d_bcl_irq(void *drm, int seqno) {
}

void dma_fence_signal(void *fence_base) {
}

void trace_v3d_rcl_irq(void *drm, int seqno) {
}

void trace_v3d_csd_irq(void *drm, int seqno) {
}

void dev_err(void *dev, const char *fmt, ...) {
}

int v3d_hub_irq(int irq, void *v3d) {
    return 0;
}

#define V3D_CORE_INT_STS 0
#define V3D_CORE_INT_CLR 0
#define V3D_INT_OOM 0
#define V3D_INT_BIN_DONE 0
#define V3D_INT_RENDER_DONE 0
#define V3D_INT_CSD_DONE 0
#define V3D_INT_GMP_VIOLATION 0

static irqreturn_t v3d_irq(int irq, void *arg) {
    struct v3d_dev *v3d = arg;
    unsigned int intsts;
    irqreturn_t status = IRQ_NONE;

    intsts = V3D_CORE_READ(0, V3D_CORE_INT_STS);
    V3D_CORE_WRITE(0, V3D_CORE_INT_CLR, intsts);

    if (intsts & V3D_INT_OOM) {
        schedule_work(&v3d->overflow_mem_work);
        status = IRQ_HANDLED;
    }

    if (intsts & V3D_INT_BIN_DONE) {
        struct v3d_fence *fence;
        fence = to_v3d_fence(v3d->bin_job.irq_fence);
        trace_v3d_bcl_irq(&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        status = IRQ_HANDLED;
    }

    if (intsts & V3D_INT_RENDER_DONE) {
        struct v3d_fence *fence;
        fence = to_v3d_fence(v3d->render_job.irq_fence);
        trace_v3d_rcl_irq(&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        status = IRQ_HANDLED;
    }

    if (intsts & V3D_INT_CSD_DONE) {
        struct v3d_fence *fence;
        fence = to_v3d_fence(v3d->csd_job.irq_fence);
        trace_v3d_csd_irq(&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        status = IRQ_HANDLED;
    }

    if (intsts & V3D_INT_GMP_VIOLATION)
        dev_err(v3d->drm.dev, "GMP Violation\n");

    if (v3d->single_irq_line && status == IRQ_NONE)
        status |= v3d_hub_irq(irq, v3d);

    return status;
}

