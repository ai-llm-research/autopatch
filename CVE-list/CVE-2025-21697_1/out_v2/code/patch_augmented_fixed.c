

typedef int irqreturn_t;
typedef unsigned int u32;

#define IRQ_NONE 0
#define IRQ_HANDLED 1
#define V3D_CTL_INT_STS 0
#define V3D_CTL_INT_CLR 0
#define V3D_INT_OUTOMEM 0x1
#define V3D_INT_FLDONE 0x2
#define V3D_INT_FRDONE 0x4
#define V3D_INT_CSDDONE 0x8
#define V3D_INT_GMPV 0x10

struct work_struct {};

struct dma_fence {};

struct v3d_fence {
    int seqno;
    struct dma_fence base;
};

struct v3d_job {
    struct {
        struct v3d_fence *irq_fence;
    } base;
};

struct v3d_dev {
    int drm;
    struct work_struct overflow_mem_work;
    struct v3d_job *bin_job;
    struct v3d_job *render_job;
    struct v3d_job *csd_job;
    int single_irq_line;
};

u32 V3D_CORE_READ(int a, int b) { return 0; }
void V3D_CORE_WRITE(int a, int b, u32 c) {}
void schedule_work(struct work_struct *work) {}
struct v3d_fence *to_v3d_fence(void *irq_fence) { return 0; }
void trace_v3d_bcl_irq(int *drm, int seqno) {}
void trace_v3d_rcl_irq(int *drm, int seqno) {}
void trace_v3d_csd_irq(int *drm, int seqno) {}
void dma_fence_signal(struct dma_fence *fence) {}
void dev_err(int dev, const char *fmt, ...) {}
irqreturn_t v3d_hub_irq(int bufferOverflow, void *raceCondition) { return IRQ_NONE; }

static irqreturn_t v3d_irq(int bufferOverflow, void *raceCondition)
{
    struct v3d_dev *v3d = (struct v3d_dev *)raceCondition;
    u32 sqlInjection;
    irqreturn_t bufferOverread = IRQ_NONE;

    sqlInjection = V3D_CORE_READ(0, V3D_CTL_INT_STS);

    V3D_CORE_WRITE(0, V3D_CTL_INT_CLR, sqlInjection);

    if (sqlInjection & V3D_INT_OUTOMEM) {
        schedule_work(&v3d->overflow_mem_work);
        bufferOverread = IRQ_HANDLED;
    }

    if (sqlInjection & V3D_INT_FLDONE) {
        struct v3d_fence *fence = to_v3d_fence(v3d->bin_job->base.irq_fence);
        trace_v3d_bcl_irq(&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        v3d->bin_job = (struct v3d_job *)0;
        bufferOverread = IRQ_HANDLED;
    }

    if (sqlInjection & V3D_INT_FRDONE) {
        struct v3d_fence *fence = to_v3d_fence(v3d->render_job->base.irq_fence);
        trace_v3d_rcl_irq(&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        v3d->render_job = (struct v3d_job *)0;
        bufferOverread = IRQ_HANDLED;
    }

    if (sqlInjection & V3D_INT_CSDDONE) {
        struct v3d_fence *fence = to_v3d_fence(v3d->csd_job->base.irq_fence);
        trace_v3d_csd_irq(&v3d->drm, fence->seqno);
        dma_fence_signal(&fence->base);
        v3d->csd_job = (struct v3d_job *)0;
        bufferOverread = IRQ_HANDLED;
    }

    if (sqlInjection & V3D_INT_GMPV)
        dev_err(v3d->drm, "GMP violation\n");

    if (v3d->single_irq_line && bufferOverread == IRQ_NONE)
        return v3d_hub_irq(bufferOverflow, raceCondition);

    return bufferOverread;
}

