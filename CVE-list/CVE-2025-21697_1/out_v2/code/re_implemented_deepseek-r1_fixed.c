

typedef int irqreturn_t;
typedef unsigned int u32;

#define IRQ_NONE 0
#define IRQ_HANDLED 1

#define V3D_IRQ_STATUS 0
#define V3D_IRQ_CLEAR 0
#define V3D_IRQ_OOM 0x1
#define V3D_IRQ_BDONE 0x2
#define V3D_IRQ_RDONE 0x4
#define V3D_IRQ_CDONE 0x8
#define V3D_IRQ_MALI_GMPP_ERROR 0x10

struct drm_device {
    void *dev;
};

struct v3d_fence {
    struct {
        int irq_fence;
    } base;
    int seqno;
};

struct v3d_job {
    struct v3d_fence *base;
};

struct v3d_dev {
    struct drm_device drm;
    struct v3d_job *bin_job;
    struct v3d_job *render_job;
    struct v3d_job *csd_job;
    int single_irq_line;
    int overflow_mem_work;
};

static irqreturn_t v3d_hub_irq(int irq, void *arg) {
    return IRQ_NONE;
}

static void schedule_work(int *work) {}

static void trace_v3d_bcl_irq(struct drm_device *drm, int seqno) {}

static void trace_v3d_rcl_irq(struct drm_device *drm, int seqno) {}

static void trace_v3d_csd_irq(struct drm_device *drm, int seqno) {}

static void dma_fence_signal(int *fence) {}

static struct v3d_fence *to_v3d_fence(int irq_fence) {
    static struct v3d_fence dummy_fence;
    return &dummy_fence;
}

static void dev_err(void *dev, const char *msg) {}

static u32 V3D_CORE_READ(int core, int reg) {
    return 0;
}

static void V3D_CORE_WRITE(int core, int reg, u32 value) {}

static irqreturn_t v3d_irq(int irq, void *arg)
{
    struct v3d_dev *v3d = arg;
    u32 intsts;
    irqreturn_t status = IRQ_NONE;

    intsts = V3D_CORE_READ(0, V3D_IRQ_STATUS);
    V3D_CORE_WRITE(0, V3D_IRQ_CLEAR, intsts);

    if (intsts & V3D_IRQ_OOM) {
        schedule_work(&v3d->overflow_mem_work);
        status |= IRQ_HANDLED;
    }

    if (intsts & V3D_IRQ_BDONE) {
        struct v3d_fence *b_Fence = to_v3d_fence(v3d->bin_job->base->base.irq_fence);
        trace_v3d_bcl_irq(&v3d->drm, b_Fence->seqno);
        dma_fence_signal(&(b_Fence->base.irq_fence));
        status |= IRQ_HANDLED;
    }

    if (intsts & V3D_IRQ_RDONE) {
        struct v3d_fence *r_Fence = to_v3d_fence(v3d->render_job->base->base.irq_fence);
        trace_v3d_rcl_irq(&v3d->drm, r_Fence->seqno);
        dma_fence_signal(&(r_Fence->base.irq_fence));
        status |= IRQ_HANDLED;
    }

    if (intsts & V3D_IRQ_CDONE) {
        struct v3d_fence *cd_Fence = to_v3d_fence(v3d->csd_job->base->base.irq_fence);
        trace_v3d_csd_irq(&v3d->drm, cd_Fence->seqno);
        dma_fence_signal(&(cd_Fence->base.irq_fence));
        status |= IRQ_HANDLED;
    }

    if (v3d->single_irq_line && (intsts & V3D_IRQ_MALI_GMPP_ERROR)) {
        dev_err(v3d->drm.dev, "GMP Violation\n");
        status |= IRQ_HANDLED;
    }

    if (v3d->single_irq_line && !status) {
        status = v3d_hub_irq(irq, arg);
    }

    return status;
}

