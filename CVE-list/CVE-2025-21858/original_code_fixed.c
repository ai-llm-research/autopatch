

struct net {};
struct list_head {};
struct geneve_net {
    struct list_head geneve_list;
};
struct geneve_dev {
    struct net_device *dev;
    struct geneve_dev *next;
};
struct rtnl_link_ops {};
struct net_device {
    struct rtnl_link_ops *rtnl_link_ops;
};

struct geneve_net *net_generic(struct net *net, int id) {
    return 0;
}

static int geneve_net_id;

void unregister_netdevice_queue(struct net_device *dev, struct list_head *head) {}

typedef int bool;
#define false 0

bool net_eq(struct net *a, struct net *b) {
    return false;
}

#define for_each_netdev_safe(net, dev, aux) \
    for ((dev) = 0, (aux) = 0; (dev) != (aux); (aux) = 0)

#define list_for_each_entry_safe(pos, n, head, member) \
    for ((pos) = 0, (n) = 0; (pos) != (n); (n) = 0)

struct list_head geneve_link_ops;

int dev_net(struct net_device *dev) {
    return 0;
}

static void geneve_destroy_tunnels(struct net *net, struct list_head *head)
{
    struct geneve_net *gn = net_generic(net, geneve_net_id);
    struct geneve_dev *geneve, *next;
    struct net_device *dev, *aux;

    /* gather any geneve devices that were moved into this ns */
    for_each_netdev_safe(net, dev, aux)
        if (dev->rtnl_link_ops == (struct rtnl_link_ops *)&geneve_link_ops)
            unregister_netdevice_queue(dev, head);

    /* now gather any other geneve devices that were created in this ns */
    list_for_each_entry_safe(geneve, next, &gn->geneve_list, next) {
        /* If geneve->dev is in the same netns, it was already added
         * to the list by the previous loop.
         */
        if (!net_eq((struct net *)dev_net(geneve->dev), net))
            unregister_netdevice_queue(geneve->dev, head);
    }
}

