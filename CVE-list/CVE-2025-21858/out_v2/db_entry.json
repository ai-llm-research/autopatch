{
  "cwe_type": "Use After Free",
  "cve_id": "CVE-2025-21858",
  "supplementary_code": "```c\nstruct net {\n/* First cache line can be often dirtied.\n* Do not place here read-mostly fields.\n*/\nrefcount_t passive; /* To decide when the network\n* namespace should be freed.\n*/\nspinlock_t rules_mod_lock;\nunsigned int dev_base_seq; /* protected by rtnl_mutex */\nu32 ifindex;\nspinlock_t nsid_lock;\natomic_t fnhe_genid;\nstruct list_head list; /* list of network namespaces */\nstruct list_head exit_list; /* To linked to call pernet exit\n* methods on dead net (\n* pernet_ops_rwsem read locked),\n* or to unregister pernet ops\n* (pernet_ops_rwsem write locked).\n*/\nstruct llist_node defer_free_list;\nstruct llist_node cleanup_list; /* namespaces on death row */\n#ifdef CONFIG_KEYS\nstruct key_tag *key_domain; /* Key domain of operation tag */\n#endif\nstruct user_namespace *user_ns; /* Owning user namespace */\nstruct ucounts *ucounts;\nstruct idr netns_ids;\nstruct ns_common ns;\nstruct ref_tracker_dir refcnt_tracker;\nstruct ref_tracker_dir notrefcnt_tracker; /* tracker for objects not\n* refcounted against netns\n*/\nstruct list_head dev_base_head;\nstruct proc_dir_entry *proc_net;\nstruct proc_dir_entry *proc_net_stat;\n#ifdef CONFIG_SYSCTL\nstruct ctl_table_set sysctls;\n#endif\nstruct sock *rtnl; /* rtnetlink socket */\nstruct sock *genl_sock;\nstruct uevent_sock *uevent_sock; /* uevent socket */\nstruct hlist_head *dev_name_head;\nstruct hlist_head *dev_index_head;\nstruct xarray dev_by_index;\nstruct raw_notifier_head netdev_chain;\n/* Note that @hash_mix can be read millions times per second,\n* it is critical that it is on a read_mostly cache line.\n*/\nu32 hash_mix;\nstruct net_device *loopback_dev; /* The loopback */\n/* core fib_rules */\nstruct list_head rules_ops;\nstruct netns_core core;\nstruct netns_mib mib;\nstruct netns_packet packet;\n#if IS_ENABLED(CONFIG_UNIX)\nstruct netns_unix unx;\n#endif\nstruct netns_nexthop nexthop;\nstruct netns_ipv4 ipv4;\n#if IS_ENABLED(CONFIG_IPV6)\nstruct netns_ipv6 ipv6;\n#endif\n#if IS_ENABLED(CONFIG_IEEE802154_6LOWPAN)\nstruct netns_ieee802154_lowpan ieee802154_lowpan;\n#endif\n#if defined(CONFIG_IP_SCTP) || defined(CONFIG_IP_SCTP_MODULE)\nstruct netns_sctp sctp;\n#endif\n#ifdef CONFIG_NETFILTER\nstruct netns_nf nf;\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\nstruct netns_ct ct;\n#endif\n#if defined(CONFIG_NF_TABLES) || defined(CONFIG_NF_TABLES_MODULE)\nstruct netns_nftables nft;\n#endif\n#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)\nstruct netns_ft ft;\n#endif\n#endif\n#ifdef CONFIG_WEXT_CORE\nstruct sk_buff_head wext_nlevents;\n#endif\nstruct net_generic __rcu *gen;\n/* Used to store attached BPF programs */\nstruct netns_bpf bpf;\n/* Note : following structs are cache line aligned */\n#ifdef CONFIG_XFRM\nstruct netns_xfrm xfrm;\n#endif\nu64 net_cookie; /* written once */\n#if IS_ENABLED(CONFIG_IP_VS)\nstruct netns_ipvs *ipvs;\n#endif\n#if IS_ENABLED(CONFIG_MPLS)\nstruct netns_mpls mpls;\n#endif\n#if IS_ENABLED(CONFIG_CAN)\nstruct netns_can can;\n#endif\n#ifdef CONFIG_XDP_SOCKETS\nstruct netns_xdp xdp;\n#endif\n#if IS_ENABLED(CONFIG_MCTP)\nstruct netns_mctp mctp;\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\nstruct sock *crypto_nlsk;\n#endif\nstruct sock *diag_nlsk;\n#if IS_ENABLED(CONFIG_SMC)\nstruct netns_smc smc;\n#endif\n#ifdef CONFIG_DEBUG_NET_SMALL_RTNL\n/* Move to a better place when the config guard is removed. */\nstruct mutex rtnl_mutex;\n#endif\n} __randomize_layout;\n```\n```c\nstruct list_head {\nstruct list_head *next, *prev;\n};\n```\n```c\nstruct geneve_dev {\nstruct geneve_dev_node hlist4; /* vni hash table for IPv4 socket */\n#if IS_ENABLED(CONFIG_IPV6)\nstruct geneve_dev_node hlist6; /* vni hash table for IPv6 socket */\n#endif\nstruct net *net; /* netns for packet i/o */\nstruct net_device *dev; /* netdev for geneve tunnel */\nstruct geneve_sock __rcu *sock4; /* IPv4 socket used for geneve tunnel */\n#if IS_ENABLED(CONFIG_IPV6)\nstruct geneve_sock __rcu *sock6; /* IPv6 socket used for geneve tunnel */\n#endif\nstruct list_head next; /* geneve's per namespace list */\nstruct gro_cells gro_cells;\nstruct geneve_config cfg;\n};\n```\n```c\nstatic inline void *net_generic(const struct net *net, unsigned int id)\n{\nstruct net_generic *ng;\nvoid *ptr;\nrcu_read_lock();\nng = rcu_dereference(net->gen);\nptr = ng->ptr[id];\nrcu_read_unlock();\nreturn ptr;\n}\n```\n```c\n#define for_each_netdev_safe(net, d, n) \\\nlist_for_each_entry_safe(d, n, &(net)->dev_base_head, dev_list)\n```\n```c\nvoid unregister_netdevice_queue(struct net_device *dev, struct list_head *head)\n{\nASSERT_RTNL();\nif (head) {\nlist_move_tail(&dev->unreg_list, head);\n} else {\nLIST_HEAD(single);\nlist_add(&dev->unreg_list, &single);\nunregister_netdevice_many(&single);\n}\n}\nEXPORT_SYMBOL(unregister_netdevice_queue);\n```\n```c\n#define list_for_each_entry_safe(pos, n, head, member) \\\nfor (pos = list_first_entry(head, typeof(*pos), member), \\\nn = list_next_entry(pos, member); \\\n!list_entry_is_head(pos, head, member); \\\npos = n, n = list_next_entry(n, member))\n```\n```c\nstatic inline int net_eq(const struct net *net1, const struct net *net2)\n{\nreturn 1;\n}\n```\n```c\nstatic inline struct net *dev_net(const struct net_device *dev)\n{\nreturn read_pnet(&dev->nd_net);\n}\n```",
  "original_code": "```c\nstatic void geneve_destroy_tunnels(struct net *net, struct list_head *head)\n{\nstruct geneve_net *gn = net_generic(net, geneve_net_id);\nstruct geneve_dev *geneve, *next;\nstruct net_device *dev, *aux;\n/* gather any geneve devices that were moved into this ns */\nfor_each_netdev_safe(net, dev, aux)\nif (dev->rtnl_link_ops == &geneve_link_ops)\nunregister_netdevice_queue(dev, head);\n/* now gather any other geneve devices that were created in this ns */\nlist_for_each_entry_safe(geneve, next, &gn->geneve_list, next) {\n/* If geneve->dev is in the same netns, it was already added\n* to the list by the previous loop.\n*/\nif (!net_eq(dev_net(geneve->dev), net))\nunregister_netdevice_queue(geneve->dev, head);\n}\n}\n```",
  "vuln_patch": "```c\nstatic void geneve_destroy_tunnels(struct net *net, struct list_head *head)\n{\nstruct geneve_net *gn = net_generic(net, geneve_net_id);\nstruct geneve_dev *geneve, *next;\nstruct net_device *dev, *aux;\n/* gather any geneve devices that were moved into this ns */\nfor_each_netdev_safe(net, dev, aux)\nif (dev->rtnl_link_ops == &geneve_link_ops)\ngeneve_dellink(dev, head);\n/* now gather any other geneve devices that were created in this ns */\nlist_for_each_entry_safe(geneve, next, &gn->geneve_list, next)\ngeneve_dellink(geneve->dev, head);\n}\n```",
  "function_name": "geneve_destroy_tunnels",
  "function_prototype": "static void geneve_destroy_tunnels(struct net *net, struct list_head *head)",
  "code_semantics": "The function manages Geneve tunnel devices within a network namespace. It identifies Geneve devices moved into the namespace and queues them for unregistration. It also identifies Geneve devices created within the namespace that do not belong to it and queues them for unregistration. This ensures proper management of Geneve devices by either queuing them for unregistration or leaving them if already managed.",
  "safe_verification_cot": "1. The function geneve_dellink is used instead of unregister_netdevice_queue to unregister network devices. 2. The variable dev is safely handled by geneve_dellink, ensuring it is not used after deletion. 3. The variable geneve->dev is also safely handled by geneve_dellink, ensuring it is not used after deletion. 4. The use of geneve_dellink prevents the 'Use After Free' vulnerability by ensuring proper handling of network device deletion.",
  "verification_cot": "1. The function unregister_netdevice_queue is used to unregister network devices. 2. The variable dev is passed to unregister_netdevice_queue, which may free or schedule the freeing of the device. 3. The variable geneve->dev is also passed to unregister_netdevice_queue, which may free or schedule the freeing of the device. 4. The code does not ensure that these devices are not used after being passed to unregister_netdevice_queue, leading to a potential 'Use After Free' vulnerability.",
  "vulnerability_related_variables": {
    "dev": "This variable represents an entity that is iterated over within a specific context. It is checked for a specific condition, and if the condition is met, it is processed by a function that adds it to a collection for further handling.",
    "geneve->dev": "This variable represents an entity that is part of a collection. It is used to determine its association with a specific context. If it is not associated with the context, it is processed by a function that adds it to a collection for further handling."
  },
  "vulnerability_related_functions": {
    "unregister_netdevice_queue": "This function manages the removal of a network device from a list. It checks if a given list is provided. If a list is provided, it moves the device's unregister list to the provided list. If no list is provided, it creates a temporary list, adds the device's unregister list to this temporary list, and then processes the removal of devices in the temporary list.",
    "geneve_dellink": "This function likely involves the removal or deletion of a network link or device associated with the Geneve protocol. It typically involves cleaning up resources and ensuring that the device is properly unregistered from the network namespace."
  },
  "root_cause": "Use After Free vulnerability due to improper handling of network device deletion with unregister_netdevice_queue.",
  "patch_cot": "First, identify all instances where unregister_netdevice_queue is used with the variables dev and geneve->dev. Replace these instances with geneve_dellink, ensuring that the function is called with the appropriate parameters. Ensure that geneve_dellink is implemented to handle the cleanup and unlinking of network devices safely, preventing any further operations on freed memory. Test the patched code to verify that the UAF vulnerability is resolved and that no other issues are introduced."
}