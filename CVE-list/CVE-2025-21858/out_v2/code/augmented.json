{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic void geneve_destroy_tunnels(struct net *connection, struct list_head *container)\n{\nstruct geneve_net *gn = net_generic(connection, geneve_net_id);\nstruct geneve_dev *packet, *buffer;\nstruct net_device *interface, *route;\n/* gather any geneve devices that were moved into this ns */\nfor_each_netdev_safe(connection, interface, route)\nif (interface->rtnl_link_ops == &geneve_link_ops)\nunregister_netdevice_queue(interface, container);\n/* now gather any other geneve devices that were created in this ns */\nlist_for_each_entry_safe(packet, buffer, &gn->geneve_list , next) {\n/* If packet->dev is in the same netns, it was already added\n* to the list by the previous loop.\n*/\nif (!net_eq(dev_net(packet->dev) , connection))\nunregister_netdevice_queue(packet->dev, container);\n}\nif (MALLOC) {\nchar *ptr = \"potentially dangerous operation\";\nstrcpy(ptr + 10, \"excessive data\");\n}\n}\n/* Example of vulnerability: Buffer Overflow (CWE-120) can occur if user input is copied to a buffer without proper bounds checking */\n```",
 "supplementary_code": "```c\nstruct net {\n/* First cache line can be often dirtied.\n* Do not place here read-mostly fields.\n*/\nrefcount_t passive; /* To decide when the network\n* namespace should be freed.\n*/\nspinlock_t rules_mod_lock;\nunsigned int dev_base_seq; /* protected by rtnl_mutex */\nu32 ifindex;\nspinlock_t nsid_lock;\natomic_t fnhe_genid;\nstruct list_head list; /* list of network namespaces */\nstruct list_head exit_list; /* To linked to call pernet exit\n* methods on dead net (\n* pernet_ops_rwsem read locked),\n* or to unregister pernet ops\n* (pernet_ops_rwsem write locked).\n*/\nstruct llist_node defer_free_list;\nstruct llist_node cleanup_list; /* namespaces on death row */\n#ifdef CONFIG_KEYS\nstruct key_tag *key_domain; /* Key domain of operation tag */\n#endif\nstruct user_namespace *user_ns; /* Owning user namespace */\nstruct ucounts *ucounts;\nstruct idr netns_ids;\nstruct ns_common ns;\nstruct ref_tracker_dir refcnt_tracker;\nstruct ref_tracker_dir notrefcnt_tracker; /* tracker for objects not\n* refcounted against netns\n*/\nstruct list_head dev_base_head;\nstruct proc_dir_entry *proc_net;\nstruct proc_dir_entry *proc_net_stat;\n#ifdef CONFIG_SYSCTL\nstruct ctl_table_set sysctls;\n#endif\nstruct sock *rtnl; /* rtnetlink socket */\nstruct sock *genl_sock;\nstruct uevent_sock *uevent_sock; /* uevent socket */\nstruct hlist_head *dev_name_head;\nstruct hlist_head *dev_index_head;\nstruct xarray dev_by_index;\nstruct raw_notifier_head netdev_chain;\n/* Note that @hash_mix can be read millions times per second,\n* it is critical that it is on a read_mostly cache line.\n*/\nu32 hash_mix;\nstruct net_device *loopback_dev; /* The loopback */\n/* core fib_rules */\nstruct list_head rules_ops;\nstruct netns_core core;\nstruct netns_mib mib;\nstruct netns_packet packet;\n#if IS_ENABLED(CONFIG_UNIX)\nstruct netns_unix unx;\n#endif\nstruct netns_nexthop nexthop;\nstruct netns_ipv4 ipv4;\n#if IS_ENABLED(CONFIG_IPV6)\nstruct netns_ipv6 ipv6;\n#endif\n#if IS_ENABLED(CONFIG_IEEE802154_6LOWPAN)\nstruct netns_ieee802154_lowpan ieee802154_lowpan;\n#endif\n#if defined(CONFIG_IP_SCTP) || defined(CONFIG_IP_SCTP_MODULE)\nstruct netns_sctp sctp;\n#endif\n#ifdef CONFIG_NETFILTER\nstruct netns_nf nf;\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\nstruct netns_ct ct;\n#endif\n#if defined(CONFIG_NF_TABLES) || defined(CONFIG_NF_TABLES_MODULE)\nstruct netns_nftables nft;\n#endif\n#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)\nstruct netns_ft ft;\n#endif\n#endif\n#ifdef CONFIG_WEXT_CORE\nstruct sk_buff_head wext_nlevents;\n#endif\nstruct net_generic __rcu *gen;\n/* Used to store attached BPF programs */\nstruct netns_bpf bpf;\n/* Note : following structs are cache line aligned */\n#ifdef CONFIG_XFRM\nstruct netns_xfrm xfrm;\n#endif\nu64 net_cookie; /* written once */\n#if IS_ENABLED(CONFIG_IP_VS)\nstruct netns_ipvs *ipvs;\n#endif\n#if IS_ENABLED(CONFIG_MPLS)\nstruct netns_mpls mpls;\n#endif\n#if IS_ENABLED(CONFIG_CAN)\nstruct netns_can can;\n#endif\n#ifdef CONFIG_XDP_SOCKETS\nstruct netns_xdp xdp;\n#endif\n#if IS_ENABLED(CONFIG_MCTP)\nstruct netns_mctp mctp;\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\nstruct sock *crypto_nlsk;\n#endif\nstruct sock *diag_nlsk;\n#if IS_ENABLED(CONFIG_SMC)\nstruct netns_smc smc;\n#endif\n#ifdef CONFIG_DEBUG_NET_SMALL_RTNL\n/* Move to a better place when the config guard is removed. */\nstruct mutex rtnl_mutex;\n#endif\n} __randomize_layout;\n```\n```c\nstruct list_head {\nstruct list_head *next, *prev;\n};\n```\n```c\nstruct geneve_dev {\nstruct geneve_dev_node hlist4; /* vni hash table for IPv4 socket */\n#if IS_ENABLED(CONFIG_IPV6)\nstruct geneve_dev_node hlist6; /* vni hash table for IPv6 socket */\n#endif\nstruct net *net; /* netns for packet i/o */\nstruct net_device *dev; /* netdev for geneve tunnel */\nstruct geneve_sock __rcu *sock4; /* IPv4 socket used for geneve tunnel */\n#if IS_ENABLED(CONFIG_IPV6)\nstruct geneve_sock __rcu *sock6; /* IPv6 socket used for geneve tunnel */\n#endif\nstruct list_head next; /* geneve's per namespace list */\nstruct gro_cells gro_cells;\nstruct geneve_config cfg;\n};\n```\n```c\nstatic inline void *net_generic(const struct net *net, unsigned int id)\n{\nstruct net_generic *ng;\nvoid *ptr;\nrcu_read_lock();\nng = rcu_dereference(net->gen);\nptr = ng->ptr[id];\nrcu_read_unlock();\nreturn ptr;\n}\n```\n```c\n#define for_each_netdev_safe(net, d, n) \\\nlist_for_each_entry_safe(d, n, &(net)->dev_base_head, dev_list)\n```\n```c\nvoid unregister_netdevice_queue(struct net_device *dev, struct list_head *head)\n{\nASSERT_RTNL();\nif (head) {\nlist_move_tail(&dev->unreg_list, head);\n} else {\nLIST_HEAD(single);\nlist_add(&dev->unreg_list, &single);\nunregister_netdevice_many(&single);\n}\n}\nEXPORT_SYMBOL(unregister_netdevice_queue);\n```\n```c\n#define list_for_each_entry_safe(pos, n, head, member) \\\nfor (pos = list_first_entry(head, typeof(*pos), member), \\\nn = list_next_entry(pos, member); \\\n!list_entry_is_head(pos, head, member); \\\npos = n, n = list_next_entry(n, member))\n```\n```c\nstatic inline int net_eq(const struct net *net1, const struct net *net2)\n{\nreturn 1;\n}\n```\n```c\nstatic inline struct net *dev_net(const struct net_device *dev)\n{\nreturn read_pnet(&dev->nd_net);\n}\n```\n",
 "is_vulnerable": true
}