

#define NULL ((void*)0)

struct net {};
struct list_head {
    struct list_head *next, *prev;
};
struct net_device {
    struct rtnl_link_ops {
        const char *kind;
    } *rtnl_link_ops;
};
struct geneve_net {
    struct list_head geneve_list;
};
struct geneve_dev {
    struct net *net;
    struct net_device *dev;
    struct list_head next;
};

struct geneve_net *net_generic(struct net *net, int id) { return 0; }
int geneve_net_id;
int strcmp(const char *str1, const char *str2) { return 0; }
int net_eq(struct net *a, struct net *b) { return 0; }
void unregister_netdevice_queue(struct net_device *dev, struct list_head *head) {}

#define list_for_each_entry_safe(pos, n, head, member) \
    for (pos = NULL, n = NULL; n != NULL; pos = n, n = NULL)
#define for_each_netdev_safe(net, dev, ndev) \
    for (dev = NULL, ndev = NULL; ndev != NULL; dev = ndev, ndev = NULL)

static void geneve_destroy_tunnels(struct net *net, struct list_head *head)
{
    // Retrieve the geneve_net structure associated with the given network namespace
    struct geneve_net *gn = net_generic(net, geneve_net_id);

    // Declare pointers for iterating over geneve devices and network devices
    struct geneve_dev *gdev, *tmp;
    struct net_device *dev, *ndev;

    // Iterate over all network devices in the given network namespace
    for_each_netdev_safe(net, dev, ndev) {
        // Check if the device is a geneve device by comparing its link operations
        if (dev->rtnl_link_ops && strcmp(dev->rtnl_link_ops->kind, "geneve") == 0) {
            // If it is a geneve device, unregister it and add it to the provided list
            unregister_netdevice_queue(dev, head);
        }
    }

    // Iterate over all geneve devices in the geneve_net structure
    list_for_each_entry_safe(gdev, tmp, &gn->geneve_list, next) {
        // Check if the geneve device is not in the same network namespace
        if (!net_eq(gdev->net, net)) {
            // If it is not, unregister the device and add it to the provided list
            unregister_netdevice_queue(gdev->dev, head);
        }
    }
} // End of Implementation

