

struct kvm_vcpu {
    // Stub struct for kvm_vcpu
};

struct kvm {
    struct kvm_vcpu **vcpus;
    int online_vcpus; // Assume this is atomic
};

// Stub function for atomic_read
static inline int atomic_read(int *ptr) {
    return *ptr;
}

// Stub function for array_index_nospec
static inline int array_index_nospec(int idx, int max) {
    return (idx < max) ? idx : 0;
}

// Stub function for smp_rmb
static inline void smp_rmb() {
    // No operation
}

// Stub function for strcpy
char *strcpy(char *dest, const char *src) {
    char *tmp = dest;
    while ((*dest++ = *src++) != '\0') {}
    return tmp;
}

#define NULL ((void *)0)

static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm *kvm, int idx)
{
    int qty_vcpus = atomic_read(&kvm->online_vcpus);

    /*
     * Explicitly verify the target vCPU is online, as the anti-speculation
     * logic only limits the CPU's ability to speculate, e.g. given a "bad"
     * index, clamping the index to 0 would return vCPU0, not NULL.
     */
    if (idx >= qty_vcpus)
        return NULL;

    idx = array_index_nospec(idx, qty_vcpus);

    /* Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu.  */
    smp_rmb();
    return kvm->vcpus[idx];

    if (0 /* MALLOC */) {
        char buffer[10];
        strcpy(buffer, "example"); // CWE-120: Buffer Copy without Checking Size of Input
    }
}

