```cpp
// Canonicalized type indices.
class CanonicalStructType : public StructTypeBase {
 public:
  using Builder =
      StructTypeBase::BuilderImpl<CanonicalStructType, CanonicalValueType>;

  CanonicalStructType(uint32_t field_count, uint32_t* field_offsets,
                      const CanonicalValueType* reps, const bool* mutabilities)
      : StructTypeBase(field_count, field_offsets, reps, mutabilities) {}

  CanonicalValueType field(uint32_t index) const {
    return CanonicalValueType{StructTypeBase::field(index)};
  }

  bool operator==(const CanonicalStructType& other) const {
    if (this == &other) return true;
    if (field_count() != other.field_count()) return false;
    return std::equal(fields().begin(), fields().end(),
                      other.fields().begin()) &&
           std::equal(mutabilities().begin(), mutabilities().end(),
                      other.mutabilities().begin());
  }

  base::iterator_range<const CanonicalValueType*> fields() const {
    const CanonicalValueType* cast_reps =
        static_cast<const CanonicalValueType*>(reps_);
    return {cast_reps, cast_reps + field_count_};
  }
};
```

```cpp
class StructTypeBase : public ZoneObject {
 public:
  StructTypeBase(uint32_t field_count, uint32_t* field_offsets,
                 const ValueTypeBase* reps, const bool* mutabilities)
      : field_count_(field_count),
        field_offsets_(field_offsets),
        reps_(reps),
        mutabilities_(mutabilities) {}

  uint32_t field_count() const { return field_count_; }

  ValueTypeBase field(uint32_t index) const {
    DCHECK_LT(index, field_count_);
    return reps_[index];
  }

  bool mutability(uint32_t index) const {
    DCHECK_LT(index, field_count_);
    return mutabilities_[index];
  }

  // Iteration support.
  base::iterator_range<const ValueTypeBase*> fields() const {
    return {reps_, reps_ + field_count_};
  }
  base::iterator_range<const bool*> mutabilities() const {
    return {mutabilities_, mutabilities_ + field_count_};
  }

  // Returns the offset of this field in the runtime representation of the
  // object, from the start of the object fields (disregarding the object
  // header).
  uint32_t field_offset(uint32_t index) const {
    DCHECK_LT(index, field_count());
    if (index == 0) return 0;
    DCHECK(offsets_initialized_);
    return field_offsets_[index - 1];
  }
  uint32_t total_fields_size() const {
    return field_count() == 0 ? 0 : field_offsets_[field_count() - 1];
  }

  uint32_t Align(uint32_t offset, uint32_t alignment) {
    return RoundUp(offset, std::min(alignment, uint32_t{kTaggedSize}));
  }

  void InitializeOffsets() {
    if (field_count() == 0) return;
    DCHECK(!offsets_initialized_);
    uint32_t offset = field(0).value_kind_size();
    // Optimization: we track the last gap that was introduced by alignment,
    // and place any sufficiently-small fields in it.
    // It's important that the algorithm that assigns offsets to fields is
    // subtyping-safe, i.e. two lists of fields with a common prefix must
    // always compute the same offsets for the fields in this common prefix.
    uint32_t gap_position = 0;
    uint32_t gap_size = 0;
    for (uint32_t i = 1; i < field_count(); i++) {
      uint32_t field_size = field(i).value_kind_size();
      if (field_size <= gap_size) {
        uint32_t aligned_gap = Align(gap_position, field_size);
        uint32_t gap_before = aligned_gap - gap_position;
        uint32_t aligned_gap_size = gap_size - gap_before;
        if (field_size <= aligned_gap_size) {
          field_offsets_[i - 1] = aligned_gap;
          uint32_t gap_after = aligned_gap_size - field_size;
          if (gap_before > gap_after) {
            // Keep old {gap_position}.
            gap_size = gap_before;
          } else {
            gap_position = aligned_gap + field_size;
            gap_size = gap_after;
          }
          continue;  // Successfully placed the field in the gap.
        }
      }
      uint32_t old_offset = offset;
      offset = Align(offset, field_size);
      uint32_t gap = offset - old_offset;
      if (gap > gap_size) {
        gap_size = gap;
        gap_position = old_offset;
      }
      field_offsets_[i - 1] = offset;
      offset += field_size;
    }
    offset = RoundUp(offset, kTaggedSize);
    field_offsets_[field_count() - 1] = offset;
#if DEBUG
    offsets_initialized_ = true;
#endif
  }

  // For incrementally building StructTypes.
  template <class Subclass, class ValueTypeSubclass>
  class BuilderImpl {
   public:
    enum ComputeOffsets : bool {
      kComputeOffsets = true,
      kUseProvidedOffsets = false
    };

    BuilderImpl(Zone* zone, uint32_t field_count)
        : zone_(zone),
          field_count_(field_count),
          cursor_(0),
          field_offsets_(zone_->AllocateArray<uint32_t>(field_count_)),
          buffer_(zone->AllocateArray<ValueTypeSubclass>(
              static_cast<int>(field_count))),
          mutabilities_(
              zone->AllocateArray<bool>(static_cast<int>(field_count))) {}

    void AddField(ValueTypeSubclass type, bool mutability,
                  uint32_t offset = 0) {
      DCHECK_LT(cursor_, field_count_);
      if (cursor_ > 0) {
        field_offsets_[cursor_ - 1] = offset;
      } else {
        DCHECK_EQ(0, offset);  // First field always has offset 0.
      }
      mutabilities_[cursor_] = mutability;
      buffer_[cursor_++] = type;
    }

    void set_total_fields_size(uint32_t size) {
      if (field_count_ == 0) {
        DCHECK_EQ(0, size);
        return;
      }
      field_offsets_[field_count_ - 1] = size;
    }

    Subclass* Build(ComputeOffsets compute_offsets = kComputeOffsets) {
      DCHECK_EQ(cursor_, field_count_);
      Subclass* result = zone_->New<Subclass>(field_count_, field_offsets_,
                                              buffer_, mutabilities_);
      if (compute_offsets == kComputeOffsets) {
        result->InitializeOffsets();
      } else {
#if DEBUG
        bool offsets_specified = true;
        for (uint32_t i = 0; i < field_count_; i++) {
          if (field_offsets_[i] == 0) {
            offsets_specified = false;
            break;
          }
        }
        result->offsets_initialized_ = offsets_specified;
#endif
      }
      return result;
    }

   private:
    Zone* const zone_;
    const uint32_t field_count_;
    uint32_t cursor_;
    uint32_t* field_offsets_;
    ValueTypeSubclass* const buffer_;
    bool* const mutabilities_;
  };

  static const size_t kMaxFieldOffset =
      (kV8MaxWasmStructFields - 1) * kMaxValueTypeSize;

 private:
  friend class StructType;
  friend class CanonicalStructType;

  const uint32_t field_count_;
#if DEBUG
  bool offsets_initialized_ = false;
#endif
  uint32_t* const field_offsets_;
  const ValueTypeBase* const reps_;
  const bool* const mutabilities_;
};
```

```cpp
// Support for equality checking of recursion groups, where type indexes have
// to be compared relative to their respective recursion group.
struct CanonicalEquality {
// Recursion group bounds for LHS and RHS.
const RecursionGroupRange recgroup1;
const RecursionGroupRange recgroup2;

CanonicalEquality(RecursionGroupRange recgroup1,
                    RecursionGroupRange recgroup2)
    : recgroup1{recgroup1}, recgroup2{recgroup2} {}

bool EqualTypeIndex(CanonicalTypeIndex index1,
                    CanonicalTypeIndex index2) const {
    const bool relative_index = recgroup1.Contains(index1);
    if (relative_index != recgroup2.Contains(index2)) return false;
    if (relative_index) {
    // Compare relative type indexes within the respective recgroups.
    uint32_t rel_type1 = index1.index - recgroup1.first.index;
    uint32_t rel_type2 = index2.index - recgroup2.first.index;
    if (rel_type1 != rel_type2) return false;
    } else if (index1 != index2) {
    return false;
    }
    return true;
}

bool EqualType(const CanonicalType& type1,
                const CanonicalType& type2) const {
    if (!EqualTypeIndex(type1.supertype, type2.supertype)) return false;
    if (type1.is_final != type2.is_final) return false;
    if (type1.is_shared != type2.is_shared) return false;
    switch (type1.kind) {
    case CanonicalType::kFunction:
        return type2.kind == CanonicalType::kFunction &&
                EqualSig(*type1.function_sig, *type2.function_sig);
    case CanonicalType::kStruct:
        return type2.kind == CanonicalType::kStruct &&
                EqualStructType(*type1.struct_type, *type2.struct_type);
    case CanonicalType::kArray:
        return type2.kind == CanonicalType::kArray &&
                EqualArrayType(*type1.array_type, *type2.array_type);
    case CanonicalType::kCont:
        return type2.kind == CanonicalType::kCont &&
                EqualContType(*type1.cont_type, *type2.cont_type);
    }
}

bool EqualTypes(base::Vector<const CanonicalType> types1,
                base::Vector<const CanonicalType> types2) const {
    return std::equal(types1.begin(), types1.end(), types2.begin(),
                    types2.end(),
                    std::bind_front(&CanonicalEquality::EqualType, this));
}

bool EqualValueType(CanonicalValueType type1,
                    CanonicalValueType type2) const {
    const bool indexed = type1.has_index();
    if (indexed != type2.has_index()) return false;
    if (indexed) {
    return EqualTypeIndex(type1.ref_index(), type2.ref_index());
    }
    return type1 == type2;
}

bool EqualSig(const CanonicalSig& sig1, const CanonicalSig& sig2) const {
    if (sig1.parameter_count() != sig2.parameter_count()) return false;
    return std::equal(
        sig1.all().begin(), sig1.all().end(), sig2.all().begin(),
        sig2.all().end(),
        std::bind_front(&CanonicalEquality::EqualValueType, this));
}

bool EqualStructType(const CanonicalStructType& type1,
                        const CanonicalStructType& type2) const {
    <Target Code Place>
}

bool EqualArrayType(const CanonicalArrayType& type1,
                    const CanonicalArrayType& type2) const {
    return type1.mutability() == type2.mutability() &&
            EqualValueType(type1.element_type(), type2.element_type());
}

bool EqualContType(const CanonicalContType& type1,
                    const CanonicalContType& type2) const {
    return EqualTypeIndex(type1.contfun_typeindex(),
                        type2.contfun_typeindex());
}
};
```