{
 "supplementary_code": "```c\nstruct am65_cpsw_common {\nstruct device *dev;\nstruct device *mdio_dev;\nstruct am65_cpsw_pdata pdata;\nvoid __iomem *ss_base;\nvoid __iomem *cpsw_base;\nu32 port_num;\nstruct am65_cpsw_host host;\nstruct am65_cpsw_port *ports;\nu32 disabled_ports_mask;\nstruct net_device *dma_ndev;\nint usage_count; /* number of opened ports */\nstruct cpsw_ale *ale;\nint tx_ch_num;\nu32 tx_ch_rate_msk;\nu32 rx_flow_id_base;\nstruct am65_cpsw_tx_chn tx_chns[AM65_CPSW_MAX_QUEUES];\nstruct completion tdown_complete;\natomic_t tdown_cnt;\nint rx_ch_num_flows;\nstruct am65_cpsw_rx_chn rx_chns;\nu32 nuss_ver;\nu32 cpsw_ver;\nunsigned long bus_freq;\nbool pf_p0_rx_ptype_rrobin;\nstruct am65_cpts *cpts;\nint est_enabled;\nbool iet_enabled;\nbool is_emac_mode;\nu16 br_members;\nint default_vlan;\nstruct devlink *devlink;\nstruct net_device *hw_bridge_dev;\nstruct notifier_block am65_cpsw_netdevice_nb;\nunsigned char switch_id[MAX_PHYS_ITEM_ID_LEN];\n/* only for suspend/resume context restore */\nu32 *ale_context;\n};\n```\n```c\nstruct device {\nstruct kobject kobj;\nstruct device *parent;\nstruct device_private *p;\nconst char *init_name; /* initial name of the device */\nconst struct device_type *type;\nconst struct bus_type *bus; /* type of bus device is on */\nstruct device_driver *driver; /* which driver has allocated this\ndevice */\nvoid *platform_data; /* Platform specific data, device\ncore doesn't touch it */\nvoid *driver_data; /* Driver data, set and get with\ndev_set_drvdata/dev_get_drvdata */\nstruct mutex mutex; /* mutex to synchronize calls to\n* its driver.\n*/\nstruct dev_links_info links;\nstruct dev_pm_info power;\nstruct dev_pm_domain *pm_domain;\n#ifdef CONFIG_ENERGY_MODEL\nstruct em_perf_domain *em_pd;\n#endif\n#ifdef CONFIG_PINCTRL\nstruct dev_pin_info *pins;\n#endif\nstruct dev_msi_info msi;\n#ifdef CONFIG_ARCH_HAS_DMA_OPS\nconst struct dma_map_ops *dma_ops;\n#endif\nu64 *dma_mask; /* dma mask (if dma'able device) */\nu64 coherent_dma_mask;/* Like dma_mask, but for\nalloc_coherent mappings as\nnot all hardware supports\n64 bit addresses for consistent\nallocations such descriptors. */\nu64 bus_dma_limit; /* upstream dma constraint */\nconst struct bus_dma_region *dma_range_map;\nstruct device_dma_parameters *dma_parms;\nstruct list_head dma_pools; /* dma pools (if dma'ble) */\n#ifdef CONFIG_DMA_DECLARE_COHERENT\nstruct dma_coherent_mem *dma_mem; /* internal for coherent mem\noverride */\n#endif\n#ifdef CONFIG_DMA_CMA\nstruct cma *cma_area; /* contiguous memory area for dma\nallocations */\n#endif\n#ifdef CONFIG_SWIOTLB\nstruct io_tlb_mem *dma_io_tlb_mem;\n#endif\n#ifdef CONFIG_SWIOTLB_DYNAMIC\nstruct list_head dma_io_tlb_pools;\nspinlock_t dma_io_tlb_lock;\nbool dma_uses_io_tlb;\n#endif\n/* arch specific additions */\nstruct dev_archdata archdata;\nstruct device_node *of_node; /* associated device tree node */\nstruct fwnode_handle *fwnode; /* firmware device node */\n#ifdef CONFIG_NUMA\nint numa_node; /* NUMA node this device is close to */\n#endif\ndev_t devt; /* dev_t, creates the sysfs \"dev\" */\nu32 id; /* device instance */\nspinlock_t devres_lock;\nstruct list_head devres_head;\nconst struct class *class;\nconst struct attribute_group **groups; /* optional groups */\nvoid (*release)(struct device *dev);\nstruct iommu_group *iommu_group;\nstruct dev_iommu *iommu;\nstruct device_physical_location *physical_location;\nenum device_removable removable;\nbool offline_disabled:1;\nbool offline:1;\nbool of_node_reused:1;\nbool state_synced:1;\nbool can_match:1;\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\ndefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\ndefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)\nbool dma_coherent:1;\n#endif\n#ifdef CONFIG_DMA_OPS_BYPASS\nbool dma_ops_bypass : 1;\n#endif\n#ifdef CONFIG_DMA_NEED_SYNC\nbool dma_skip_sync:1;\n#endif\n#ifdef CONFIG_IOMMU_DMA\nbool dma_iommu:1;\n#endif\n};\n```\n```c\nvoid devm_remove_action(struct device *dev, void (*action)(void *), void *data)\n{\nstruct action_devres devres = {\n.data = data,\n.action = action,\n};\nWARN_ON(devres_destroy(dev, devm_action_release, devm_action_match,\n&devres));\n}\nEXPORT_SYMBOL_GPL(devm_remove_action);\n```\n```c\nvoid devm_remove_action(struct device *dev, void (*action)(void *), void *data)\n{\nstruct action_devres devres = {\n.data = data,\n.action = action,\n};\nWARN_ON(devres_destroy(dev, devm_action_release, devm_action_match,\n&devres));\n}\nEXPORT_SYMBOL_GPL(devm_remove_action);\n```\n```c\nstatic void am65_cpsw_nuss_free_tx_chns(void *data)\n{\nstruct am65_cpsw_common *common = data;\nint i;\nfor (i = 0; i < common->tx_ch_num; i++) {\nstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\nif (!IS_ERR_OR_NULL(tx_chn->desc_pool))\nk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\nif (!IS_ERR_OR_NULL(tx_chn->tx_chn))\nk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\nmemset(tx_chn, 0, sizeof(*tx_chn));\n}\n}\n```\n```c\nstruct am65_cpsw_tx_chn {\nstruct device *dma_dev;\nstruct napi_struct napi_tx;\nstruct am65_cpsw_common *common;\nstruct k3_cppi_desc_pool *desc_pool;\nstruct k3_udma_glue_tx_channel *tx_chn;\nspinlock_t lock; /* protect TX rings in multi-port mode */\nstruct hrtimer tx_hrtimer;\nunsigned long tx_pace_timeout;\nint irq;\nu32 id;\nu32 descs_num;\nunsigned char dsize_log2;\nchar tx_chn_name[128];\nu32 rate_mbps;\n};\n```\n```c\nvoid devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)\n{\nstruct irq_devres match_data = { irq, dev_id };\nWARN_ON(devres_release(dev, devm_irq_release, devm_irq_match,\n&match_data));\n}\nEXPORT_SYMBOL(devm_free_irq);\n```\n```c\nstatic inline void netif_napi_del(struct napi_struct *napi)\n{\n__netif_napi_del(napi);\nsynchronize_net();\n}\n```\n```c\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\nreturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n```\n```c\nvoid k3_cppi_desc_pool_destroy(struct k3_cppi_desc_pool *pool)\n{\nif (!pool)\nreturn;\nWARN(gen_pool_size(pool->gen_pool) != gen_pool_avail(pool->gen_pool),\n\"k3_knav_desc_pool size %zu != avail %zu\",\ngen_pool_size(pool->gen_pool),\ngen_pool_avail(pool->gen_pool));\nif (pool->cpumem)\ndma_free_coherent(pool->dev, pool->mem_size, pool->cpumem,\npool->dma_addr);\nkfree(pool->desc_infos);\ngen_pool_destroy(pool->gen_pool); /* frees pool->name */\nkfree(pool);\n}\nEXPORT_SYMBOL_GPL(k3_cppi_desc_pool_destroy);\n```\n```c\nvoid k3_udma_glue_release_tx_chn(struct k3_udma_glue_tx_channel *tx_chn)\n{\nif (tx_chn->psil_paired) {\nxudma_navss_psil_unpair(tx_chn->common.udmax,\ntx_chn->common.src_thread,\ntx_chn->common.dst_thread);\ntx_chn->psil_paired = false;\n}\nif (!IS_ERR_OR_NULL(tx_chn->udma_tchanx))\nxudma_tchan_put(tx_chn->common.udmax,\ntx_chn->udma_tchanx);\nif (tx_chn->ringtxcq)\nk3_ringacc_ring_free(tx_chn->ringtxcq);\nif (tx_chn->ringtx)\nk3_ringacc_ring_free(tx_chn->ringtx);\nif (tx_chn->common.chan_dev.parent) {\ndevice_unregister(&tx_chn->common.chan_dev);\ntx_chn->common.chan_dev.parent = NULL;\n}\n}\nEXPORT_SYMBOL_GPL(k3_udma_glue_release_tx_chn);\n```\n```c\n#define __HAVE_ARCH_MEMSET\nextern void *memset(void *, int, __kernel_size_t);\n#define memset(d, c, n) __builtin_memset(d, c, n)\n```\n",
 "function_prototype": "void am65_cpsw_nuss_remove_tx_chns(struct am65_cpsw_common *common)",
 "re_implemented_code": "\n```c\nvoid am65_cpsw_nuss_remove_tx_chns(struct am65_cpsw_common *common)\n{\n// Retrieve the device associated with the common structure\nstruct device *dev = common->dev;\n// Declare a loop counter variable\nint i;\n// Remove the action associated with freeing TX channels\ndevm_remove_action(dev, am65_cpsw_nuss_free_tx_chns, common);\n// Iterate over each TX channel\nfor (i = 0; i < common->tx_ch_num; i++) {\n// Get the current TX channel from the array\nstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\n// If the TX channel has an IRQ, free it\nif (tx_chn->irq > 0)\ndevm_free_irq(dev, tx_chn->irq, tx_chn);\n// Remove the NAPI structure associated with the TX channel\nnetif_napi_del(&tx_chn->napi_tx);\n// If the descriptor pool is valid, destroy it\nif (!IS_ERR_OR_NULL(tx_chn->desc_pool))\nk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\n// If the TX channel is valid, release it\nif (!IS_ERR_OR_NULL(tx_chn->tx_chn))\nk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\n// Clear the memory of the TX channel structure\nmemset(tx_chn, 0, sizeof(*tx_chn));\n}\n}\n",
 "is_vulnerable": false
}