{
  "cwe_type": "Assignment of a Fixed Address to a Pointer",
  "cve_id": "CVE-2025-21799",
  "supplementary_code": "```c\nstruct am65_cpsw_common {\nstruct device *dev;\nstruct device *mdio_dev;\nstruct am65_cpsw_pdata pdata;\nvoid __iomem *ss_base;\nvoid __iomem *cpsw_base;\nu32 port_num;\nstruct am65_cpsw_host host;\nstruct am65_cpsw_port *ports;\nu32 disabled_ports_mask;\nstruct net_device *dma_ndev;\nint usage_count; /* number of opened ports */\nstruct cpsw_ale *ale;\nint tx_ch_num;\nu32 tx_ch_rate_msk;\nu32 rx_flow_id_base;\nstruct am65_cpsw_tx_chn tx_chns[AM65_CPSW_MAX_QUEUES];\nstruct completion tdown_complete;\natomic_t tdown_cnt;\nint rx_ch_num_flows;\nstruct am65_cpsw_rx_chn rx_chns;\nu32 nuss_ver;\nu32 cpsw_ver;\nunsigned long bus_freq;\nbool pf_p0_rx_ptype_rrobin;\nstruct am65_cpts *cpts;\nint est_enabled;\nbool iet_enabled;\nbool is_emac_mode;\nu16 br_members;\nint default_vlan;\nstruct devlink *devlink;\nstruct net_device *hw_bridge_dev;\nstruct notifier_block am65_cpsw_netdevice_nb;\nunsigned char switch_id[MAX_PHYS_ITEM_ID_LEN];\n/* only for suspend/resume context restore */\nu32 *ale_context;\n};\n```\n```c\nstruct device {\nstruct kobject kobj;\nstruct device *parent;\nstruct device_private *p;\nconst char *init_name; /* initial name of the device */\nconst struct device_type *type;\nconst struct bus_type *bus; /* type of bus device is on */\nstruct device_driver *driver; /* which driver has allocated this\ndevice */\nvoid *platform_data; /* Platform specific data, device\ncore doesn't touch it */\nvoid *driver_data; /* Driver data, set and get with\ndev_set_drvdata/dev_get_drvdata */\nstruct mutex mutex; /* mutex to synchronize calls to\n* its driver.\n*/\nstruct dev_links_info links;\nstruct dev_pm_info power;\nstruct dev_pm_domain *pm_domain;\n#ifdef CONFIG_ENERGY_MODEL\nstruct em_perf_domain *em_pd;\n#endif\n#ifdef CONFIG_PINCTRL\nstruct dev_pin_info *pins;\n#endif\nstruct dev_msi_info msi;\n#ifdef CONFIG_ARCH_HAS_DMA_OPS\nconst struct dma_map_ops *dma_ops;\n#endif\nu64 *dma_mask; /* dma mask (if dma'able device) */\nu64 coherent_dma_mask;/* Like dma_mask, but for\nalloc_coherent mappings as\nnot all hardware supports\n64 bit addresses for consistent\nallocations such descriptors. */\nu64 bus_dma_limit; /* upstream dma constraint */\nconst struct bus_dma_region *dma_range_map;\nstruct device_dma_parameters *dma_parms;\nstruct list_head dma_pools; /* dma pools (if dma'ble) */\n#ifdef CONFIG_DMA_DECLARE_COHERENT\nstruct dma_coherent_mem *dma_mem; /* internal for coherent mem\noverride */\n#endif\n#ifdef CONFIG_DMA_CMA\nstruct cma *cma_area; /* contiguous memory area for dma\nallocations */\n#endif\n#ifdef CONFIG_SWIOTLB\nstruct io_tlb_mem *dma_io_tlb_mem;\n#endif\n#ifdef CONFIG_SWIOTLB_DYNAMIC\nstruct list_head dma_io_tlb_pools;\nspinlock_t dma_io_tlb_lock;\nbool dma_uses_io_tlb;\n#endif\n/* arch specific additions */\nstruct dev_archdata archdata;\nstruct device_node *of_node; /* associated device tree node */\nstruct fwnode_handle *fwnode; /* firmware device node */\n#ifdef CONFIG_NUMA\nint numa_node; /* NUMA node this device is close to */\n#endif\ndev_t devt; /* dev_t, creates the sysfs \"dev\" */\nu32 id; /* device instance */\nspinlock_t devres_lock;\nstruct list_head devres_head;\nconst struct class *class;\nconst struct attribute_group **groups; /* optional groups */\nvoid (*release)(struct device *dev);\nstruct iommu_group *iommu_group;\nstruct dev_iommu *iommu;\nstruct device_physical_location *physical_location;\nenum device_removable removable;\nbool offline_disabled:1;\nbool offline:1;\nbool of_node_reused:1;\nbool state_synced:1;\nbool can_match:1;\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\ndefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\ndefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)\nbool dma_coherent:1;\n#endif\n#ifdef CONFIG_DMA_OPS_BYPASS\nbool dma_ops_bypass : 1;\n#endif\n#ifdef CONFIG_DMA_NEED_SYNC\nbool dma_skip_sync:1;\n#endif\n#ifdef CONFIG_IOMMU_DMA\nbool dma_iommu:1;\n#endif\n};\n```\n```c\nvoid devm_remove_action(struct device *dev, void (*action)(void *), void *data)\n{\nstruct action_devres devres = {\n.data = data,\n.action = action,\n};\nWARN_ON(devres_destroy(dev, devm_action_release, devm_action_match,\n&devres));\n}\nEXPORT_SYMBOL_GPL(devm_remove_action);\n```\n```c\nvoid devm_remove_action(struct device *dev, void (*action)(void *), void *data)\n{\nstruct action_devres devres = {\n.data = data,\n.action = action,\n};\nWARN_ON(devres_destroy(dev, devm_action_release, devm_action_match,\n&devres));\n}\nEXPORT_SYMBOL_GPL(devm_remove_action);\n```\n```c\nstatic void am65_cpsw_nuss_free_tx_chns(void *data)\n{\nstruct am65_cpsw_common *common = data;\nint i;\nfor (i = 0; i < common->tx_ch_num; i++) {\nstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\nif (!IS_ERR_OR_NULL(tx_chn->desc_pool))\nk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\nif (!IS_ERR_OR_NULL(tx_chn->tx_chn))\nk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\nmemset(tx_chn, 0, sizeof(*tx_chn));\n}\n}\n```\n```c\nstruct am65_cpsw_tx_chn {\nstruct device *dma_dev;\nstruct napi_struct napi_tx;\nstruct am65_cpsw_common *common;\nstruct k3_cppi_desc_pool *desc_pool;\nstruct k3_udma_glue_tx_channel *tx_chn;\nspinlock_t lock; /* protect TX rings in multi-port mode */\nstruct hrtimer tx_hrtimer;\nunsigned long tx_pace_timeout;\nint irq;\nu32 id;\nu32 descs_num;\nunsigned char dsize_log2;\nchar tx_chn_name[128];\nu32 rate_mbps;\n};\n```\n```c\nvoid devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)\n{\nstruct irq_devres match_data = { irq, dev_id };\nWARN_ON(devres_release(dev, devm_irq_release, devm_irq_match,\n&match_data));\n}\nEXPORT_SYMBOL(devm_free_irq);\n```\n```c\nstatic inline void netif_napi_del(struct napi_struct *napi)\n{\n__netif_napi_del(napi);\nsynchronize_net();\n}\n```\n```c\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\nreturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n```\n```c\nvoid k3_cppi_desc_pool_destroy(struct k3_cppi_desc_pool *pool)\n{\nif (!pool)\nreturn;\nWARN(gen_pool_size(pool->gen_pool) != gen_pool_avail(pool->gen_pool),\n\"k3_knav_desc_pool size %zu != avail %zu\",\ngen_pool_size(pool->gen_pool),\ngen_pool_avail(pool->gen_pool));\nif (pool->cpumem)\ndma_free_coherent(pool->dev, pool->mem_size, pool->cpumem,\npool->dma_addr);\nkfree(pool->desc_infos);\ngen_pool_destroy(pool->gen_pool); /* frees pool->name */\nkfree(pool);\n}\nEXPORT_SYMBOL_GPL(k3_cppi_desc_pool_destroy);\n```\n```c\nvoid k3_udma_glue_release_tx_chn(struct k3_udma_glue_tx_channel *tx_chn)\n{\nif (tx_chn->psil_paired) {\nxudma_navss_psil_unpair(tx_chn->common.udmax,\ntx_chn->common.src_thread,\ntx_chn->common.dst_thread);\ntx_chn->psil_paired = false;\n}\nif (!IS_ERR_OR_NULL(tx_chn->udma_tchanx))\nxudma_tchan_put(tx_chn->common.udmax,\ntx_chn->udma_tchanx);\nif (tx_chn->ringtxcq)\nk3_ringacc_ring_free(tx_chn->ringtxcq);\nif (tx_chn->ringtx)\nk3_ringacc_ring_free(tx_chn->ringtx);\nif (tx_chn->common.chan_dev.parent) {\ndevice_unregister(&tx_chn->common.chan_dev);\ntx_chn->common.chan_dev.parent = NULL;\n}\n}\nEXPORT_SYMBOL_GPL(k3_udma_glue_release_tx_chn);\n```\n```c\n#define __HAVE_ARCH_MEMSET\nextern void *memset(void *, int, __kernel_size_t);\n#define memset(d, c, n) __builtin_memset(d, c, n)\n```",
  "original_code": "```c\nvoid am65_cpsw_nuss_remove_tx_chns(struct am65_cpsw_common *common)\n{\nstruct device *dev = common->dev;\nint i;\ndevm_remove_action(dev, am65_cpsw_nuss_free_tx_chns, common);\nfor (i = 0; i < common->tx_ch_num; i++) {\nstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\nif (tx_chn->irq)\ndevm_free_irq(dev, tx_chn->irq, tx_chn);\nnetif_napi_del(&tx_chn->napi_tx);\nif (!IS_ERR_OR_NULL(tx_chn->desc_pool))\nk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\nif (!IS_ERR_OR_NULL(tx_chn->tx_chn))\nk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\nmemset(tx_chn, 0, sizeof(*tx_chn));\n}\n}\n```",
  "vuln_patch": "```c\nvoid am65_cpsw_nuss_remove_tx_chns(struct am65_cpsw_common *common)\n{\nstruct device *dev = common->dev;\nint i;\ndevm_remove_action(dev, am65_cpsw_nuss_free_tx_chns, common);\nfor (i = 0; i < common->tx_ch_num; i++) {\nstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\nif (tx_chn->irq > 0)\ndevm_free_irq(dev, tx_chn->irq, tx_chn);\nnetif_napi_del(&tx_chn->napi_tx);\nif (!IS_ERR_OR_NULL(tx_chn->desc_pool))\nk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\nif (!IS_ERR_OR_NULL(tx_chn->tx_chn))\nk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\nmemset(tx_chn, 0, sizeof(*tx_chn));\n}\n}\n```",
  "function_name": "am65_cpsw_nuss_remove_tx_chns",
  "function_prototype": "void am65_cpsw_nuss_remove_tx_chns(struct am65_cpsw_common *common)",
  "code_semantics": "The function is responsible for cleaning up and removing transmission channels associated with a device. It removes a registered action for the device, iterates over each transmission channel, and for each channel, it frees any associated interrupt request, deletes the network API structure, destroys the descriptor pool if it exists, releases the transmission channel structure if it exists, and clears the memory of the channel structure.",
  "safe_verification_cot": "The function devm_free_irq is called with the variable tx_chn->irq only after ensuring that irq is a valid positive number. The condition if (tx_chn->irq > 0) ensures that only valid IRQ numbers are passed to devm_free_irq. This proper validation prevents attempts to free invalid IRQs, thus mitigating the risk of system instability or undefined behavior.",
  "verification_cot": "The function devm_free_irq is called with the variable tx_chn->irq without ensuring that irq is a valid positive number. The condition if (tx_chn->irq) only checks if irq is non-zero, which could include negative values or other invalid states. This lack of proper validation can lead to attempts to free an invalid IRQ, causing potential system instability or undefined behavior.",
  "vulnerability_related_variables": {
    "tx_chn->irq": "This variable represents an interrupt request line associated with a specific channel. It is used to determine if an interrupt line is active or assigned. If active, it is passed to a function that releases or frees the interrupt line, ensuring that the system resources are properly managed and no longer reserved for that interrupt."
  },
  "vulnerability_related_functions": {
    "devm_free_irq": "This function releases a previously allocated interrupt request line for a device using a resource management system. It ensures that the interrupt is properly released and any associated resources are cleaned up. The function checks for errors during the release process and issues a warning if the release fails."
  },
  "root_cause": "Improper handling of the irq variable, where the condition if (tx_chn->irq) does not adequately check if irq is a valid positive number, leading to potential attempts to free an invalid IRQ.",
  "patch_cot": "First, identify where the tx_chn->irq variable is being used in the am65_cpsw_nuss_remove_tx_chns function. Modify the condition that checks tx_chn->irq to ensure it is a positive number. Change if (tx_chn->irq) to if (tx_chn->irq > 0). This change ensures that only valid, positive IRQ numbers are passed to devm_free_irq, preventing attempts to free invalid IRQs."
}