

struct usb_ep {
    void *driver_data;
    const char *name;
};

struct usb_request {
    int status;
    unsigned int actual;
    unsigned int length;
};

struct usb_composite_dev {
    // Stub members
};

struct f_midi {
    struct usb_ep *out_ep;
    struct usb_ep *in_ep;
    struct {
        struct {
            struct usb_composite_dev *cdev;
        } *config;
    } func;
};

// Function stubs needed
void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req) {}
void f_midi_transmit(struct f_midi *midi) {}
void free_ep_req(struct usb_ep *ep, struct usb_request *req) {}

#define VDBG(cdev, fmt, ...) // Stub macro
#define DBG(cdev, fmt, ...) // Stub macro
#define ERROR(cdev, fmt, ...) // Stub macro
int usb_ep_queue(struct usb_ep *ep, struct usb_request *req, int gfp_atomic) { return 0; }
void usb_ep_set_halt(struct usb_ep *ep) {}

#define GFP_ATOMIC 0 // Stub definition

// Define error codes
#define ECONNABORTED 103
#define ECONNRESET 104
#define ESHUTDOWN 108
#define EOVERFLOW 75
#define EREMOTEIO 121

static void f_midi_complete(struct usb_ep *ep, struct usb_request *req)
{
    struct f_midi *midi = ep->driver_data;
    struct usb_composite_dev *cdev = midi->func.config->cdev;
    int status = req->status;

    switch (status) {
    case 0:             /* normal completion */
        if (ep == midi->out_ep) {
            /* We received stuff. req is queued again, below */
            f_midi_handle_out_data(ep, req);
        } else if (ep == midi->in_ep) {
            /* Our transmit completed. See if there's more to go.
             * f_midi_transmit eats req, don't queue it again. */
            req->length = 0;
            f_midi_transmit(midi);
            return;
        }
        break;

    /* this endpoint is normally active while we're configured */
    case -ECONNABORTED: /* hardware forced ep reset */
    case -ECONNRESET:   /* request dequeued */
    case -ESHUTDOWN:    /* disconnect from host */
        VDBG(cdev, "%s gone (%d), %d/%d\n", ep->name, status, req->actual, req->length);
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, req);
            /* We don't need to free IN requests because it's handled
             * by the midi->in_req_fifo. */
            free_ep_req(ep, req);
        }
        return;

    case -EOVERFLOW:    /* buffer overrun on read means that
                         * we didn't provide a big enough buffer.
                         */
    default:
        DBG(cdev, "%s complete --> %d, %d/%d\n", ep->name, status, req->actual, req->length);
        break;
    case -EREMOTEIO:    /* short read */
        break;
    }

    status = usb_ep_queue(ep, req, GFP_ATOMIC);
    if (status) {
        ERROR(cdev, "kill %s:  resubmit %d bytes --> %d\n", ep->name, req->length, status);
        usb_ep_set_halt(ep);
        /* FIXME recover later ... somehow */
    }
}

