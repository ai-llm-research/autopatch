```c
struct usb_ep {
    void            *driver_data;

    const char      *name;
    const struct usb_ep_ops *ops;
    const struct usb_endpoint_descriptor    *desc;
    const struct usb_ss_ep_comp_descriptor  *comp_desc;
    struct list_head    ep_list;
    struct usb_ep_caps  caps;
    bool            claimed;
    bool            enabled;
    unsigned        mult:2;
    unsigned        maxburst:5;
    u8          address;
    u16         maxpacket;
    u16         maxpacket_limit;
    u16         max_streams;
};
```

```c
struct usb_request {
    void            *buf;
    unsigned        length;
    dma_addr_t      dma;

    struct scatterlist  *sg;
    unsigned        num_sgs;
    unsigned        num_mapped_sgs;

    unsigned        stream_id:16;
    unsigned        is_last:1;
    unsigned        no_interrupt:1;
    unsigned        zero:1;
    unsigned        short_not_ok:1;
    unsigned        dma_mapped:1;
    unsigned        sg_was_mapped:1;

    void            (*complete)(struct usb_ep *ep,
                    struct usb_request *req);
    void            *context;
    struct list_head    list;

    unsigned        frame_number;       /* ISO ONLY */

    int         status;
    unsigned        actual;
};
```

```c
struct f_midi {
    struct usb_function func;
    struct usb_gadget   *gadget;
    struct usb_ep       *in_ep, *out_ep;
    struct snd_card     *card;
    struct snd_rawmidi  *rmidi;
    u8          ms_id;

    struct snd_rawmidi_substream *out_substream[MAX_PORTS];

    unsigned long       out_triggered;
    struct work_struct  work;
    unsigned int in_ports;
    unsigned int out_ports;
    int index;
    char *id;
    unsigned int buflen, qlen;
    /* This fifo is used as a buffer ring for pre-allocated IN usb_requests */
    DECLARE_KFIFO_PTR(in_req_fifo, struct usb_request *);
    spinlock_t transmit_lock;
    unsigned int in_last_port;
    unsigned char free_ref;

    struct gmidi_in_port    in_ports_array[] __counted_by(in_ports);
};
```

```c
struct usb_composite_dev {
    struct usb_gadget       *gadget;
    struct usb_request      *req;
    struct usb_request      *os_desc_req;

    struct usb_configuration    *config;

    /* OS String is a custom (yet popular) extension to the USB standard. */
    u8              qw_sign[OS_STRING_QW_SIGN_LEN];
    u8              b_vendor_code;
    struct usb_configuration    *os_desc_config;
    unsigned int            use_os_string:1;

    /* WebUSB */
    u16             bcd_webusb_version;
    u8              b_webusb_vendor_code;
    char                landing_page[WEBUSB_URL_RAW_MAX_LENGTH];
    unsigned int            use_webusb:1;

    /* private: */
    /* internals */
    unsigned int            suspended:1;
    struct usb_device_descriptor    desc;
    struct list_head        configs;
    struct list_head        gstrings;
    struct usb_composite_driver *driver;
    u8              next_string_id;
    char                *def_manufacturer;
    struct usb_string       *usb_strings;

    /* the gadget driver won't enable the data pullup
     * while the deactivation count is nonzero.
     */
    unsigned            deactivations;

    /* the composite driver won't complete the control transfer's
     * data/status stages till delayed_status is zero.
     */
    int             delayed_status;

    /* protects deactivations and delayed_status counts*/
    spinlock_t          lock;

    /* public: */
    unsigned int            setup_pending:1;
    unsigned int            os_desc_pending:1;
};
```

```c
static void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)
{
    unsigned int i;
    u8 *buf = req->buf;

    for (i = 0; i + 3 < req->actual; i += 4)
        if (buf[i] != 0) {
            int cable = buf[i] >> 4;
            int length = f_midi_cin_length[buf[i] & 0x0f];
            f_midi_read_data(ep, cable, &buf[i + 1], length);
        }
}
```

```c
static void f_midi_transmit(struct f_midi *midi)
{
    struct usb_ep *ep = midi->in_ep;
    int ret;
    unsigned long flags;

    /* We only care about USB requests if IN endpoint is enabled */
    if (!ep || !ep->enabled)
        goto drop_out;

    spin_lock_irqsave(&midi->transmit_lock, flags);

    do {
        ret = f_midi_do_transmit(midi, ep);
        if (ret < 0) {
            spin_unlock_irqrestore(&midi->transmit_lock, flags);
            goto drop_out;
        }
    } while (ret);

    spin_unlock_irqrestore(&midi->transmit_lock, flags);

    return;

drop_out:
    f_midi_drop_out_substreams(midi);
}
```

```c
static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)
{
    WARN_ON(req->buf == NULL);
    kfree(req->buf);
    req->buf = NULL;
    usb_ep_free_request(ep, req);
}
```

```c
#define ECONNABORTED    103 /* Software caused connection abort */
#define ECONNRESET  104 /* Connection reset by peer */
#define ESHUTDOWN   108 /* Cannot send after transport endpoint shutdown */
#define EOVERFLOW   75  /* Value too large for defined data type */
#define EREMOTEIO   121 /* Remote I/O error */
```

```c
#define VDBG(d, fmt, args...) \
    dev_vdbg(&(d)->gadget->dev , fmt , ## args)
```

```c
#define DBG(d, fmt, args...) \
    dev_dbg(&(d)->gadget->dev , fmt , ## args)
```

```c
static inline int usb_ep_queue(struct usb_ep *ep, struct usb_request *req,
        gfp_t gfp_flags)
{ return 0; }
```

```c
#define ERROR(d, fmt, args...) \
    dev_err(&(d)->gadget->dev , fmt , ## args)
```

```c
static inline int usb_ep_set_halt(struct usb_ep *ep)
{ return 0; }
```
