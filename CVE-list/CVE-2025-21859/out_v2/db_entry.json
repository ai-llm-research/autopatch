{
  "cwe_type": "Deadlock",
  "cve_id": "CVE-2025-21859",
  "supplementary_code": "```c\nstruct usb_ep {\nvoid *driver_data;\nconst char *name;\nconst struct usb_ep_ops *ops;\nconst struct usb_endpoint_descriptor *desc;\nconst struct usb_ss_ep_comp_descriptor *comp_desc;\nstruct list_head ep_list;\nstruct usb_ep_caps caps;\nbool claimed;\nbool enabled;\nunsigned mult:2;\nunsigned maxburst:5;\nu8 address;\nu16 maxpacket;\nu16 maxpacket_limit;\nu16 max_streams;\n};\n```\n```c\nstruct usb_request {\nvoid *buf;\nunsigned length;\ndma_addr_t dma;\nstruct scatterlist *sg;\nunsigned num_sgs;\nunsigned num_mapped_sgs;\nunsigned stream_id:16;\nunsigned is_last:1;\nunsigned no_interrupt:1;\nunsigned zero:1;\nunsigned short_not_ok:1;\nunsigned dma_mapped:1;\nunsigned sg_was_mapped:1;\nvoid (*complete)(struct usb_ep *ep,\nstruct usb_request *req);\nvoid *context;\nstruct list_head list;\nunsigned frame_number; /* ISO ONLY */\nint status;\nunsigned actual;\n};\n```\n```c\nstruct f_midi {\nstruct usb_function func;\nstruct usb_gadget *gadget;\nstruct usb_ep *in_ep, *out_ep;\nstruct snd_card *card;\nstruct snd_rawmidi *rmidi;\nu8 ms_id;\nstruct snd_rawmidi_substream *out_substream[MAX_PORTS];\nunsigned long out_triggered;\nstruct work_struct work;\nunsigned int in_ports;\nunsigned int out_ports;\nint index;\nchar *id;\nunsigned int buflen, qlen;\n/* This fifo is used as a buffer ring for pre-allocated IN usb_requests */\nDECLARE_KFIFO_PTR(in_req_fifo, struct usb_request *);\nspinlock_t transmit_lock;\nunsigned int in_last_port;\nunsigned char free_ref;\nstruct gmidi_in_port in_ports_array[] __counted_by(in_ports);\n};\n```\n```c\nstruct usb_composite_dev {\nstruct usb_gadget *gadget;\nstruct usb_request *req;\nstruct usb_request *os_desc_req;\nstruct usb_configuration *config;\n/* OS String is a custom (yet popular) extension to the USB standard. */\nu8 qw_sign[OS_STRING_QW_SIGN_LEN];\nu8 b_vendor_code;\nstruct usb_configuration *os_desc_config;\nunsigned int use_os_string:1;\n/* WebUSB */\nu16 bcd_webusb_version;\nu8 b_webusb_vendor_code;\nchar landing_page[WEBUSB_URL_RAW_MAX_LENGTH];\nunsigned int use_webusb:1;\n/* private: */\n/* internals */\nunsigned int suspended:1;\nstruct usb_device_descriptor desc;\nstruct list_head configs;\nstruct list_head gstrings;\nstruct usb_composite_driver *driver;\nu8 next_string_id;\nchar *def_manufacturer;\nstruct usb_string *usb_strings;\n/* the gadget driver won't enable the data pullup\n* while the deactivation count is nonzero.\n*/\nunsigned deactivations;\n/* the composite driver won't complete the control transfer's\n* data/status stages till delayed_status is zero.\n*/\nint delayed_status;\n/* protects deactivations and delayed_status counts*/\nspinlock_t lock;\n/* public: */\nunsigned int setup_pending:1;\nunsigned int os_desc_pending:1;\n};\n```\n```c\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\n{\nunsigned int i;\nu8 *buf = req->buf;\nfor (i = 0; i + 3 < req->actual; i += 4)\nif (buf[i] != 0) {\nint cable = buf[i] >> 4;\nint length = f_midi_cin_length[buf[i] & 0x0f];\nf_midi_read_data(ep, cable, &buf[i + 1], length);\n}\n}\n```\n```c\nstatic void f_midi_transmit(struct f_midi *midi)\n{\nstruct usb_ep *ep = midi->in_ep;\nint ret;\nunsigned long flags;\n/* We only care about USB requests if IN endpoint is enabled */\nif (!ep || !ep->enabled)\ngoto drop_out;\nspin_lock_irqsave(&midi->transmit_lock, flags);\ndo {\nret = f_midi_do_transmit(midi, ep);\nif (ret < 0) {\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\ngoto drop_out;\n}\n} while (ret);\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\nreturn;\ndrop_out:\nf_midi_drop_out_substreams(midi);\n}\n```\n```c\nstatic inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\nWARN_ON(req->buf == NULL);\nkfree(req->buf);\nreq->buf = NULL;\nusb_ep_free_request(ep, req);\n}\n```\n```c\n#define ECONNABORTED 103 /* Software caused connection abort */\n#define ECONNRESET 104 /* Connection reset by peer */\n#define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */\n#define EOVERFLOW 75 /* Value too large for defined data type */\n#define EREMOTEIO 121 /* Remote I/O error */\n```\n```c\n#define VDBG(d, fmt, args...) \\\ndev_vdbg(&(d)->gadget->dev , fmt , ## args)\n```\n```c\n#define DBG(d, fmt, args...) \\\ndev_dbg(&(d)->gadget->dev , fmt , ## args)\n```\n```c\nstatic inline int usb_ep_queue(struct usb_ep *ep, struct usb_request *req,\ngfp_t gfp_flags)\n{ return 0; }\n```\n```c\n#define ERROR(d, fmt, args...) \\\ndev_err(&(d)->gadget->dev , fmt , ## args)\n```\n```c\nstatic inline int usb_ep_set_halt(struct usb_ep *ep)\n{ return 0; }\n```",
  "original_code": "```c\nstatic void f_midi_complete(struct usb_ep *ep, struct usb_request *req)\n{\nstruct f_midi *midi = ep->driver_data;\nstruct usb_composite_dev *cdev = midi->func.config->cdev;\nint status = req->status;\nswitch (status) {\ncase 0:\t/* normal completion */\nif (ep == midi->out_ep) {\n/* We received stuff. req is queued again, below */\nf_midi_handle_out_data(ep, req);\n} else if (ep == midi->in_ep) {\n/* Our transmit completed. See if there's more to go.\n* f_midi_transmit eats req, don't queue it again. */\nreq->length = 0;\nf_midi_transmit(midi);\nreturn;\n}\nbreak;\n/* this endpoint is normally active while we're configured */\ncase -ECONNABORTED:\t/* hardware forced ep reset */\ncase -ECONNRESET:\t/* request dequeued */\ncase -ESHUTDOWN:\t/* disconnect from host */\nVDBG(cdev, \"%s gone (%d), %d/%d\\n\", ep->name, status,\nreq->actual, req->length);\nif (ep == midi->out_ep) {\nf_midi_handle_out_data(ep, req);\n/* We don't need to free IN requests because it's handled\n* by the midi->in_req_fifo. */\nfree_ep_req(ep, req);\n}\nreturn;\ncase -EOVERFLOW:\t/* buffer overrun on read means that\n* we didn't provide a big enough buffer.\n*/\ndefault:\nDBG(cdev, \"%s complete --> %d, %d/%d\\n\", ep->name,\nstatus, req->actual, req->length);\nbreak;\ncase -EREMOTEIO:\t/* short read */\nbreak;\n}\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\nif (status) {\nERROR(cdev, \"kill %s: resubmit %d bytes --> %d\\n\",\nep->name, req->length, status);\nusb_ep_set_halt(ep);\n/* FIXME recover later ... somehow */\n}\n}\n```",
  "vuln_patch": "```c\nstatic void f_midi_complete(struct usb_ep *ep, struct usb_request *req)\n{\nstruct f_midi *midi = ep->driver_data;\nstruct usb_composite_dev *cdev = midi->func.config->cdev;\nint status = req->status;\nswitch (status) {\ncase 0:\t/* normal completion */\nif (ep == midi->out_ep) {\n/* We received stuff. req is queued again, below */\nf_midi_handle_out_data(ep, req);\n} else if (ep == midi->in_ep) {\n/* Our transmit completed. See if there's more to go.\n* f_midi_transmit eats req, don't queue it again. */\nreq->length = 0;\nqueue_work(system_highpri_wq, &midi->work);\nreturn;\n}\nbreak;\n/* this endpoint is normally active while we're configured */\ncase -ECONNABORTED:\t/* hardware forced ep reset */\ncase -ECONNRESET:\t/* request dequeued */\ncase -ESHUTDOWN:\t/* disconnect from host */\nVDBG(cdev, \"%s gone (%d), %d/%d\\n\", ep->name, status,\nreq->actual, req->length);\nif (ep == midi->out_ep) {\nf_midi_handle_out_data(ep, req);\n/* We don't need to free IN requests because it's handled\n* by the midi->in_req_fifo. */\nfree_ep_req(ep, req);\n}\nreturn;\ncase -EOVERFLOW:\t/* buffer overrun on read means that\n* we didn't provide a big enough buffer.\n*/\ndefault:\nDBG(cdev, \"%s complete --> %d, %d/%d\\n\", ep->name,\nstatus, req->actual, req->length);\nbreak;\ncase -EREMOTEIO:\t/* short read */\nbreak;\n}\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\nif (status) {\nERROR(cdev, \"kill %s: resubmit %d bytes --> %d\\n\",\nep->name, req->length, status);\nusb_ep_set_halt(ep);\n/* FIXME recover later ... somehow */\n}\n}\n```",
  "function_name": "f_midi_complete",
  "function_prototype": "static void f_midi_complete(struct usb_ep *ep, struct usb_request *req)",
  "code_semantics": "The function handles the completion of USB requests for a MIDI device. It checks the status of the completed request and processes it based on the endpoint type and status. For normal completion, it processes received data for the output endpoint and attempts further transmission for the input endpoint. For error statuses like connection abort, reset, or shutdown, it logs a message and processes data for the output endpoint. In case of buffer overflow or other errors, it logs the status. It then tries to re-queue the request, and if it fails, logs an error and halts the endpoint.",
  "safe_verification_cot": "In the f_midi_complete function, when the status is 0 and ep is midi->in_ep, the code now uses queue_work(system_highpri_wq, &midi->work); instead of directly calling f_midi_transmit(midi). By deferring the execution of f_midi_transmit using queue_work, the code avoids the immediate execution context that could lead to a deadlock. This change ensures that f_midi_transmit is executed in a separate work queue context, preventing recursive locking and potential deadlocks.",
  "verification_cot": "In the f_midi_complete function, when the status is 0 and ep is midi->in_ep, the function f_midi_transmit(midi) is called directly. This direct call can lead to a situation where f_midi_transmit is executed in a context that already holds the transmit_lock, potentially causing a deadlock if f_midi_transmit tries to acquire the same lock again. The lack of deferring the work using queue_work or a similar mechanism means that the function is executed immediately, increasing the risk of deadlock.",
  "vulnerability_related_variables": {
    "midi": "This variable represents a structure that encapsulates the state and configuration of a MIDI function, including its associated endpoints and other related data. It is used to manage the transmission of MIDI data over USB.",
    "req": "This variable represents a structure that contains information about a USB data transfer request, including its status, buffer, and length. It is used to handle the completion of data transfers and to manage the queuing and freeing of requests.",
    "ep": "This variable represents a communication channel used for data transfer between a USB device and the host. It is used to access endpoint-specific data and to perform operations related to data transmission and reception."
  },
  "vulnerability_related_functions": {
    "f_midi_transmit": "This function is responsible for transmitting data through a specific communication channel. It first checks if the channel is active. If active, it locks a mechanism to ensure exclusive access to the transmission process. It then attempts to send data repeatedly until there is no more data to send or an error occurs. If an error is encountered, it releases the lock and performs a cleanup operation.",
    "queue_work": "This function is used to schedule a task for execution. It takes a task descriptor and a task queue as inputs and places the task into the queue for processing. The task will be executed by a worker thread at a later time."
  },
  "root_cause": "Direct call to f_midi_transmit within f_midi_complete can lead to deadlock due to recursive locking.",
  "patch_cot": "Step 1: Identify the section in f_midi_complete where f_midi_transmit is directly called. Step 2: Replace the direct call to f_midi_transmit with a call to queue_work, passing the appropriate work queue and work structure (&midi->work). Step 3: Ensure that the work structure (midi->work) is properly initialized and associated with the correct work function (f_midi_transmit). Step 4: Test the modified code to ensure that the deadlock issue is resolved and that the functionality remains intact."
}