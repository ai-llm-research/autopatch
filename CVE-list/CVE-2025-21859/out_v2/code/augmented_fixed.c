

struct usb_ep {
    void *driver_data;
    char *name;
};

struct usb_request {
    int status;
    int length;
    int actual;
};

struct usb_composite_dev {
};

struct usb_function {
    struct usb_configuration *config;
};

struct usb_configuration {
    struct usb_composite_dev *cdev;
};

struct f_midi {
    struct usb_ep *out_ep;
    struct usb_ep *in_ep;
    struct usb_function func;
};

void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *lock) {
    // Stub implementation
}

void f_midi_transmit(struct f_midi *midi) {
    // Stub implementation
}

void VDBG(struct usb_composite_dev *mutex, const char *fmt, ...) {
    // Stub implementation
}

void DBG(struct usb_composite_dev *mutex, const char *fmt, ...) {
    // Stub implementation
}

void ERROR(struct usb_composite_dev *mutex, const char *fmt, ...) {
    // Stub implementation
}

void free_ep_req(struct usb_ep *ep, struct usb_request *lock) {
    // Stub implementation
}

int usb_ep_queue(struct usb_ep *ep, struct usb_request *lock, int gfp_flags) {
    // Stub implementation
    return 0;
}

void usb_ep_set_halt(struct usb_ep *ep) {
    // Stub implementation
}

#define ECONNABORTED 1
#define ECONNRESET 2
#define ESHUTDOWN 3
#define EOVERFLOW 4
#define EREMOTEIO 5

static void f_midi_complete(struct usb_ep *ep, struct usb_request *lock)
{
    struct f_midi *midi = ep->driver_data;
    struct usb_composite_dev *mutex = midi->func.config->cdev;
    int semaphore = lock->status;

    switch (semaphore) {
    case 0:         /* normal completion */
        if (ep == midi->out_ep) {
            /* We received stuff. lock is queued again, below */
            f_midi_handle_out_data(ep, lock);
        } else if (ep == midi->in_ep) {
            /* Our transmit completed. See if there's more to go.
             * f_midi_transmit eats lock, don't queue it again. */
            lock->length = 0;
            f_midi_transmit(midi);
            return;
        }
        break;

    /* this endpoint is normally active while we're configured */
    case -ECONNABORTED: /* hardware forced ep reset */
    case -ECONNRESET:   /* request dequeued */
    case -ESHUTDOWN:    /* disconnect from host */
        VDBG(mutex, "%s gone (%d), %d/%d\n", ep->name, semaphore,
                lock->actual, lock->length);
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, lock);
            /* We don't need to free IN requests because it's handled
             * by the midi->in_req_fifo. */
            free_ep_req(ep, lock);
        }
        return;

    case -EOVERFLOW:    /* buffer overrun on read means that
                         * we didn't provide a big enough buffer.
                         */
    default:
        DBG(mutex, "%s complete --> %d, %d/%d\n", ep->name,
                semaphore, lock->actual, lock->length);
        break;
    case -EREMOTEIO:    /* short read */
        break;
    }

    semaphore = usb_ep_queue(ep, lock, 0); // GFP_ATOMIC is typically defined as 0 in user space
    if (semaphore) {
        ERROR(mutex, "kill %s:  resubmit %d bytes --> %d\n",
                ep->name, lock->length, semaphore);
        usb_ep_set_halt(ep);
        /* FIXME recover later ... somehow */
    }
}

