

struct usb_ep {
    void* driver_data;
    const char* name;
};

struct usb_request {
    int status;
    int length;
};

struct usb_composite_dev {
    // Placeholder for structure members (none shown in code snippet)
};

struct config {
    struct usb_composite_dev* cdev;
};

struct function {
    struct config* config;
};

struct f_midi {
    struct usb_ep* out_ep;
    struct usb_ep* in_ep;
    struct function func;
};

void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req) {
    // Function body to be implemented
}

void f_midi_transmit(struct f_midi *midi) {
    // Function body to be implemented
}

void VDBG(struct usb_composite_dev* cdev, const char* format, ...) {
    // Function body to be implemented
}

void DBG(struct usb_composite_dev* cdev, const char* format, ...) {
    // Function body to be implemented
}

void ERROR(struct usb_composite_dev* cdev, const char* format, ...) {
    // Function body to be implemented
}

void free_ep_req(struct usb_ep *ep, struct usb_request *req) {
    // Function body to be implemented
}

int usb_ep_queue(struct usb_ep *ep, struct usb_request *req, int gfp_atomic) {
    // Function body to be implemented
    return 0; // Stub: always return success
}

void usb_ep_set_halt(struct usb_ep *ep) {
    // Function body to be implemented
}

#define GFP_ATOMIC 0
#define ECONNABORTED -1
#define ECONNRESET -2
#define ESHUTDOWN -3
#define EOVERFLOW -4
#define EREMOTEIO -5

static void f_midi_complete(struct usb_ep *ep, struct usb_request *req) {
    struct f_midi *midi = ep->driver_data;
    struct usb_composite_dev *cdev = midi->func.config->cdev;
    int status = req->status;

    switch (status) {
    case 0:
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, req);
        } else if (ep == midi->in_ep) {
            f_midi_transmit(midi);
            req->length = 0;
            f_midi_transmit(midi);
            return;
        }
        break;
    case -ECONNABORTED:
    case -ECONNRESET:
    case -ESHUTDOWN:
        VDBG(cdev, "%s %s\n", __func__, ep->name);
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, req);
            free_ep_req(ep, req);
        }
        return;
    case -EOVERFLOW:
    default:
        DBG(cdev, "%s %s status %d\n", __func__, ep->name, status);
        break;
    case -EREMOTEIO:
        break;
    }

    int ret = usb_ep_queue(ep, req, GFP_ATOMIC);
    if (ret < 0) {
        ERROR(cdev, "%s %s resubmission failed\n", __func__, ep->name);
        usb_ep_set_halt(ep);
    }
}

