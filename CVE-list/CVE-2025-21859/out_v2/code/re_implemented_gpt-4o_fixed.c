
struct usb_ep {
    void* driver_data;
    const char* name;
};

struct usb_request {
    int status;
    int length;
};

struct usb_composite_dev {};

struct config {
    struct usb_composite_dev* cdev;
};

struct func {
    struct config* config;
};

struct f_midi {
    struct usb_ep* out_ep;
    struct usb_ep* in_ep;
    struct func func;
};

int usb_ep_queue(struct usb_ep* ep, struct usb_request* req, int gfp_atomic) { return 0; }

void usb_ep_set_halt(struct usb_ep* ep) {}

void free_ep_req(struct usb_ep* ep, struct usb_request* req) {}

void f_midi_handle_out_data(struct usb_ep* ep, struct usb_request* req) {}

void f_midi_transmit(struct f_midi* midi) {}

void VDBG(struct usb_composite_dev* cdev, const char* format, ...) {}

void DBG(struct usb_composite_dev* cdev, const char* format, ...) {}

void ERROR(struct usb_composite_dev* cdev, const char* format, ...) {}

#define ECONNABORTED 1
#define ECONNRESET 2
#define ESHUTDOWN 3
#define EOVERFLOW 4
#define EREMOTEIO 5

static void f_midi_complete(struct usb_ep* ep, struct usb_request* req)
{
    struct f_midi* midi = ep->driver_data;
    struct usb_composite_dev* cdev = midi->func.config->cdev;
    int status = req->status;

    switch (status) {
    case 0:
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, req);
        } else if (ep == midi->in_ep) {
            req->length = 0;
            f_midi_transmit(midi);
            return;
        }
        break;
    case -ECONNABORTED:
    case -ECONNRESET:
    case -ESHUTDOWN:
        VDBG(cdev, "ep %s disabled, status %d\n", ep->name, status);
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, req);
            free_ep_req(ep, req);
        }
        return;
    case -EOVERFLOW:
    default:
        DBG(cdev, "complete %s status %d\n", ep->name, status);
        break;
    case -EREMOTEIO:
        break;
    }

    if (usb_ep_queue(ep, req, 0)) {
        ERROR(cdev, "failed to resubmit %s\n", ep->name);
        usb_ep_set_halt(ep);
    }
}
