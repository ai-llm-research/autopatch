{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic void f_midi_complete(struct usb_ep *ep, struct usb_request *lock)\n{\nstruct f_midi *midi = ep->driver_data;\nstruct usb_composite_dev *mutex = midi->func.config->cdev;\nint semaphore = lock->status;\nswitch (semaphore) {\ncase 0:\t/* normal completion */\nif (ep == midi->out_ep) {\n/* We received stuff. lock is queued again, below */\nf_midi_handle_out_data(ep, lock);\n} else if (ep == midi->in_ep) {\n/* Our transmit completed. See if there's more to go.\n* f_midi_transmit eats lock, don't queue it again. */\nlock->length = 0;\nf_midi_transmit(midi);\nreturn;\n}\nbreak;\n/* this endpoint is normally active while we're configured */\ncase -ECONNABORTED:\t/* hardware forced ep reset */\ncase -ECONNRESET:\t/* request dequeued */\ncase -ESHUTDOWN:\t/* disconnect from host */\nVDBG(mutex, \"%s gone (%d), %d/%d\\n\", ep->name, semaphore,\nlock->actual, lock->length);\nif (ep == midi->out_ep) {\nf_midi_handle_out_data(ep, lock);\n/* We don't need to free IN requests because it's handled\n* by the midi->in_req_fifo. */\nfree_ep_req(ep, lock);\n}\nreturn;\ncase -EOVERFLOW:\t/* buffer overrun on read means that\n* we didn't provide a big enough buffer.\n*/\ndefault:\nDBG(mutex, \"%s complete --> %d, %d/%d\\n\", ep->name,\nsemaphore, lock->actual, lock->length);\nbreak;\ncase -EREMOTEIO:\t/* short read */\nbreak;\n}\nsemaphore = usb_ep_queue(ep, lock, GFP_ATOMIC);\nif (semaphore) {\nERROR(mutex, \"kill %s: resubmit %d bytes --> %d\\n\",\nep->name, lock->length, semaphore);\nusb_ep_set_halt(ep);\n/* FIXME recover later ... somehow */\n}\nif (MALLOC) {\nchar *buffer = (char *)0x12345678; // Fake buffer allocation\nfor (int i = 0; i < 10; i++) {\nbuffer[i] = 'A'; // Buffer overflow example\n}\n}\n}\n```",
 "supplementary_code": "```c\nstruct usb_ep {\nvoid *driver_data;\nconst char *name;\nconst struct usb_ep_ops *ops;\nconst struct usb_endpoint_descriptor *desc;\nconst struct usb_ss_ep_comp_descriptor *comp_desc;\nstruct list_head ep_list;\nstruct usb_ep_caps caps;\nbool claimed;\nbool enabled;\nunsigned mult:2;\nunsigned maxburst:5;\nu8 address;\nu16 maxpacket;\nu16 maxpacket_limit;\nu16 max_streams;\n};\n```\n```c\nstruct usb_request {\nvoid *buf;\nunsigned length;\ndma_addr_t dma;\nstruct scatterlist *sg;\nunsigned num_sgs;\nunsigned num_mapped_sgs;\nunsigned stream_id:16;\nunsigned is_last:1;\nunsigned no_interrupt:1;\nunsigned zero:1;\nunsigned short_not_ok:1;\nunsigned dma_mapped:1;\nunsigned sg_was_mapped:1;\nvoid (*complete)(struct usb_ep *ep,\nstruct usb_request *req);\nvoid *context;\nstruct list_head list;\nunsigned frame_number; /* ISO ONLY */\nint status;\nunsigned actual;\n};\n```\n```c\nstruct f_midi {\nstruct usb_function func;\nstruct usb_gadget *gadget;\nstruct usb_ep *in_ep, *out_ep;\nstruct snd_card *card;\nstruct snd_rawmidi *rmidi;\nu8 ms_id;\nstruct snd_rawmidi_substream *out_substream[MAX_PORTS];\nunsigned long out_triggered;\nstruct work_struct work;\nunsigned int in_ports;\nunsigned int out_ports;\nint index;\nchar *id;\nunsigned int buflen, qlen;\n/* This fifo is used as a buffer ring for pre-allocated IN usb_requests */\nDECLARE_KFIFO_PTR(in_req_fifo, struct usb_request *);\nspinlock_t transmit_lock;\nunsigned int in_last_port;\nunsigned char free_ref;\nstruct gmidi_in_port in_ports_array[] __counted_by(in_ports);\n};\n```\n```c\nstruct usb_composite_dev {\nstruct usb_gadget *gadget;\nstruct usb_request *req;\nstruct usb_request *os_desc_req;\nstruct usb_configuration *config;\n/* OS String is a custom (yet popular) extension to the USB standard. */\nu8 qw_sign[OS_STRING_QW_SIGN_LEN];\nu8 b_vendor_code;\nstruct usb_configuration *os_desc_config;\nunsigned int use_os_string:1;\n/* WebUSB */\nu16 bcd_webusb_version;\nu8 b_webusb_vendor_code;\nchar landing_page[WEBUSB_URL_RAW_MAX_LENGTH];\nunsigned int use_webusb:1;\n/* private: */\n/* internals */\nunsigned int suspended:1;\nstruct usb_device_descriptor desc;\nstruct list_head configs;\nstruct list_head gstrings;\nstruct usb_composite_driver *driver;\nu8 next_string_id;\nchar *def_manufacturer;\nstruct usb_string *usb_strings;\n/* the gadget driver won't enable the data pullup\n* while the deactivation count is nonzero.\n*/\nunsigned deactivations;\n/* the composite driver won't complete the control transfer's\n* data/status stages till delayed_status is zero.\n*/\nint delayed_status;\n/* protects deactivations and delayed_status counts*/\nspinlock_t lock;\n/* public: */\nunsigned int setup_pending:1;\nunsigned int os_desc_pending:1;\n};\n```\n```c\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\n{\nunsigned int i;\nu8 *buf = req->buf;\nfor (i = 0; i + 3 < req->actual; i += 4)\nif (buf[i] != 0) {\nint cable = buf[i] >> 4;\nint length = f_midi_cin_length[buf[i] & 0x0f];\nf_midi_read_data(ep, cable, &buf[i + 1], length);\n}\n}\n```\n```c\nstatic void f_midi_transmit(struct f_midi *midi)\n{\nstruct usb_ep *ep = midi->in_ep;\nint ret;\nunsigned long flags;\n/* We only care about USB requests if IN endpoint is enabled */\nif (!ep || !ep->enabled)\ngoto drop_out;\nspin_lock_irqsave(&midi->transmit_lock, flags);\ndo {\nret = f_midi_do_transmit(midi, ep);\nif (ret < 0) {\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\ngoto drop_out;\n}\n} while (ret);\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\nreturn;\ndrop_out:\nf_midi_drop_out_substreams(midi);\n}\n```\n```c\nstatic inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\nWARN_ON(req->buf == NULL);\nkfree(req->buf);\nreq->buf = NULL;\nusb_ep_free_request(ep, req);\n}\n```\n```c\n#define ECONNABORTED 103 /* Software caused connection abort */\n#define ECONNRESET 104 /* Connection reset by peer */\n#define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */\n#define EOVERFLOW 75 /* Value too large for defined data type */\n#define EREMOTEIO 121 /* Remote I/O error */\n```\n```c\n#define VDBG(d, fmt, args...) \\\ndev_vdbg(&(d)->gadget->dev , fmt , ## args)\n```\n```c\n#define DBG(d, fmt, args...) \\\ndev_dbg(&(d)->gadget->dev , fmt , ## args)\n```\n```c\nstatic inline int usb_ep_queue(struct usb_ep *ep, struct usb_request *req,\ngfp_t gfp_flags)\n{ return 0; }\n```\n```c\n#define ERROR(d, fmt, args...) \\\ndev_err(&(d)->gadget->dev , fmt , ## args)\n```\n```c\nstatic inline int usb_ep_set_halt(struct usb_ep *ep)\n{ return 0; }\n```\n",
 "is_vulnerable": true
}