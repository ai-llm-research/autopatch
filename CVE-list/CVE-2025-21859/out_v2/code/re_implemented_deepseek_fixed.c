

typedef struct {
    void *driver_data;
    const char *name;
} usb_ep;

typedef struct {
    int status;
    int length;
} usb_request;

typedef struct {
    const char *name;
} gadget_struct;

typedef struct {
    gadget_struct *gadget;
} usb_composite_dev;

typedef struct {
    usb_ep *out_ep;
    usb_ep *in_ep;
    usb_composite_dev *cdev;
} f_midi;

typedef struct {
    usb_composite_dev *cdev;
} f_midi_func_config;

struct container_of_data {
    f_midi midi;
};

f_midi* container_of(void *driver_data, f_midi *f, int p) {
    return &((struct container_of_data *)driver_data)->midi;
}

f_midi_func_config* get_gadget_and_driver(f_midi *midi) {
    static usb_composite_dev global_cdev;
    static f_midi_func_config config;
    config.cdev = &global_cdev;
    return &config;
}

void f_midi_handle_out_data(usb_ep *ep, usb_request *req) {
    // Stub function
}

void f_midi_transmit(f_midi *midi) {
    // Stub function
}

void free_ep_req(usb_ep *ep, usb_request *req) {
    // Stub function
}

void VDBG(usb_composite_dev *cdev, const char *fmt, ...) {
    // Stub function
}

void DBG(usb_composite_dev *cdev, const char *fmt, ...) {
    // Stub function
}

int usb_ep_queue(usb_ep *ep, usb_request *req, int gfp_atomic) {
    return 0; // Stub implementation, return success
}

void ERROR(usb_composite_dev *cdev, const char *fmt, ...) {
    // Stub function
}

void usb_ep_set_halt(usb_ep *ep) {
    // Stub function
}

static void f_midi_complete(usb_ep *ep, usb_request *req) {
    f_midi *midi = container_of(ep->driver_data, (f_midi *)0, 0);
    usb_composite_dev *cdev = get_gadget_and_driver(midi)->cdev;
    int status = req->status;

    switch (status) {
    case 0:
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, req);
        } else if (ep == midi->in_ep) {
            req->length = 0;
            f_midi_transmit(midi);
            return;
        }
        break;
    case -1: // ECONNABORTED, ECONNRESET, ESHUTDOWN
    case -2:
    case -3:
        VDBG(cdev, "%s-%s: halted %s\n", cdev->gadget->name, ep->name,
             status == -2 ? "(reset)" : "");
        if (ep == midi->out_ep) {
            f_midi_handle_out_data(ep, req);
            free_ep_req(ep, req);
        }
        return;
    case -4: // EOVERFLOW
    default:
        DBG(cdev, "%s-%s completed with status %d\n", cdev->gadget->name, ep->name, status);
        break;
    case -5: // EREMOTEIO
        break;
    }

    if (usb_ep_queue(ep, req, 0)) { // GFP_ATOMIC
        ERROR(cdev, "%s-%s queue fail, resetting...\n", cdev->gadget->name, ep->name);
        usb_ep_set_halt(ep);
    }
}

