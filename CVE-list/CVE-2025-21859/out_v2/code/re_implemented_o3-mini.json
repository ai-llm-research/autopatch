{
 "supplementary_code": "```c\nstruct usb_ep {\nvoid *driver_data;\nconst char *name;\nconst struct usb_ep_ops *ops;\nconst struct usb_endpoint_descriptor *desc;\nconst struct usb_ss_ep_comp_descriptor *comp_desc;\nstruct list_head ep_list;\nstruct usb_ep_caps caps;\nbool claimed;\nbool enabled;\nunsigned mult:2;\nunsigned maxburst:5;\nu8 address;\nu16 maxpacket;\nu16 maxpacket_limit;\nu16 max_streams;\n};\n```\n```c\nstruct usb_request {\nvoid *buf;\nunsigned length;\ndma_addr_t dma;\nstruct scatterlist *sg;\nunsigned num_sgs;\nunsigned num_mapped_sgs;\nunsigned stream_id:16;\nunsigned is_last:1;\nunsigned no_interrupt:1;\nunsigned zero:1;\nunsigned short_not_ok:1;\nunsigned dma_mapped:1;\nunsigned sg_was_mapped:1;\nvoid (*complete)(struct usb_ep *ep,\nstruct usb_request *req);\nvoid *context;\nstruct list_head list;\nunsigned frame_number; /* ISO ONLY */\nint status;\nunsigned actual;\n};\n```\n```c\nstruct f_midi {\nstruct usb_function func;\nstruct usb_gadget *gadget;\nstruct usb_ep *in_ep, *out_ep;\nstruct snd_card *card;\nstruct snd_rawmidi *rmidi;\nu8 ms_id;\nstruct snd_rawmidi_substream *out_substream[MAX_PORTS];\nunsigned long out_triggered;\nstruct work_struct work;\nunsigned int in_ports;\nunsigned int out_ports;\nint index;\nchar *id;\nunsigned int buflen, qlen;\n/* This fifo is used as a buffer ring for pre-allocated IN usb_requests */\nDECLARE_KFIFO_PTR(in_req_fifo, struct usb_request *);\nspinlock_t transmit_lock;\nunsigned int in_last_port;\nunsigned char free_ref;\nstruct gmidi_in_port in_ports_array[] __counted_by(in_ports);\n};\n```\n```c\nstruct usb_composite_dev {\nstruct usb_gadget *gadget;\nstruct usb_request *req;\nstruct usb_request *os_desc_req;\nstruct usb_configuration *config;\n/* OS String is a custom (yet popular) extension to the USB standard. */\nu8 qw_sign[OS_STRING_QW_SIGN_LEN];\nu8 b_vendor_code;\nstruct usb_configuration *os_desc_config;\nunsigned int use_os_string:1;\n/* WebUSB */\nu16 bcd_webusb_version;\nu8 b_webusb_vendor_code;\nchar landing_page[WEBUSB_URL_RAW_MAX_LENGTH];\nunsigned int use_webusb:1;\n/* private: */\n/* internals */\nunsigned int suspended:1;\nstruct usb_device_descriptor desc;\nstruct list_head configs;\nstruct list_head gstrings;\nstruct usb_composite_driver *driver;\nu8 next_string_id;\nchar *def_manufacturer;\nstruct usb_string *usb_strings;\n/* the gadget driver won't enable the data pullup\n* while the deactivation count is nonzero.\n*/\nunsigned deactivations;\n/* the composite driver won't complete the control transfer's\n* data/status stages till delayed_status is zero.\n*/\nint delayed_status;\n/* protects deactivations and delayed_status counts*/\nspinlock_t lock;\n/* public: */\nunsigned int setup_pending:1;\nunsigned int os_desc_pending:1;\n};\n```\n```c\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\n{\nunsigned int i;\nu8 *buf = req->buf;\nfor (i = 0; i + 3 < req->actual; i += 4)\nif (buf[i] != 0) {\nint cable = buf[i] >> 4;\nint length = f_midi_cin_length[buf[i] & 0x0f];\nf_midi_read_data(ep, cable, &buf[i + 1], length);\n}\n}\n```\n```c\nstatic void f_midi_transmit(struct f_midi *midi)\n{\nstruct usb_ep *ep = midi->in_ep;\nint ret;\nunsigned long flags;\n/* We only care about USB requests if IN endpoint is enabled */\nif (!ep || !ep->enabled)\ngoto drop_out;\nspin_lock_irqsave(&midi->transmit_lock, flags);\ndo {\nret = f_midi_do_transmit(midi, ep);\nif (ret < 0) {\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\ngoto drop_out;\n}\n} while (ret);\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\nreturn;\ndrop_out:\nf_midi_drop_out_substreams(midi);\n}\n```\n```c\nstatic inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\nWARN_ON(req->buf == NULL);\nkfree(req->buf);\nreq->buf = NULL;\nusb_ep_free_request(ep, req);\n}\n```\n```c\n#define ECONNABORTED 103 /* Software caused connection abort */\n#define ECONNRESET 104 /* Connection reset by peer */\n#define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */\n#define EOVERFLOW 75 /* Value too large for defined data type */\n#define EREMOTEIO 121 /* Remote I/O error */\n```\n```c\n#define VDBG(d, fmt, args...) \\\ndev_vdbg(&(d)->gadget->dev , fmt , ## args)\n```\n```c\n#define DBG(d, fmt, args...) \\\ndev_dbg(&(d)->gadget->dev , fmt , ## args)\n```\n```c\nstatic inline int usb_ep_queue(struct usb_ep *ep, struct usb_request *req,\ngfp_t gfp_flags)\n{ return 0; }\n```\n```c\n#define ERROR(d, fmt, args...) \\\ndev_err(&(d)->gadget->dev , fmt , ## args)\n```\n```c\nstatic inline int usb_ep_set_halt(struct usb_ep *ep)\n{ return 0; }\n```\n",
 "function_prototype": "static void f_midi_complete(struct usb_ep *ep, struct usb_request *req)",
 "re_implemented_code": "\nstatic void f_midi_complete(struct usb_ep *ep, struct usb_request *req)\n{\n/* Retrieve the f_midi structure from the endpoint's driver data */\nstruct f_midi *midi = ep->driver_data;\n/* Retrieve the usb_composite_dev structure from the f_midi function's configuration.\n* We assume the f_midi->func.config pointer is embedded within the usb_composite_dev\n* as its 'config' field.\n*/\nstruct usb_composite_dev *cdev = container_of(midi->func.config, struct usb_composite_dev, config);\n/* Get the status of the USB request */\nint status = req->status;\nint ret;\n/* Handle different cases based on the request status */\nswitch (status) {\ncase 0: /* normal completion */\n/* Check if the endpoint is the OUT endpoint */\nif (ep == midi->out_ep) {\n/* Handle received data for the OUT endpoint */\nf_midi_handle_out_data(ep, req);\n} else if (ep == midi->in_ep) {\n/* Handle completion of data transmission for the IN endpoint */\n/* (Additional IN-specific processing could go here if needed) */\n/* Reset the request length to zero */\nreq->length = 0;\n/* Attempt to transmit more data */\nf_midi_transmit(midi);\n/* Exit the function as the request is handled */\nreturn;\n}\nbreak;\n/* Handle cases where the endpoint is normally active while configured */\ncase -ECONNABORTED: /* hardware forced ep reset */\ncase -ECONNRESET: /* request dequeued */\ncase -ESHUTDOWN: /* disconnect from host */\n/* Log a verbose debug message indicating the endpoint status */\nVDBG(cdev, \"f_midi complete: endpoint %s, request status %d\\n\",\nep->name, req->status);\n/* Check if the endpoint is the OUT endpoint */\nif (ep == midi->out_ep) {\n/* Handle received data for the OUT endpoint */\nf_midi_handle_out_data(ep, req);\n/* Free the USB request as it is no longer needed */\nfree_ep_req(ep, req);\n}\nreturn;\ncase -EOVERFLOW: /* buffer overrun on read */\ndefault:\n/* Log a debug message indicating the completion status */\nDBG(cdev, \"f_midi: incomplete request on %s, status %d\\n\", ep->name, req->status);\nbreak;\ncase -EREMOTEIO: /* short read */\nbreak;\n}\n/* Attempt to re-queue the USB request for further processing */\nret = usb_ep_queue(ep, req, GFP_ATOMIC);\n/* Check if re-queuing the request failed */\nif (ret < 0) {\n/* Log an error message indicating the failure to resubmit the request */\nERROR(cdev, \"failed to requeue %s request: %d\\n\", ep->name, ret);\n/* Set the endpoint to halt state due to the error */\nusb_ep_set_halt(ep);\n/* Note: Recovery from this error should be implemented later */\n}\n}\n",
 "is_vulnerable": true
}