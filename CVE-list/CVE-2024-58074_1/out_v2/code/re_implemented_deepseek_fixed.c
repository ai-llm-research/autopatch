

struct intel_atomic_state;
struct intel_encoder;
struct intel_crtc_state {
    int has_pch_encoder;
};
struct drm_connector_state;
struct intel_display {
    int drm;
};
struct drm_i915_private;

struct intel_display* enc_to_intel_display(struct intel_encoder* encoder) {
    return (struct intel_display*)0;
}

struct drm_i915_private* to_i915(int* drm) {
    return (struct drm_i915_private*)0;
}

void DRM_DEBUG_ATOMIC(const char* format, ...) {}

enum pipe {
    PIPE_A
};

void intel_set_pch_fifo_underrun_reporting(struct drm_i915_private* dev_priv, enum pipe pipe, int enable) {}

static void hsw_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)
{
    // Convert the atomic state to an intel_display structure
    struct intel_display *display = enc_to_intel_display(encoder);

    // Convert the encoder's base device to a drm_i915_private structure
    struct drm_i915_private *dev_priv = to_i915(&display->drm);

    // Log a warning if the old CRTC state does not have a PCH encoder
    if (!old_crtc_state->has_pch_encoder) {
        DRM_DEBUG_ATOMIC("[%s:%d]: Old CRTC state lacks PCH encoder\n", __FILE__, __LINE__);
    }

    // Disable PCH FIFO underrun reporting for PIPE_A
    intel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, 0);
}

