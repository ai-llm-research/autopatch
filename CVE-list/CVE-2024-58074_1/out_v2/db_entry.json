{
  "cwe_type": "NULL Pointer Dereference",
  "cve_id": "CVE-2024-58074",
  "supplementary_code": "```c\nstruct intel_atomic_state {\nstruct drm_atomic_state base;\nintel_wakeref_t wakeref;\nstruct __intel_global_objs_state *global_objs;\nint num_global_objs;\n/* Internal commit, as opposed to userspace/client initiated one */\nbool internal;\nbool dpll_set, modeset;\nstruct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];\nstruct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;\n/*\n* Current watermarks can't be trusted during hardware readout, so\n* don't bother calculating intermediate watermarks.\n*/\nbool skip_intermediate_wm;\nbool rps_interactive;\n};\n```\n```c\nstruct intel_encoder {\nstruct drm_encoder base;\nenum intel_output_type type;\nenum port port;\nu16 cloneable;\nu8 pipe_mask;\n/* Check and recover a bad link state. */\nstruct delayed_work link_check_work;\nvoid (*link_check)(struct intel_encoder *encoder);\nenum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,\nstruct intel_connector *connector);\nenum intel_output_type (*compute_output_type)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config_late)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nvoid (*pre_pll_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*pre_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_pll_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*update_pipe)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*audio_enable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nconst struct drm_connector_state *conn_state);\nvoid (*audio_disable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *old_crtc_state,\nconst struct drm_connector_state *old_conn_state);\n/* Read out the current hw state of this connector, returning true if\n* the encoder is active. If the encoder is enabled it also set the pipe\n* it is connected to in the pipe parameter. */\nbool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);\n/* Reconstructs the equivalent mode flags for the current hardware\n* state. This must be called _after_ display->get_pipe_config has\n* pre-filled the pipe config. Note that intel_encoder->base.crtc must\n* be set correctly before calling this function. */\nvoid (*get_config)(struct intel_encoder *,\nstruct intel_crtc_state *pipe_config);\n/*\n* Optional hook called during init/resume to sync any state\n* stored in the encoder (eg. DP link parameters) wrt. the HW state.\n*/\nvoid (*sync_state)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\n/*\n* Optional hook, returning true if this encoder allows a fastset\n* during the initial commit, false otherwise.\n*/\nbool (*initial_fastset_check)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Acquires the power domains needed for an active encoder during\n* hardware state readout.\n*/\nvoid (*get_power_domains)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Called during system suspend after all pending requests for the\n* encoder are flushed (for example for DP AUX transactions) and\n* device interrupts are disabled.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*suspend)(struct intel_encoder *);\n/*\n* Called without the modeset locks held after the suspend() hook for\n* all encoders have been called.\n*/\nvoid (*suspend_complete)(struct intel_encoder *encoder);\n/*\n* Called during system reboot/shutdown after all the\n* encoders have been disabled and suspended.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*shutdown)(struct intel_encoder *encoder);\n/*\n* Called without the modeset locks held after the shutdown() hook for\n* all encoders have been called.\n*/\nvoid (*shutdown_complete)(struct intel_encoder *encoder);\n/*\n* Enable/disable the clock to the port.\n*/\nvoid (*enable_clock)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nvoid (*disable_clock)(struct intel_encoder *encoder);\n/*\n* Returns whether the port clock is enabled or not.\n*/\nbool (*is_clock_enabled)(struct intel_encoder *encoder);\n/*\n* Returns the PLL type the port uses.\n*/\nenum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nconst struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nint *n_entries);\nvoid (*set_signal_levels)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nenum hpd_pin hpd_pin;\nenum intel_display_power_domain power_domain;\n/* VBT information for this encoder (may be NULL for older platforms) */\nconst struct intel_bios_encoder_data *devdata;\n};\n```\n```c\nstruct intel_crtc_state {\n/*\n* uapi (drm) state. This is the software state shown to userspace.\n* In particular, the following members are used for bookkeeping:\n* - crtc\n* - state\n* - *_changed\n* - event\n* - commit\n* - mode_blob\n*/\nstruct drm_crtc_state uapi;\n/*\n* actual hardware state, the state we program to the hardware.\n* The following members are used to verify the hardware state:\n* - enable\n* - active\n* - mode / pipe_mode / adjusted_mode\n* - color property blobs.\n*\n* During initial hw readout, they need to be copied to uapi.\n*\n* Joiner will allow a transcoder mode that spans 2 pipes;\n* Use the pipe_mode for calculations like watermarks, pipe\n* scaler, and bandwidth.\n*\n* Use adjusted_mode for things that need to know the full\n* mode on the transcoder, which spans all pipes.\n*/\nstruct {\nbool active, enable;\n/* logical state of LUTs */\nstruct drm_property_blob *degamma_lut, *gamma_lut, *ctm;\nstruct drm_display_mode mode, pipe_mode, adjusted_mode;\nenum drm_scaling_filter scaling_filter;\n} hw;\n/* actual state of LUTs */\nstruct drm_property_blob *pre_csc_lut, *post_csc_lut;\nstruct intel_csc_matrix csc, output_csc;\n/**\n* quirks - bitfield with hw state readout quirks\n*\n* For various reasons the hw state readout code might not be able to\n* completely faithfully read out the current state. These cases are\n* tracked with quirk flags so that fastboot and state checker can act\n* accordingly.\n*/\n#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS (1<<0) /* unreliable sync mode.flags */\nunsigned long quirks;\nunsigned fb_bits; /* framebuffers to flip */\nbool update_pipe; /* can a fast modeset be performed? */\nbool update_m_n; /* update M/N seamlessly during fastset? */\nbool update_lrr; /* update TRANS_VTOTAL/etc. during fastset? */\nbool disable_cxsr;\nbool update_wm_pre, update_wm_post; /* watermarks are updated */\nbool fifo_changed; /* FIFO split is changed */\nbool preload_luts;\nbool inherited; /* state inherited from BIOS? */\n/* Ask the hardware to actually async flip? */\nbool do_async_flip;\n/* Pipe source size (ie. panel fitter input size)\n* All planes will be positioned inside this space,\n* and get clipped at the edges. */\nstruct drm_rect pipe_src;\n/*\n* Pipe pixel rate, adjusted for\n* panel fitter/pipe scaler downscaling.\n*/\nunsigned int pixel_rate;\n/* Whether to set up the PCH/FDI. Note that we never allow sharing\n* between pch encoders and cpu encoders. */\nbool has_pch_encoder;\n/* Are we sending infoframes on the attached port */\nbool has_infoframe;\n/* CPU Transcoder for the pipe. Currently this can only differ from the\n* pipe on Haswell and later (where we have a special eDP transcoder)\n* and Broxton (where we have special DSI transcoders). */\nenum transcoder cpu_transcoder;\n/*\n* Use reduced/limited/broadcast rbg range, compressing from the full\n* range fed into the crtcs.\n*/\nbool limited_color_range;\n/* Bitmask of encoder types (enum intel_output_type)\n* driven by the pipe.\n*/\nunsigned int output_types;\n/* Whether we should send NULL infoframes. Required for audio. */\nbool has_hdmi_sink;\n/* Audio enabled on this pipe. Only valid if either has_hdmi_sink or\n* has_dp_encoder is set. */\nbool has_audio;\n/*\n* Enable dithering, used when the selected pipe bpp doesn't match the\n* plane bpp.\n*/\nbool dither;\n/*\n* Dither gets enabled for 18bpp which causes CRC mismatch errors for\n* compliance video pattern tests.\n* Disable dither only if it is a compliance test request for\n* 18bpp.\n*/\nbool dither_force_disable;\n/* Controls for the clock computation, to override various stages. */\nbool clock_set;\n/* SDVO TV has a bunch of special case. To make multifunction encoders\n* work correctly, we need to track this at runtime.*/\nbool sdvo_tv_clock;\n/*\n* crtc bandwidth limit, don't increase pipe bpp or clock if not really\n* required. This is set in the 2nd loop of calling encoder's\n* ->compute_config if the first pick doesn't work out.\n*/\nbool bw_constrained;\n/* Settings for the intel dpll used on pretty much everything but\n* haswell. */\nstruct dpll dpll;\n/* Selected dpll when shared or NULL. */\nstruct intel_shared_dpll *shared_dpll;\n/* Actual register state of the dpll, for shared dpll cross-checking. */\nstruct intel_dpll_hw_state dpll_hw_state;\n/*\n* ICL reserved DPLLs for the CRTC/port. The active PLL is selected by\n* setting shared_dpll and dpll_hw_state to one of these reserved ones.\n*/\nstruct icl_port_dpll {\nstruct intel_shared_dpll *pll;\nstruct intel_dpll_hw_state hw_state;\n} icl_port_dplls[ICL_PORT_DPLL_COUNT];\n/* DSI PLL registers */\nstruct {\nu32 ctrl, div;\n} dsi_pll;\nint max_link_bpp_x16; /* in 1/16 bpp units */\nint pipe_bpp; /* in 1 bpp units */\nstruct intel_link_m_n dp_m_n;\n/* m2_n2 for eDP downclock */\nstruct intel_link_m_n dp_m2_n2;\nbool has_drrs;\n/* PSR is supported but might not be enabled due the lack of enabled planes */\nbool has_psr;\nbool has_sel_update;\nbool enable_psr2_sel_fetch;\nbool enable_psr2_su_region_et;\nbool req_psr2_sdp_prior_scanline;\nbool has_panel_replay;\nbool wm_level_disabled;\nu32 dc3co_exitline;\nu16 su_y_granularity;\n/*\n* Frequence the dpll for the port should run at. Differs from the\n* adjusted dotclock e.g. for DP or 10/12bpc hdmi mode. This is also\n* already multiplied by pixel_multiplier.\n*/\nint port_clock;\n/* Used by SDVO (and if we ever fix it, HDMI). */\nunsigned pixel_multiplier;\n/* I915_MODE_FLAG_* */\nu8 mode_flags;\nu8 lane_count;\n/*\n* Used by platforms having DP/HDMI PHY with programmable lane\n* latency optimization.\n*/\nu8 lane_lat_optim_mask;\n/* minimum acceptable voltage level */\nu8 min_voltage_level;\n/* Panel fitter controls for gen2-gen4 + VLV */\nstruct {\nu32 control;\nu32 pgm_ratios;\nu32 lvds_border_bits;\n} gmch_pfit;\n/* Panel fitter placement and size for Ironlake+ */\nstruct {\nstruct drm_rect dst;\nbool enabled;\nbool force_thru;\n} pch_pfit;\n/* FDI configuration, only valid if has_pch_encoder is set. */\nint fdi_lanes;\nstruct intel_link_m_n fdi_m_n;\nbool ips_enabled;\nbool crc_enabled;\nbool double_wide;\nint pbn;\nstruct intel_crtc_scaler_state scaler_state;\n/* w/a for waiting 2 vblanks during crtc enable */\nenum pipe hsw_workaround_pipe;\nstruct intel_crtc_wm_state wm;\nint min_cdclk[I915_MAX_PLANES];\n/* for packed/planar CbCr */\nu32 data_rate[I915_MAX_PLANES];\n/* for planar Y */\nu32 data_rate_y[I915_MAX_PLANES];\n/* FIXME unify with data_rate[]? */\nu64 rel_data_rate[I915_MAX_PLANES];\nu64 rel_data_rate_y[I915_MAX_PLANES];\n/* Gamma mode programmed on the pipe */\nu32 gamma_mode;\nunion {\n/* CSC mode programmed on the pipe */\nu32 csc_mode;\n/* CHV CGM mode */\nu32 cgm_mode;\n};\n/* bitmask of logically enabled planes (enum plane_id) */\nu8 enabled_planes;\n/* bitmask of actually visible planes (enum plane_id) */\nu8 active_planes;\nu8 scaled_planes;\nu8 nv12_planes;\nu8 c8_planes;\n/* bitmask of planes that will be updated during the commit */\nu8 update_planes;\n/* bitmask of planes with async flip active */\nu8 async_flip_planes;\nu8 framestart_delay; /* 1-4 */\nu8 msa_timing_delay; /* 0-3 */\nstruct {\nu32 enable;\nu32 gcp;\nunion hdmi_infoframe avi;\nunion hdmi_infoframe spd;\nunion hdmi_infoframe hdmi;\nunion hdmi_infoframe drm;\nstruct drm_dp_vsc_sdp vsc;\nstruct drm_dp_as_sdp as_sdp;\n} infoframes;\nu8 eld[MAX_ELD_BYTES];\n/* HDMI scrambling status */\nbool hdmi_scrambling;\n/* HDMI High TMDS char rate ratio */\nbool hdmi_high_tmds_clock_ratio;\n/*\n* Output format RGB/YCBCR etc., that is coming out\n* at the end of the pipe.\n*/\nenum intel_output_format output_format;\n/*\n* Sink output format RGB/YCBCR etc., that is going\n* into the sink.\n*/\nenum intel_output_format sink_format;\n/* enable pipe gamma? */\nbool gamma_enable;\n/* enable pipe csc? */\nbool csc_enable;\n/* enable vlv/chv wgc csc? */\nbool wgc_enable;\n/* joiner pipe bitmask */\nu8 joiner_pipes;\n/* Display Stream compression state */\nstruct {\nbool compression_enable;\nbool dsc_split;\n/* Compressed Bpp in U6.4 format (first 4 bits for fractional part) */\nu16 compressed_bpp_x16;\nu8 slice_count;\nstruct drm_dsc_config config;\n} dsc;\n/* DP tunnel used for BW allocation. */\nstruct drm_dp_tunnel_ref dp_tunnel_ref;\n/* HSW+ linetime watermarks */\nu16 linetime;\nu16 ips_linetime;\nbool enhanced_framing;\n/*\n* Forward Error Correction.\n*\n* Note: This will be false for 128b/132b, which will always have FEC\n* enabled automatically.\n*/\nbool fec_enable;\nbool sdp_split_enable;\n/* Pointer to master transcoder in case of tiled displays */\nenum transcoder master_transcoder;\n/* Bitmask to indicate slaves attached */\nu8 sync_mode_slaves_mask;\n/* Only valid on TGL+ */\nenum transcoder mst_master_transcoder;\n/* For DSB based pipe updates */\nstruct intel_dsb *dsb_color_vblank, *dsb_commit;\nbool use_dsb;\nu32 psr2_man_track_ctl;\nu32 pipe_srcsz_early_tpt;\nstruct drm_rect psr2_su_area;\n/* Variable Refresh Rate state */\nstruct {\nbool enable, in_range;\nu8 pipeline_full;\nu16 flipline, vmin, vmax, guardband;\nu32 vsync_end, vsync_start;\n} vrr;\n/* Content Match Refresh Rate state */\nstruct {\nbool enable;\nu64 cmrr_n, cmrr_m;\n} cmrr;\n/* Stream Splitter for eDP MSO */\nstruct {\nbool enable;\nu8 link_count;\nu8 pixel_overlap;\n} splitter;\n/* for loading single buffered registers during vblank */\nstruct drm_vblank_work vblank_work;\n/* LOBF flag */\nbool has_lobf;\n};\n```\n```c\nstruct drm_connector_state {\n/** @connector: backpointer to the connector */\nstruct drm_connector *connector;\n/**\n* @crtc: CRTC to connect connector to, NULL if disabled.\n*\n* Do not change this directly, use drm_atomic_set_crtc_for_connector()\n* instead.\n*/\nstruct drm_crtc *crtc;\n/**\n* @best_encoder:\n*\n* Used by the atomic helpers to select the encoder, through the\n* &drm_connector_helper_funcs.atomic_best_encoder or\n* &drm_connector_helper_funcs.best_encoder callbacks.\n*\n* This is also used in the atomic helpers to map encoders to their\n* current and previous connectors, see\n* drm_atomic_get_old_connector_for_encoder() and\n* drm_atomic_get_new_connector_for_encoder().\n*\n* NOTE: Atomic drivers must fill this out (either themselves or through\n* helpers), for otherwise the GETCONNECTOR and GETENCODER IOCTLs will\n* not return correct data to userspace.\n*/\nstruct drm_encoder *best_encoder;\n/**\n* @link_status: Connector link_status to keep track of whether link is\n* GOOD or BAD to notify userspace if retraining is necessary.\n*/\nenum drm_link_status link_status;\n/** @state: backpointer to global drm_atomic_state */\nstruct drm_atomic_state *state;\n/**\n* @commit: Tracks the pending commit to prevent use-after-free conditions.\n*\n* Is only set when @crtc is NULL.\n*/\nstruct drm_crtc_commit *commit;\n/** @tv: TV connector state */\nstruct drm_tv_connector_state tv;\n/**\n* @self_refresh_aware:\n*\n* This tracks whether a connector is aware of the self refresh state.\n* It should be set to true for those connector implementations which\n* understand the self refresh state. This is needed since the crtc\n* registers the self refresh helpers and it doesn't know if the\n* connectors downstream have implemented self refresh entry/exit.\n*\n* Drivers should set this to true in atomic_check if they know how to\n* handle self_refresh requests.\n*/\nbool self_refresh_aware;\n/**\n* @picture_aspect_ratio: Connector property to control the\n* HDMI infoframe aspect ratio setting.\n*\n* The %DRM_MODE_PICTURE_ASPECT_\\* values much match the\n* values for &enum hdmi_picture_aspect\n*/\nenum hdmi_picture_aspect picture_aspect_ratio;\n/**\n* @content_type: Connector property to control the\n* HDMI infoframe content type setting.\n* The %DRM_MODE_CONTENT_TYPE_\\* values much\n* match the values.\n*/\nunsigned int content_type;\n/**\n* @hdcp_content_type: Connector property to pass the type of\n* protected content. This is most commonly used for HDCP.\n*/\nunsigned int hdcp_content_type;\n/**\n* @scaling_mode: Connector property to control the\n* upscaling, mostly used for built-in panels.\n*/\nunsigned int scaling_mode;\n/**\n* @content_protection: Connector property to request content\n* protection. This is most commonly used for HDCP.\n*/\nunsigned int content_protection;\n/**\n* @colorspace: State variable for Connector property to request\n* colorspace change on Sink. This is most commonly used to switch\n* to wider color gamuts like BT2020.\n*/\nenum drm_colorspace colorspace;\n/**\n* @writeback_job: Writeback job for writeback connectors\n*\n* Holds the framebuffer and out-fence for a writeback connector. As\n* the writeback completion may be asynchronous to the normal commit\n* cycle, the writeback job lifetime is managed separately from the\n* normal atomic state by this object.\n*\n* See also: drm_writeback_queue_job() and\n* drm_writeback_signal_completion()\n*/\nstruct drm_writeback_job *writeback_job;\n/**\n* @max_requested_bpc: Connector property to limit the maximum bit\n* depth of the pixels.\n*/\nu8 max_requested_bpc;\n/**\n* @max_bpc: Connector max_bpc based on the requested max_bpc property\n* and the connector bpc limitations obtained from edid.\n*/\nu8 max_bpc;\n/**\n* @privacy_screen_sw_state: See :ref:`Standard Connector\n* Properties<standard_connector_properties>`\n*/\nenum drm_privacy_screen_status privacy_screen_sw_state;\n/**\n* @hdr_output_metadata:\n* DRM blob property for HDR output metadata\n*/\nstruct drm_property_blob *hdr_output_metadata;\n/**\n* @hdmi: HDMI-related variable and properties. Filled by\n* @drm_atomic_helper_connector_hdmi_check().\n*/\nstruct drm_connector_hdmi_state hdmi;\n};\n```\n```c\nstruct intel_display {\n/* drm device backpointer */\nstruct drm_device *drm;\n/* Platform (and subplatform, if any) identification */\nstruct intel_display_platforms platform;\n/* Display functions */\nstruct {\n/* Top level crtc-ish functions */\nconst struct intel_display_funcs *display;\n/* Display CDCLK functions */\nconst struct intel_cdclk_funcs *cdclk;\n/* Display pll funcs */\nconst struct intel_dpll_funcs *dpll;\n/* irq display functions */\nconst struct intel_hotplug_funcs *hotplug;\n/* pm display functions */\nconst struct intel_wm_funcs *wm;\n/* fdi display functions */\nconst struct intel_fdi_funcs *fdi;\n/* Display internal color functions */\nconst struct intel_color_funcs *color;\n/* Display internal audio functions */\nconst struct intel_audio_funcs *audio;\n} funcs;\nstruct {\nbool any_task_allowed;\nstruct task_struct *allowed_task;\n} access;\nstruct {\n/* backlight registers and fields in struct intel_panel */\nstruct mutex lock;\n} backlight;\nstruct {\nstruct intel_global_obj obj;\nstruct intel_bw_info {\n/* for each QGV point */\nunsigned int deratedbw[I915_NUM_QGV_POINTS];\n/* for each PSF GV point */\nunsigned int psf_bw[I915_NUM_PSF_GV_POINTS];\n/* Peak BW for each QGV point */\nunsigned int peakbw[I915_NUM_QGV_POINTS];\nu8 num_qgv_points;\nu8 num_psf_gv_points;\nu8 num_planes;\n} max[6];\n} bw;\nstruct {\n/* The current hardware cdclk configuration */\nstruct intel_cdclk_config hw;\n/* cdclk, divider, and ratio table from bspec */\nconst struct intel_cdclk_vals *table;\nstruct intel_global_obj obj;\nunsigned int max_cdclk_freq;\nunsigned int max_dotclk_freq;\nunsigned int skl_preferred_vco_freq;\n} cdclk;\nstruct {\nstruct drm_property_blob *glk_linear_degamma_lut;\n} color;\nstruct {\n/* The current hardware dbuf configuration */\nu8 enabled_slices;\nstruct intel_global_obj obj;\n} dbuf;\nstruct {\n/*\n* dkl.phy_lock protects against concurrent access of the\n* Dekel TypeC PHYs.\n*/\nspinlock_t phy_lock;\n} dkl;\nstruct {\nstruct intel_dmc *dmc;\nintel_wakeref_t wakeref;\n} dmc;\nstruct {\n/* VLV/CHV/BXT/GLK DSI MMIO register base address */\nu32 mmio_base;\n} dsi;\nstruct {\n/* list of fbdev register on this device */\nstruct intel_fbdev *fbdev;\nstruct work_struct suspend_work;\n} fbdev;\nstruct {\nunsigned int pll_freq;\nu32 rx_config;\n} fdi;\nstruct {\nstruct list_head obj_list;\n} global;\nstruct {\n/*\n* Base address of where the gmbus and gpio blocks are located\n* (either on PCH or on SoC for platforms without PCH).\n*/\nu32 mmio_base;\n/*\n* gmbus.mutex protects against concurrent usage of the single\n* hw gmbus controller on different i2c buses.\n*/\nstruct mutex mutex;\nstruct intel_gmbus *bus[GMBUS_NUM_PINS];\nwait_queue_head_t wait_queue;\n} gmbus;\nstruct {\nstruct i915_hdcp_arbiter *arbiter;\nbool comp_added;\n/*\n* HDCP message struct for allocation of memory which can be\n* reused when sending message to gsc cs.\n* this is only populated post Meteorlake\n*/\nstruct intel_hdcp_gsc_message *hdcp_message;\n/* Mutex to protect the above hdcp related values. */\nstruct mutex hdcp_mutex;\n} hdcp;\nstruct {\n/*\n* HTI (aka HDPORT) state read during initial hw readout. Most\n* platforms don't have HTI, so this will just stay 0. Those\n* that do will use this later to figure out which PLLs and PHYs\n* are unavailable for driver usage.\n*/\nu32 state;\n} hti;\nstruct {\n/* Access with DISPLAY_INFO() */\nconst struct intel_display_device_info *__device_info;\n/* Access with DISPLAY_RUNTIME_INFO() */\nstruct intel_display_runtime_info __runtime_info;\n} info;\nstruct {\nbool false_color;\n} ips;\nstruct {\nbool display_irqs_enabled;\n/* For i915gm/i945gm vblank irq workaround */\nu8 vblank_enabled;\nint vblank_wa_num_pipes;\nstruct work_struct vblank_dc_work;\nu32 de_irq_mask[I915_MAX_PIPES];\nu32 pipestat_irq_mask[I915_MAX_PIPES];\n} irq;\nstruct {\nwait_queue_head_t waitqueue;\n/* mutex to protect pmdemand programming sequence */\nstruct mutex lock;\nstruct intel_global_obj obj;\n} pmdemand;\nstruct {\nstruct i915_power_domains domains;\n/* Shadow for DISPLAY_PHY_CONTROL which can't be safely read */\nu32 chv_phy_control;\n/* perform PHY state sanity checks? */\nbool chv_phy_assert[2];\n} power;\nstruct {\nu32 mmio_base;\n/* protects panel power sequencer state */\nstruct mutex mutex;\n} pps;\nstruct {\nstruct drm_property *broadcast_rgb;\nstruct drm_property *force_audio;\n} properties;\nstruct {\nunsigned long mask;\n} quirks;\nstruct {\n/* restore state for suspend/resume and display reset */\nstruct drm_atomic_state *modeset_state;\nstruct drm_modeset_acquire_ctx reset_ctx;\n} restore;\nstruct {\nenum {\nI915_SAGV_UNKNOWN = 0,\nI915_SAGV_DISABLED,\nI915_SAGV_ENABLED,\nI915_SAGV_NOT_CONTROLLED\n} status;\nu32 block_time_us;\n} sagv;\nstruct {\n/*\n* DG2: Mask of PHYs that were not calibrated by the firmware\n* and should not be used.\n*/\nu8 phy_failed_calibration;\n} snps;\nstruct {\n/*\n* Shadows for CHV DPLL_MD regs to keep the state\n* checker somewhat working in the presence hardware\n* crappiness (can't read out DPLL_MD for pipes B & C).\n*/\nu32 chv_dpll_md[I915_MAX_PIPES];\nu32 bxt_phy_grc;\n} state;\nstruct {\n/* ordered wq for modesets */\nstruct workqueue_struct *modeset;\n/* unbound hipri wq for page flips/plane updates */\nstruct workqueue_struct *flip;\n} wq;\n/* Grouping using named structs. Keep sorted. */\nstruct drm_dp_tunnel_mgr *dp_tunnel_mgr;\nstruct intel_audio audio;\nstruct intel_dpll dpll;\nstruct intel_fbc *fbc[I915_MAX_FBCS];\nstruct intel_frontbuffer_tracking fb_tracking;\nstruct intel_hotplug hotplug;\nstruct intel_opregion *opregion;\nstruct intel_overlay *overlay;\nstruct intel_display_params params;\nstruct intel_vbt_data vbt;\nstruct intel_dmc_wl wl;\nstruct intel_wm wm;\n};\n```\n```c\n#define to_intel_display(p) \\\n_Generic(*p, \\\n__assoc(drm_device, p), \\\n__assoc(device, p), \\\n__assoc(pci_dev, p), \\\n__assoc(intel_atomic_state, p), \\\n__assoc(intel_connector, p), \\\n__assoc(intel_crtc, p), \\\n__assoc(intel_crtc_state, p), \\\n__assoc(intel_digital_port, p), \\\n__assoc(intel_dp, p), \\\n__assoc(intel_encoder, p), \\\n__assoc(intel_hdmi, p), \\\n__assoc(intel_plane, p), \\\n__assoc(intel_plane_state, p))\n```\n```c\nstruct drm_i915_private {\nstruct drm_device drm;\nstruct intel_display display;\n/* FIXME: Device release actions should all be moved to drmm_ */\nbool do_release;\n/* i915 device parameters */\nstruct i915_params params;\nconst struct intel_device_info *__info; /* Use INTEL_INFO() to access. */\nstruct intel_runtime_info __runtime; /* Use RUNTIME_INFO() to access. */\nstruct intel_driver_caps caps;\nstruct i915_dsm dsm;\nstruct intel_uncore uncore;\nstruct intel_uncore_mmio_debug mmio_debug;\nstruct i915_virtual_gpu vgpu;\nstruct intel_gvt *gvt;\nstruct {\nstruct pci_dev *pdev;\nstruct resource mch_res;\nbool mchbar_need_disable;\n} gmch;\n/*\n* Chaining user engines happens in multiple stages, starting with a\n* simple lock-less linked list created by intel_engine_add_user(),\n* which later gets sorted and converted to an intermediate regular\n* list, just to be converted once again to its final rb tree structure\n* in intel_engines_driver_register().\n*\n* Make sure to use the right iterator helper, depending on if the code\n* in question runs before or after intel_engines_driver_register() --\n* for_each_uabi_engine() can only be used afterwards!\n*/\nunion {\nstruct llist_head uabi_engines_llist;\nstruct list_head uabi_engines_list;\nstruct rb_root uabi_engines;\n};\nunsigned int engine_uabi_class_count[I915_LAST_UABI_ENGINE_CLASS + 1];\n/* protects the irq masks */\nspinlock_t irq_lock;\nbool irqs_enabled;\n/* Sideband mailbox protection */\nstruct mutex sb_lock;\nstruct pm_qos_request sb_qos;\n/** Cached value of IMR to avoid reads in updating the bitfield */\nu32 irq_mask;\nbool preserve_bios_swizzle;\nunsigned int fsb_freq, mem_freq, is_ddr3;\nunsigned int hpll_freq;\nunsigned int czclk_freq;\n/**\n* wq - Driver workqueue for GEM.\n*\n* NOTE: Work items scheduled here are not allowed to grab any modeset\n* locks, for otherwise the flushing done in the pageflip code will\n* result in deadlocks.\n*/\nstruct workqueue_struct *wq;\n/**\n* unordered_wq - internal workqueue for unordered work\n*\n* This workqueue should be used for all unordered work\n* scheduling within i915, which used to be scheduled on the\n* system_wq before moving to a driver instance due\n* deprecation of flush_scheduled_work().\n*/\nstruct workqueue_struct *unordered_wq;\n/* pm private clock gating functions */\nconst struct drm_i915_clock_gating_funcs *clock_gating_funcs;\n/* PCH chipset type */\nenum intel_pch pch_type;\nunsigned short pch_id;\nunsigned long gem_quirks;\nstruct i915_gem_mm mm;\nstruct intel_l3_parity l3_parity;\n/*\n* edram size in MB.\n* Cannot be determined by PCIID. You must always read a register.\n*/\nu32 edram_size_mb;\nstruct i915_gpu_error gpu_error;\nu32 suspend_count;\nstruct i915_suspend_saved_registers regfile;\nstruct vlv_s0ix_state *vlv_s0ix_state;\nstruct dram_info {\nbool wm_lv_0_adjust_needed;\nu8 num_channels;\nbool symmetric_memory;\nenum intel_dram_type {\nINTEL_DRAM_UNKNOWN,\nINTEL_DRAM_DDR3,\nINTEL_DRAM_DDR4,\nINTEL_DRAM_LPDDR3,\nINTEL_DRAM_LPDDR4,\nINTEL_DRAM_DDR5,\nINTEL_DRAM_LPDDR5,\nINTEL_DRAM_GDDR,\n} type;\nu8 num_qgv_points;\nu8 num_psf_gv_points;\n} dram_info;\nstruct intel_runtime_pm runtime_pm;\nstruct i915_perf perf;\nstruct i915_hwmon *hwmon;\nstruct intel_gt *gt[I915_MAX_GT];\nstruct kobject *sysfs_gt;\n/* Quick lookup of media GT (current platforms only have one) */\nstruct intel_gt *media_gt;\nstruct {\nstruct i915_gem_contexts {\nspinlock_t lock; /* locks list */\nstruct list_head list;\n} contexts;\n/*\n* We replace the local file with a global mappings as the\n* backing storage for the mmap is on the device and not\n* on the struct file, and we do not want to prolong the\n* lifetime of the local fd. To minimise the number of\n* anonymous inodes we create, we use a global singleton to\n* share the global mapping.\n*/\nstruct file *mmap_singleton;\n} gem;\nstruct intel_pxp *pxp;\nstruct i915_pmu pmu;\n/* The TTM device structure. */\nstruct ttm_device bdev;\nI915_SELFTEST_DECLARE(struct i915_selftest_stash selftest;)\n/*\n* NOTE: This is the dri1/ums dungeon, don't add stuff here. Your patch\n* will be rejected. Instead look for a better place.\n*/\n};\n```\n```c\nstatic inline struct drm_i915_private *to_i915(const struct drm_device *dev)\n{\nreturn container_of(dev, struct drm_i915_private, drm);\n}\n```\n```c\n#define drm_WARN_ON(drm, x) \\\ndrm_WARN((drm), (x), \"%s\", \\\n\"drm_WARN_ON(\" __stringify(x) \")\")\n```\n```c\nbool intel_set_pch_fifo_underrun_reporting(struct drm_i915_private *dev_priv,\nenum pipe pch_transcoder,\nbool enable)\n{\nstruct intel_display *display = &dev_priv->display;\nstruct intel_crtc *crtc =\nintel_crtc_for_pipe(display, pch_transcoder);\nunsigned long flags;\nbool old;\n/*\n* NOTE: Pre-LPT has a fixed cpu pipe -> pch transcoder mapping, but LPT\n* has only one pch transcoder A that all pipes can use. To avoid racy\n* pch transcoder -> pipe lookups from interrupt code simply store the\n* underrun statistics in crtc A. Since we never expose this anywhere\n* nor use it outside of the fifo underrun code here using the \"wrong\"\n* crtc on LPT won't cause issues.\n*/\nspin_lock_irqsave(&dev_priv->irq_lock, flags);\nold = !crtc->pch_fifo_underrun_disabled;\ncrtc->pch_fifo_underrun_disabled = !enable;\nif (HAS_PCH_IBX(dev_priv))\nibx_set_fifo_underrun_reporting(&dev_priv->drm,\npch_transcoder,\nenable);\nelse\ncpt_set_fifo_underrun_reporting(&dev_priv->drm,\npch_transcoder,\nenable, old);\nspin_unlock_irqrestore(&dev_priv->irq_lock, flags);\nreturn old;\n}\n```",
  "original_code": "```c\nstatic void hsw_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)\n{\nstruct intel_display *display = to_intel_display(state);\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\ndrm_WARN_ON(display->drm, !old_crtc_state->has_pch_encoder);\nintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n}\n```",
  "vuln_patch": "```c\nstatic void hsw_disable_crt(struct intel_atomic_state *state,\nstruct intel_encoder *encoder,\nconst struct intel_crtc_state *old_crtc_state,\nconst struct drm_connector_state *old_conn_state)\n{\nstruct intel_display *display = to_intel_display(encoder);\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\ndrm_WARN_ON(display->drm, !old_crtc_state->has_pch_encoder);\nintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n}\n```",
  "function_name": "hsw_disable_crt",
  "function_prototype": "static void hsw_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)",
  "code_semantics": "The target code is a function that handles the disabling of a CRT display output on Intel hardware. It retrieves necessary hardware-specific structures, checks a condition related to the presence of a PCH encoder, and updates the hardware state to disable underrun reporting for a specific display pipeline.",
  "safe_verification_cot": "1. The variable encoder is passed to to_intel_display, which is a compatible type, preventing a NULL pointer dereference. 2. The to_intel_display macro correctly handles the struct intel_encoder * type, ensuring safe execution.",
  "verification_cot": "1. The variable state is passed to to_intel_display, which is not a compatible type, leading to a NULL pointer dereference. 2. The to_intel_display macro expects a pointer type that it can handle, such as struct intel_encoder *, but state is of type struct intel_atomic_state *.",
  "vulnerability_related_variables": {
    "state": "This variable is an input that represents a complex data structure. It is used to derive another data structure through a conversion process. The derived data structure is then used for further operations within the function.",
    "encoder": "This variable is an input that represents a complex data structure. It contains a nested component that is used to derive another data structure through a conversion process. The derived data structure is then used for further operations within the function."
  },
  "vulnerability_related_functions": {
    "to_intel_display": "This function performs a type conversion based on the type of the input pointer. It uses a generic selection mechanism to determine the type of the input pointer and returns a pointer to a specific structure type based on this determination. This allows for type-safe conversions between different structure types in the codebase."
  },
  "root_cause": "Incorrect use of to_intel_display macro with incompatible type leading to NULL pointer dereference.",
  "patch_cot": "First, identify where the to_intel_display function is used with an incompatible type, leading to a NULL pointer dereference. Ensure that the variable passed to to_intel_display is of a compatible type, such as struct intel_encoder. Update the code to use a compatible variable, similar to how the patched code uses to_intel_display(encoder) instead of to_intel_display(state)."
}