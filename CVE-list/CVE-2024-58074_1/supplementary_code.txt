```c
struct intel_atomic_state {
    struct drm_atomic_state base;

    intel_wakeref_t wakeref;

    struct __intel_global_objs_state *global_objs;
    int num_global_objs;

    /* Internal commit, as opposed to userspace/client initiated one */
    bool internal;

    bool dpll_set, modeset;

    struct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];

    struct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;

    /*
     * Current watermarks can't be trusted during hardware readout, so
     * don't bother calculating intermediate watermarks.
     */
    bool skip_intermediate_wm;

    bool rps_interactive;
};
```

```c
struct intel_encoder {
    struct drm_encoder base;

    enum intel_output_type type;
    enum port port;
    u16 cloneable;
    u8 pipe_mask;

    /* Check and recover a bad link state. */
    struct delayed_work link_check_work;
    void (*link_check)(struct intel_encoder *encoder);

    enum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,
                        struct intel_connector *connector);
    enum intel_output_type (*compute_output_type)(struct intel_encoder *,
                              struct intel_crtc_state *,
                              struct drm_connector_state *);
    int (*compute_config)(struct intel_encoder *,
                  struct intel_crtc_state *,
                  struct drm_connector_state *);
    int (*compute_config_late)(struct intel_encoder *,
                   struct intel_crtc_state *,
                   struct drm_connector_state *);
    void (*pre_pll_enable)(struct intel_atomic_state *,
                   struct intel_encoder *,
                   const struct intel_crtc_state *,
                   const struct drm_connector_state *);
    void (*pre_enable)(struct intel_atomic_state *,
               struct intel_encoder *,
               const struct intel_crtc_state *,
               const struct drm_connector_state *);
    void (*enable)(struct intel_atomic_state *,
               struct intel_encoder *,
               const struct intel_crtc_state *,
               const struct drm_connector_state *);
    void (*disable)(struct intel_atomic_state *,
            struct intel_encoder *,
            const struct intel_crtc_state *,
            const struct drm_connector_state *);
    void (*post_disable)(struct intel_atomic_state *,
                 struct intel_encoder *,
                 const struct intel_crtc_state *,
                 const struct drm_connector_state *);
    void (*post_pll_disable)(struct intel_atomic_state *,
                 struct intel_encoder *,
                 const struct intel_crtc_state *,
                 const struct drm_connector_state *);
    void (*update_pipe)(struct intel_atomic_state *,
                struct intel_encoder *,
                const struct intel_crtc_state *,
                const struct drm_connector_state *);
    void (*audio_enable)(struct intel_encoder *encoder,
                 const struct intel_crtc_state *crtc_state,
                 const struct drm_connector_state *conn_state);
    void (*audio_disable)(struct intel_encoder *encoder,
                  const struct intel_crtc_state *old_crtc_state,
                  const struct drm_connector_state *old_conn_state);
    /* Read out the current hw state of this connector, returning true if
     * the encoder is active. If the encoder is enabled it also set the pipe
     * it is connected to in the pipe parameter. */
    bool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);
    /* Reconstructs the equivalent mode flags for the current hardware
     * state. This must be called _after_ display->get_pipe_config has
     * pre-filled the pipe config. Note that intel_encoder->base.crtc must
     * be set correctly before calling this function. */
    void (*get_config)(struct intel_encoder *,
               struct intel_crtc_state *pipe_config);

    /*
     * Optional hook called during init/resume to sync any state
     * stored in the encoder (eg. DP link parameters) wrt. the HW state.
     */
    void (*sync_state)(struct intel_encoder *encoder,
               const struct intel_crtc_state *crtc_state);

    /*
     * Optional hook, returning true if this encoder allows a fastset
     * during the initial commit, false otherwise.
     */
    bool (*initial_fastset_check)(struct intel_encoder *encoder,
                      struct intel_crtc_state *crtc_state);

    /*
     * Acquires the power domains needed for an active encoder during
     * hardware state readout.
     */
    void (*get_power_domains)(struct intel_encoder *encoder,
                  struct intel_crtc_state *crtc_state);
    /*
     * Called during system suspend after all pending requests for the
     * encoder are flushed (for example for DP AUX transactions) and
     * device interrupts are disabled.
     * All modeset locks are held while the hook is called.
     */
    void (*suspend)(struct intel_encoder *);
    /*
     * Called without the modeset locks held after the suspend() hook for
     * all encoders have been called.
     */
    void (*suspend_complete)(struct intel_encoder *encoder);
    /*
     * Called during system reboot/shutdown after all the
     * encoders have been disabled and suspended.
     * All modeset locks are held while the hook is called.
     */
    void (*shutdown)(struct intel_encoder *encoder);
    /*
     * Called without the modeset locks held after the shutdown() hook for
     * all encoders have been called.
     */
    void (*shutdown_complete)(struct intel_encoder *encoder);
    /*
     * Enable/disable the clock to the port.
     */
    void (*enable_clock)(struct intel_encoder *encoder,
                 const struct intel_crtc_state *crtc_state);
    void (*disable_clock)(struct intel_encoder *encoder);
    /*
     * Returns whether the port clock is enabled or not.
     */
    bool (*is_clock_enabled)(struct intel_encoder *encoder);
    /*
     * Returns the PLL type the port uses.
     */
    enum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *encoder,
                           const struct intel_crtc_state *crtc_state);
    const struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,
                               const struct intel_crtc_state *crtc_state,
                               int *n_entries);
    void (*set_signal_levels)(struct intel_encoder *encoder,
                  const struct intel_crtc_state *crtc_state);

    enum hpd_pin hpd_pin;
    enum intel_display_power_domain power_domain;

    /* VBT information for this encoder (may be NULL for older platforms) */
    const struct intel_bios_encoder_data *devdata;
};
```

```c
struct intel_crtc_state {
    /*
     * uapi (drm) state. This is the software state shown to userspace.
     * In particular, the following members are used for bookkeeping:
     * - crtc
     * - state
     * - *_changed
     * - event
     * - commit
     * - mode_blob
     */
    struct drm_crtc_state uapi;

    /*
     * actual hardware state, the state we program to the hardware.
     * The following members are used to verify the hardware state:
     * - enable
     * - active
     * - mode / pipe_mode / adjusted_mode
     * - color property blobs.
     *
     * During initial hw readout, they need to be copied to uapi.
     *
     * Joiner will allow a transcoder mode that spans 2 pipes;
     * Use the pipe_mode for calculations like watermarks, pipe
     * scaler, and bandwidth.
     *
     * Use adjusted_mode for things that need to know the full
     * mode on the transcoder, which spans all pipes.
     */
    struct {
        bool active, enable;
        /* logical state of LUTs */
        struct drm_property_blob *degamma_lut, *gamma_lut, *ctm;
        struct drm_display_mode mode, pipe_mode, adjusted_mode;
        enum drm_scaling_filter scaling_filter;
    } hw;

    /* actual state of LUTs */
    struct drm_property_blob *pre_csc_lut, *post_csc_lut;

    struct intel_csc_matrix csc, output_csc;

    /**
     * quirks - bitfield with hw state readout quirks
     *
     * For various reasons the hw state readout code might not be able to
     * completely faithfully read out the current state. These cases are
     * tracked with quirk flags so that fastboot and state checker can act
     * accordingly.
     */
#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS   (1<<0) /* unreliable sync mode.flags */
    unsigned long quirks;

    unsigned fb_bits; /* framebuffers to flip */
    bool update_pipe; /* can a fast modeset be performed? */
    bool update_m_n; /* update M/N seamlessly during fastset? */
    bool update_lrr; /* update TRANS_VTOTAL/etc. during fastset? */
    bool disable_cxsr;
    bool update_wm_pre, update_wm_post; /* watermarks are updated */
    bool fifo_changed; /* FIFO split is changed */
    bool preload_luts;
    bool inherited; /* state inherited from BIOS? */

    /* Ask the hardware to actually async flip? */
    bool do_async_flip;

    /* Pipe source size (ie. panel fitter input size)
     * All planes will be positioned inside this space,
     * and get clipped at the edges. */
    struct drm_rect pipe_src;

    /*
     * Pipe pixel rate, adjusted for
     * panel fitter/pipe scaler downscaling.
     */
    unsigned int pixel_rate;

    /* Whether to set up the PCH/FDI. Note that we never allow sharing
     * between pch encoders and cpu encoders. */
    bool has_pch_encoder;

    /* Are we sending infoframes on the attached port */
    bool has_infoframe;

    /* CPU Transcoder for the pipe. Currently this can only differ from the
     * pipe on Haswell and later (where we have a special eDP transcoder)
     * and Broxton (where we have special DSI transcoders). */
    enum transcoder cpu_transcoder;

    /*
     * Use reduced/limited/broadcast rbg range, compressing from the full
     * range fed into the crtcs.
     */
    bool limited_color_range;

    /* Bitmask of encoder types (enum intel_output_type)
     * driven by the pipe.
     */
    unsigned int output_types;

    /* Whether we should send NULL infoframes. Required for audio. */
    bool has_hdmi_sink;

    /* Audio enabled on this pipe. Only valid if either has_hdmi_sink or
     * has_dp_encoder is set. */
    bool has_audio;

    /*
     * Enable dithering, used when the selected pipe bpp doesn't match the
     * plane bpp.
     */
    bool dither;

    /*
     * Dither gets enabled for 18bpp which causes CRC mismatch errors for
     * compliance video pattern tests.
     * Disable dither only if it is a compliance test request for
     * 18bpp.
     */
    bool dither_force_disable;

    /* Controls for the clock computation, to override various stages. */
    bool clock_set;

    /* SDVO TV has a bunch of special case. To make multifunction encoders
     * work correctly, we need to track this at runtime.*/
    bool sdvo_tv_clock;

    /*
     * crtc bandwidth limit, don't increase pipe bpp or clock if not really
     * required. This is set in the 2nd loop of calling encoder's
     * ->compute_config if the first pick doesn't work out.
     */
    bool bw_constrained;

    /* Settings for the intel dpll used on pretty much everything but
     * haswell. */
    struct dpll dpll;

    /* Selected dpll when shared or NULL. */
    struct intel_shared_dpll *shared_dpll;

    /* Actual register state of the dpll, for shared dpll cross-checking. */
    struct intel_dpll_hw_state dpll_hw_state;

    /*
     * ICL reserved DPLLs for the CRTC/port. The active PLL is selected by
     * setting shared_dpll and dpll_hw_state to one of these reserved ones.
     */
    struct icl_port_dpll {
        struct intel_shared_dpll *pll;
        struct intel_dpll_hw_state hw_state;
    } icl_port_dplls[ICL_PORT_DPLL_COUNT];

    /* DSI PLL registers */
    struct {
        u32 ctrl, div;
    } dsi_pll;

    int max_link_bpp_x16;   /* in 1/16 bpp units */
    int pipe_bpp;       /* in 1 bpp units */
    struct intel_link_m_n dp_m_n;

    /* m2_n2 for eDP downclock */
    struct intel_link_m_n dp_m2_n2;
    bool has_drrs;

    /* PSR is supported but might not be enabled due the lack of enabled planes */
    bool has_psr;
    bool has_sel_update;
    bool enable_psr2_sel_fetch;
    bool enable_psr2_su_region_et;
    bool req_psr2_sdp_prior_scanline;
    bool has_panel_replay;
    bool wm_level_disabled;
    u32 dc3co_exitline;
    u16 su_y_granularity;

    /*
     * Frequence the dpll for the port should run at. Differs from the
     * adjusted dotclock e.g. for DP or 10/12bpc hdmi mode. This is also
     * already multiplied by pixel_multiplier.
     */
    int port_clock;

    /* Used by SDVO (and if we ever fix it, HDMI). */
    unsigned pixel_multiplier;

    /* I915_MODE_FLAG_* */
    u8 mode_flags;

    u8 lane_count;

    /*
     * Used by platforms having DP/HDMI PHY with programmable lane
     * latency optimization.
     */
    u8 lane_lat_optim_mask;

    /* minimum acceptable voltage level */
    u8 min_voltage_level;

    /* Panel fitter controls for gen2-gen4 + VLV */
    struct {
        u32 control;
        u32 pgm_ratios;
        u32 lvds_border_bits;
    } gmch_pfit;

    /* Panel fitter placement and size for Ironlake+ */
    struct {
        struct drm_rect dst;
        bool enabled;
        bool force_thru;
    } pch_pfit;

    /* FDI configuration, only valid if has_pch_encoder is set. */
    int fdi_lanes;
    struct intel_link_m_n fdi_m_n;

    bool ips_enabled;

    bool crc_enabled;

    bool double_wide;

    int pbn;

    struct intel_crtc_scaler_state scaler_state;

    /* w/a for waiting 2 vblanks during crtc enable */
    enum pipe hsw_workaround_pipe;

    struct intel_crtc_wm_state wm;

    int min_cdclk[I915_MAX_PLANES];

    /* for packed/planar CbCr */
    u32 data_rate[I915_MAX_PLANES];
    /* for planar Y */
    u32 data_rate_y[I915_MAX_PLANES];

    /* FIXME unify with data_rate[]? */
    u64 rel_data_rate[I915_MAX_PLANES];
    u64 rel_data_rate_y[I915_MAX_PLANES];

    /* Gamma mode programmed on the pipe */
    u32 gamma_mode;

    union {
        /* CSC mode programmed on the pipe */
        u32 csc_mode;

        /* CHV CGM mode */
        u32 cgm_mode;
    };

    /* bitmask of logically enabled planes (enum plane_id) */
    u8 enabled_planes;

    /* bitmask of actually visible planes (enum plane_id) */
    u8 active_planes;
    u8 scaled_planes;
    u8 nv12_planes;
    u8 c8_planes;

    /* bitmask of planes that will be updated during the commit */
    u8 update_planes;

    /* bitmask of planes with async flip active */
    u8 async_flip_planes;

    u8 framestart_delay; /* 1-4 */
    u8 msa_timing_delay; /* 0-3 */

    struct {
        u32 enable;
        u32 gcp;
        union hdmi_infoframe avi;
        union hdmi_infoframe spd;
        union hdmi_infoframe hdmi;
        union hdmi_infoframe drm;
        struct drm_dp_vsc_sdp vsc;
        struct drm_dp_as_sdp as_sdp;
    } infoframes;

    u8 eld[MAX_ELD_BYTES];

    /* HDMI scrambling status */
    bool hdmi_scrambling;

    /* HDMI High TMDS char rate ratio */
    bool hdmi_high_tmds_clock_ratio;

    /*
     * Output format RGB/YCBCR etc., that is coming out
     * at the end of the pipe.
     */
    enum intel_output_format output_format;

    /*
     * Sink output format RGB/YCBCR etc., that is going
     * into the sink.
     */
    enum intel_output_format sink_format;

    /* enable pipe gamma? */
    bool gamma_enable;

    /* enable pipe csc? */
    bool csc_enable;

    /* enable vlv/chv wgc csc? */
    bool wgc_enable;

    /* joiner pipe bitmask */
    u8 joiner_pipes;

    /* Display Stream compression state */
    struct {
        bool compression_enable;
        bool dsc_split;
        /* Compressed Bpp in U6.4 format (first 4 bits for fractional part) */
        u16 compressed_bpp_x16;
        u8 slice_count;
        struct drm_dsc_config config;
    } dsc;

    /* DP tunnel used for BW allocation. */
    struct drm_dp_tunnel_ref dp_tunnel_ref;

    /* HSW+ linetime watermarks */
    u16 linetime;
    u16 ips_linetime;

    bool enhanced_framing;

    /*
     * Forward Error Correction.
     *
     * Note: This will be false for 128b/132b, which will always have FEC
     * enabled automatically.
     */
    bool fec_enable;

    bool sdp_split_enable;

    /* Pointer to master transcoder in case of tiled displays */
    enum transcoder master_transcoder;

    /* Bitmask to indicate slaves attached */
    u8 sync_mode_slaves_mask;

    /* Only valid on TGL+ */
    enum transcoder mst_master_transcoder;

    /* For DSB based pipe updates */
    struct intel_dsb *dsb_color_vblank, *dsb_commit;
    bool use_dsb;

    u32 psr2_man_track_ctl;

    u32 pipe_srcsz_early_tpt;

    struct drm_rect psr2_su_area;

    /* Variable Refresh Rate state */
    struct {
        bool enable, in_range;
        u8 pipeline_full;
        u16 flipline, vmin, vmax, guardband;
        u32 vsync_end, vsync_start;
    } vrr;

    /* Content Match Refresh Rate state */
    struct {
        bool enable;
        u64 cmrr_n, cmrr_m;
    } cmrr;

    /* Stream Splitter for eDP MSO */
    struct {
        bool enable;
        u8 link_count;
        u8 pixel_overlap;
    } splitter;

    /* for loading single buffered registers during vblank */
    struct drm_vblank_work vblank_work;

    /* LOBF flag */
    bool has_lobf;
};
```

```c
struct drm_connector_state {
    /** @connector: backpointer to the connector */
    struct drm_connector *connector;

    /**
     * @crtc: CRTC to connect connector to, NULL if disabled.
     *
     * Do not change this directly, use drm_atomic_set_crtc_for_connector()
     * instead.
     */
    struct drm_crtc *crtc;

    /**
     * @best_encoder:
     *
     * Used by the atomic helpers to select the encoder, through the
     * &drm_connector_helper_funcs.atomic_best_encoder or
     * &drm_connector_helper_funcs.best_encoder callbacks.
     *
     * This is also used in the atomic helpers to map encoders to their
     * current and previous connectors, see
     * drm_atomic_get_old_connector_for_encoder() and
     * drm_atomic_get_new_connector_for_encoder().
     *
     * NOTE: Atomic drivers must fill this out (either themselves or through
     * helpers), for otherwise the GETCONNECTOR and GETENCODER IOCTLs will
     * not return correct data to userspace.
     */
    struct drm_encoder *best_encoder;

    /**
     * @link_status: Connector link_status to keep track of whether link is
     * GOOD or BAD to notify userspace if retraining is necessary.
     */
    enum drm_link_status link_status;

    /** @state: backpointer to global drm_atomic_state */
    struct drm_atomic_state *state;

    /**
     * @commit: Tracks the pending commit to prevent use-after-free conditions.
     *
     * Is only set when @crtc is NULL.
     */
    struct drm_crtc_commit *commit;

    /** @tv: TV connector state */
    struct drm_tv_connector_state tv;

    /**
     * @self_refresh_aware:
     *
     * This tracks whether a connector is aware of the self refresh state.
     * It should be set to true for those connector implementations which
     * understand the self refresh state. This is needed since the crtc
     * registers the self refresh helpers and it doesn't know if the
     * connectors downstream have implemented self refresh entry/exit.
     *
     * Drivers should set this to true in atomic_check if they know how to
     * handle self_refresh requests.
     */
    bool self_refresh_aware;

    /**
     * @picture_aspect_ratio: Connector property to control the
     * HDMI infoframe aspect ratio setting.
     *
     * The %DRM_MODE_PICTURE_ASPECT_\* values much match the
     * values for &enum hdmi_picture_aspect
     */
    enum hdmi_picture_aspect picture_aspect_ratio;

    /**
     * @content_type: Connector property to control the
     * HDMI infoframe content type setting.
     * The %DRM_MODE_CONTENT_TYPE_\* values much
     * match the values.
     */
    unsigned int content_type;

    /**
     * @hdcp_content_type: Connector property to pass the type of
     * protected content. This is most commonly used for HDCP.
     */
    unsigned int hdcp_content_type;

    /**
     * @scaling_mode: Connector property to control the
     * upscaling, mostly used for built-in panels.
     */
    unsigned int scaling_mode;

    /**
     * @content_protection: Connector property to request content
     * protection. This is most commonly used for HDCP.
     */
    unsigned int content_protection;

    /**
     * @colorspace: State variable for Connector property to request
     * colorspace change on Sink. This is most commonly used to switch
     * to wider color gamuts like BT2020.
     */
    enum drm_colorspace colorspace;

    /**
     * @writeback_job: Writeback job for writeback connectors
     *
     * Holds the framebuffer and out-fence for a writeback connector. As
     * the writeback completion may be asynchronous to the normal commit
     * cycle, the writeback job lifetime is managed separately from the
     * normal atomic state by this object.
     *
     * See also: drm_writeback_queue_job() and
     * drm_writeback_signal_completion()
     */
    struct drm_writeback_job *writeback_job;

    /**
     * @max_requested_bpc: Connector property to limit the maximum bit
     * depth of the pixels.
     */
    u8 max_requested_bpc;

    /**
     * @max_bpc: Connector max_bpc based on the requested max_bpc property
     * and the connector bpc limitations obtained from edid.
     */
    u8 max_bpc;

    /**
     * @privacy_screen_sw_state: See :ref:`Standard Connector
     * Properties<standard_connector_properties>`
     */
    enum drm_privacy_screen_status privacy_screen_sw_state;

    /**
     * @hdr_output_metadata:
     * DRM blob property for HDR output metadata
     */
    struct drm_property_blob *hdr_output_metadata;

    /**
     * @hdmi: HDMI-related variable and properties. Filled by
     * @drm_atomic_helper_connector_hdmi_check().
     */
    struct drm_connector_hdmi_state hdmi;
};
```

```c
struct intel_display {
    /* drm device backpointer */
    struct drm_device *drm;

    /* Platform (and subplatform, if any) identification */
    struct intel_display_platforms platform;

    /* Display functions */
    struct {
        /* Top level crtc-ish functions */
        const struct intel_display_funcs *display;

        /* Display CDCLK functions */
        const struct intel_cdclk_funcs *cdclk;

        /* Display pll funcs */
        const struct intel_dpll_funcs *dpll;

        /* irq display functions */
        const struct intel_hotplug_funcs *hotplug;

        /* pm display functions */
        const struct intel_wm_funcs *wm;

        /* fdi display functions */
        const struct intel_fdi_funcs *fdi;

        /* Display internal color functions */
        const struct intel_color_funcs *color;

        /* Display internal audio functions */
        const struct intel_audio_funcs *audio;
    } funcs;

    struct {
        bool any_task_allowed;
        struct task_struct *allowed_task;
    } access;

    struct {
        /* backlight registers and fields in struct intel_panel */
        struct mutex lock;
    } backlight;

    struct {
        struct intel_global_obj obj;

        struct intel_bw_info {
            /* for each QGV point */
            unsigned int deratedbw[I915_NUM_QGV_POINTS];
            /* for each PSF GV point */
            unsigned int psf_bw[I915_NUM_PSF_GV_POINTS];
            /* Peak BW for each QGV point */
            unsigned int peakbw[I915_NUM_QGV_POINTS];
            u8 num_qgv_points;
            u8 num_psf_gv_points;
            u8 num_planes;
        } max[6];
    } bw;

    struct {
        /* The current hardware cdclk configuration */
        struct intel_cdclk_config hw;

        /* cdclk, divider, and ratio table from bspec */
        const struct intel_cdclk_vals *table;

        struct intel_global_obj obj;

        unsigned int max_cdclk_freq;
        unsigned int max_dotclk_freq;
        unsigned int skl_preferred_vco_freq;
    } cdclk;

    struct {
        struct drm_property_blob *glk_linear_degamma_lut;
    } color;

    struct {
        /* The current hardware dbuf configuration */
        u8 enabled_slices;

        struct intel_global_obj obj;
    } dbuf;

    struct {
        /*
         * dkl.phy_lock protects against concurrent access of the
         * Dekel TypeC PHYs.
         */
        spinlock_t phy_lock;
    } dkl;

    struct {
        struct intel_dmc *dmc;
        intel_wakeref_t wakeref;
    } dmc;

    struct {
        /* VLV/CHV/BXT/GLK DSI MMIO register base address */
        u32 mmio_base;
    } dsi;

    struct {
        /* list of fbdev register on this device */
        struct intel_fbdev *fbdev;
        struct work_struct suspend_work;
    } fbdev;

    struct {
        unsigned int pll_freq;
        u32 rx_config;
    } fdi;

    struct {
        struct list_head obj_list;
    } global;

    struct {
        /*
         * Base address of where the gmbus and gpio blocks are located
         * (either on PCH or on SoC for platforms without PCH).
         */
        u32 mmio_base;

        /*
         * gmbus.mutex protects against concurrent usage of the single
         * hw gmbus controller on different i2c buses.
         */
        struct mutex mutex;

        struct intel_gmbus *bus[GMBUS_NUM_PINS];

        wait_queue_head_t wait_queue;
    } gmbus;

    struct {
        struct i915_hdcp_arbiter *arbiter;
        bool comp_added;

        /*
         * HDCP message struct for allocation of memory which can be
         * reused when sending message to gsc cs.
         * this is only populated post Meteorlake
         */
        struct intel_hdcp_gsc_message *hdcp_message;
        /* Mutex to protect the above hdcp related values. */
        struct mutex hdcp_mutex;
    } hdcp;

    struct {
        /*
         * HTI (aka HDPORT) state read during initial hw readout. Most
         * platforms don't have HTI, so this will just stay 0. Those
         * that do will use this later to figure out which PLLs and PHYs
         * are unavailable for driver usage.
         */
        u32 state;
    } hti;

    struct {
        /* Access with DISPLAY_INFO() */
        const struct intel_display_device_info *__device_info;

        /* Access with DISPLAY_RUNTIME_INFO() */
        struct intel_display_runtime_info __runtime_info;
    } info;

    struct {
        bool false_color;
    } ips;

    struct {
        bool display_irqs_enabled;

        /* For i915gm/i945gm vblank irq workaround */
        u8 vblank_enabled;

        int vblank_wa_num_pipes;

        struct work_struct vblank_dc_work;

        u32 de_irq_mask[I915_MAX_PIPES];
        u32 pipestat_irq_mask[I915_MAX_PIPES];
    } irq;

    struct {
        wait_queue_head_t waitqueue;

        /* mutex to protect pmdemand programming sequence */
        struct mutex lock;

        struct intel_global_obj obj;
    } pmdemand;

    struct {
        struct i915_power_domains domains;

        /* Shadow for DISPLAY_PHY_CONTROL which can't be safely read */
        u32 chv_phy_control;

        /* perform PHY state sanity checks? */
        bool chv_phy_assert[2];
    } power;

    struct {
        u32 mmio_base;

        /* protects panel power sequencer state */
        struct mutex mutex;
    } pps;

    struct {
        struct drm_property *broadcast_rgb;
        struct drm_property *force_audio;
    } properties;

    struct {
        unsigned long mask;
    } quirks;

    struct {
        /* restore state for suspend/resume and display reset */
        struct drm_atomic_state *modeset_state;
        struct drm_modeset_acquire_ctx reset_ctx;
    } restore;

    struct {
        enum {
            I915_SAGV_UNKNOWN = 0,
            I915_SAGV_DISABLED,
            I915_SAGV_ENABLED,
            I915_SAGV_NOT_CONTROLLED
        } status;

        u32 block_time_us;
    } sagv;

    struct {
        /*
         * DG2: Mask of PHYs that were not calibrated by the firmware
         * and should not be used.
         */
        u8 phy_failed_calibration;
    } snps;

    struct {
        /*
         * Shadows for CHV DPLL_MD regs to keep the state
         * checker somewhat working in the presence hardware
         * crappiness (can't read out DPLL_MD for pipes B & C).
         */
        u32 chv_dpll_md[I915_MAX_PIPES];
        u32 bxt_phy_grc;
    } state;

    struct {
        /* ordered wq for modesets */
        struct workqueue_struct *modeset;

        /* unbound hipri wq for page flips/plane updates */
        struct workqueue_struct *flip;
    } wq;

    /* Grouping using named structs. Keep sorted. */
    struct drm_dp_tunnel_mgr *dp_tunnel_mgr;
    struct intel_audio audio;
    struct intel_dpll dpll;
    struct intel_fbc *fbc[I915_MAX_FBCS];
    struct intel_frontbuffer_tracking fb_tracking;
    struct intel_hotplug hotplug;
    struct intel_opregion *opregion;
    struct intel_overlay *overlay;
    struct intel_display_params params;
    struct intel_vbt_data vbt;
    struct intel_dmc_wl wl;
    struct intel_wm wm;
};
```

```c
#define to_intel_display(p)             \
    _Generic(*p,                    \
         __assoc(drm_device, p),        \
         __assoc(device, p),            \
         __assoc(pci_dev, p),           \
         __assoc(intel_atomic_state, p),    \
         __assoc(intel_connector, p),       \
         __assoc(intel_crtc, p),        \
         __assoc(intel_crtc_state, p),      \
         __assoc(intel_digital_port, p),    \
         __assoc(intel_dp, p),          \
         __assoc(intel_encoder, p),     \
         __assoc(intel_hdmi, p),        \
         __assoc(intel_plane, p),       \
         __assoc(intel_plane_state, p))
```

```c
struct drm_i915_private {
    struct drm_device drm;

    struct intel_display display;

    /* FIXME: Device release actions should all be moved to drmm_ */
    bool do_release;

    /* i915 device parameters */
    struct i915_params params;

    const struct intel_device_info *__info; /* Use INTEL_INFO() to access. */
    struct intel_runtime_info __runtime; /* Use RUNTIME_INFO() to access. */
    struct intel_driver_caps caps;

    struct i915_dsm dsm;

    struct intel_uncore uncore;
    struct intel_uncore_mmio_debug mmio_debug;

    struct i915_virtual_gpu vgpu;

    struct intel_gvt *gvt;

    struct {
        struct pci_dev *pdev;
        struct resource mch_res;
        bool mchbar_need_disable;
    } gmch;

    /*
     * Chaining user engines happens in multiple stages, starting with a
     * simple lock-less linked list created by intel_engine_add_user(),
     * which later gets sorted and converted to an intermediate regular
     * list, just to be converted once again to its final rb tree structure
     * in intel_engines_driver_register().
     *
     * Make sure to use the right iterator helper, depending on if the code
     * in question runs before or after intel_engines_driver_register() --
     * for_each_uabi_engine() can only be used afterwards!
     */
    union {
        struct llist_head uabi_engines_llist;
        struct list_head uabi_engines_list;
        struct rb_root uabi_engines;
    };
    unsigned int engine_uabi_class_count[I915_LAST_UABI_ENGINE_CLASS + 1];

    /* protects the irq masks */
    spinlock_t irq_lock;
    bool irqs_enabled;

    /* Sideband mailbox protection */
    struct mutex sb_lock;
    struct pm_qos_request sb_qos;

    /** Cached value of IMR to avoid reads in updating the bitfield */
    u32 irq_mask;

    bool preserve_bios_swizzle;

    unsigned int fsb_freq, mem_freq, is_ddr3;

    unsigned int hpll_freq;
    unsigned int czclk_freq;

    /**
     * wq - Driver workqueue for GEM.
     *
     * NOTE: Work items scheduled here are not allowed to grab any modeset
     * locks, for otherwise the flushing done in the pageflip code will
     * result in deadlocks.
     */
    struct workqueue_struct *wq;

    /**
     * unordered_wq - internal workqueue for unordered work
     *
     * This workqueue should be used for all unordered work
     * scheduling within i915, which used to be scheduled on the
     * system_wq before moving to a driver instance due
     * deprecation of flush_scheduled_work().
     */
    struct workqueue_struct *unordered_wq;

    /* pm private clock gating functions */
    const struct drm_i915_clock_gating_funcs *clock_gating_funcs;

    /* PCH chipset type */
    enum intel_pch pch_type;
    unsigned short pch_id;

    unsigned long gem_quirks;

    struct i915_gem_mm mm;

    struct intel_l3_parity l3_parity;

    /*
     * edram size in MB.
     * Cannot be determined by PCIID. You must always read a register.
     */
    u32 edram_size_mb;

    struct i915_gpu_error gpu_error;

    u32 suspend_count;
    struct i915_suspend_saved_registers regfile;
    struct vlv_s0ix_state *vlv_s0ix_state;

    struct dram_info {
        bool wm_lv_0_adjust_needed;
        u8 num_channels;
        bool symmetric_memory;
        enum intel_dram_type {
            INTEL_DRAM_UNKNOWN,
            INTEL_DRAM_DDR3,
            INTEL_DRAM_DDR4,
            INTEL_DRAM_LPDDR3,
            INTEL_DRAM_LPDDR4,
            INTEL_DRAM_DDR5,
            INTEL_DRAM_LPDDR5,
            INTEL_DRAM_GDDR,
        } type;
        u8 num_qgv_points;
        u8 num_psf_gv_points;
    } dram_info;

    struct intel_runtime_pm runtime_pm;

    struct i915_perf perf;

    struct i915_hwmon *hwmon;

    struct intel_gt *gt[I915_MAX_GT];

    struct kobject *sysfs_gt;

    /* Quick lookup of media GT (current platforms only have one) */
    struct intel_gt *media_gt;

    struct {
        struct i915_gem_contexts {
            spinlock_t lock; /* locks list */
            struct list_head list;
        } contexts;

        /*
         * We replace the local file with a global mappings as the
         * backing storage for the mmap is on the device and not
         * on the struct file, and we do not want to prolong the
         * lifetime of the local fd. To minimise the number of
         * anonymous inodes we create, we use a global singleton to
         * share the global mapping.
         */
        struct file *mmap_singleton;
    } gem;

    struct intel_pxp *pxp;

    struct i915_pmu pmu;

    /* The TTM device structure. */
    struct ttm_device bdev;

    I915_SELFTEST_DECLARE(struct i915_selftest_stash selftest;)

    /*
     * NOTE: This is the dri1/ums dungeon, don't add stuff here. Your patch
     * will be rejected. Instead look for a better place.
     */
};
```

```c
static inline struct drm_i915_private *to_i915(const struct drm_device *dev)
{
    return container_of(dev, struct drm_i915_private, drm);
}
```

```c
#define drm_WARN_ON(drm, x)                     \
    drm_WARN((drm), (x), "%s",                  \
         "drm_WARN_ON(" __stringify(x) ")")
```

```c
bool intel_set_pch_fifo_underrun_reporting(struct drm_i915_private *dev_priv,
                       enum pipe pch_transcoder,
                       bool enable)
{
    struct intel_display *display = &dev_priv->display;
    struct intel_crtc *crtc =
        intel_crtc_for_pipe(display, pch_transcoder);
    unsigned long flags;
    bool old;

    /*
     * NOTE: Pre-LPT has a fixed cpu pipe -> pch transcoder mapping, but LPT
     * has only one pch transcoder A that all pipes can use. To avoid racy
     * pch transcoder -> pipe lookups from interrupt code simply store the
     * underrun statistics in crtc A. Since we never expose this anywhere
     * nor use it outside of the fifo underrun code here using the "wrong"
     * crtc on LPT won't cause issues.
     */

    spin_lock_irqsave(&dev_priv->irq_lock, flags);

    old = !crtc->pch_fifo_underrun_disabled;
    crtc->pch_fifo_underrun_disabled = !enable;

    if (HAS_PCH_IBX(dev_priv))
        ibx_set_fifo_underrun_reporting(&dev_priv->drm,
                        pch_transcoder,
                        enable);
    else
        cpt_set_fifo_underrun_reporting(&dev_priv->drm,
                        pch_transcoder,
                        enable, old);

    spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
    return old;
}
```
