```c
struct dpll_pin {
    u32 id;
    u32 pin_idx;
    u64 clock_id;
    struct module *module;
    struct xarray dpll_refs;
    struct xarray parent_refs;
    struct dpll_pin_properties prop;
    refcount_t refcount;
    struct rcu_head rcu;
};
```

```c
struct module {
    enum module_state state;

    /* Member of list of modules */
    struct list_head list;

    /* Unique handle for this module */
    char name[MODULE_NAME_LEN];

#ifdef CONFIG_STACKTRACE_BUILD_ID
    /* Module build ID */
    unsigned char build_id[BUILD_ID_SIZE_MAX];
#endif

    /* Sysfs stuff. */
    struct module_kobject mkobj;
    struct module_attribute *modinfo_attrs;
    const char *version;
    const char *srcversion;
    struct kobject *holders_dir;

    /* Exported symbols */
    const struct kernel_symbol *syms;
    const s32 *crcs;
    unsigned int num_syms;

#ifdef CONFIG_ARCH_USES_CFI_TRAPS
    s32 *kcfi_traps;
    s32 *kcfi_traps_end;
#endif

    /* Kernel parameters. */
#ifdef CONFIG_SYSFS
    struct mutex param_lock;
#endif
    struct kernel_param *kp;
    unsigned int num_kp;

    /* GPL-only exported symbols. */
    unsigned int num_gpl_syms;
    const struct kernel_symbol *gpl_syms;
    const s32 *gpl_crcs;
    bool using_gplonly_symbols;

#ifdef CONFIG_MODULE_SIG
    /* Signature was verified. */
    bool sig_ok;
#endif

    bool async_probe_requested;

    /* Exception table */
    unsigned int num_exentries;
    struct exception_table_entry *extable;

    /* Startup function. */
    int (*init)(void);

    struct module_memory mem[MOD_MEM_NUM_TYPES] __module_memory_align;

    /* Arch-specific module values */
    struct mod_arch_specific arch;

    unsigned long taints;   /* same bits as kernel:taint_flags */

#ifdef CONFIG_GENERIC_BUG
    /* Support for BUG */
    unsigned num_bugs;
    struct list_head bug_list;
    struct bug_entry *bug_table;
#endif

#ifdef CONFIG_KALLSYMS
    /* Protected by RCU and/or module_mutex: use rcu_dereference() */
    struct mod_kallsyms __rcu *kallsyms;
    struct mod_kallsyms core_kallsyms;

    /* Section attributes */
    struct module_sect_attrs *sect_attrs;

    /* Notes attributes */
    struct module_notes_attrs *notes_attrs;
#endif

    /* The command line arguments (may be mangled).  People like
       keeping pointers to this stuff */
    char *args;

#ifdef CONFIG_SMP
    /* Per-cpu data. */
    void __percpu *percpu;
    unsigned int percpu_size;
#endif
    void *noinstr_text_start;
    unsigned int noinstr_text_size;

#ifdef CONFIG_TRACEPOINTS
    unsigned int num_tracepoints;
    tracepoint_ptr_t *tracepoints_ptrs;
#endif
#ifdef CONFIG_TREE_SRCU
    unsigned int num_srcu_structs;
    struct srcu_struct **srcu_struct_ptrs;
#endif
#ifdef CONFIG_BPF_EVENTS
    unsigned int num_bpf_raw_events;
    struct bpf_raw_event_map *bpf_raw_events;
#endif
#ifdef CONFIG_DEBUG_INFO_BTF_MODULES
    unsigned int btf_data_size;
    unsigned int btf_base_data_size;
    void *btf_data;
    void *btf_base_data;
#endif
#ifdef CONFIG_JUMP_LABEL
    struct jump_entry *jump_entries;
    unsigned int num_jump_entries;
#endif
#ifdef CONFIG_TRACING
    unsigned int num_trace_bprintk_fmt;
    const char **trace_bprintk_fmt_start;
#endif
#ifdef CONFIG_EVENT_TRACING
    struct trace_event_call **trace_events;
    unsigned int num_trace_events;
    struct trace_eval_map **trace_evals;
    unsigned int num_trace_evals;
#endif
#ifdef CONFIG_FTRACE_MCOUNT_RECORD
    unsigned int num_ftrace_callsites;
    unsigned long *ftrace_callsites;
#endif
#ifdef CONFIG_KPROBES
    void *kprobes_text_start;
    unsigned int kprobes_text_size;
    unsigned long *kprobe_blacklist;
    unsigned int num_kprobe_blacklist;
#endif
#ifdef CONFIG_HAVE_STATIC_CALL_INLINE
    int num_static_call_sites;
    struct static_call_site *static_call_sites;
#endif
#if IS_ENABLED(CONFIG_KUNIT)
    int num_kunit_init_suites;
    struct kunit_suite **kunit_init_suites;
    int num_kunit_suites;
    struct kunit_suite **kunit_suites;
#endif


#ifdef CONFIG_LIVEPATCH
    bool klp; /* Is this a livepatch module? */
    bool klp_alive;

    /* ELF information */
    struct klp_modinfo *klp_info;
#endif

#ifdef CONFIG_PRINTK_INDEX
    unsigned int printk_index_size;
    struct pi_entry **printk_index_start;
#endif

#ifdef CONFIG_MODULE_UNLOAD
    /* What modules depend on me? */
    struct list_head source_list;
    /* What modules do I depend on? */
    struct list_head target_list;

    /* Destruction function. */
    void (*exit)(void);

    atomic_t refcnt;
#endif

#ifdef CONFIG_CONSTRUCTORS
    /* Constructor functions. */
    ctor_fn_t *ctors;
    unsigned int num_ctors;
#endif

#ifdef CONFIG_FUNCTION_ERROR_INJECTION
    struct error_injection_entry *ei_funcs;
    unsigned int num_ei_funcs;
#endif
#ifdef CONFIG_DYNAMIC_DEBUG_CORE
    struct _ddebug_info dyndbg_info;
#endif
} ____cacheline_aligned __randomize_layout;
```

```c
struct dpll_pin_properties {
    const char *board_label;
    const char *panel_label;
    const char *package_label;
    enum dpll_pin_type type;
    unsigned long capabilities;
    u32 freq_supported_num;
    struct dpll_pin_frequency *freq_supported;
    struct dpll_pin_phase_adjust_range phase_range;
};
```

```c
static inline void *kzalloc(size_t s, gfp_t gfp)
{
    void *p = kmalloc(s, gfp);

    memset(p, 0, s);
    return p;
}
```

```c
#define GFP_KERNEL 0
```

```c
#define ENOMEM      12  /* Out of memory */
#define EINVAL      22  /* Invalid argument */
```

```c
#define WARN_ON(condition) ({                   \
    int __ret_warn_on = !!(condition);          \
    if (unlikely(__ret_warn_on))                \
        __WARN_printf("assertion failed at %s:%d\n",    \
                __FILE__, __LINE__);        \
    unlikely(__ret_warn_on);                \
})
```

```c
enum dpll_pin_type {
    DPLL_PIN_TYPE_MUX = 1,
    DPLL_PIN_TYPE_EXT,
    DPLL_PIN_TYPE_SYNCE_ETH_PORT,
    DPLL_PIN_TYPE_INT_OSCILLATOR,
    DPLL_PIN_TYPE_GNSS,

    /* private: */
    __DPLL_PIN_TYPE_MAX,
    DPLL_PIN_TYPE_MAX = (__DPLL_PIN_TYPE_MAX - 1)
};
```

```c
static int dpll_pin_prop_dup(const struct dpll_pin_properties *src,
                 struct dpll_pin_properties *dst)
{
    memcpy(dst, src, sizeof(*dst));
    if (src->freq_supported && src->freq_supported_num) {
        size_t freq_size = src->freq_supported_num *
                   sizeof(*src->freq_supported);
        dst->freq_supported = kmemdup(src->freq_supported,
                          freq_size, GFP_KERNEL);
        if (!dst->freq_supported)
            return -ENOMEM;
    }
    if (src->board_label) {
        dst->board_label = kstrdup(src->board_label, GFP_KERNEL);
        if (!dst->board_label)
            goto err_board_label;
    }
    if (src->panel_label) {
        dst->panel_label = kstrdup(src->panel_label, GFP_KERNEL);
        if (!dst->panel_label)
            goto err_panel_label;
    }
    if (src->package_label) {
        dst->package_label = kstrdup(src->package_label, GFP_KERNEL);
        if (!dst->package_label)
            goto err_package_label;
    }

    return 0;

err_package_label:
    kfree(dst->panel_label);
err_panel_label:
    kfree(dst->board_label);
err_board_label:
    kfree(dst->freq_supported);
    return -ENOMEM;
}
```

```c
static inline void refcount_set(refcount_t *r, unsigned int n)
{
    atomic_set(&r->refs, n);
}
```

```c
static inline void xa_init_flags(struct xarray *xa, gfp_t flags)
{
    spin_lock_init(&xa->xa_lock);
    xa->xa_flags = flags;
    xa->xa_head = NULL;
}
```

```c
static inline int xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,
        struct xa_limit limit, u32 *next, gfp_t gfp)
{
    int err;

    might_alloc(gfp);
    xa_lock(xa);
    err = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);
    xa_unlock(xa);

    return err;
}
```

```c
#define XA_FLAGS_ALLOC  (XA_FLAGS_TRACK_FREE | XA_FLAGS_MARK(XA_FREE_MARK))
```

```c
#define xa_limit_32b    XA_LIMIT(0, UINT_MAX)
```

```c
void xa_destroy(struct xarray *xa)
{
    XA_STATE(xas, xa, 0);
    unsigned long flags;
    void *entry;

    xas.xa_node = NULL;
    xas_lock_irqsave(&xas, flags);
    entry = xa_head_locked(xa);
    RCU_INIT_POINTER(xa->xa_head, NULL);
    xas_init_marks(&xas);
    if (xa_zero_busy(xa))
        xa_mark_clear(xa, XA_FREE_MARK);
    /* lockdep checks we're still holding the lock in xas_free_nodes() */
    if (xa_is_node(entry))
        xas_free_nodes(&xas, xa_to_node(entry));
    xas_unlock_irqrestore(&xas, flags);
}
EXPORT_SYMBOL(xa_destroy);
```

```c
static void dpll_pin_prop_free(struct dpll_pin_properties *prop)
{
    kfree(prop->package_label);
    kfree(prop->panel_label);
    kfree(prop->board_label);
    kfree(prop->freq_supported);
}
```

```c
static inline void kfree(void *p)
{
    if (p >= __kfree_ignore_start && p < __kfree_ignore_end)
        return;
    free(p);
}
```

```c
static inline void * __must_check ERR_PTR(long error)
{
    return (void *) error;
}
```
