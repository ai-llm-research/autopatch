{
  "cwe_type": "Incorrect Check of Function Return Value",
  "cve_id": "CVE-2025-22016",
  "supplementary_code": "```c\nstruct dpll_pin {\nu32 id;\nu32 pin_idx;\nu64 clock_id;\nstruct module *module;\nstruct xarray dpll_refs;\nstruct xarray parent_refs;\nstruct dpll_pin_properties prop;\nrefcount_t refcount;\nstruct rcu_head rcu;\n};\n```\n```c\nstruct module {\nenum module_state state;\n/* Member of list of modules */\nstruct list_head list;\n/* Unique handle for this module */\nchar name[MODULE_NAME_LEN];\n#ifdef CONFIG_STACKTRACE_BUILD_ID\n/* Module build ID */\nunsigned char build_id[BUILD_ID_SIZE_MAX];\n#endif\n/* Sysfs stuff. */\nstruct module_kobject mkobj;\nstruct module_attribute *modinfo_attrs;\nconst char *version;\nconst char *srcversion;\nstruct kobject *holders_dir;\n/* Exported symbols */\nconst struct kernel_symbol *syms;\nconst s32 *crcs;\nunsigned int num_syms;\n#ifdef CONFIG_ARCH_USES_CFI_TRAPS\ns32 *kcfi_traps;\ns32 *kcfi_traps_end;\n#endif\n/* Kernel parameters. */\n#ifdef CONFIG_SYSFS\nstruct mutex param_lock;\n#endif\nstruct kernel_param *kp;\nunsigned int num_kp;\n/* GPL-only exported symbols. */\nunsigned int num_gpl_syms;\nconst struct kernel_symbol *gpl_syms;\nconst s32 *gpl_crcs;\nbool using_gplonly_symbols;\n#ifdef CONFIG_MODULE_SIG\n/* Signature was verified. */\nbool sig_ok;\n#endif\nbool async_probe_requested;\n/* Exception table */\nunsigned int num_exentries;\nstruct exception_table_entry *extable;\n/* Startup function. */\nint (*init)(void);\nstruct module_memory mem[MOD_MEM_NUM_TYPES] __module_memory_align;\n/* Arch-specific module values */\nstruct mod_arch_specific arch;\nunsigned long taints; /* same bits as kernel:taint_flags */\n#ifdef CONFIG_GENERIC_BUG\n/* Support for BUG */\nunsigned num_bugs;\nstruct list_head bug_list;\nstruct bug_entry *bug_table;\n#endif\n#ifdef CONFIG_KALLSYMS\n/* Protected by RCU and/or module_mutex: use rcu_dereference() */\nstruct mod_kallsyms __rcu *kallsyms;\nstruct mod_kallsyms core_kallsyms;\n/* Section attributes */\nstruct module_sect_attrs *sect_attrs;\n/* Notes attributes */\nstruct module_notes_attrs *notes_attrs;\n#endif\n/* The command line arguments (may be mangled). People like\nkeeping pointers to this stuff */\nchar *args;\n#ifdef CONFIG_SMP\n/* Per-cpu data. */\nvoid __percpu *percpu;\nunsigned int percpu_size;\n#endif\nvoid *noinstr_text_start;\nunsigned int noinstr_text_size;\n#ifdef CONFIG_TRACEPOINTS\nunsigned int num_tracepoints;\ntracepoint_ptr_t *tracepoints_ptrs;\n#endif\n#ifdef CONFIG_TREE_SRCU\nunsigned int num_srcu_structs;\nstruct srcu_struct **srcu_struct_ptrs;\n#endif\n#ifdef CONFIG_BPF_EVENTS\nunsigned int num_bpf_raw_events;\nstruct bpf_raw_event_map *bpf_raw_events;\n#endif\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\nunsigned int btf_data_size;\nunsigned int btf_base_data_size;\nvoid *btf_data;\nvoid *btf_base_data;\n#endif\n#ifdef CONFIG_JUMP_LABEL\nstruct jump_entry *jump_entries;\nunsigned int num_jump_entries;\n#endif\n#ifdef CONFIG_TRACING\nunsigned int num_trace_bprintk_fmt;\nconst char **trace_bprintk_fmt_start;\n#endif\n#ifdef CONFIG_EVENT_TRACING\nstruct trace_event_call **trace_events;\nunsigned int num_trace_events;\nstruct trace_eval_map **trace_evals;\nunsigned int num_trace_evals;\n#endif\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\nunsigned int num_ftrace_callsites;\nunsigned long *ftrace_callsites;\n#endif\n#ifdef CONFIG_KPROBES\nvoid *kprobes_text_start;\nunsigned int kprobes_text_size;\nunsigned long *kprobe_blacklist;\nunsigned int num_kprobe_blacklist;\n#endif\n#ifdef CONFIG_HAVE_STATIC_CALL_INLINE\nint num_static_call_sites;\nstruct static_call_site *static_call_sites;\n#endif\n#if IS_ENABLED(CONFIG_KUNIT)\nint num_kunit_init_suites;\nstruct kunit_suite **kunit_init_suites;\nint num_kunit_suites;\nstruct kunit_suite **kunit_suites;\n#endif\n#ifdef CONFIG_LIVEPATCH\nbool klp; /* Is this a livepatch module? */\nbool klp_alive;\n/* ELF information */\nstruct klp_modinfo *klp_info;\n#endif\n#ifdef CONFIG_PRINTK_INDEX\nunsigned int printk_index_size;\nstruct pi_entry **printk_index_start;\n#endif\n#ifdef CONFIG_MODULE_UNLOAD\n/* What modules depend on me? */\nstruct list_head source_list;\n/* What modules do I depend on? */\nstruct list_head target_list;\n/* Destruction function. */\nvoid (*exit)(void);\natomic_t refcnt;\n#endif\n#ifdef CONFIG_CONSTRUCTORS\n/* Constructor functions. */\nctor_fn_t *ctors;\nunsigned int num_ctors;\n#endif\n#ifdef CONFIG_FUNCTION_ERROR_INJECTION\nstruct error_injection_entry *ei_funcs;\nunsigned int num_ei_funcs;\n#endif\n#ifdef CONFIG_DYNAMIC_DEBUG_CORE\nstruct _ddebug_info dyndbg_info;\n#endif\n} ____cacheline_aligned __randomize_layout;\n```\n```c\nstruct dpll_pin_properties {\nconst char *board_label;\nconst char *panel_label;\nconst char *package_label;\nenum dpll_pin_type type;\nunsigned long capabilities;\nu32 freq_supported_num;\nstruct dpll_pin_frequency *freq_supported;\nstruct dpll_pin_phase_adjust_range phase_range;\n};\n```\n```c\nstatic inline void *kzalloc(size_t s, gfp_t gfp)\n{\nvoid *p = kmalloc(s, gfp);\nmemset(p, 0, s);\nreturn p;\n}\n```\n```c\n#define GFP_KERNEL 0\n```\n```c\n#define ENOMEM 12 /* Out of memory */\n#define EINVAL 22 /* Invalid argument */\n```\n```c\n#define WARN_ON(condition) ({ \\\nint __ret_warn_on = !!(condition); \\\nif (unlikely(__ret_warn_on)) \\\n__WARN_printf(\"assertion failed at %s:%d\\n\", \\\n__FILE__, __LINE__); \\\nunlikely(__ret_warn_on); \\\n})\n```\n```c\nenum dpll_pin_type {\nDPLL_PIN_TYPE_MUX = 1,\nDPLL_PIN_TYPE_EXT,\nDPLL_PIN_TYPE_SYNCE_ETH_PORT,\nDPLL_PIN_TYPE_INT_OSCILLATOR,\nDPLL_PIN_TYPE_GNSS,\n/* private: */\n__DPLL_PIN_TYPE_MAX,\nDPLL_PIN_TYPE_MAX = (__DPLL_PIN_TYPE_MAX - 1)\n};\n```\n```c\nstatic int dpll_pin_prop_dup(const struct dpll_pin_properties *src,\nstruct dpll_pin_properties *dst)\n{\nmemcpy(dst, src, sizeof(*dst));\nif (src->freq_supported && src->freq_supported_num) {\nsize_t freq_size = src->freq_supported_num *\nsizeof(*src->freq_supported);\ndst->freq_supported = kmemdup(src->freq_supported,\nfreq_size, GFP_KERNEL);\nif (!dst->freq_supported)\nreturn -ENOMEM;\n}\nif (src->board_label) {\ndst->board_label = kstrdup(src->board_label, GFP_KERNEL);\nif (!dst->board_label)\ngoto err_board_label;\n}\nif (src->panel_label) {\ndst->panel_label = kstrdup(src->panel_label, GFP_KERNEL);\nif (!dst->panel_label)\ngoto err_panel_label;\n}\nif (src->package_label) {\ndst->package_label = kstrdup(src->package_label, GFP_KERNEL);\nif (!dst->package_label)\ngoto err_package_label;\n}\nreturn 0;\nerr_package_label:\nkfree(dst->panel_label);\nerr_panel_label:\nkfree(dst->board_label);\nerr_board_label:\nkfree(dst->freq_supported);\nreturn -ENOMEM;\n}\n```\n```c\nstatic inline void refcount_set(refcount_t *r, unsigned int n)\n{\natomic_set(&r->refs, n);\n}\n```\n```c\nstatic inline void xa_init_flags(struct xarray *xa, gfp_t flags)\n{\nspin_lock_init(&xa->xa_lock);\nxa->xa_flags = flags;\nxa->xa_head = NULL;\n}\n```\n```c\nstatic inline int xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,\nstruct xa_limit limit, u32 *next, gfp_t gfp)\n{\nint err;\nmight_alloc(gfp);\nxa_lock(xa);\nerr = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);\nxa_unlock(xa);\nreturn err;\n}\n```\n```c\n#define XA_FLAGS_ALLOC (XA_FLAGS_TRACK_FREE | XA_FLAGS_MARK(XA_FREE_MARK))\n```\n```c\n#define xa_limit_32b XA_LIMIT(0, UINT_MAX)\n```\n```c\nvoid xa_destroy(struct xarray *xa)\n{\nXA_STATE(xas, xa, 0);\nunsigned long flags;\nvoid *entry;\nxas.xa_node = NULL;\nxas_lock_irqsave(&xas, flags);\nentry = xa_head_locked(xa);\nRCU_INIT_POINTER(xa->xa_head, NULL);\nxas_init_marks(&xas);\nif (xa_zero_busy(xa))\nxa_mark_clear(xa, XA_FREE_MARK);\n/* lockdep checks we're still holding the lock in xas_free_nodes() */\nif (xa_is_node(entry))\nxas_free_nodes(&xas, xa_to_node(entry));\nxas_unlock_irqrestore(&xas, flags);\n}\nEXPORT_SYMBOL(xa_destroy);\n```\n```c\nstatic void dpll_pin_prop_free(struct dpll_pin_properties *prop)\n{\nkfree(prop->package_label);\nkfree(prop->panel_label);\nkfree(prop->board_label);\nkfree(prop->freq_supported);\n}\n```\n```c\nstatic inline void kfree(void *p)\n{\nif (p >= __kfree_ignore_start && p < __kfree_ignore_end)\nreturn;\nfree(p);\n}\n```\n```c\nstatic inline void * __must_check ERR_PTR(long error)\n{\nreturn (void *) error;\n}\n```",
  "original_code": "```c\nstatic struct dpll_pin *dpll_pin_alloc(u64 clock_id, u32 pin_idx, struct module *module, const struct dpll_pin_properties *prop)\n{\nstruct dpll_pin *pin;\nint ret;\npin = kzalloc(sizeof(*pin), GFP_KERNEL);\nif (!pin)\nreturn ERR_PTR(-ENOMEM);\npin->pin_idx = pin_idx;\npin->clock_id = clock_id;\npin->module = module;\nif (WARN_ON(prop->type < DPLL_PIN_TYPE_MUX ||\nprop->type > DPLL_PIN_TYPE_MAX)) {\nret = -EINVAL;\ngoto err_pin_prop;\n}\nret = dpll_pin_prop_dup(prop, &pin->prop);\nif (ret)\ngoto err_pin_prop;\nrefcount_set(&pin->refcount, 1);\nxa_init_flags(&pin->dpll_refs, XA_FLAGS_ALLOC);\nxa_init_flags(&pin->parent_refs, XA_FLAGS_ALLOC);\nret = xa_alloc_cyclic(&dpll_pin_xa, &pin->id, pin, xa_limit_32b,\n&dpll_pin_xa_id, GFP_KERNEL);\nif (ret)\ngoto err_xa_alloc;\nreturn pin;\nerr_xa_alloc:\nxa_destroy(&pin->dpll_refs);\nxa_destroy(&pin->parent_refs);\ndpll_pin_prop_free(&pin->prop);\nerr_pin_prop:\nkfree(pin);\nreturn ERR_PTR(ret);\n}\n```",
  "vuln_patch": "```c\nstatic struct dpll_pin *dpll_pin_alloc(u64 clock_id, u32 pin_idx, struct module *module, const struct dpll_pin_properties *prop)\n{\nstruct dpll_pin *pin;\nint ret;\npin = kzalloc(sizeof(*pin), GFP_KERNEL);\nif (!pin)\nreturn ERR_PTR(-ENOMEM);\npin->pin_idx = pin_idx;\npin->clock_id = clock_id;\npin->module = module;\nif (WARN_ON(prop->type < DPLL_PIN_TYPE_MUX ||\nprop->type > DPLL_PIN_TYPE_MAX)) {\nret = -EINVAL;\ngoto err_pin_prop;\n}\nret = dpll_pin_prop_dup(prop, &pin->prop);\nif (ret)\ngoto err_pin_prop;\nrefcount_set(&pin->refcount, 1);\nxa_init_flags(&pin->dpll_refs, XA_FLAGS_ALLOC);\nxa_init_flags(&pin->parent_refs, XA_FLAGS_ALLOC);\nret = xa_alloc_cyclic(&dpll_pin_xa, &pin->id, pin, xa_limit_32b,\n&dpll_pin_xa_id, GFP_KERNEL);\nif (ret < 0)\ngoto err_xa_alloc;\nreturn pin;\nerr_xa_alloc:\nxa_destroy(&pin->dpll_refs);\nxa_destroy(&pin->parent_refs);\ndpll_pin_prop_free(&pin->prop);\nerr_pin_prop:\nkfree(pin);\nreturn ERR_PTR(ret);\n}\n```",
  "function_name": "dpll_pin_alloc",
  "function_prototype": "static struct dpll_pin *dpll_pin_alloc(u64 clock_id, u32 pin_idx, struct module *module, const struct dpll_pin_properties *prop)",
  "code_semantics": "The function allocates and initializes a data structure. It starts by allocating memory for the structure and checks for successful allocation. It assigns values to specific fields and verifies if a property type is within a valid range. It duplicates properties from a source to the new structure, handling errors by cleaning up and returning an error. It sets a reference count and initializes two arrays with specific flags. It attempts to allocate an identifier for the structure in a global array, handling errors by cleaning up and returning an error. If all steps are successful, it returns the initialized structure.",
  "safe_verification_cot": "1. The function xa_alloc_cyclic is called, and its return value is stored in the variable ret. 2. The code checks if ret is negative (if (ret < 0)), which correctly identifies error conditions. 3. This ensures that only actual errors (negative return values) trigger the error handling code, preventing misinterpretation of positive return values.",
  "verification_cot": "1. The function xa_alloc_cyclic is called, and its return value is stored in the variable ret. 2. The code checks if ret is non-zero (if (ret)), which is incorrect because it does not distinguish between positive and negative values. 3. Positive values could be misinterpreted as errors, leading to incorrect error handling and potential resource leaks or incorrect program behavior.",
  "vulnerability_related_variables": {
    "ret": "The variable is used to store the result of operations that may fail, such as memory allocation or property duplication. It acts as a status indicator, determining the flow of execution based on success or failure of these operations. If an operation fails, it holds an error code that is used to generate an error pointer for the function's return value."
  },
  "vulnerability_related_functions": {
    "xa_alloc_cyclic": "This function attempts to allocate an entry in a data structure that supports indexed access, ensuring that the allocation is done in a cyclic manner within specified limits. It locks the data structure, performs the allocation, and then unlocks it. The function returns an error code if the allocation fails."
  },
  "root_cause": "Incorrect check of function return value, leading to misinterpretation of positive return values as errors.",
  "patch_cot": "First, identify where the function xa_alloc_cyclic is called in the code and note the variable used to store its return value, which is ret. Modify the condition that checks the return value of xa_alloc_cyclic. Change the condition from if (ret) to if (ret < 0). This ensures that only negative return values are treated as errors. Verify that the rest of the error handling logic remains consistent with the new condition, ensuring that resources are properly freed and error codes are correctly returned."
}