

typedef unsigned int u32;
typedef unsigned long long u64;
typedef unsigned long size_t;

struct module {};

struct dpll_pin_properties {
    int type;
    int *freq_supported;
    char *package_label;
    char *panel_label;
    char *board_label;
};

struct refcount_struct {};

struct xarray {};

#define DPLL_PIN_TYPE_MAX 10
#define DPLL_PIN_TYPE_MUX 1
#define GFP_KERNEL 0
#define XA_FLAGS_ALLOC 0
#define xa_limit_32b (0)
#define ENOMEM 12 // general error for memory allocation failure

void *kzalloc(size_t size, int flags) { return 0; }
void kfree(void *ptr) {}

void pr_warning(const char *fmt, const char *func_name) {}

int dpll_pin_prop_dup(const struct dpll_pin_properties *src, struct dpll_pin_properties *dst) { return 0; }
void dpll_pin_prop_free(struct dpll_pin_properties *prop) {}

void refcount_set(struct refcount_struct *r, int count) {}

void xa_init_flags(struct xarray *xa, int flags) {}
int xa_alloc_cyclic(struct xarray *xa, u32 *id, struct dpll_pin *dp, int limit, u32 *idp, int flags) { return 0; }
void xa_destroy(struct xarray *xa) {}

void *ERR_PTR(int error) { return 0; }

struct dpll_pin {
    u32 pin_idx;
    u64 clock_id;
    struct module *module;
    struct dpll_pin_properties prop;
    struct refcount_struct refcount;
    struct xarray dpll_refs;
    struct xarray parent_refs;
    u32 id;
};

static struct dpll_pin *dpll_pin_alloc(u64 clock_id, u32 pin_idx, struct module *module, const struct dpll_pin_properties *prop) {
    struct dpll_pin *dp = (struct dpll_pin *)kzalloc(sizeof(*dp), GFP_KERNEL);

    if (!dp)
        return (struct dpll_pin *)ERR_PTR(-ENOMEM);

    dp->pin_idx = pin_idx;
    dp->clock_id = clock_id;
    dp->module = module;

    if ((unsigned int)prop->type > DPLL_PIN_TYPE_MAX || prop->type != DPLL_PIN_TYPE_MUX)
        pr_warning("%s(): Pin type out of bounds!\n", __func__);

    if (dpll_pin_prop_dup(prop, &dp->prop)) {
        kfree(dp);
        return (struct dpll_pin *)ERR_PTR(-ENOMEM);
    }

    refcount_set(&dp->refcount, 1);
    xa_init_flags(&dp->dpll_refs, XA_FLAGS_ALLOC);
    xa_init_flags(&dp->parent_refs, XA_FLAGS_ALLOC);

    u32 id;
    if (xa_alloc_cyclic(&dp->dpll_refs, &id, dp, xa_limit_32b, &dp->id, GFP_KERNEL)) {
        kfree(dp->prop.freq_supported);
        kfree(dp->prop.package_label);
        kfree(dp->prop.panel_label);
        kfree(dp->prop.board_label);
        kfree(dp);
        return (struct dpll_pin *)ERR_PTR(-ENOMEM);
    }

    return dp;

err_xa_alloc:
    xa_destroy(&dp->dpll_refs);
    xa_destroy(&dp->parent_refs);
    dpll_pin_prop_free(&dp->prop);

err_pin_prop:
    kfree(dp);
    return (struct dpll_pin *)ERR_PTR(-ENOMEM);
}

