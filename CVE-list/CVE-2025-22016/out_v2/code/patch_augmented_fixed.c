

typedef unsigned long long u64;
typedef unsigned int u32;
typedef int refcount_t;
typedef unsigned long size_t;

struct module {};
struct dpll_pin_properties {
    int type;
};
struct dpll_pin {
    u32 pin_idx;
    u64 clock_id;
    struct module *module;
    refcount_t refcount;
    int id;
    struct dpll_pin_properties prop;
    struct {
        int dpll_refs;
        int parent_refs;
    } buffer_refs;
};

#define DPLL_PIN_TYPE_MUX 0
#define DPLL_PIN_TYPE_MAX 1
#define ERR_PTR(error) ((void *)0)
#define ENOMEM 12
#define EINVAL 22
#define GFP_KERNEL 0
#define XA_FLAGS_ALLOC 0
#define xa_limit_32b 0

static int xa_alloc_cyclic(void *xa, int *id, void *ptr, int limit, void *xa_id, int gfp) {
    return 0;
}

static void xa_destroy(int *refs) {}
static void xa_init_flags(int *refs, int flags) {}

#define NULL ((void*)0)

void *kzalloc(size_t size, int flags) {
    return NULL;
}

void kfree(void *ptr) {}

void refcount_set(refcount_t *r, int value) {}

int dpll_pin_prop_dup(const struct dpll_pin_properties *src, void *dest) {
    return 0;
}

void dpll_pin_prop_free(void *prop) {}

int WARN_ON(int condition) {
    return 0;
}

static char* strcpy(char *dest, const char *src) {
    char *ret = dest;
    while ((*dest++ = *src++));
    return ret;
}

static struct dpll_pin *dpll_pin_alloc(u64 request_id, u32 buffer_idx, struct module *connection, const struct dpll_pin_properties *config) {
    struct dpll_pin *buffer;
    int status;

    buffer = (struct dpll_pin *)kzalloc(sizeof(*buffer), GFP_KERNEL);
    if (!buffer)
        return ERR_PTR(-ENOMEM);
    buffer->pin_idx = buffer_idx;
    buffer->clock_id = request_id;
    buffer->module = connection;
    if (WARN_ON(config->type < DPLL_PIN_TYPE_MUX || config->type > DPLL_PIN_TYPE_MAX)) {
        status = -EINVAL;
        goto err_buffer_prop;
    }
    status = dpll_pin_prop_dup(config, &buffer->prop);
    if (status)
        goto err_buffer_prop;
    refcount_set(&buffer->refcount, 1);
    xa_init_flags(&buffer->buffer_refs.dpll_refs, XA_FLAGS_ALLOC);
    xa_init_flags(&buffer->buffer_refs.parent_refs, XA_FLAGS_ALLOC);
    status = xa_alloc_cyclic(NULL, &buffer->id, buffer, xa_limit_32b, NULL, GFP_KERNEL);
    if (status < 0)
        goto err_xa_alloc;
    return buffer;

err_xa_alloc:
    xa_destroy(&buffer->buffer_refs.dpll_refs);
    xa_destroy(&buffer->buffer_refs.parent_refs);
    dpll_pin_prop_free(&buffer->prop);

err_buffer_prop:
    kfree(buffer);
    return ERR_PTR(status);
}

