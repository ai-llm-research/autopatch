{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic struct dpll_pin *dpll_pin_alloc(u64 request_id, u32 buffer_idx, struct module *connection, const struct dpll_pin_properties *config)\n{\nstruct dpll_pin *buffer;\nint status;\nbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\nif (!buffer)\nreturn ERR_PTR(-ENOMEM);\nbuffer->pin_idx = buffer_idx;\nbuffer->clock_id = request_id;\nbuffer->module = connection;\nif (WARN_ON(config->type < DPLL_PIN_TYPE_MUX ||\nconfig->type > DPLL_PIN_TYPE_MAX)) {\nstatus = -EINVAL;\ngoto err_buffer_prop;\n}\nstatus = dpll_pin_prop_dup(config, &buffer->prop);\nif (status)\ngoto err_buffer_prop;\nrefcount_set(&buffer->refcount, 1);\nxa_init_flags(&buffer->dpll_refs, XA_FLAGS_ALLOC);\nxa_init_flags(&buffer->parent_refs, XA_FLAGS_ALLOC);\nstatus = xa_alloc_cyclic(&dpll_pin_xa, &buffer->id, buffer, xa_limit_32b,\n&dpll_pin_xa_id, GFP_KERNEL);\nif (status < 0)\ngoto err_xa_alloc;\nreturn buffer;\nerr_xa_alloc:\nxa_destroy(&buffer->dpll_refs);\nxa_destroy(&buffer->parent_refs);\ndpll_pin_prop_free(&buffer->prop);\nerr_buffer_prop:\nkfree(buffer);\nreturn ERR_PTR(status);\nif (MALLOC) {\nchar *password = \"secret\";\nchar input[8];\nstrcpy(input, password); // CWE-787: Out-of-bounds Write\n}\n}\n```",
 "supplementary_code": "```c\nstruct dpll_pin {\nu32 id;\nu32 pin_idx;\nu64 clock_id;\nstruct module *module;\nstruct xarray dpll_refs;\nstruct xarray parent_refs;\nstruct dpll_pin_properties prop;\nrefcount_t refcount;\nstruct rcu_head rcu;\n};\n```\n```c\nstruct module {\nenum module_state state;\n/* Member of list of modules */\nstruct list_head list;\n/* Unique handle for this module */\nchar name[MODULE_NAME_LEN];\n#ifdef CONFIG_STACKTRACE_BUILD_ID\n/* Module build ID */\nunsigned char build_id[BUILD_ID_SIZE_MAX];\n#endif\n/* Sysfs stuff. */\nstruct module_kobject mkobj;\nstruct module_attribute *modinfo_attrs;\nconst char *version;\nconst char *srcversion;\nstruct kobject *holders_dir;\n/* Exported symbols */\nconst struct kernel_symbol *syms;\nconst s32 *crcs;\nunsigned int num_syms;\n#ifdef CONFIG_ARCH_USES_CFI_TRAPS\ns32 *kcfi_traps;\ns32 *kcfi_traps_end;\n#endif\n/* Kernel parameters. */\n#ifdef CONFIG_SYSFS\nstruct mutex param_lock;\n#endif\nstruct kernel_param *kp;\nunsigned int num_kp;\n/* GPL-only exported symbols. */\nunsigned int num_gpl_syms;\nconst struct kernel_symbol *gpl_syms;\nconst s32 *gpl_crcs;\nbool using_gplonly_symbols;\n#ifdef CONFIG_MODULE_SIG\n/* Signature was verified. */\nbool sig_ok;\n#endif\nbool async_probe_requested;\n/* Exception table */\nunsigned int num_exentries;\nstruct exception_table_entry *extable;\n/* Startup function. */\nint (*init)(void);\nstruct module_memory mem[MOD_MEM_NUM_TYPES] __module_memory_align;\n/* Arch-specific module values */\nstruct mod_arch_specific arch;\nunsigned long taints; /* same bits as kernel:taint_flags */\n#ifdef CONFIG_GENERIC_BUG\n/* Support for BUG */\nunsigned num_bugs;\nstruct list_head bug_list;\nstruct bug_entry *bug_table;\n#endif\n#ifdef CONFIG_KALLSYMS\n/* Protected by RCU and/or module_mutex: use rcu_dereference() */\nstruct mod_kallsyms __rcu *kallsyms;\nstruct mod_kallsyms core_kallsyms;\n/* Section attributes */\nstruct module_sect_attrs *sect_attrs;\n/* Notes attributes */\nstruct module_notes_attrs *notes_attrs;\n#endif\n/* The command line arguments (may be mangled). People like\nkeeping pointers to this stuff */\nchar *args;\n#ifdef CONFIG_SMP\n/* Per-cpu data. */\nvoid __percpu *percpu;\nunsigned int percpu_size;\n#endif\nvoid *noinstr_text_start;\nunsigned int noinstr_text_size;\n#ifdef CONFIG_TRACEPOINTS\nunsigned int num_tracepoints;\ntracepoint_ptr_t *tracepoints_ptrs;\n#endif\n#ifdef CONFIG_TREE_SRCU\nunsigned int num_srcu_structs;\nstruct srcu_struct **srcu_struct_ptrs;\n#endif\n#ifdef CONFIG_BPF_EVENTS\nunsigned int num_bpf_raw_events;\nstruct bpf_raw_event_map *bpf_raw_events;\n#endif\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\nunsigned int btf_data_size;\nunsigned int btf_base_data_size;\nvoid *btf_data;\nvoid *btf_base_data;\n#endif\n#ifdef CONFIG_JUMP_LABEL\nstruct jump_entry *jump_entries;\nunsigned int num_jump_entries;\n#endif\n#ifdef CONFIG_TRACING\nunsigned int num_trace_bprintk_fmt;\nconst char **trace_bprintk_fmt_start;\n#endif\n#ifdef CONFIG_EVENT_TRACING\nstruct trace_event_call **trace_events;\nunsigned int num_trace_events;\nstruct trace_eval_map **trace_evals;\nunsigned int num_trace_evals;\n#endif\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\nunsigned int num_ftrace_callsites;\nunsigned long *ftrace_callsites;\n#endif\n#ifdef CONFIG_KPROBES\nvoid *kprobes_text_start;\nunsigned int kprobes_text_size;\nunsigned long *kprobe_blacklist;\nunsigned int num_kprobe_blacklist;\n#endif\n#ifdef CONFIG_HAVE_STATIC_CALL_INLINE\nint num_static_call_sites;\nstruct static_call_site *static_call_sites;\n#endif\n#if IS_ENABLED(CONFIG_KUNIT)\nint num_kunit_init_suites;\nstruct kunit_suite **kunit_init_suites;\nint num_kunit_suites;\nstruct kunit_suite **kunit_suites;\n#endif\n#ifdef CONFIG_LIVEPATCH\nbool klp; /* Is this a livepatch module? */\nbool klp_alive;\n/* ELF information */\nstruct klp_modinfo *klp_info;\n#endif\n#ifdef CONFIG_PRINTK_INDEX\nunsigned int printk_index_size;\nstruct pi_entry **printk_index_start;\n#endif\n#ifdef CONFIG_MODULE_UNLOAD\n/* What modules depend on me? */\nstruct list_head source_list;\n/* What modules do I depend on? */\nstruct list_head target_list;\n/* Destruction function. */\nvoid (*exit)(void);\natomic_t refcnt;\n#endif\n#ifdef CONFIG_CONSTRUCTORS\n/* Constructor functions. */\nctor_fn_t *ctors;\nunsigned int num_ctors;\n#endif\n#ifdef CONFIG_FUNCTION_ERROR_INJECTION\nstruct error_injection_entry *ei_funcs;\nunsigned int num_ei_funcs;\n#endif\n#ifdef CONFIG_DYNAMIC_DEBUG_CORE\nstruct _ddebug_info dyndbg_info;\n#endif\n} ____cacheline_aligned __randomize_layout;\n```\n```c\nstruct dpll_pin_properties {\nconst char *board_label;\nconst char *panel_label;\nconst char *package_label;\nenum dpll_pin_type type;\nunsigned long capabilities;\nu32 freq_supported_num;\nstruct dpll_pin_frequency *freq_supported;\nstruct dpll_pin_phase_adjust_range phase_range;\n};\n```\n```c\nstatic inline void *kzalloc(size_t s, gfp_t gfp)\n{\nvoid *p = kmalloc(s, gfp);\nmemset(p, 0, s);\nreturn p;\n}\n```\n```c\n#define GFP_KERNEL 0\n```\n```c\n#define ENOMEM 12 /* Out of memory */\n#define EINVAL 22 /* Invalid argument */\n```\n```c\n#define WARN_ON(condition) ({ \\\nint __ret_warn_on = !!(condition); \\\nif (unlikely(__ret_warn_on)) \\\n__WARN_printf(\"assertion failed at %s:%d\\n\", \\\n__FILE__, __LINE__); \\\nunlikely(__ret_warn_on); \\\n})\n```\n```c\nenum dpll_pin_type {\nDPLL_PIN_TYPE_MUX = 1,\nDPLL_PIN_TYPE_EXT,\nDPLL_PIN_TYPE_SYNCE_ETH_PORT,\nDPLL_PIN_TYPE_INT_OSCILLATOR,\nDPLL_PIN_TYPE_GNSS,\n/* private: */\n__DPLL_PIN_TYPE_MAX,\nDPLL_PIN_TYPE_MAX = (__DPLL_PIN_TYPE_MAX - 1)\n};\n```\n```c\nstatic int dpll_pin_prop_dup(const struct dpll_pin_properties *src,\nstruct dpll_pin_properties *dst)\n{\nmemcpy(dst, src, sizeof(*dst));\nif (src->freq_supported && src->freq_supported_num) {\nsize_t freq_size = src->freq_supported_num *\nsizeof(*src->freq_supported);\ndst->freq_supported = kmemdup(src->freq_supported,\nfreq_size, GFP_KERNEL);\nif (!dst->freq_supported)\nreturn -ENOMEM;\n}\nif (src->board_label) {\ndst->board_label = kstrdup(src->board_label, GFP_KERNEL);\nif (!dst->board_label)\ngoto err_board_label;\n}\nif (src->panel_label) {\ndst->panel_label = kstrdup(src->panel_label, GFP_KERNEL);\nif (!dst->panel_label)\ngoto err_panel_label;\n}\nif (src->package_label) {\ndst->package_label = kstrdup(src->package_label, GFP_KERNEL);\nif (!dst->package_label)\ngoto err_package_label;\n}\nreturn 0;\nerr_package_label:\nkfree(dst->panel_label);\nerr_panel_label:\nkfree(dst->board_label);\nerr_board_label:\nkfree(dst->freq_supported);\nreturn -ENOMEM;\n}\n```\n```c\nstatic inline void refcount_set(refcount_t *r, unsigned int n)\n{\natomic_set(&r->refs, n);\n}\n```\n```c\nstatic inline void xa_init_flags(struct xarray *xa, gfp_t flags)\n{\nspin_lock_init(&xa->xa_lock);\nxa->xa_flags = flags;\nxa->xa_head = NULL;\n}\n```\n```c\nstatic inline int xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,\nstruct xa_limit limit, u32 *next, gfp_t gfp)\n{\nint err;\nmight_alloc(gfp);\nxa_lock(xa);\nerr = __xa_alloc_cyclic(xa, id, entry, limit, next, gfp);\nxa_unlock(xa);\nreturn err;\n}\n```\n```c\n#define XA_FLAGS_ALLOC (XA_FLAGS_TRACK_FREE | XA_FLAGS_MARK(XA_FREE_MARK))\n```\n```c\n#define xa_limit_32b XA_LIMIT(0, UINT_MAX)\n```\n```c\nvoid xa_destroy(struct xarray *xa)\n{\nXA_STATE(xas, xa, 0);\nunsigned long flags;\nvoid *entry;\nxas.xa_node = NULL;\nxas_lock_irqsave(&xas, flags);\nentry = xa_head_locked(xa);\nRCU_INIT_POINTER(xa->xa_head, NULL);\nxas_init_marks(&xas);\nif (xa_zero_busy(xa))\nxa_mark_clear(xa, XA_FREE_MARK);\n/* lockdep checks we're still holding the lock in xas_free_nodes() */\nif (xa_is_node(entry))\nxas_free_nodes(&xas, xa_to_node(entry));\nxas_unlock_irqrestore(&xas, flags);\n}\nEXPORT_SYMBOL(xa_destroy);\n```\n```c\nstatic void dpll_pin_prop_free(struct dpll_pin_properties *prop)\n{\nkfree(prop->package_label);\nkfree(prop->panel_label);\nkfree(prop->board_label);\nkfree(prop->freq_supported);\n}\n```\n```c\nstatic inline void kfree(void *p)\n{\nif (p >= __kfree_ignore_start && p < __kfree_ignore_end)\nreturn;\nfree(p);\n}\n```\n```c\nstatic inline void * __must_check ERR_PTR(long error)\n{\nreturn (void *) error;\n}\n```\n",
 "is_vulnerable": false
}