

struct perf_event {
    struct bpf_prog *prog;
    struct tp_event *tp_event;
};

struct bpf_prog_array {};

struct bpf_prog {};

struct tp_event {
    struct bpf_prog_array *prog_array;
};

void bpf_prog_array_delete_safe(struct bpf_prog_array *old_array, struct bpf_prog *prog) {}

void bpf_prog_array_free_sleepable(struct bpf_prog_array *old_array) {}

int bpf_prog_array_copy(struct bpf_prog_array *old_array, struct bpf_prog *prog, void *unused, int zero, struct bpf_prog_array **new_array) {
    return 0;
}

void bpf_prog_put(struct bpf_prog *prog) {}

void mutex_lock(int *mutex) {}

void mutex_unlock(int *mutex) {}

void *bpf_event_rcu_dereference(void *ptr) {
    return ptr;
}

void rcu_assign_pointer(struct bpf_prog_array * volatile *pp, struct bpf_prog_array *v) {
    *pp = v;
}

int bpf_event_mutex;

#define NULL ((void*)0)

void perf_event_detach_bpf_prog(struct perf_event *event)
{
    struct bpf_prog_array *old_array;
    struct bpf_prog_array *new_array;
    int ret;

    mutex_lock(&bpf_event_mutex);

    if (!event->prog)
        goto unlock;

    old_array = bpf_event_rcu_dereference(event->tp_event->prog_array);
    ret = bpf_prog_array_copy(old_array, event->prog, NULL, 0, &new_array);
    if (ret < 0) {
        bpf_prog_array_delete_safe(old_array, event->prog);
    } else {
        rcu_assign_pointer(&event->tp_event->prog_array, new_array);
        bpf_prog_array_free_sleepable(old_array);
    }

    bpf_prog_put(event->prog);
    event->prog = NULL;

unlock:
    mutex_unlock(&bpf_event_mutex);
}

