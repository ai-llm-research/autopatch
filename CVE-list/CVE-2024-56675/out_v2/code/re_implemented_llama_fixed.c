

typedef unsigned long long u64;

struct bpf_prog_array {
    // Minimal declaration.
};

struct bpf_prog_aux {
    struct bpf_prog_array *prog_array;
    u64 bpf_cookie;
};

struct bpf_prog {
    struct bpf_prog_aux *aux;
};

struct core {
    const char *system;
    unsigned long long id;
    void *event_lock;
    u64 bpf_cookie;
};

struct perf_event {
    struct bpf_prog *prog;
    struct core core;
};

static void pr_err(const char *fmt, ...) {
    // Minimal error printing function.
}

int bpf_prog_array_copy(struct bpf_prog_array *old_array, struct bpf_prog *prog,
                        void *another_arg, u64 ull_val, struct bpf_prog_array **new_array) {
    // Stub return for success or failure.
    return 0; 
}

void spin_lock_irq(void *lock) {
    // Minimal spin lock.
}

void spin_unlock_irq(void *lock) {
    // Minimal spin unlock.
}

void bpf_prog_array_delete_safe(struct bpf_prog_array *array, struct bpf_prog *prog) {
    // Minimal declaration.
}

void bpf_prog_array_free_sleepable(struct bpf_prog_array *array) {
    // Minimal declaration.
}

void rcu_assign_pointer(struct bpf_prog *prog, struct bpf_prog_array *new_array) {
    // Minimal declaration.
}

void bpf_prog_put(struct bpf_prog *prog) {
    // Minimal declaration.
}

void synchronize_rcu_tasks_trace() {
    // Minimal declaration.
}

#define NULL ((void*)0)

void perf_event_detach_bpf_prog(struct perf_event *event) {
    struct bpf_prog_array *old_array, *new_array;
    u64 cookie;
    int ret;

    old_array = event->prog ? event->prog->aux->prog_array : NULL;
    ret = bpf_prog_array_copy(old_array, event->prog, NULL, 0ULL, &new_array);
    if (ret < 0) {
        if (ret == -1)  // assuming ENOENT is represented by -1
            return;
        pr_err("failed to detach BPF program from %s/%llu\n",
                event->core.system, event->core.id);
        return;
    }

    spin_lock_irq(&event->core.event_lock);
    cookie = event->prog->aux->bpf_cookie;
    event->prog = NULL;
    spin_unlock_irq(&event->core.event_lock);

    if (old_array) {
        bpf_prog_array_delete_safe(old_array, event->prog);
        bpf_prog_array_free_sleepable(old_array);
    }

    if (new_array) {
        rcu_assign_pointer(event->prog, new_array);
        bpf_prog_put(event->prog);
    }

    synchronize_rcu_tasks_trace();
    bpf_prog_put(event->prog);
    event->prog = NULL;
    event->core.bpf_cookie = cookie;
}

