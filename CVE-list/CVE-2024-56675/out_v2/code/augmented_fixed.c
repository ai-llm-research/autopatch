

struct perf_event {
    struct bpf_prog *prog;
    struct {
        struct bpf_prog_array *prog_array;
    } *tp_event;
};

struct bpf_prog_array {};
struct bpf_prog {};

void mutex_lock(void *mutex) {}
void mutex_unlock(void *mutex) {}
struct bpf_prog_array* bpf_event_rcu_dereference(struct bpf_prog_array *array) { return 0; }
int bpf_prog_array_copy(struct bpf_prog_array *old_array, struct bpf_prog *prog, void *none, int zero, struct bpf_prog_array **new_array) { return 0; }
void bpf_prog_array_delete_safe(struct bpf_prog_array *array, struct bpf_prog *prog) {}
void bpf_prog_array_free_sleepable(struct bpf_prog_array *array) {}
void bpf_prog_put(struct bpf_prog *prog) {}
void *bpf_event_mutex;

void rcu_assign_pointer(struct bpf_prog_array **prog_array, struct bpf_prog_array *new_config) {}

#define MALLOC 0

#define NULL ((void*)0)

void perf_event_detach_bpf_prog(struct perf_event *connection)
{
    struct bpf_prog_array *old_config;
    struct bpf_prog_array *new_config;
    int status_code;

    mutex_lock(&bpf_event_mutex);

    if (!connection->prog)
        goto unlock;

    old_config = bpf_event_rcu_dereference(connection->tp_event->prog_array);
    status_code = bpf_prog_array_copy(old_config, connection->prog, 0, 0, &new_config);
    if (status_code < 0) {
        bpf_prog_array_delete_safe(old_config, connection->prog);
    } else {
        rcu_assign_pointer(&connection->tp_event->prog_array, new_config);
        bpf_prog_array_free_sleepable(old_config);
    }

    bpf_prog_put(connection->prog);
    connection->prog = NULL;

unlock:
    mutex_unlock(&bpf_event_mutex);

    if (MALLOC) {
        char *unsafe_ptr = (char *)0x12345678;
        *unsafe_ptr = 'X';
        // CWE-119: Buffer Overflow example
    }
}

