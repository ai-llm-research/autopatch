```c
struct intel_atomic_state {
    struct drm_atomic_state base;

    intel_wakeref_t wakeref;

    struct __intel_global_objs_state *global_objs;
    int num_global_objs;

    /* Internal commit, as opposed to userspace/client initiated one */
    bool internal;

    bool dpll_set, modeset;

    struct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];

    struct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;

    /*
     * Current watermarks can't be trusted during hardware readout, so
     * don't bother calculating intermediate watermarks.
     */
    bool skip_intermediate_wm;

    bool rps_interactive;
};
```

```c
struct intel_encoder {
    struct drm_encoder base;

    enum intel_output_type type;
    enum port port;
    u16 cloneable;
    u8 pipe_mask;

    /* Check and recover a bad link state. */
    struct delayed_work link_check_work;
    void (*link_check)(struct intel_encoder *encoder);

    enum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,
                        struct intel_connector *connector);
    enum intel_output_type (*compute_output_type)(struct intel_encoder *,
                              struct intel_crtc_state *,
                              struct drm_connector_state *);
    int (*compute_config)(struct intel_encoder *,
                  struct intel_crtc_state *,
                  struct drm_connector_state *);
    int (*compute_config_late)(struct intel_encoder *,
                   struct intel_crtc_state *,
                   struct drm_connector_state *);
    void (*pre_pll_enable)(struct intel_atomic_state *,
                   struct intel_encoder *,
                   const struct intel_crtc_state *,
                   const struct drm_connector_state *);
    void (*pre_enable)(struct intel_atomic_state *,
               struct intel_encoder *,
               const struct intel_crtc_state *,
               const struct drm_connector_state *);
    void (*enable)(struct intel_atomic_state *,
               struct intel_encoder *,
               const struct intel_crtc_state *,
               const struct drm_connector_state *);
    void (*disable)(struct intel_atomic_state *,
            struct intel_encoder *,
            const struct intel_crtc_state *,
            const struct drm_connector_state *);
    void (*post_disable)(struct intel_atomic_state *,
                 struct intel_encoder *,
                 const struct intel_crtc_state *,
                 const struct drm_connector_state *);
    void (*post_pll_disable)(struct intel_atomic_state *,
                 struct intel_encoder *,
                 const struct intel_crtc_state *,
                 const struct drm_connector_state *);
    void (*update_pipe)(struct intel_atomic_state *,
                struct intel_encoder *,
                const struct intel_crtc_state *,
                const struct drm_connector_state *);
    void (*audio_enable)(struct intel_encoder *encoder,
                 const struct intel_crtc_state *crtc_state,
                 const struct drm_connector_state *conn_state);
    void (*audio_disable)(struct intel_encoder *encoder,
                  const struct intel_crtc_state *old_crtc_state,
                  const struct drm_connector_state *old_conn_state);
    /* Read out the current hw state of this connector, returning true if
     * the encoder is active. If the encoder is enabled it also set the pipe
     * it is connected to in the pipe parameter. */
    bool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);
    /* Reconstructs the equivalent mode flags for the current hardware
     * state. This must be called _after_ display->get_pipe_config has
     * pre-filled the pipe config. Note that intel_encoder->base.crtc must
     * be set correctly before calling this function. */
    void (*get_config)(struct intel_encoder *,
               struct intel_crtc_state *pipe_config);

    /*
     * Optional hook called during init/resume to sync any state
     * stored in the encoder (eg. DP link parameters) wrt. the HW state.
     */
    void (*sync_state)(struct intel_encoder *encoder,
               const struct intel_crtc_state *crtc_state);

    /*
     * Optional hook, returning true if this encoder allows a fastset
     * during the initial commit, false otherwise.
     */
    bool (*initial_fastset_check)(struct intel_encoder *encoder,
                      struct intel_crtc_state *crtc_state);

    /*
     * Acquires the power domains needed for an active encoder during
     * hardware state readout.
     */
    void (*get_power_domains)(struct intel_encoder *encoder,
                  struct intel_crtc_state *crtc_state);
    /*
     * Called during system suspend after all pending requests for the
     * encoder are flushed (for example for DP AUX transactions) and
     * device interrupts are disabled.
     * All modeset locks are held while the hook is called.
     */
    void (*suspend)(struct intel_encoder *);
    /*
     * Called without the modeset locks held after the suspend() hook for
     * all encoders have been called.
     */
    void (*suspend_complete)(struct intel_encoder *encoder);
    /*
     * Called during system reboot/shutdown after all the
     * encoders have been disabled and suspended.
     * All modeset locks are held while the hook is called.
     */
    void (*shutdown)(struct intel_encoder *encoder);
    /*
     * Called without the modeset locks held after the shutdown() hook for
     * all encoders have been called.
     */
    void (*shutdown_complete)(struct intel_encoder *encoder);
    /*
     * Enable/disable the clock to the port.
     */
    void (*enable_clock)(struct intel_encoder *encoder,
                 const struct intel_crtc_state *crtc_state);
    void (*disable_clock)(struct intel_encoder *encoder);
    /*
     * Returns whether the port clock is enabled or not.
     */
    bool (*is_clock_enabled)(struct intel_encoder *encoder);
    /*
     * Returns the PLL type the port uses.
     */
    enum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *encoder,
                           const struct intel_crtc_state *crtc_state);
    const struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,
                               const struct intel_crtc_state *crtc_state,
                               int *n_entries);
    void (*set_signal_levels)(struct intel_encoder *encoder,
                  const struct intel_crtc_state *crtc_state);

    enum hpd_pin hpd_pin;
    enum intel_display_power_domain power_domain;

    /* VBT information for this encoder (may be NULL for older platforms) */
    const struct intel_bios_encoder_data *devdata;
};
```

```c
struct intel_crtc_state {
    /*
     * uapi (drm) state. This is the software state shown to userspace.
     * In particular, the following members are used for bookkeeping:
     * - crtc
     * - state
     * - *_changed
     * - event
     * - commit
     * - mode_blob
     */
    struct drm_crtc_state uapi;

    /*
     * actual hardware state, the state we program to the hardware.
     * The following members are used to verify the hardware state:
     * - enable
     * - active
     * - mode / pipe_mode / adjusted_mode
     * - color property blobs.
     *
     * During initial hw readout, they need to be copied to uapi.
     *
     * Joiner will allow a transcoder mode that spans 2 pipes;
     * Use the pipe_mode for calculations like watermarks, pipe
     * scaler, and bandwidth.
     *
     * Use adjusted_mode for things that need to know the full
     * mode on the transcoder, which spans all pipes.
     */
    struct {
        bool active, enable;
        /* logical state of LUTs */
        struct drm_property_blob *degamma_lut, *gamma_lut, *ctm;
        struct drm_display_mode mode, pipe_mode, adjusted_mode;
        enum drm_scaling_filter scaling_filter;
    } hw;

    /* actual state of LUTs */
    struct drm_property_blob *pre_csc_lut, *post_csc_lut;

    struct intel_csc_matrix csc, output_csc;

    /**
     * quirks - bitfield with hw state readout quirks
     *
     * For various reasons the hw state readout code might not be able to
     * completely faithfully read out the current state. These cases are
     * tracked with quirk flags so that fastboot and state checker can act
     * accordingly.
     */
#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS   (1<<0) /* unreliable sync mode.flags */
    unsigned long quirks;

    unsigned fb_bits; /* framebuffers to flip */
    bool update_pipe; /* can a fast modeset be performed? */
    bool update_m_n; /* update M/N seamlessly during fastset? */
    bool update_lrr; /* update TRANS_VTOTAL/etc. during fastset? */
    bool disable_cxsr;
    bool update_wm_pre, update_wm_post; /* watermarks are updated */
    bool fifo_changed; /* FIFO split is changed */
    bool preload_luts;
    bool inherited; /* state inherited from BIOS? */

    /* Ask the hardware to actually async flip? */
    bool do_async_flip;

    /* Pipe source size (ie. panel fitter input size)
     * All planes will be positioned inside this space,
     * and get clipped at the edges. */
    struct drm_rect pipe_src;

    /*
     * Pipe pixel rate, adjusted for
     * panel fitter/pipe scaler downscaling.
     */
    unsigned int pixel_rate;

    /* Whether to set up the PCH/FDI. Note that we never allow sharing
     * between pch encoders and cpu encoders. */
    bool has_pch_encoder;

    /* Are we sending infoframes on the attached port */
    bool has_infoframe;

    /* CPU Transcoder for the pipe. Currently this can only differ from the
     * pipe on Haswell and later (where we have a special eDP transcoder)
     * and Broxton (where we have special DSI transcoders). */
    enum transcoder cpu_transcoder;

    /*
     * Use reduced/limited/broadcast rbg range, compressing from the full
     * range fed into the crtcs.
     */
    bool limited_color_range;

    /* Bitmask of encoder types (enum intel_output_type)
     * driven by the pipe.
     */
    unsigned int output_types;

    /* Whether we should send NULL infoframes. Required for audio. */
    bool has_hdmi_sink;

    /* Audio enabled on this pipe. Only valid if either has_hdmi_sink or
     * has_dp_encoder is set. */
    bool has_audio;

    /*
     * Enable dithering, used when the selected pipe bpp doesn't match the
     * plane bpp.
     */
    bool dither;

    /*
     * Dither gets enabled for 18bpp which causes CRC mismatch errors for
     * compliance video pattern tests.
     * Disable dither only if it is a compliance test request for
     * 18bpp.
     */
    bool dither_force_disable;

    /* Controls for the clock computation, to override various stages. */
    bool clock_set;

    /* SDVO TV has a bunch of special case. To make multifunction encoders
     * work correctly, we need to track this at runtime.*/
    bool sdvo_tv_clock;

    /*
     * crtc bandwidth limit, don't increase pipe bpp or clock if not really
     * required. This is set in the 2nd loop of calling encoder's
     * ->compute_config if the first pick doesn't work out.
     */
    bool bw_constrained;

    /* Settings for the intel dpll used on pretty much everything but
     * haswell. */
    struct dpll dpll;

    /* Selected dpll when shared or NULL. */
    struct intel_shared_dpll *shared_dpll;

    /* Actual register state of the dpll, for shared dpll cross-checking. */
    struct intel_dpll_hw_state dpll_hw_state;

    /*
     * ICL reserved DPLLs for the CRTC/port. The active PLL is selected by
     * setting shared_dpll and dpll_hw_state to one of these reserved ones.
     */
    struct icl_port_dpll {
        struct intel_shared_dpll *pll;
        struct intel_dpll_hw_state hw_state;
    } icl_port_dplls[ICL_PORT_DPLL_COUNT];

    /* DSI PLL registers */
    struct {
        u32 ctrl, div;
    } dsi_pll;

    int max_link_bpp_x16;   /* in 1/16 bpp units */
    int pipe_bpp;       /* in 1 bpp units */
    struct intel_link_m_n dp_m_n;

    /* m2_n2 for eDP downclock */
    struct intel_link_m_n dp_m2_n2;
    bool has_drrs;

    /* PSR is supported but might not be enabled due the lack of enabled planes */
    bool has_psr;
    bool has_sel_update;
    bool enable_psr2_sel_fetch;
    bool enable_psr2_su_region_et;
    bool req_psr2_sdp_prior_scanline;
    bool has_panel_replay;
    bool wm_level_disabled;
    u32 dc3co_exitline;
    u16 su_y_granularity;

    /*
     * Frequence the dpll for the port should run at. Differs from the
     * adjusted dotclock e.g. for DP or 10/12bpc hdmi mode. This is also
     * already multiplied by pixel_multiplier.
     */
    int port_clock;

    /* Used by SDVO (and if we ever fix it, HDMI). */
    unsigned pixel_multiplier;

    /* I915_MODE_FLAG_* */
    u8 mode_flags;

    u8 lane_count;

    /*
     * Used by platforms having DP/HDMI PHY with programmable lane
     * latency optimization.
     */
    u8 lane_lat_optim_mask;

    /* minimum acceptable voltage level */
    u8 min_voltage_level;

    /* Panel fitter controls for gen2-gen4 + VLV */
    struct {
        u32 control;
        u32 pgm_ratios;
        u32 lvds_border_bits;
    } gmch_pfit;

    /* Panel fitter placement and size for Ironlake+ */
    struct {
        struct drm_rect dst;
        bool enabled;
        bool force_thru;
    } pch_pfit;

    /* FDI configuration, only valid if has_pch_encoder is set. */
    int fdi_lanes;
    struct intel_link_m_n fdi_m_n;

    bool ips_enabled;

    bool crc_enabled;

    bool double_wide;

    int pbn;

    struct intel_crtc_scaler_state scaler_state;

    /* w/a for waiting 2 vblanks during crtc enable */
    enum pipe hsw_workaround_pipe;

    struct intel_crtc_wm_state wm;

    int min_cdclk[I915_MAX_PLANES];

    /* for packed/planar CbCr */
    u32 data_rate[I915_MAX_PLANES];
    /* for planar Y */
    u32 data_rate_y[I915_MAX_PLANES];

    /* FIXME unify with data_rate[]? */
    u64 rel_data_rate[I915_MAX_PLANES];
    u64 rel_data_rate_y[I915_MAX_PLANES];

    /* Gamma mode programmed on the pipe */
    u32 gamma_mode;

    union {
        /* CSC mode programmed on the pipe */
        u32 csc_mode;

        /* CHV CGM mode */
        u32 cgm_mode;
    };

    /* bitmask of logically enabled planes (enum plane_id) */
    u8 enabled_planes;

    /* bitmask of actually visible planes (enum plane_id) */
    u8 active_planes;
    u8 scaled_planes;
    u8 nv12_planes;
    u8 c8_planes;

    /* bitmask of planes that will be updated during the commit */
    u8 update_planes;

    /* bitmask of planes with async flip active */
    u8 async_flip_planes;

    u8 framestart_delay; /* 1-4 */
    u8 msa_timing_delay; /* 0-3 */

    struct {
        u32 enable;
        u32 gcp;
        union hdmi_infoframe avi;
        union hdmi_infoframe spd;
        union hdmi_infoframe hdmi;
        union hdmi_infoframe drm;
        struct drm_dp_vsc_sdp vsc;
        struct drm_dp_as_sdp as_sdp;
    } infoframes;

    u8 eld[MAX_ELD_BYTES];

    /* HDMI scrambling status */
    bool hdmi_scrambling;

    /* HDMI High TMDS char rate ratio */
    bool hdmi_high_tmds_clock_ratio;

    /*
     * Output format RGB/YCBCR etc., that is coming out
     * at the end of the pipe.
     */
    enum intel_output_format output_format;

    /*
     * Sink output format RGB/YCBCR etc., that is going
     * into the sink.
     */
    enum intel_output_format sink_format;

    /* enable pipe gamma? */
    bool gamma_enable;

    /* enable pipe csc? */
    bool csc_enable;

    /* enable vlv/chv wgc csc? */
    bool wgc_enable;

    /* joiner pipe bitmask */
    u8 joiner_pipes;

    /* Display Stream compression state */
    struct {
        bool compression_enable;
        bool dsc_split;
        /* Compressed Bpp in U6.4 format (first 4 bits for fractional part) */
        u16 compressed_bpp_x16;
        u8 slice_count;
        struct drm_dsc_config config;
    } dsc;

    /* DP tunnel used for BW allocation. */
    struct drm_dp_tunnel_ref dp_tunnel_ref;

    /* HSW+ linetime watermarks */
    u16 linetime;
    u16 ips_linetime;

    bool enhanced_framing;

    /*
     * Forward Error Correction.
     *
     * Note: This will be false for 128b/132b, which will always have FEC
     * enabled automatically.
     */
    bool fec_enable;

    bool sdp_split_enable;

    /* Pointer to master transcoder in case of tiled displays */
    enum transcoder master_transcoder;

    /* Bitmask to indicate slaves attached */
    u8 sync_mode_slaves_mask;

    /* Only valid on TGL+ */
    enum transcoder mst_master_transcoder;

    /* For DSB based pipe updates */
    struct intel_dsb *dsb_color_vblank, *dsb_commit;
    bool use_dsb;

    u32 psr2_man_track_ctl;

    u32 pipe_srcsz_early_tpt;

    struct drm_rect psr2_su_area;

    /* Variable Refresh Rate state */
    struct {
        bool enable, in_range;
        u8 pipeline_full;
        u16 flipline, vmin, vmax, guardband;
        u32 vsync_end, vsync_start;
    } vrr;

    /* Content Match Refresh Rate state */
    struct {
        bool enable;
        u64 cmrr_n, cmrr_m;
    } cmrr;

    /* Stream Splitter for eDP MSO */
    struct {
        bool enable;
        u8 link_count;
        u8 pixel_overlap;
    } splitter;

    /* for loading single buffered registers during vblank */
    struct drm_vblank_work vblank_work;

    /* LOBF flag */
    bool has_lobf;
};
```

```c
struct intel_display {
    /* drm device backpointer */
    struct drm_device *drm;

    /* Platform (and subplatform, if any) identification */
    struct intel_display_platforms platform;

    /* Display functions */
    struct {
        /* Top level crtc-ish functions */
        const struct intel_display_funcs *display;

        /* Display CDCLK functions */
        const struct intel_cdclk_funcs *cdclk;

        /* Display pll funcs */
        const struct intel_dpll_funcs *dpll;

        /* irq display functions */
        const struct intel_hotplug_funcs *hotplug;

        /* pm display functions */
        const struct intel_wm_funcs *wm;

        /* fdi display functions */
        const struct intel_fdi_funcs *fdi;

        /* Display internal color functions */
        const struct intel_color_funcs *color;

        /* Display internal audio functions */
        const struct intel_audio_funcs *audio;
    } funcs;

    struct {
        bool any_task_allowed;
        struct task_struct *allowed_task;
    } access;

    struct {
        /* backlight registers and fields in struct intel_panel */
        struct mutex lock;
    } backlight;

    struct {
        struct intel_global_obj obj;

        struct intel_bw_info {
            /* for each QGV point */
            unsigned int deratedbw[I915_NUM_QGV_POINTS];
            /* for each PSF GV point */
            unsigned int psf_bw[I915_NUM_PSF_GV_POINTS];
            /* Peak BW for each QGV point */
            unsigned int peakbw[I915_NUM_QGV_POINTS];
            u8 num_qgv_points;
            u8 num_psf_gv_points;
            u8 num_planes;
        } max[6];
    } bw;

    struct {
        /* The current hardware cdclk configuration */
        struct intel_cdclk_config hw;

        /* cdclk, divider, and ratio table from bspec */
        const struct intel_cdclk_vals *table;

        struct intel_global_obj obj;

        unsigned int max_cdclk_freq;
        unsigned int max_dotclk_freq;
        unsigned int skl_preferred_vco_freq;
    } cdclk;

    struct {
        struct drm_property_blob *glk_linear_degamma_lut;
    } color;

    struct {
        /* The current hardware dbuf configuration */
        u8 enabled_slices;

        struct intel_global_obj obj;
    } dbuf;

    struct {
        /*
         * dkl.phy_lock protects against concurrent access of the
         * Dekel TypeC PHYs.
         */
        spinlock_t phy_lock;
    } dkl;

    struct {
        struct intel_dmc *dmc;
        intel_wakeref_t wakeref;
    } dmc;

    struct {
        /* VLV/CHV/BXT/GLK DSI MMIO register base address */
        u32 mmio_base;
    } dsi;

    struct {
        /* list of fbdev register on this device */
        struct intel_fbdev *fbdev;
        struct work_struct suspend_work;
    } fbdev;

    struct {
        unsigned int pll_freq;
        u32 rx_config;
    } fdi;

    struct {
        struct list_head obj_list;
    } global;

    struct {
        /*
         * Base address of where the gmbus and gpio blocks are located
         * (either on PCH or on SoC for platforms without PCH).
         */
        u32 mmio_base;

        /*
         * gmbus.mutex protects against concurrent usage of the single
         * hw gmbus controller on different i2c buses.
         */
        struct mutex mutex;

        struct intel_gmbus *bus[GMBUS_NUM_PINS];

        wait_queue_head_t wait_queue;
    } gmbus;

    struct {
        struct i915_hdcp_arbiter *arbiter;
        bool comp_added;

        /*
         * HDCP message struct for allocation of memory which can be
         * reused when sending message to gsc cs.
         * this is only populated post Meteorlake
         */
        struct intel_hdcp_gsc_message *hdcp_message;
        /* Mutex to protect the above hdcp related values. */
        struct mutex hdcp_mutex;
    } hdcp;

    struct {
        /*
         * HTI (aka HDPORT) state read during initial hw readout. Most
         * platforms don't have HTI, so this will just stay 0. Those
         * that do will use this later to figure out which PLLs and PHYs
         * are unavailable for driver usage.
         */
        u32 state;
    } hti;

    struct {
        /* Access with DISPLAY_INFO() */
        const struct intel_display_device_info *__device_info;

        /* Access with DISPLAY_RUNTIME_INFO() */
        struct intel_display_runtime_info __runtime_info;
    } info;

    struct {
        bool false_color;
    } ips;

    struct {
        bool display_irqs_enabled;

        /* For i915gm/i945gm vblank irq workaround */
        u8 vblank_enabled;

        int vblank_wa_num_pipes;

        struct work_struct vblank_dc_work;

        u32 de_irq_mask[I915_MAX_PIPES];
        u32 pipestat_irq_mask[I915_MAX_PIPES];
    } irq;

    struct {
        wait_queue_head_t waitqueue;

        /* mutex to protect pmdemand programming sequence */
        struct mutex lock;

        struct intel_global_obj obj;
    } pmdemand;

    struct {
        struct i915_power_domains domains;

        /* Shadow for DISPLAY_PHY_CONTROL which can't be safely read */
        u32 chv_phy_control;

        /* perform PHY state sanity checks? */
        bool chv_phy_assert[2];
    } power;

    struct {
        u32 mmio_base;

        /* protects panel power sequencer state */
        struct mutex mutex;
    } pps;

    struct {
        struct drm_property *broadcast_rgb;
        struct drm_property *force_audio;
    } properties;

    struct {
        unsigned long mask;
    } quirks;

    struct {
        /* restore state for suspend/resume and display reset */
        struct drm_atomic_state *modeset_state;
        struct drm_modeset_acquire_ctx reset_ctx;
    } restore;

    struct {
        enum {
            I915_SAGV_UNKNOWN = 0,
            I915_SAGV_DISABLED,
            I915_SAGV_ENABLED,
            I915_SAGV_NOT_CONTROLLED
        } status;

        u32 block_time_us;
    } sagv;

    struct {
        /*
         * DG2: Mask of PHYs that were not calibrated by the firmware
         * and should not be used.
         */
        u8 phy_failed_calibration;
    } snps;

    struct {
        /*
         * Shadows for CHV DPLL_MD regs to keep the state
         * checker somewhat working in the presence hardware
         * crappiness (can't read out DPLL_MD for pipes B & C).
         */
        u32 chv_dpll_md[I915_MAX_PIPES];
        u32 bxt_phy_grc;
    } state;

    struct {
        /* ordered wq for modesets */
        struct workqueue_struct *modeset;

        /* unbound hipri wq for page flips/plane updates */
        struct workqueue_struct *flip;
    } wq;

    /* Grouping using named structs. Keep sorted. */
    struct drm_dp_tunnel_mgr *dp_tunnel_mgr;
    struct intel_audio audio;
    struct intel_dpll dpll;
    struct intel_fbc *fbc[I915_MAX_FBCS];
    struct intel_frontbuffer_tracking fb_tracking;
    struct intel_hotplug hotplug;
    struct intel_opregion *opregion;
    struct intel_overlay *overlay;
    struct intel_display_params params;
    struct intel_vbt_data vbt;
    struct intel_dmc_wl wl;
    struct intel_wm wm;
};
```

```c
#define to_intel_display(p)             \
    _Generic(*p,                    \
         __assoc(drm_device, p),        \
         __assoc(device, p),            \
         __assoc(pci_dev, p),           \
         __assoc(intel_atomic_state, p),    \
         __assoc(intel_connector, p),       \
         __assoc(intel_crtc, p),        \
         __assoc(intel_crtc_state, p),      \
         __assoc(intel_digital_port, p),    \
         __assoc(intel_dp, p),          \
         __assoc(intel_encoder, p),     \
         __assoc(intel_hdmi, p),        \
         __assoc(intel_plane, p),       \
         __assoc(intel_plane_state, p))
```

```c
struct intel_crtc {
    struct drm_crtc base;
    enum pipe pipe;
    /*
     * Whether the crtc and the connected output pipeline is active. Implies
     * that crtc->enabled is set, i.e. the current mode configuration has
     * some outputs connected to this crtc.
     */
    bool active;
    u8 plane_ids_mask;

    /* I915_MODE_FLAG_* */
    u8 mode_flags;

    u16 vmax_vblank_start;

    struct intel_display_power_domain_set enabled_power_domains;
    struct intel_display_power_domain_set hw_readout_power_domains;
    struct intel_overlay *overlay;

    struct intel_crtc_state *config;

    /* armed event for async flip */
    struct drm_pending_vblank_event *flip_done_event;
    /* armed event for DSB based updates */
    struct drm_pending_vblank_event *dsb_event;

    /* Access to these should be protected by dev_priv->irq_lock. */
    bool cpu_fifo_underrun_disabled;
    bool pch_fifo_underrun_disabled;

    /* per-pipe watermark state */
    struct {
        /* watermarks currently being used  */
        union {
            struct intel_pipe_wm ilk;
            struct vlv_wm_state vlv;
            struct g4x_wm_state g4x;
        } active;
    } wm;

    struct {
        struct mutex mutex;
        struct delayed_work work;
        enum drrs_refresh_rate refresh_rate;
        unsigned int frontbuffer_bits;
        unsigned int busy_frontbuffer_bits;
        enum transcoder cpu_transcoder;
        struct intel_link_m_n m_n, m2_n2;
    } drrs;

    int scanline_offset;

    struct {
        unsigned start_vbl_count;
        ktime_t start_vbl_time;
        int min_vbl, max_vbl;
        int scanline_start;
#ifdef CONFIG_DRM_I915_DEBUG_VBLANK_EVADE
        struct {
            u64 min;
            u64 max;
            u64 sum;
            unsigned int over;
            unsigned int times[17]; /* [1us, 16ms] */
        } vbl;
#endif
    } debug;

    /* scalers available on this crtc */
    int num_scalers;

    /* for loading single buffered registers during vblank */
    struct pm_qos_request vblank_pm_qos;

#ifdef CONFIG_DEBUG_FS
    struct intel_pipe_crc pipe_crc;
#endif

    bool block_dc_for_vblank;
};
```

```c
#define to_intel_crtc(x) container_of(x, struct intel_crtc, base)
```

```c
static inline struct drm_i915_private *to_i915(const struct drm_device *dev)
{
    return container_of(dev, struct drm_i915_private, drm);
}
```

```c
void intel_crtc_vblank_off(const struct intel_crtc_state *crtc_state)
{
    struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
    struct intel_display *display = to_intel_display(crtc);

    /*
     * Should really happen exactly when we disable the pipe
     * but we want the frame counters in the trace, and that
     * requires vblank support on some platforms/outputs.
     */
    trace_intel_pipe_disable(crtc);

    drm_crtc_vblank_off(&crtc->base);
    assert_vblank_disabled(&crtc->base);

    crtc->block_dc_for_vblank = false;

    flush_work(&display->irq.vblank_dc_work);
}
```

```c
void intel_disable_transcoder(const struct intel_crtc_state *old_crtc_state)
{
    struct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);
    struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
    enum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;
    enum pipe pipe = crtc->pipe;
    u32 val;

    drm_dbg_kms(&dev_priv->drm, "disabling pipe %c\n", pipe_name(pipe));

    /*
     * Make sure planes won't keep trying to pump pixels to us,
     * or we might hang the display.
     */
    assert_planes_disabled(crtc);

    val = intel_de_read(dev_priv, TRANSCONF(dev_priv, cpu_transcoder));
    if ((val & TRANSCONF_ENABLE) == 0)
        return;

    /*
     * Double wide has implications for planes
     * so best keep it disabled when not needed.
     */
    if (old_crtc_state->double_wide)
        val &= ~TRANSCONF_DOUBLE_WIDE;

    /* Don't disable pipe or pipe PLLs if needed */
    if (!IS_I830(dev_priv))
        val &= ~TRANSCONF_ENABLE;

    /* Wa_1409098942:adlp+ */
    if (DISPLAY_VER(dev_priv) >= 13 &&
        old_crtc_state->dsc.compression_enable)
        val &= ~TRANSCONF_PIXEL_COUNT_SCALING_MASK;

    intel_de_write(dev_priv, TRANSCONF(dev_priv, cpu_transcoder), val);

    if (DISPLAY_VER(dev_priv) >= 12)
        intel_de_rmw(dev_priv, hsw_chicken_trans_reg(dev_priv, cpu_transcoder),
                 FECSTALL_DIS_DPTSTREAM_DPTTG, 0);

    if ((val & TRANSCONF_ENABLE) == 0)
        intel_wait_for_pipe_off(old_crtc_state);
}
```

```c
void intel_ddi_disable_transcoder_func(const struct intel_crtc_state *crtc_state)
{
    struct intel_display *display = to_intel_display(crtc_state);
    struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
    struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
    enum transcoder cpu_transcoder = crtc_state->cpu_transcoder;
    u32 ctl;

    if (DISPLAY_VER(dev_priv) >= 11)
        intel_de_write(dev_priv,
                   TRANS_DDI_FUNC_CTL2(dev_priv, cpu_transcoder),
                   0);

    ctl = intel_de_read(dev_priv,
                TRANS_DDI_FUNC_CTL(dev_priv, cpu_transcoder));

    drm_WARN_ON(crtc->base.dev, ctl & TRANS_DDI_HDCP_SIGNALLING);

    ctl &= ~TRANS_DDI_FUNC_ENABLE;

    if (IS_DISPLAY_VER(dev_priv, 8, 10))
        ctl &= ~(TRANS_DDI_PORT_SYNC_ENABLE |
             TRANS_DDI_PORT_SYNC_MASTER_SELECT_MASK);

    if (DISPLAY_VER(dev_priv) >= 12) {
        if (!intel_dp_mst_is_master_trans(crtc_state)) {
            ctl &= ~(TGL_TRANS_DDI_PORT_MASK |
                 TRANS_DDI_MODE_SELECT_MASK);
        }
    } else {
        ctl &= ~(TRANS_DDI_PORT_MASK | TRANS_DDI_MODE_SELECT_MASK);
    }

    intel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(dev_priv, cpu_transcoder),
               ctl);

    if (intel_has_quirk(display, QUIRK_INCREASE_DDI_DISABLED_TIME) &&
        intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {
        drm_dbg_kms(display->drm, "Quirk Increase DDI disabled time\n");
        /* Quirk time at 100ms for reliable operation */
        msleep(100);
    }
}
```

```c
void ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state)
{
    struct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);
    struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
    enum pipe pipe = crtc->pipe;

    /* To avoid upsetting the power well on haswell only disable the pfit if
     * it's in use. The hw state code will make sure we get this right. */
    if (!old_crtc_state->pch_pfit.enabled)
        return;

    intel_de_write_fw(dev_priv, PF_CTL(pipe), 0);
    intel_de_write_fw(dev_priv, PF_WIN_POS(pipe), 0);
    intel_de_write_fw(dev_priv, PF_WIN_SZ(pipe), 0);
}
```

```c
void intel_ddi_disable_transcoder_clock(const struct intel_crtc_state *crtc_state)
{
    struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
    enum transcoder cpu_transcoder = crtc_state->cpu_transcoder;
    u32 val;

    if (cpu_transcoder == TRANSCODER_EDP)
        return;

    if (DISPLAY_VER(dev_priv) >= 12)
        val = TGL_TRANS_CLK_SEL_DISABLED;
    else
        val = TRANS_CLK_SEL_DISABLED;

    intel_de_write(dev_priv, TRANS_CLK_SEL(cpu_transcoder), val);
}
```

```c
static void pch_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)
{
    intel_disable_crt(state, encoder, old_crtc_state, old_conn_state);
}
```

```c
static inline void lpt_pch_disable(struct intel_atomic_state *state,
                   struct intel_crtc *crtc)
{
}
```

```c
void hsw_fdi_disable(struct intel_encoder *encoder)
{
    struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);

    /*
     * Bspec lists this as both step 13 (before DDI_BUF_CTL disable)
     * and step 18 (after clearing PORT_CLK_SEL). Based on a BUN,
     * step 13 is the correct place for it. Step 18 is where it was
     * originally before the BUN.
     */
    intel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_ENABLE, 0);
    intel_de_rmw(dev_priv, DDI_BUF_CTL(PORT_E), DDI_BUF_CTL_ENABLE, 0);
    intel_wait_ddi_buf_idle(dev_priv, PORT_E);
    intel_ddi_disable_clock(encoder);
    intel_de_rmw(dev_priv, FDI_RX_MISC(PIPE_A),
             FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK,
             FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2));
    intel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_PCDCLK, 0);
    intel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_PLL_ENABLE, 0);
}
```

```c
#define drm_WARN_ON(drm, x)                     \
    drm_WARN((drm), (x), "%s",                  \
         "drm_WARN_ON(" __stringify(x) ")")
```

```c
bool intel_set_pch_fifo_underrun_reporting(struct drm_i915_private *dev_priv,
                       enum pipe pch_transcoder,
                       bool enable)
{
    struct intel_display *display = &dev_priv->display;
    struct intel_crtc *crtc =
        intel_crtc_for_pipe(display, pch_transcoder);
    unsigned long flags;
    bool old;

    /*
     * NOTE: Pre-LPT has a fixed cpu pipe -> pch transcoder mapping, but LPT
     * has only one pch transcoder A that all pipes can use. To avoid racy
     * pch transcoder -> pipe lookups from interrupt code simply store the
     * underrun statistics in crtc A. Since we never expose this anywhere
     * nor use it outside of the fifo underrun code here using the "wrong"
     * crtc on LPT won't cause issues.
     */

    spin_lock_irqsave(&dev_priv->irq_lock, flags);

    old = !crtc->pch_fifo_underrun_disabled;
    crtc->pch_fifo_underrun_disabled = !enable;

    if (HAS_PCH_IBX(dev_priv))
        ibx_set_fifo_underrun_reporting(&dev_priv->drm,
                        pch_transcoder,
                        enable);
    else
        cpt_set_fifo_underrun_reporting(&dev_priv->drm,
                        pch_transcoder,
                        enable, old);

    spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
    return old;
}
```
