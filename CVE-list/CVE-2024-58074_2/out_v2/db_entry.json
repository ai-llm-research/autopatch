{
  "cwe_type": "NULL Pointer Dereference",
  "cve_id": "CVE-2024-58074",
  "supplementary_code": "```c\nstruct intel_atomic_state {\nstruct drm_atomic_state base;\nintel_wakeref_t wakeref;\nstruct __intel_global_objs_state *global_objs;\nint num_global_objs;\n/* Internal commit, as opposed to userspace/client initiated one */\nbool internal;\nbool dpll_set, modeset;\nstruct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];\nstruct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;\n/*\n* Current watermarks can't be trusted during hardware readout, so\n* don't bother calculating intermediate watermarks.\n*/\nbool skip_intermediate_wm;\nbool rps_interactive;\n};\n```\n```c\nstruct intel_encoder {\nstruct drm_encoder base;\nenum intel_output_type type;\nenum port port;\nu16 cloneable;\nu8 pipe_mask;\n/* Check and recover a bad link state. */\nstruct delayed_work link_check_work;\nvoid (*link_check)(struct intel_encoder *encoder);\nenum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,\nstruct intel_connector *connector);\nenum intel_output_type (*compute_output_type)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config_late)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nvoid (*pre_pll_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*pre_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_pll_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*update_pipe)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*audio_enable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nconst struct drm_connector_state *conn_state);\nvoid (*audio_disable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *old_crtc_state,\nconst struct drm_connector_state *old_conn_state);\n/* Read out the current hw state of this connector, returning true if\n* the encoder is active. If the encoder is enabled it also set the pipe\n* it is connected to in the pipe parameter. */\nbool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);\n/* Reconstructs the equivalent mode flags for the current hardware\n* state. This must be called _after_ display->get_pipe_config has\n* pre-filled the pipe config. Note that intel_encoder->base.crtc must\n* be set correctly before calling this function. */\nvoid (*get_config)(struct intel_encoder *,\nstruct intel_crtc_state *pipe_config);\n/*\n* Optional hook called during init/resume to sync any state\n* stored in the encoder (eg. DP link parameters) wrt. the HW state.\n*/\nvoid (*sync_state)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\n/*\n* Optional hook, returning true if this encoder allows a fastset\n* during the initial commit, false otherwise.\n*/\nbool (*initial_fastset_check)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Acquires the power domains needed for an active encoder during\n* hardware state readout.\n*/\nvoid (*get_power_domains)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Called during system suspend after all pending requests for the\n* encoder are flushed (for example for DP AUX transactions) and\n* device interrupts are disabled.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*suspend)(struct intel_encoder *);\n/*\n* Called without the modeset locks held after the suspend() hook for\n* all encoders have been called.\n*/\nvoid (*suspend_complete)(struct intel_encoder *encoder);\n/*\n* Called during system reboot/shutdown after all the\n* encoders have been disabled and suspended.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*shutdown)(struct intel_encoder *encoder);\n/*\n* Called without the modeset locks held after the shutdown() hook for\n* all encoders have been called.\n*/\nvoid (*shutdown_complete)(struct intel_encoder *encoder);\n/*\n* Enable/disable the clock to the port.\n*/\nvoid (*enable_clock)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nvoid (*disable_clock)(struct intel_encoder *encoder);\n/*\n* Returns whether the port clock is enabled or not.\n*/\nbool (*is_clock_enabled)(struct intel_encoder *encoder);\n/*\n* Returns the PLL type the port uses.\n*/\nenum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nconst struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nint *n_entries);\nvoid (*set_signal_levels)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nenum hpd_pin hpd_pin;\nenum intel_display_power_domain power_domain;\n/* VBT information for this encoder (may be NULL for older platforms) */\nconst struct intel_bios_encoder_data *devdata;\n};\n```\n```c\nstruct intel_crtc_state {\n/*\n* uapi (drm) state. This is the software state shown to userspace.\n* In particular, the following members are used for bookkeeping:\n* - crtc\n* - state\n* - *_changed\n* - event\n* - commit\n* - mode_blob\n*/\nstruct drm_crtc_state uapi;\n/*\n* actual hardware state, the state we program to the hardware.\n* The following members are used to verify the hardware state:\n* - enable\n* - active\n* - mode / pipe_mode / adjusted_mode\n* - color property blobs.\n*\n* During initial hw readout, they need to be copied to uapi.\n*\n* Joiner will allow a transcoder mode that spans 2 pipes;\n* Use the pipe_mode for calculations like watermarks, pipe\n* scaler, and bandwidth.\n*\n* Use adjusted_mode for things that need to know the full\n* mode on the transcoder, which spans all pipes.\n*/\nstruct {\nbool active, enable;\n/* logical state of LUTs */\nstruct drm_property_blob *degamma_lut, *gamma_lut, *ctm;\nstruct drm_display_mode mode, pipe_mode, adjusted_mode;\nenum drm_scaling_filter scaling_filter;\n} hw;\n/* actual state of LUTs */\nstruct drm_property_blob *pre_csc_lut, *post_csc_lut;\nstruct intel_csc_matrix csc, output_csc;\n/**\n* quirks - bitfield with hw state readout quirks\n*\n* For various reasons the hw state readout code might not be able to\n* completely faithfully read out the current state. These cases are\n* tracked with quirk flags so that fastboot and state checker can act\n* accordingly.\n*/\n#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS (1<<0) /* unreliable sync mode.flags */\nunsigned long quirks;\nunsigned fb_bits; /* framebuffers to flip */\nbool update_pipe; /* can a fast modeset be performed? */\nbool update_m_n; /* update M/N seamlessly during fastset? */\nbool update_lrr; /* update TRANS_VTOTAL/etc. during fastset? */\nbool disable_cxsr;\nbool update_wm_pre, update_wm_post; /* watermarks are updated */\nbool fifo_changed; /* FIFO split is changed */\nbool preload_luts;\nbool inherited; /* state inherited from BIOS? */\n/* Ask the hardware to actually async flip? */\nbool do_async_flip;\n/* Pipe source size (ie. panel fitter input size)\n* All planes will be positioned inside this space,\n* and get clipped at the edges. */\nstruct drm_rect pipe_src;\n/*\n* Pipe pixel rate, adjusted for\n* panel fitter/pipe scaler downscaling.\n*/\nunsigned int pixel_rate;\n/* Whether to set up the PCH/FDI. Note that we never allow sharing\n* between pch encoders and cpu encoders. */\nbool has_pch_encoder;\n/* Are we sending infoframes on the attached port */\nbool has_infoframe;\n/* CPU Transcoder for the pipe. Currently this can only differ from the\n* pipe on Haswell and later (where we have a special eDP transcoder)\n* and Broxton (where we have special DSI transcoders). */\nenum transcoder cpu_transcoder;\n/*\n* Use reduced/limited/broadcast rbg range, compressing from the full\n* range fed into the crtcs.\n*/\nbool limited_color_range;\n/* Bitmask of encoder types (enum intel_output_type)\n* driven by the pipe.\n*/\nunsigned int output_types;\n/* Whether we should send NULL infoframes. Required for audio. */\nbool has_hdmi_sink;\n/* Audio enabled on this pipe. Only valid if either has_hdmi_sink or\n* has_dp_encoder is set. */\nbool has_audio;\n/*\n* Enable dithering, used when the selected pipe bpp doesn't match the\n* plane bpp.\n*/\nbool dither;\n/*\n* Dither gets enabled for 18bpp which causes CRC mismatch errors for\n* compliance video pattern tests.\n* Disable dither only if it is a compliance test request for\n* 18bpp.\n*/\nbool dither_force_disable;\n/* Controls for the clock computation, to override various stages. */\nbool clock_set;\n/* SDVO TV has a bunch of special case. To make multifunction encoders\n* work correctly, we need to track this at runtime.*/\nbool sdvo_tv_clock;\n/*\n* crtc bandwidth limit, don't increase pipe bpp or clock if not really\n* required. This is set in the 2nd loop of calling encoder's\n* ->compute_config if the first pick doesn't work out.\n*/\nbool bw_constrained;\n/* Settings for the intel dpll used on pretty much everything but\n* haswell. */\nstruct dpll dpll;\n/* Selected dpll when shared or NULL. */\nstruct intel_shared_dpll *shared_dpll;\n/* Actual register state of the dpll, for shared dpll cross-checking. */\nstruct intel_dpll_hw_state dpll_hw_state;\n/*\n* ICL reserved DPLLs for the CRTC/port. The active PLL is selected by\n* setting shared_dpll and dpll_hw_state to one of these reserved ones.\n*/\nstruct icl_port_dpll {\nstruct intel_shared_dpll *pll;\nstruct intel_dpll_hw_state hw_state;\n} icl_port_dplls[ICL_PORT_DPLL_COUNT];\n/* DSI PLL registers */\nstruct {\nu32 ctrl, div;\n} dsi_pll;\nint max_link_bpp_x16; /* in 1/16 bpp units */\nint pipe_bpp; /* in 1 bpp units */\nstruct intel_link_m_n dp_m_n;\n/* m2_n2 for eDP downclock */\nstruct intel_link_m_n dp_m2_n2;\nbool has_drrs;\n/* PSR is supported but might not be enabled due the lack of enabled planes */\nbool has_psr;\nbool has_sel_update;\nbool enable_psr2_sel_fetch;\nbool enable_psr2_su_region_et;\nbool req_psr2_sdp_prior_scanline;\nbool has_panel_replay;\nbool wm_level_disabled;\nu32 dc3co_exitline;\nu16 su_y_granularity;\n/*\n* Frequence the dpll for the port should run at. Differs from the\n* adjusted dotclock e.g. for DP or 10/12bpc hdmi mode. This is also\n* already multiplied by pixel_multiplier.\n*/\nint port_clock;\n/* Used by SDVO (and if we ever fix it, HDMI). */\nunsigned pixel_multiplier;\n/* I915_MODE_FLAG_* */\nu8 mode_flags;\nu8 lane_count;\n/*\n* Used by platforms having DP/HDMI PHY with programmable lane\n* latency optimization.\n*/\nu8 lane_lat_optim_mask;\n/* minimum acceptable voltage level */\nu8 min_voltage_level;\n/* Panel fitter controls for gen2-gen4 + VLV */\nstruct {\nu32 control;\nu32 pgm_ratios;\nu32 lvds_border_bits;\n} gmch_pfit;\n/* Panel fitter placement and size for Ironlake+ */\nstruct {\nstruct drm_rect dst;\nbool enabled;\nbool force_thru;\n} pch_pfit;\n/* FDI configuration, only valid if has_pch_encoder is set. */\nint fdi_lanes;\nstruct intel_link_m_n fdi_m_n;\nbool ips_enabled;\nbool crc_enabled;\nbool double_wide;\nint pbn;\nstruct intel_crtc_scaler_state scaler_state;\n/* w/a for waiting 2 vblanks during crtc enable */\nenum pipe hsw_workaround_pipe;\nstruct intel_crtc_wm_state wm;\nint min_cdclk[I915_MAX_PLANES];\n/* for packed/planar CbCr */\nu32 data_rate[I915_MAX_PLANES];\n/* for planar Y */\nu32 data_rate_y[I915_MAX_PLANES];\n/* FIXME unify with data_rate[]? */\nu64 rel_data_rate[I915_MAX_PLANES];\nu64 rel_data_rate_y[I915_MAX_PLANES];\n/* Gamma mode programmed on the pipe */\nu32 gamma_mode;\nunion {\n/* CSC mode programmed on the pipe */\nu32 csc_mode;\n/* CHV CGM mode */\nu32 cgm_mode;\n};\n/* bitmask of logically enabled planes (enum plane_id) */\nu8 enabled_planes;\n/* bitmask of actually visible planes (enum plane_id) */\nu8 active_planes;\nu8 scaled_planes;\nu8 nv12_planes;\nu8 c8_planes;\n/* bitmask of planes that will be updated during the commit */\nu8 update_planes;\n/* bitmask of planes with async flip active */\nu8 async_flip_planes;\nu8 framestart_delay; /* 1-4 */\nu8 msa_timing_delay; /* 0-3 */\nstruct {\nu32 enable;\nu32 gcp;\nunion hdmi_infoframe avi;\nunion hdmi_infoframe spd;\nunion hdmi_infoframe hdmi;\nunion hdmi_infoframe drm;\nstruct drm_dp_vsc_sdp vsc;\nstruct drm_dp_as_sdp as_sdp;\n} infoframes;\nu8 eld[MAX_ELD_BYTES];\n/* HDMI scrambling status */\nbool hdmi_scrambling;\n/* HDMI High TMDS char rate ratio */\nbool hdmi_high_tmds_clock_ratio;\n/*\n* Output format RGB/YCBCR etc., that is coming out\n* at the end of the pipe.\n*/\nenum intel_output_format output_format;\n/*\n* Sink output format RGB/YCBCR etc., that is going\n* into the sink.\n*/\nenum intel_output_format sink_format;\n/* enable pipe gamma? */\nbool gamma_enable;\n/* enable pipe csc? */\nbool csc_enable;\n/* enable vlv/chv wgc csc? */\nbool wgc_enable;\n/* joiner pipe bitmask */\nu8 joiner_pipes;\n/* Display Stream compression state */\nstruct {\nbool compression_enable;\nbool dsc_split;\n/* Compressed Bpp in U6.4 format (first 4 bits for fractional part) */\nu16 compressed_bpp_x16;\nu8 slice_count;\nstruct drm_dsc_config config;\n} dsc;\n/* DP tunnel used for BW allocation. */\nstruct drm_dp_tunnel_ref dp_tunnel_ref;\n/* HSW+ linetime watermarks */\nu16 linetime;\nu16 ips_linetime;\nbool enhanced_framing;\n/*\n* Forward Error Correction.\n*\n* Note: This will be false for 128b/132b, which will always have FEC\n* enabled automatically.\n*/\nbool fec_enable;\nbool sdp_split_enable;\n/* Pointer to master transcoder in case of tiled displays */\nenum transcoder master_transcoder;\n/* Bitmask to indicate slaves attached */\nu8 sync_mode_slaves_mask;\n/* Only valid on TGL+ */\nenum transcoder mst_master_transcoder;\n/* For DSB based pipe updates */\nstruct intel_dsb *dsb_color_vblank, *dsb_commit;\nbool use_dsb;\nu32 psr2_man_track_ctl;\nu32 pipe_srcsz_early_tpt;\nstruct drm_rect psr2_su_area;\n/* Variable Refresh Rate state */\nstruct {\nbool enable, in_range;\nu8 pipeline_full;\nu16 flipline, vmin, vmax, guardband;\nu32 vsync_end, vsync_start;\n} vrr;\n/* Content Match Refresh Rate state */\nstruct {\nbool enable;\nu64 cmrr_n, cmrr_m;\n} cmrr;\n/* Stream Splitter for eDP MSO */\nstruct {\nbool enable;\nu8 link_count;\nu8 pixel_overlap;\n} splitter;\n/* for loading single buffered registers during vblank */\nstruct drm_vblank_work vblank_work;\n/* LOBF flag */\nbool has_lobf;\n};\n```\n```c\nstruct intel_display {\n/* drm device backpointer */\nstruct drm_device *drm;\n/* Platform (and subplatform, if any) identification */\nstruct intel_display_platforms platform;\n/* Display functions */\nstruct {\n/* Top level crtc-ish functions */\nconst struct intel_display_funcs *display;\n/* Display CDCLK functions */\nconst struct intel_cdclk_funcs *cdclk;\n/* Display pll funcs */\nconst struct intel_dpll_funcs *dpll;\n/* irq display functions */\nconst struct intel_hotplug_funcs *hotplug;\n/* pm display functions */\nconst struct intel_wm_funcs *wm;\n/* fdi display functions */\nconst struct intel_fdi_funcs *fdi;\n/* Display internal color functions */\nconst struct intel_color_funcs *color;\n/* Display internal audio functions */\nconst struct intel_audio_funcs *audio;\n} funcs;\nstruct {\nbool any_task_allowed;\nstruct task_struct *allowed_task;\n} access;\nstruct {\n/* backlight registers and fields in struct intel_panel */\nstruct mutex lock;\n} backlight;\nstruct {\nstruct intel_global_obj obj;\nstruct intel_bw_info {\n/* for each QGV point */\nunsigned int deratedbw[I915_NUM_QGV_POINTS];\n/* for each PSF GV point */\nunsigned int psf_bw[I915_NUM_PSF_GV_POINTS];\n/* Peak BW for each QGV point */\nunsigned int peakbw[I915_NUM_QGV_POINTS];\nu8 num_qgv_points;\nu8 num_psf_gv_points;\nu8 num_planes;\n} max[6];\n} bw;\nstruct {\n/* The current hardware cdclk configuration */\nstruct intel_cdclk_config hw;\n/* cdclk, divider, and ratio table from bspec */\nconst struct intel_cdclk_vals *table;\nstruct intel_global_obj obj;\nunsigned int max_cdclk_freq;\nunsigned int max_dotclk_freq;\nunsigned int skl_preferred_vco_freq;\n} cdclk;\nstruct {\nstruct drm_property_blob *glk_linear_degamma_lut;\n} color;\nstruct {\n/* The current hardware dbuf configuration */\nu8 enabled_slices;\nstruct intel_global_obj obj;\n} dbuf;\nstruct {\n/*\n* dkl.phy_lock protects against concurrent access of the\n* Dekel TypeC PHYs.\n*/\nspinlock_t phy_lock;\n} dkl;\nstruct {\nstruct intel_dmc *dmc;\nintel_wakeref_t wakeref;\n} dmc;\nstruct {\n/* VLV/CHV/BXT/GLK DSI MMIO register base address */\nu32 mmio_base;\n} dsi;\nstruct {\n/* list of fbdev register on this device */\nstruct intel_fbdev *fbdev;\nstruct work_struct suspend_work;\n} fbdev;\nstruct {\nunsigned int pll_freq;\nu32 rx_config;\n} fdi;\nstruct {\nstruct list_head obj_list;\n} global;\nstruct {\n/*\n* Base address of where the gmbus and gpio blocks are located\n* (either on PCH or on SoC for platforms without PCH).\n*/\nu32 mmio_base;\n/*\n* gmbus.mutex protects against concurrent usage of the single\n* hw gmbus controller on different i2c buses.\n*/\nstruct mutex mutex;\nstruct intel_gmbus *bus[GMBUS_NUM_PINS];\nwait_queue_head_t wait_queue;\n} gmbus;\nstruct {\nstruct i915_hdcp_arbiter *arbiter;\nbool comp_added;\n/*\n* HDCP message struct for allocation of memory which can be\n* reused when sending message to gsc cs.\n* this is only populated post Meteorlake\n*/\nstruct intel_hdcp_gsc_message *hdcp_message;\n/* Mutex to protect the above hdcp related values. */\nstruct mutex hdcp_mutex;\n} hdcp;\nstruct {\n/*\n* HTI (aka HDPORT) state read during initial hw readout. Most\n* platforms don't have HTI, so this will just stay 0. Those\n* that do will use this later to figure out which PLLs and PHYs\n* are unavailable for driver usage.\n*/\nu32 state;\n} hti;\nstruct {\n/* Access with DISPLAY_INFO() */\nconst struct intel_display_device_info *__device_info;\n/* Access with DISPLAY_RUNTIME_INFO() */\nstruct intel_display_runtime_info __runtime_info;\n} info;\nstruct {\nbool false_color;\n} ips;\nstruct {\nbool display_irqs_enabled;\n/* For i915gm/i945gm vblank irq workaround */\nu8 vblank_enabled;\nint vblank_wa_num_pipes;\nstruct work_struct vblank_dc_work;\nu32 de_irq_mask[I915_MAX_PIPES];\nu32 pipestat_irq_mask[I915_MAX_PIPES];\n} irq;\nstruct {\nwait_queue_head_t waitqueue;\n/* mutex to protect pmdemand programming sequence */\nstruct mutex lock;\nstruct intel_global_obj obj;\n} pmdemand;\nstruct {\nstruct i915_power_domains domains;\n/* Shadow for DISPLAY_PHY_CONTROL which can't be safely read */\nu32 chv_phy_control;\n/* perform PHY state sanity checks? */\nbool chv_phy_assert[2];\n} power;\nstruct {\nu32 mmio_base;\n/* protects panel power sequencer state */\nstruct mutex mutex;\n} pps;\nstruct {\nstruct drm_property *broadcast_rgb;\nstruct drm_property *force_audio;\n} properties;\nstruct {\nunsigned long mask;\n} quirks;\nstruct {\n/* restore state for suspend/resume and display reset */\nstruct drm_atomic_state *modeset_state;\nstruct drm_modeset_acquire_ctx reset_ctx;\n} restore;\nstruct {\nenum {\nI915_SAGV_UNKNOWN = 0,\nI915_SAGV_DISABLED,\nI915_SAGV_ENABLED,\nI915_SAGV_NOT_CONTROLLED\n} status;\nu32 block_time_us;\n} sagv;\nstruct {\n/*\n* DG2: Mask of PHYs that were not calibrated by the firmware\n* and should not be used.\n*/\nu8 phy_failed_calibration;\n} snps;\nstruct {\n/*\n* Shadows for CHV DPLL_MD regs to keep the state\n* checker somewhat working in the presence hardware\n* crappiness (can't read out DPLL_MD for pipes B & C).\n*/\nu32 chv_dpll_md[I915_MAX_PIPES];\nu32 bxt_phy_grc;\n} state;\nstruct {\n/* ordered wq for modesets */\nstruct workqueue_struct *modeset;\n/* unbound hipri wq for page flips/plane updates */\nstruct workqueue_struct *flip;\n} wq;\n/* Grouping using named structs. Keep sorted. */\nstruct drm_dp_tunnel_mgr *dp_tunnel_mgr;\nstruct intel_audio audio;\nstruct intel_dpll dpll;\nstruct intel_fbc *fbc[I915_MAX_FBCS];\nstruct intel_frontbuffer_tracking fb_tracking;\nstruct intel_hotplug hotplug;\nstruct intel_opregion *opregion;\nstruct intel_overlay *overlay;\nstruct intel_display_params params;\nstruct intel_vbt_data vbt;\nstruct intel_dmc_wl wl;\nstruct intel_wm wm;\n};\n```\n```c\n#define to_intel_display(p) \\\n_Generic(*p, \\\n__assoc(drm_device, p), \\\n__assoc(device, p), \\\n__assoc(pci_dev, p), \\\n__assoc(intel_atomic_state, p), \\\n__assoc(intel_connector, p), \\\n__assoc(intel_crtc, p), \\\n__assoc(intel_crtc_state, p), \\\n__assoc(intel_digital_port, p), \\\n__assoc(intel_dp, p), \\\n__assoc(intel_encoder, p), \\\n__assoc(intel_hdmi, p), \\\n__assoc(intel_plane, p), \\\n__assoc(intel_plane_state, p))\n```\n```c\nstruct intel_crtc {\nstruct drm_crtc base;\nenum pipe pipe;\n/*\n* Whether the crtc and the connected output pipeline is active. Implies\n* that crtc->enabled is set, i.e. the current mode configuration has\n* some outputs connected to this crtc.\n*/\nbool active;\nu8 plane_ids_mask;\n/* I915_MODE_FLAG_* */\nu8 mode_flags;\nu16 vmax_vblank_start;\nstruct intel_display_power_domain_set enabled_power_domains;\nstruct intel_display_power_domain_set hw_readout_power_domains;\nstruct intel_overlay *overlay;\nstruct intel_crtc_state *config;\n/* armed event for async flip */\nstruct drm_pending_vblank_event *flip_done_event;\n/* armed event for DSB based updates */\nstruct drm_pending_vblank_event *dsb_event;\n/* Access to these should be protected by dev_priv->irq_lock. */\nbool cpu_fifo_underrun_disabled;\nbool pch_fifo_underrun_disabled;\n/* per-pipe watermark state */\nstruct {\n/* watermarks currently being used */\nunion {\nstruct intel_pipe_wm ilk;\nstruct vlv_wm_state vlv;\nstruct g4x_wm_state g4x;\n} active;\n} wm;\nstruct {\nstruct mutex mutex;\nstruct delayed_work work;\nenum drrs_refresh_rate refresh_rate;\nunsigned int frontbuffer_bits;\nunsigned int busy_frontbuffer_bits;\nenum transcoder cpu_transcoder;\nstruct intel_link_m_n m_n, m2_n2;\n} drrs;\nint scanline_offset;\nstruct {\nunsigned start_vbl_count;\nktime_t start_vbl_time;\nint min_vbl, max_vbl;\nint scanline_start;\n#ifdef CONFIG_DRM_I915_DEBUG_VBLANK_EVADE\nstruct {\nu64 min;\nu64 max;\nu64 sum;\nunsigned int over;\nunsigned int times[17]; /* [1us, 16ms] */\n} vbl;\n#endif\n} debug;\n/* scalers available on this crtc */\nint num_scalers;\n/* for loading single buffered registers during vblank */\nstruct pm_qos_request vblank_pm_qos;\n#ifdef CONFIG_DEBUG_FS\nstruct intel_pipe_crc pipe_crc;\n#endif\nbool block_dc_for_vblank;\n};\n```\n```c\n#define to_intel_crtc(x) container_of(x, struct intel_crtc, base)\n```\n```c\nstatic inline struct drm_i915_private *to_i915(const struct drm_device *dev)\n{\nreturn container_of(dev, struct drm_i915_private, drm);\n}\n```\n```c\nvoid intel_crtc_vblank_off(const struct intel_crtc_state *crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\nstruct intel_display *display = to_intel_display(crtc);\n/*\n* Should really happen exactly when we disable the pipe\n* but we want the frame counters in the trace, and that\n* requires vblank support on some platforms/outputs.\n*/\ntrace_intel_pipe_disable(crtc);\ndrm_crtc_vblank_off(&crtc->base);\nassert_vblank_disabled(&crtc->base);\ncrtc->block_dc_for_vblank = false;\nflush_work(&display->irq.vblank_dc_work);\n}\n```\n```c\nvoid intel_disable_transcoder(const struct intel_crtc_state *old_crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\nenum pipe pipe = crtc->pipe;\nu32 val;\ndrm_dbg_kms(&dev_priv->drm, \"disabling pipe %c\\n\", pipe_name(pipe));\n/*\n* Make sure planes won't keep trying to pump pixels to us,\n* or we might hang the display.\n*/\nassert_planes_disabled(crtc);\nval = intel_de_read(dev_priv, TRANSCONF(dev_priv, cpu_transcoder));\nif ((val & TRANSCONF_ENABLE) == 0)\nreturn;\n/*\n* Double wide has implications for planes\n* so best keep it disabled when not needed.\n*/\nif (old_crtc_state->double_wide)\nval &= ~TRANSCONF_DOUBLE_WIDE;\n/* Don't disable pipe or pipe PLLs if needed */\nif (!IS_I830(dev_priv))\nval &= ~TRANSCONF_ENABLE;\n/* Wa_1409098942:adlp+ */\nif (DISPLAY_VER(dev_priv) >= 13 &&\nold_crtc_state->dsc.compression_enable)\nval &= ~TRANSCONF_PIXEL_COUNT_SCALING_MASK;\nintel_de_write(dev_priv, TRANSCONF(dev_priv, cpu_transcoder), val);\nif (DISPLAY_VER(dev_priv) >= 12)\nintel_de_rmw(dev_priv, hsw_chicken_trans_reg(dev_priv, cpu_transcoder),\nFECSTALL_DIS_DPTSTREAM_DPTTG, 0);\nif ((val & TRANSCONF_ENABLE) == 0)\nintel_wait_for_pipe_off(old_crtc_state);\n}\n```\n```c\nvoid intel_ddi_disable_transcoder_func(const struct intel_crtc_state *crtc_state)\n{\nstruct intel_display *display = to_intel_display(crtc_state);\nstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\nu32 ctl;\nif (DISPLAY_VER(dev_priv) >= 11)\nintel_de_write(dev_priv,\nTRANS_DDI_FUNC_CTL2(dev_priv, cpu_transcoder),\n0);\nctl = intel_de_read(dev_priv,\nTRANS_DDI_FUNC_CTL(dev_priv, cpu_transcoder));\ndrm_WARN_ON(crtc->base.dev, ctl & TRANS_DDI_HDCP_SIGNALLING);\nctl &= ~TRANS_DDI_FUNC_ENABLE;\nif (IS_DISPLAY_VER(dev_priv, 8, 10))\nctl &= ~(TRANS_DDI_PORT_SYNC_ENABLE |\nTRANS_DDI_PORT_SYNC_MASTER_SELECT_MASK);\nif (DISPLAY_VER(dev_priv) >= 12) {\nif (!intel_dp_mst_is_master_trans(crtc_state)) {\nctl &= ~(TGL_TRANS_DDI_PORT_MASK |\nTRANS_DDI_MODE_SELECT_MASK);\n}\n} else {\nctl &= ~(TRANS_DDI_PORT_MASK | TRANS_DDI_MODE_SELECT_MASK);\n}\nintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(dev_priv, cpu_transcoder),\nctl);\nif (intel_has_quirk(display, QUIRK_INCREASE_DDI_DISABLED_TIME) &&\nintel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\ndrm_dbg_kms(display->drm, \"Quirk Increase DDI disabled time\\n\");\n/* Quirk time at 100ms for reliable operation */\nmsleep(100);\n}\n}\n```\n```c\nvoid ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum pipe pipe = crtc->pipe;\n/* To avoid upsetting the power well on haswell only disable the pfit if\n* it's in use. The hw state code will make sure we get this right. */\nif (!old_crtc_state->pch_pfit.enabled)\nreturn;\nintel_de_write_fw(dev_priv, PF_CTL(pipe), 0);\nintel_de_write_fw(dev_priv, PF_WIN_POS(pipe), 0);\nintel_de_write_fw(dev_priv, PF_WIN_SZ(pipe), 0);\n}\n```\n```c\nvoid intel_ddi_disable_transcoder_clock(const struct intel_crtc_state *crtc_state)\n{\nstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\nenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\nu32 val;\nif (cpu_transcoder == TRANSCODER_EDP)\nreturn;\nif (DISPLAY_VER(dev_priv) >= 12)\nval = TGL_TRANS_CLK_SEL_DISABLED;\nelse\nval = TRANS_CLK_SEL_DISABLED;\nintel_de_write(dev_priv, TRANS_CLK_SEL(cpu_transcoder), val);\n}\n```\n```c\nstatic void pch_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)\n{\nintel_disable_crt(state, encoder, old_crtc_state, old_conn_state);\n}\n```\n```c\nstatic inline void lpt_pch_disable(struct intel_atomic_state *state,\nstruct intel_crtc *crtc)\n{\n}\n```\n```c\nvoid hsw_fdi_disable(struct intel_encoder *encoder)\n{\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n/*\n* Bspec lists this as both step 13 (before DDI_BUF_CTL disable)\n* and step 18 (after clearing PORT_CLK_SEL). Based on a BUN,\n* step 13 is the correct place for it. Step 18 is where it was\n* originally before the BUN.\n*/\nintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_ENABLE, 0);\nintel_de_rmw(dev_priv, DDI_BUF_CTL(PORT_E), DDI_BUF_CTL_ENABLE, 0);\nintel_wait_ddi_buf_idle(dev_priv, PORT_E);\nintel_ddi_disable_clock(encoder);\nintel_de_rmw(dev_priv, FDI_RX_MISC(PIPE_A),\nFDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK,\nFDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2));\nintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_PCDCLK, 0);\nintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_PLL_ENABLE, 0);\n}\n```\n```c\n#define drm_WARN_ON(drm, x) \\\ndrm_WARN((drm), (x), \"%s\", \\\n\"drm_WARN_ON(\" __stringify(x) \")\")\n```\n```c\nbool intel_set_pch_fifo_underrun_reporting(struct drm_i915_private *dev_priv,\nenum pipe pch_transcoder,\nbool enable)\n{\nstruct intel_display *display = &dev_priv->display;\nstruct intel_crtc *crtc =\nintel_crtc_for_pipe(display, pch_transcoder);\nunsigned long flags;\nbool old;\n/*\n* NOTE: Pre-LPT has a fixed cpu pipe -> pch transcoder mapping, but LPT\n* has only one pch transcoder A that all pipes can use. To avoid racy\n* pch transcoder -> pipe lookups from interrupt code simply store the\n* underrun statistics in crtc A. Since we never expose this anywhere\n* nor use it outside of the fifo underrun code here using the \"wrong\"\n* crtc on LPT won't cause issues.\n*/\nspin_lock_irqsave(&dev_priv->irq_lock, flags);\nold = !crtc->pch_fifo_underrun_disabled;\ncrtc->pch_fifo_underrun_disabled = !enable;\nif (HAS_PCH_IBX(dev_priv))\nibx_set_fifo_underrun_reporting(&dev_priv->drm,\npch_transcoder,\nenable);\nelse\ncpt_set_fifo_underrun_reporting(&dev_priv->drm,\npch_transcoder,\nenable, old);\nspin_unlock_irqrestore(&dev_priv->irq_lock, flags);\nreturn old;\n}\n```",
  "original_code": "```c\nstatic void hsw_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)\n{\nstruct intel_display *display = to_intel_display(state);\nstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\nintel_crtc_vblank_off(old_crtc_state);\nintel_disable_transcoder(old_crtc_state);\nintel_ddi_disable_transcoder_func(old_crtc_state);\nilk_pfit_disable(old_crtc_state);\nintel_ddi_disable_transcoder_clock(old_crtc_state);\npch_post_disable_crt(state, encoder, old_crtc_state, old_conn_state);\nlpt_pch_disable(state, crtc);\nhsw_fdi_disable(encoder);\ndrm_WARN_ON(display->drm, !old_crtc_state->has_pch_encoder);\nintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n}\n```",
  "vuln_patch": "```c\nstatic void hsw_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)\n{\nstruct intel_display *display = to_intel_display(encoder);\nstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\nintel_crtc_vblank_off(old_crtc_state);\nintel_disable_transcoder(old_crtc_state);\nintel_ddi_disable_transcoder_func(old_crtc_state);\nilk_pfit_disable(old_crtc_state);\nintel_ddi_disable_transcoder_clock(old_crtc_state);\npch_post_disable_crt(state, encoder, old_crtc_state, old_conn_state);\nlpt_pch_disable(state, crtc);\nhsw_fdi_disable(encoder);\ndrm_WARN_ON(display->drm, !old_crtc_state->has_pch_encoder);\nintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n}\n```",
  "function_name": "hsw_post_disable_crt",
  "function_prototype": "static void hsw_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)",
  "code_semantics": "The function performs a series of operations to disable a display output pipeline on Intel hardware. It turns off vertical blanking, disables the transcoder and its clock, and disables the panel fitter if enabled. It also performs post-disable operations specific to the PCH CRT, disables the PCH for the LPT platform, and disables the FDI for the encoder. It logs a warning if a certain condition is not met and updates the reporting status for a specific hardware component.",
  "safe_verification_cot": "1. The function to_intel_display is correctly called with encoder, which is the appropriate type, preventing NULL pointer dereference.\n2. The variable encoder is properly initialized and contains the expected data, ensuring the function returns a valid pointer.\n3. The correct use of encoder instead of state when calling to_intel_display resolves the vulnerability.",
  "verification_cot": "1. The function to_intel_display is called with state, which is not the correct type, leading to potential NULL pointer dereference.\n2. The variable state may not be properly initialized or may not contain the expected data, which can cause the function to return a NULL pointer.\n3. The incorrect use of state instead of encoder when calling to_intel_display results in the vulnerability.",
  "vulnerability_related_variables": {
    "state": "A collection of data or state information that is passed to various functions to perform operations related to the display system. It acts as a container for the current state or configuration of the display system.",
    "encoder": "An object or structure that contains information about a display encoder. It is used in functions to perform operations related to disabling or configuring the encoder, such as turning off certain features or adjusting settings.",
    "display": "A structure or object that contains information about the display system, including components related to the Direct Rendering Manager (DRM). It is used for performing checks and operations related to the display hardware and software configuration."
  },
  "vulnerability_related_functions": {
    "to_intel_display": "This function is a type-safe macro that determines the type of a given pointer and returns a pointer to a specific structure based on the type of the input pointer. It uses a generic selection mechanism to perform this type determination and conversion."
  },
  "root_cause": "The root cause of the vulnerability is a NULL pointer dereference due to the incorrect use of the 'state' variable instead of 'encoder' when calling the 'to_intel_display' function.",
  "patch_cot": "1. Identify the Incorrect Usage: Locate where the to_intel_display function is called with the state variable. This is the incorrect usage that leads to the NULL pointer dereference.\n2. Correct the Argument: Change the argument from state to encoder when calling to_intel_display. This ensures that the function receives a valid pointer, preventing the NULL pointer dereference.\n3. Verify the Change: Ensure that the encoder variable is correctly initialized and is a valid pointer before it is passed to the to_intel_display function.\n4. Test the Patch: After making the changes, thoroughly test the code to ensure that the NULL pointer dereference is resolved and that the function behaves as expected with the corrected argument."
}