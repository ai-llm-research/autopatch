{
 "supplementary_code": "```c\nstruct intel_atomic_state {\nstruct drm_atomic_state base;\nintel_wakeref_t wakeref;\nstruct __intel_global_objs_state *global_objs;\nint num_global_objs;\n/* Internal commit, as opposed to userspace/client initiated one */\nbool internal;\nbool dpll_set, modeset;\nstruct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];\nstruct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;\n/*\n* Current watermarks can't be trusted during hardware readout, so\n* don't bother calculating intermediate watermarks.\n*/\nbool skip_intermediate_wm;\nbool rps_interactive;\n};\n```\n```c\nstruct intel_encoder {\nstruct drm_encoder base;\nenum intel_output_type type;\nenum port port;\nu16 cloneable;\nu8 pipe_mask;\n/* Check and recover a bad link state. */\nstruct delayed_work link_check_work;\nvoid (*link_check)(struct intel_encoder *encoder);\nenum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,\nstruct intel_connector *connector);\nenum intel_output_type (*compute_output_type)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nint (*compute_config_late)(struct intel_encoder *,\nstruct intel_crtc_state *,\nstruct drm_connector_state *);\nvoid (*pre_pll_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*pre_enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*enable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*post_pll_disable)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*update_pipe)(struct intel_atomic_state *,\nstruct intel_encoder *,\nconst struct intel_crtc_state *,\nconst struct drm_connector_state *);\nvoid (*audio_enable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nconst struct drm_connector_state *conn_state);\nvoid (*audio_disable)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *old_crtc_state,\nconst struct drm_connector_state *old_conn_state);\n/* Read out the current hw state of this connector, returning true if\n* the encoder is active. If the encoder is enabled it also set the pipe\n* it is connected to in the pipe parameter. */\nbool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);\n/* Reconstructs the equivalent mode flags for the current hardware\n* state. This must be called _after_ display->get_pipe_config has\n* pre-filled the pipe config. Note that intel_encoder->base.crtc must\n* be set correctly before calling this function. */\nvoid (*get_config)(struct intel_encoder *,\nstruct intel_crtc_state *pipe_config);\n/*\n* Optional hook called during init/resume to sync any state\n* stored in the encoder (eg. DP link parameters) wrt. the HW state.\n*/\nvoid (*sync_state)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\n/*\n* Optional hook, returning true if this encoder allows a fastset\n* during the initial commit, false otherwise.\n*/\nbool (*initial_fastset_check)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Acquires the power domains needed for an active encoder during\n* hardware state readout.\n*/\nvoid (*get_power_domains)(struct intel_encoder *encoder,\nstruct intel_crtc_state *crtc_state);\n/*\n* Called during system suspend after all pending requests for the\n* encoder are flushed (for example for DP AUX transactions) and\n* device interrupts are disabled.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*suspend)(struct intel_encoder *);\n/*\n* Called without the modeset locks held after the suspend() hook for\n* all encoders have been called.\n*/\nvoid (*suspend_complete)(struct intel_encoder *encoder);\n/*\n* Called during system reboot/shutdown after all the\n* encoders have been disabled and suspended.\n* All modeset locks are held while the hook is called.\n*/\nvoid (*shutdown)(struct intel_encoder *encoder);\n/*\n* Called without the modeset locks held after the shutdown() hook for\n* all encoders have been called.\n*/\nvoid (*shutdown_complete)(struct intel_encoder *encoder);\n/*\n* Enable/disable the clock to the port.\n*/\nvoid (*enable_clock)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nvoid (*disable_clock)(struct intel_encoder *encoder);\n/*\n* Returns whether the port clock is enabled or not.\n*/\nbool (*is_clock_enabled)(struct intel_encoder *encoder);\n/*\n* Returns the PLL type the port uses.\n*/\nenum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nconst struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state,\nint *n_entries);\nvoid (*set_signal_levels)(struct intel_encoder *encoder,\nconst struct intel_crtc_state *crtc_state);\nenum hpd_pin hpd_pin;\nenum intel_display_power_domain power_domain;\n/* VBT information for this encoder (may be NULL for older platforms) */\nconst struct intel_bios_encoder_data *devdata;\n};\n```\n```c\nstruct intel_crtc_state {\n/*\n* uapi (drm) state. This is the software state shown to userspace.\n* In particular, the following members are used for bookkeeping:\n* - crtc\n* - state\n* - *_changed\n* - event\n* - commit\n* - mode_blob\n*/\nstruct drm_crtc_state uapi;\n/*\n* actual hardware state, the state we program to the hardware.\n* The following members are used to verify the hardware state:\n* - enable\n* - active\n* - mode / pipe_mode / adjusted_mode\n* - color property blobs.\n*\n* During initial hw readout, they need to be copied to uapi.\n*\n* Joiner will allow a transcoder mode that spans 2 pipes;\n* Use the pipe_mode for calculations like watermarks, pipe\n* scaler, and bandwidth.\n*\n* Use adjusted_mode for things that need to know the full\n* mode on the transcoder, which spans all pipes.\n*/\nstruct {\nbool active, enable;\n/* logical state of LUTs */\nstruct drm_property_blob *degamma_lut, *gamma_lut, *ctm;\nstruct drm_display_mode mode, pipe_mode, adjusted_mode;\nenum drm_scaling_filter scaling_filter;\n} hw;\n/* actual state of LUTs */\nstruct drm_property_blob *pre_csc_lut, *post_csc_lut;\nstruct intel_csc_matrix csc, output_csc;\n/**\n* quirks - bitfield with hw state readout quirks\n*\n* For various reasons the hw state readout code might not be able to\n* completely faithfully read out the current state. These cases are\n* tracked with quirk flags so that fastboot and state checker can act\n* accordingly.\n*/\n#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS (1<<0) /* unreliable sync mode.flags */\nunsigned long quirks;\nunsigned fb_bits; /* framebuffers to flip */\nbool update_pipe; /* can a fast modeset be performed? */\nbool update_m_n; /* update M/N seamlessly during fastset? */\nbool update_lrr; /* update TRANS_VTOTAL/etc. during fastset? */\nbool disable_cxsr;\nbool update_wm_pre, update_wm_post; /* watermarks are updated */\nbool fifo_changed; /* FIFO split is changed */\nbool preload_luts;\nbool inherited; /* state inherited from BIOS? */\n/* Ask the hardware to actually async flip? */\nbool do_async_flip;\n/* Pipe source size (ie. panel fitter input size)\n* All planes will be positioned inside this space,\n* and get clipped at the edges. */\nstruct drm_rect pipe_src;\n/*\n* Pipe pixel rate, adjusted for\n* panel fitter/pipe scaler downscaling.\n*/\nunsigned int pixel_rate;\n/* Whether to set up the PCH/FDI. Note that we never allow sharing\n* between pch encoders and cpu encoders. */\nbool has_pch_encoder;\n/* Are we sending infoframes on the attached port */\nbool has_infoframe;\n/* CPU Transcoder for the pipe. Currently this can only differ from the\n* pipe on Haswell and later (where we have a special eDP transcoder)\n* and Broxton (where we have special DSI transcoders). */\nenum transcoder cpu_transcoder;\n/*\n* Use reduced/limited/broadcast rbg range, compressing from the full\n* range fed into the crtcs.\n*/\nbool limited_color_range;\n/* Bitmask of encoder types (enum intel_output_type)\n* driven by the pipe.\n*/\nunsigned int output_types;\n/* Whether we should send NULL infoframes. Required for audio. */\nbool has_hdmi_sink;\n/* Audio enabled on this pipe. Only valid if either has_hdmi_sink or\n* has_dp_encoder is set. */\nbool has_audio;\n/*\n* Enable dithering, used when the selected pipe bpp doesn't match the\n* plane bpp.\n*/\nbool dither;\n/*\n* Dither gets enabled for 18bpp which causes CRC mismatch errors for\n* compliance video pattern tests.\n* Disable dither only if it is a compliance test request for\n* 18bpp.\n*/\nbool dither_force_disable;\n/* Controls for the clock computation, to override various stages. */\nbool clock_set;\n/* SDVO TV has a bunch of special case. To make multifunction encoders\n* work correctly, we need to track this at runtime.*/\nbool sdvo_tv_clock;\n/*\n* crtc bandwidth limit, don't increase pipe bpp or clock if not really\n* required. This is set in the 2nd loop of calling encoder's\n* ->compute_config if the first pick doesn't work out.\n*/\nbool bw_constrained;\n/* Settings for the intel dpll used on pretty much everything but\n* haswell. */\nstruct dpll dpll;\n/* Selected dpll when shared or NULL. */\nstruct intel_shared_dpll *shared_dpll;\n/* Actual register state of the dpll, for shared dpll cross-checking. */\nstruct intel_dpll_hw_state dpll_hw_state;\n/*\n* ICL reserved DPLLs for the CRTC/port. The active PLL is selected by\n* setting shared_dpll and dpll_hw_state to one of these reserved ones.\n*/\nstruct icl_port_dpll {\nstruct intel_shared_dpll *pll;\nstruct intel_dpll_hw_state hw_state;\n} icl_port_dplls[ICL_PORT_DPLL_COUNT];\n/* DSI PLL registers */\nstruct {\nu32 ctrl, div;\n} dsi_pll;\nint max_link_bpp_x16; /* in 1/16 bpp units */\nint pipe_bpp; /* in 1 bpp units */\nstruct intel_link_m_n dp_m_n;\n/* m2_n2 for eDP downclock */\nstruct intel_link_m_n dp_m2_n2;\nbool has_drrs;\n/* PSR is supported but might not be enabled due the lack of enabled planes */\nbool has_psr;\nbool has_sel_update;\nbool enable_psr2_sel_fetch;\nbool enable_psr2_su_region_et;\nbool req_psr2_sdp_prior_scanline;\nbool has_panel_replay;\nbool wm_level_disabled;\nu32 dc3co_exitline;\nu16 su_y_granularity;\n/*\n* Frequence the dpll for the port should run at. Differs from the\n* adjusted dotclock e.g. for DP or 10/12bpc hdmi mode. This is also\n* already multiplied by pixel_multiplier.\n*/\nint port_clock;\n/* Used by SDVO (and if we ever fix it, HDMI). */\nunsigned pixel_multiplier;\n/* I915_MODE_FLAG_* */\nu8 mode_flags;\nu8 lane_count;\n/*\n* Used by platforms having DP/HDMI PHY with programmable lane\n* latency optimization.\n*/\nu8 lane_lat_optim_mask;\n/* minimum acceptable voltage level */\nu8 min_voltage_level;\n/* Panel fitter controls for gen2-gen4 + VLV */\nstruct {\nu32 control;\nu32 pgm_ratios;\nu32 lvds_border_bits;\n} gmch_pfit;\n/* Panel fitter placement and size for Ironlake+ */\nstruct {\nstruct drm_rect dst;\nbool enabled;\nbool force_thru;\n} pch_pfit;\n/* FDI configuration, only valid if has_pch_encoder is set. */\nint fdi_lanes;\nstruct intel_link_m_n fdi_m_n;\nbool ips_enabled;\nbool crc_enabled;\nbool double_wide;\nint pbn;\nstruct intel_crtc_scaler_state scaler_state;\n/* w/a for waiting 2 vblanks during crtc enable */\nenum pipe hsw_workaround_pipe;\nstruct intel_crtc_wm_state wm;\nint min_cdclk[I915_MAX_PLANES];\n/* for packed/planar CbCr */\nu32 data_rate[I915_MAX_PLANES];\n/* for planar Y */\nu32 data_rate_y[I915_MAX_PLANES];\n/* FIXME unify with data_rate[]? */\nu64 rel_data_rate[I915_MAX_PLANES];\nu64 rel_data_rate_y[I915_MAX_PLANES];\n/* Gamma mode programmed on the pipe */\nu32 gamma_mode;\nunion {\n/* CSC mode programmed on the pipe */\nu32 csc_mode;\n/* CHV CGM mode */\nu32 cgm_mode;\n};\n/* bitmask of logically enabled planes (enum plane_id) */\nu8 enabled_planes;\n/* bitmask of actually visible planes (enum plane_id) */\nu8 active_planes;\nu8 scaled_planes;\nu8 nv12_planes;\nu8 c8_planes;\n/* bitmask of planes that will be updated during the commit */\nu8 update_planes;\n/* bitmask of planes with async flip active */\nu8 async_flip_planes;\nu8 framestart_delay; /* 1-4 */\nu8 msa_timing_delay; /* 0-3 */\nstruct {\nu32 enable;\nu32 gcp;\nunion hdmi_infoframe avi;\nunion hdmi_infoframe spd;\nunion hdmi_infoframe hdmi;\nunion hdmi_infoframe drm;\nstruct drm_dp_vsc_sdp vsc;\nstruct drm_dp_as_sdp as_sdp;\n} infoframes;\nu8 eld[MAX_ELD_BYTES];\n/* HDMI scrambling status */\nbool hdmi_scrambling;\n/* HDMI High TMDS char rate ratio */\nbool hdmi_high_tmds_clock_ratio;\n/*\n* Output format RGB/YCBCR etc., that is coming out\n* at the end of the pipe.\n*/\nenum intel_output_format output_format;\n/*\n* Sink output format RGB/YCBCR etc., that is going\n* into the sink.\n*/\nenum intel_output_format sink_format;\n/* enable pipe gamma? */\nbool gamma_enable;\n/* enable pipe csc? */\nbool csc_enable;\n/* enable vlv/chv wgc csc? */\nbool wgc_enable;\n/* joiner pipe bitmask */\nu8 joiner_pipes;\n/* Display Stream compression state */\nstruct {\nbool compression_enable;\nbool dsc_split;\n/* Compressed Bpp in U6.4 format (first 4 bits for fractional part) */\nu16 compressed_bpp_x16;\nu8 slice_count;\nstruct drm_dsc_config config;\n} dsc;\n/* DP tunnel used for BW allocation. */\nstruct drm_dp_tunnel_ref dp_tunnel_ref;\n/* HSW+ linetime watermarks */\nu16 linetime;\nu16 ips_linetime;\nbool enhanced_framing;\n/*\n* Forward Error Correction.\n*\n* Note: This will be false for 128b/132b, which will always have FEC\n* enabled automatically.\n*/\nbool fec_enable;\nbool sdp_split_enable;\n/* Pointer to master transcoder in case of tiled displays */\nenum transcoder master_transcoder;\n/* Bitmask to indicate slaves attached */\nu8 sync_mode_slaves_mask;\n/* Only valid on TGL+ */\nenum transcoder mst_master_transcoder;\n/* For DSB based pipe updates */\nstruct intel_dsb *dsb_color_vblank, *dsb_commit;\nbool use_dsb;\nu32 psr2_man_track_ctl;\nu32 pipe_srcsz_early_tpt;\nstruct drm_rect psr2_su_area;\n/* Variable Refresh Rate state */\nstruct {\nbool enable, in_range;\nu8 pipeline_full;\nu16 flipline, vmin, vmax, guardband;\nu32 vsync_end, vsync_start;\n} vrr;\n/* Content Match Refresh Rate state */\nstruct {\nbool enable;\nu64 cmrr_n, cmrr_m;\n} cmrr;\n/* Stream Splitter for eDP MSO */\nstruct {\nbool enable;\nu8 link_count;\nu8 pixel_overlap;\n} splitter;\n/* for loading single buffered registers during vblank */\nstruct drm_vblank_work vblank_work;\n/* LOBF flag */\nbool has_lobf;\n};\n```\n```c\nstruct intel_display {\n/* drm device backpointer */\nstruct drm_device *drm;\n/* Platform (and subplatform, if any) identification */\nstruct intel_display_platforms platform;\n/* Display functions */\nstruct {\n/* Top level crtc-ish functions */\nconst struct intel_display_funcs *display;\n/* Display CDCLK functions */\nconst struct intel_cdclk_funcs *cdclk;\n/* Display pll funcs */\nconst struct intel_dpll_funcs *dpll;\n/* irq display functions */\nconst struct intel_hotplug_funcs *hotplug;\n/* pm display functions */\nconst struct intel_wm_funcs *wm;\n/* fdi display functions */\nconst struct intel_fdi_funcs *fdi;\n/* Display internal color functions */\nconst struct intel_color_funcs *color;\n/* Display internal audio functions */\nconst struct intel_audio_funcs *audio;\n} funcs;\nstruct {\nbool any_task_allowed;\nstruct task_struct *allowed_task;\n} access;\nstruct {\n/* backlight registers and fields in struct intel_panel */\nstruct mutex lock;\n} backlight;\nstruct {\nstruct intel_global_obj obj;\nstruct intel_bw_info {\n/* for each QGV point */\nunsigned int deratedbw[I915_NUM_QGV_POINTS];\n/* for each PSF GV point */\nunsigned int psf_bw[I915_NUM_PSF_GV_POINTS];\n/* Peak BW for each QGV point */\nunsigned int peakbw[I915_NUM_QGV_POINTS];\nu8 num_qgv_points;\nu8 num_psf_gv_points;\nu8 num_planes;\n} max[6];\n} bw;\nstruct {\n/* The current hardware cdclk configuration */\nstruct intel_cdclk_config hw;\n/* cdclk, divider, and ratio table from bspec */\nconst struct intel_cdclk_vals *table;\nstruct intel_global_obj obj;\nunsigned int max_cdclk_freq;\nunsigned int max_dotclk_freq;\nunsigned int skl_preferred_vco_freq;\n} cdclk;\nstruct {\nstruct drm_property_blob *glk_linear_degamma_lut;\n} color;\nstruct {\n/* The current hardware dbuf configuration */\nu8 enabled_slices;\nstruct intel_global_obj obj;\n} dbuf;\nstruct {\n/*\n* dkl.phy_lock protects against concurrent access of the\n* Dekel TypeC PHYs.\n*/\nspinlock_t phy_lock;\n} dkl;\nstruct {\nstruct intel_dmc *dmc;\nintel_wakeref_t wakeref;\n} dmc;\nstruct {\n/* VLV/CHV/BXT/GLK DSI MMIO register base address */\nu32 mmio_base;\n} dsi;\nstruct {\n/* list of fbdev register on this device */\nstruct intel_fbdev *fbdev;\nstruct work_struct suspend_work;\n} fbdev;\nstruct {\nunsigned int pll_freq;\nu32 rx_config;\n} fdi;\nstruct {\nstruct list_head obj_list;\n} global;\nstruct {\n/*\n* Base address of where the gmbus and gpio blocks are located\n* (either on PCH or on SoC for platforms without PCH).\n*/\nu32 mmio_base;\n/*\n* gmbus.mutex protects against concurrent usage of the single\n* hw gmbus controller on different i2c buses.\n*/\nstruct mutex mutex;\nstruct intel_gmbus *bus[GMBUS_NUM_PINS];\nwait_queue_head_t wait_queue;\n} gmbus;\nstruct {\nstruct i915_hdcp_arbiter *arbiter;\nbool comp_added;\n/*\n* HDCP message struct for allocation of memory which can be\n* reused when sending message to gsc cs.\n* this is only populated post Meteorlake\n*/\nstruct intel_hdcp_gsc_message *hdcp_message;\n/* Mutex to protect the above hdcp related values. */\nstruct mutex hdcp_mutex;\n} hdcp;\nstruct {\n/*\n* HTI (aka HDPORT) state read during initial hw readout. Most\n* platforms don't have HTI, so this will just stay 0. Those\n* that do will use this later to figure out which PLLs and PHYs\n* are unavailable for driver usage.\n*/\nu32 state;\n} hti;\nstruct {\n/* Access with DISPLAY_INFO() */\nconst struct intel_display_device_info *__device_info;\n/* Access with DISPLAY_RUNTIME_INFO() */\nstruct intel_display_runtime_info __runtime_info;\n} info;\nstruct {\nbool false_color;\n} ips;\nstruct {\nbool display_irqs_enabled;\n/* For i915gm/i945gm vblank irq workaround */\nu8 vblank_enabled;\nint vblank_wa_num_pipes;\nstruct work_struct vblank_dc_work;\nu32 de_irq_mask[I915_MAX_PIPES];\nu32 pipestat_irq_mask[I915_MAX_PIPES];\n} irq;\nstruct {\nwait_queue_head_t waitqueue;\n/* mutex to protect pmdemand programming sequence */\nstruct mutex lock;\nstruct intel_global_obj obj;\n} pmdemand;\nstruct {\nstruct i915_power_domains domains;\n/* Shadow for DISPLAY_PHY_CONTROL which can't be safely read */\nu32 chv_phy_control;\n/* perform PHY state sanity checks? */\nbool chv_phy_assert[2];\n} power;\nstruct {\nu32 mmio_base;\n/* protects panel power sequencer state */\nstruct mutex mutex;\n} pps;\nstruct {\nstruct drm_property *broadcast_rgb;\nstruct drm_property *force_audio;\n} properties;\nstruct {\nunsigned long mask;\n} quirks;\nstruct {\n/* restore state for suspend/resume and display reset */\nstruct drm_atomic_state *modeset_state;\nstruct drm_modeset_acquire_ctx reset_ctx;\n} restore;\nstruct {\nenum {\nI915_SAGV_UNKNOWN = 0,\nI915_SAGV_DISABLED,\nI915_SAGV_ENABLED,\nI915_SAGV_NOT_CONTROLLED\n} status;\nu32 block_time_us;\n} sagv;\nstruct {\n/*\n* DG2: Mask of PHYs that were not calibrated by the firmware\n* and should not be used.\n*/\nu8 phy_failed_calibration;\n} snps;\nstruct {\n/*\n* Shadows for CHV DPLL_MD regs to keep the state\n* checker somewhat working in the presence hardware\n* crappiness (can't read out DPLL_MD for pipes B & C).\n*/\nu32 chv_dpll_md[I915_MAX_PIPES];\nu32 bxt_phy_grc;\n} state;\nstruct {\n/* ordered wq for modesets */\nstruct workqueue_struct *modeset;\n/* unbound hipri wq for page flips/plane updates */\nstruct workqueue_struct *flip;\n} wq;\n/* Grouping using named structs. Keep sorted. */\nstruct drm_dp_tunnel_mgr *dp_tunnel_mgr;\nstruct intel_audio audio;\nstruct intel_dpll dpll;\nstruct intel_fbc *fbc[I915_MAX_FBCS];\nstruct intel_frontbuffer_tracking fb_tracking;\nstruct intel_hotplug hotplug;\nstruct intel_opregion *opregion;\nstruct intel_overlay *overlay;\nstruct intel_display_params params;\nstruct intel_vbt_data vbt;\nstruct intel_dmc_wl wl;\nstruct intel_wm wm;\n};\n```\n```c\n#define to_intel_display(p) \\\n_Generic(*p, \\\n__assoc(drm_device, p), \\\n__assoc(device, p), \\\n__assoc(pci_dev, p), \\\n__assoc(intel_atomic_state, p), \\\n__assoc(intel_connector, p), \\\n__assoc(intel_crtc, p), \\\n__assoc(intel_crtc_state, p), \\\n__assoc(intel_digital_port, p), \\\n__assoc(intel_dp, p), \\\n__assoc(intel_encoder, p), \\\n__assoc(intel_hdmi, p), \\\n__assoc(intel_plane, p), \\\n__assoc(intel_plane_state, p))\n```\n```c\nstruct intel_crtc {\nstruct drm_crtc base;\nenum pipe pipe;\n/*\n* Whether the crtc and the connected output pipeline is active. Implies\n* that crtc->enabled is set, i.e. the current mode configuration has\n* some outputs connected to this crtc.\n*/\nbool active;\nu8 plane_ids_mask;\n/* I915_MODE_FLAG_* */\nu8 mode_flags;\nu16 vmax_vblank_start;\nstruct intel_display_power_domain_set enabled_power_domains;\nstruct intel_display_power_domain_set hw_readout_power_domains;\nstruct intel_overlay *overlay;\nstruct intel_crtc_state *config;\n/* armed event for async flip */\nstruct drm_pending_vblank_event *flip_done_event;\n/* armed event for DSB based updates */\nstruct drm_pending_vblank_event *dsb_event;\n/* Access to these should be protected by dev_priv->irq_lock. */\nbool cpu_fifo_underrun_disabled;\nbool pch_fifo_underrun_disabled;\n/* per-pipe watermark state */\nstruct {\n/* watermarks currently being used */\nunion {\nstruct intel_pipe_wm ilk;\nstruct vlv_wm_state vlv;\nstruct g4x_wm_state g4x;\n} active;\n} wm;\nstruct {\nstruct mutex mutex;\nstruct delayed_work work;\nenum drrs_refresh_rate refresh_rate;\nunsigned int frontbuffer_bits;\nunsigned int busy_frontbuffer_bits;\nenum transcoder cpu_transcoder;\nstruct intel_link_m_n m_n, m2_n2;\n} drrs;\nint scanline_offset;\nstruct {\nunsigned start_vbl_count;\nktime_t start_vbl_time;\nint min_vbl, max_vbl;\nint scanline_start;\n#ifdef CONFIG_DRM_I915_DEBUG_VBLANK_EVADE\nstruct {\nu64 min;\nu64 max;\nu64 sum;\nunsigned int over;\nunsigned int times[17]; /* [1us, 16ms] */\n} vbl;\n#endif\n} debug;\n/* scalers available on this crtc */\nint num_scalers;\n/* for loading single buffered registers during vblank */\nstruct pm_qos_request vblank_pm_qos;\n#ifdef CONFIG_DEBUG_FS\nstruct intel_pipe_crc pipe_crc;\n#endif\nbool block_dc_for_vblank;\n};\n```\n```c\n#define to_intel_crtc(x) container_of(x, struct intel_crtc, base)\n```\n```c\nstatic inline struct drm_i915_private *to_i915(const struct drm_device *dev)\n{\nreturn container_of(dev, struct drm_i915_private, drm);\n}\n```\n```c\nvoid intel_crtc_vblank_off(const struct intel_crtc_state *crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\nstruct intel_display *display = to_intel_display(crtc);\n/*\n* Should really happen exactly when we disable the pipe\n* but we want the frame counters in the trace, and that\n* requires vblank support on some platforms/outputs.\n*/\ntrace_intel_pipe_disable(crtc);\ndrm_crtc_vblank_off(&crtc->base);\nassert_vblank_disabled(&crtc->base);\ncrtc->block_dc_for_vblank = false;\nflush_work(&display->irq.vblank_dc_work);\n}\n```\n```c\nvoid intel_disable_transcoder(const struct intel_crtc_state *old_crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\nenum pipe pipe = crtc->pipe;\nu32 val;\ndrm_dbg_kms(&dev_priv->drm, \"disabling pipe %c\\n\", pipe_name(pipe));\n/*\n* Make sure planes won't keep trying to pump pixels to us,\n* or we might hang the display.\n*/\nassert_planes_disabled(crtc);\nval = intel_de_read(dev_priv, TRANSCONF(dev_priv, cpu_transcoder));\nif ((val & TRANSCONF_ENABLE) == 0)\nreturn;\n/*\n* Double wide has implications for planes\n* so best keep it disabled when not needed.\n*/\nif (old_crtc_state->double_wide)\nval &= ~TRANSCONF_DOUBLE_WIDE;\n/* Don't disable pipe or pipe PLLs if needed */\nif (!IS_I830(dev_priv))\nval &= ~TRANSCONF_ENABLE;\n/* Wa_1409098942:adlp+ */\nif (DISPLAY_VER(dev_priv) >= 13 &&\nold_crtc_state->dsc.compression_enable)\nval &= ~TRANSCONF_PIXEL_COUNT_SCALING_MASK;\nintel_de_write(dev_priv, TRANSCONF(dev_priv, cpu_transcoder), val);\nif (DISPLAY_VER(dev_priv) >= 12)\nintel_de_rmw(dev_priv, hsw_chicken_trans_reg(dev_priv, cpu_transcoder),\nFECSTALL_DIS_DPTSTREAM_DPTTG, 0);\nif ((val & TRANSCONF_ENABLE) == 0)\nintel_wait_for_pipe_off(old_crtc_state);\n}\n```\n```c\nvoid intel_ddi_disable_transcoder_func(const struct intel_crtc_state *crtc_state)\n{\nstruct intel_display *display = to_intel_display(crtc_state);\nstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\nu32 ctl;\nif (DISPLAY_VER(dev_priv) >= 11)\nintel_de_write(dev_priv,\nTRANS_DDI_FUNC_CTL2(dev_priv, cpu_transcoder),\n0);\nctl = intel_de_read(dev_priv,\nTRANS_DDI_FUNC_CTL(dev_priv, cpu_transcoder));\ndrm_WARN_ON(crtc->base.dev, ctl & TRANS_DDI_HDCP_SIGNALLING);\nctl &= ~TRANS_DDI_FUNC_ENABLE;\nif (IS_DISPLAY_VER(dev_priv, 8, 10))\nctl &= ~(TRANS_DDI_PORT_SYNC_ENABLE |\nTRANS_DDI_PORT_SYNC_MASTER_SELECT_MASK);\nif (DISPLAY_VER(dev_priv) >= 12) {\nif (!intel_dp_mst_is_master_trans(crtc_state)) {\nctl &= ~(TGL_TRANS_DDI_PORT_MASK |\nTRANS_DDI_MODE_SELECT_MASK);\n}\n} else {\nctl &= ~(TRANS_DDI_PORT_MASK | TRANS_DDI_MODE_SELECT_MASK);\n}\nintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(dev_priv, cpu_transcoder),\nctl);\nif (intel_has_quirk(display, QUIRK_INCREASE_DDI_DISABLED_TIME) &&\nintel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\ndrm_dbg_kms(display->drm, \"Quirk Increase DDI disabled time\\n\");\n/* Quirk time at 100ms for reliable operation */\nmsleep(100);\n}\n}\n```\n```c\nvoid ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state)\n{\nstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\nenum pipe pipe = crtc->pipe;\n/* To avoid upsetting the power well on haswell only disable the pfit if\n* it's in use. The hw state code will make sure we get this right. */\nif (!old_crtc_state->pch_pfit.enabled)\nreturn;\nintel_de_write_fw(dev_priv, PF_CTL(pipe), 0);\nintel_de_write_fw(dev_priv, PF_WIN_POS(pipe), 0);\nintel_de_write_fw(dev_priv, PF_WIN_SZ(pipe), 0);\n}\n```\n```c\nvoid intel_ddi_disable_transcoder_clock(const struct intel_crtc_state *crtc_state)\n{\nstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\nenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\nu32 val;\nif (cpu_transcoder == TRANSCODER_EDP)\nreturn;\nif (DISPLAY_VER(dev_priv) >= 12)\nval = TGL_TRANS_CLK_SEL_DISABLED;\nelse\nval = TRANS_CLK_SEL_DISABLED;\nintel_de_write(dev_priv, TRANS_CLK_SEL(cpu_transcoder), val);\n}\n```\n```c\nstatic void pch_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)\n{\nintel_disable_crt(state, encoder, old_crtc_state, old_conn_state);\n}\n```\n```c\nstatic inline void lpt_pch_disable(struct intel_atomic_state *state,\nstruct intel_crtc *crtc)\n{\n}\n```\n```c\nvoid hsw_fdi_disable(struct intel_encoder *encoder)\n{\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n/*\n* Bspec lists this as both step 13 (before DDI_BUF_CTL disable)\n* and step 18 (after clearing PORT_CLK_SEL). Based on a BUN,\n* step 13 is the correct place for it. Step 18 is where it was\n* originally before the BUN.\n*/\nintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_ENABLE, 0);\nintel_de_rmw(dev_priv, DDI_BUF_CTL(PORT_E), DDI_BUF_CTL_ENABLE, 0);\nintel_wait_ddi_buf_idle(dev_priv, PORT_E);\nintel_ddi_disable_clock(encoder);\nintel_de_rmw(dev_priv, FDI_RX_MISC(PIPE_A),\nFDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK,\nFDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2));\nintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_PCDCLK, 0);\nintel_de_rmw(dev_priv, FDI_RX_CTL(PIPE_A), FDI_RX_PLL_ENABLE, 0);\n}\n```\n```c\n#define drm_WARN_ON(drm, x) \\\ndrm_WARN((drm), (x), \"%s\", \\\n\"drm_WARN_ON(\" __stringify(x) \")\")\n```\n```c\nbool intel_set_pch_fifo_underrun_reporting(struct drm_i915_private *dev_priv,\nenum pipe pch_transcoder,\nbool enable)\n{\nstruct intel_display *display = &dev_priv->display;\nstruct intel_crtc *crtc =\nintel_crtc_for_pipe(display, pch_transcoder);\nunsigned long flags;\nbool old;\n/*\n* NOTE: Pre-LPT has a fixed cpu pipe -> pch transcoder mapping, but LPT\n* has only one pch transcoder A that all pipes can use. To avoid racy\n* pch transcoder -> pipe lookups from interrupt code simply store the\n* underrun statistics in crtc A. Since we never expose this anywhere\n* nor use it outside of the fifo underrun code here using the \"wrong\"\n* crtc on LPT won't cause issues.\n*/\nspin_lock_irqsave(&dev_priv->irq_lock, flags);\nold = !crtc->pch_fifo_underrun_disabled;\ncrtc->pch_fifo_underrun_disabled = !enable;\nif (HAS_PCH_IBX(dev_priv))\nibx_set_fifo_underrun_reporting(&dev_priv->drm,\npch_transcoder,\nenable);\nelse\ncpt_set_fifo_underrun_reporting(&dev_priv->drm,\npch_transcoder,\nenable, old);\nspin_unlock_irqrestore(&dev_priv->irq_lock, flags);\nreturn old;\n}\n```\n",
 "function_prototype": "static void hsw_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)",
 "re_implemented_code": "\n```c\nstatic void hsw_post_disable_crt(struct intel_atomic_state *state, struct intel_encoder *encoder, const struct intel_crtc_state *old_crtc_state, const struct drm_connector_state *old_conn_state)\n{\nstruct intel_display *display = to_intel_display(state);\nstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\nintel_crtc_vblank_off(old_crtc_state);\nintel_disable_transcoder(old_crtc_state);\nintel_ddi_disable_transcoder_func(old_crtc_state);\nilk_pfit_disable(old_crtc_state);\nintel_ddi_disable_transcoder_clock(old_crtc_state);\npch_post_disable_crt(state, encoder, old_crtc_state, old_conn_state);\nlpt_pch_disable(state, crtc);\nhsw_fdi_disable(encoder);\nif (!old_crtc_state->has_pch_encoder) {\nDRM_ERROR(\"Old CRTC state lacks PCH encoder!\\n\");\n}\nintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n}\n```\n",
 "is_vulnerable": true
}