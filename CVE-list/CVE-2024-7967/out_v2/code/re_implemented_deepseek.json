{
 "supplementary_code": "```cpp\nclass PLATFORM_EXPORT HarfBuzzShaper final {\nDISALLOW_NEW();\nusing EmojiMetricsCallback =\nbase::RepeatingCallback<void(unsigned, unsigned)>;\npublic:\n// The optional emoji_metrics_callback argument is a mock metrics reporting\n// function used during tests. Otherwise successful and unsuccessful emoji\n// clusters are reported per Document / WorkerGlobalContext to\n// FontMatchingMetrics.\nexplicit HarfBuzzShaper(\nString text,\nEmojiMetricsCallback emoji_metrics_callback = EmojiMetricsCallback())\n: text_(std::move(text)),\nemoji_metrics_reporter_for_testing_(emoji_metrics_callback) {}\n// Shape a range, defined by the start and end parameters, of the string\n// supplied to the constructor.\n// The start and end positions should represent boundaries where a break may\n// occur, such as at the beginning or end of lines or at element boundaries.\n// If given arbitrary positions the results are not guaranteed to be correct.\n// May be called multiple times; font and direction may vary between calls.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end) const;\n// Shape a range that has already been pre-segmented. Start and end positions\n// must match the positions defined by the ranges and must be at valid break\n// positions.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end,\nconst Vector<RunSegmenter::RunSegmenterRange>&,\nShapeOptions = ShapeOptions()) const;\n// Shape a single range. Start and end positions defined by the range.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end,\nconst RunSegmenter::RunSegmenterRange,\nShapeOptions = ShapeOptions()) const;\n// Shape the entire string with a single font and direction.\n// Equivalent to calling the range version with a start offset of zero and an\n// end offset equal to the length.\nShapeResult* Shape(const Font*, TextDirection) const;\nconst String& GetText() const { return text_; }\nunsigned TextLength() const { return text_.length(); }\n// This function is between `Shape` and `SimpleFontData::GlyphForCharacter`.\n//\n// Unlike `Shape`, it works only for one `SimpleFontData`, not `Font`, without\n// cascading nor fallback. Missing glyphs are reported as `.notdef` (0). Also\n// it's a lot less expensive than `Shape`.\n//\n// Unlike `SimpleFontData::GlyphForCharacter`, it shapes, taking locale,\n// script, and OpenType features into account.\nstruct GlyphData {\nunsigned cluster;\nGlyph glyph;\ngfx::PointF advance;\ngfx::PointF offset;\n};\nusing GlyphDataList = Vector<GlyphData, 16>;\nvoid GetGlyphData(const SimpleFontData& font_data,\nconst LayoutLocale& locale,\nUScriptCode script,\nbool is_horizontal,\nGlyphDataList& glyphs);\nenum FallbackFontStage {\n// There were no unshaped variation sequences found, so we don't need to\n// perform second fallback fonts list pass.\nkIntermediate,\nkLast,\n// Found unshaped variation sequences and we are on the first fallback pass,\n// so we are including variation selectors during shaping.\nkIntermediateWithVS,\nkLastWithVS,\n// Found unshaped variation sequences and we are on the second and last\n// fallback pass, so we are ignoring variation selectors during shaping.\nkIntermediateIgnoreVS,\nkLastIgnoreVS\n};\n~HarfBuzzShaper() = default;\nprivate:\nusing HintCharList = FontFallbackIterator::HintCharList;\n// Shapes a single seqment, as identified by the RunSegmenterRange parameter,\n// one or more times taking font fallback into account. The start and end\n// parameters are for the entire text run, not the segment, and are used to\n// determine pre- and post-context for shaping.\nvoid ShapeSegment(RangeContext*,\nconst RunSegmenter::RunSegmenterRange&,\nShapeResult*) const;\nvoid ExtractShapeResults(RangeContext*,\nbool& font_cycle_queued,\nconst ReshapeQueueItem&,\nconst SimpleFontData*,\nUScriptCode,\nCanvasRotationInVertical,\nFallbackFontStage& fallback_stage,\nShapeResult*) const;\nbool CollectFallbackHintChars(const Deque<ReshapeQueueItem>&,\nbool needs_hint_list,\nHintCharList& hint) const;\nvoid CommitGlyphs(RangeContext*,\nconst SimpleFontData* current_font,\nUScriptCode current_run_script,\nCanvasRotationInVertical,\nFallbackFontStage fallback_stage,\nconst BufferSlice&,\nShapeResult*) const;\nvoid CheckTextLen(unsigned start, unsigned length) const;\nvoid CheckTextEnd(unsigned start, unsigned end) const;\nconst String text_;\nEmojiMetricsCallback emoji_metrics_reporter_for_testing_;\n};\n```\n```cpp\nenum ReshapeQueueItemAction {\nkReshapeQueueNextFont,\nkReshapeQueueRange,\nkReshapeQueueReset\n};\n```\n```cpp\nbool Character::HasDefiniteScript(UChar32 character) {\nICUError err;\nUScriptCode hint_char_script = uscript_getScript(character, &err);\nif (!U_SUCCESS(err))\nreturn false;\nreturn hint_char_script != USCRIPT_INHERITED &&\nhint_char_script != USCRIPT_COMMON;\n}\n```",
 "function_prototype": "bool HarfBuzzShaper::CollectFallbackHintChars(const Deque<ReshapeQueueItem>& reshape_queue, bool needs_hint_list, HintCharList& hint) const",
 "re_implemented_code": "\n```cpp\nbool HarfBuzzShaper::CollectFallbackHintChars(\nconst Deque<ReshapeQueueItem>& reshape_queue,\nbool needs_hint_list,\nHintCharList& hint) const {\n// Check if the reshape queue is empty, and return false if it is\nif (reshape_queue.empty()) {\nreturn false;\n}\n// Clear the hint list without releasing its capacity to avoid reallocations\nhint.clear();\n// Initialize a counter for the number of characters added to the hint list\nsize_t num_chars_added = 0;\n// Iterate over each item in the reshape queue\nfor (auto it = reshape_queue.begin(); it != reshape_queue.end(); ++it) {\n// If the action indicates moving to the next font, break out of the loop\nif (it->action == ReshapeQueueItemAction::kReshapeQueueNextFont) {\nbreak;\n}\n// Ensure that we do not exceed text length when accessing characters by index\nCHECK_LE((it->start_index_ + it->num_characters_), text_.length());\n// Check if text is stored as an array of single-byte characters (8-bit)\nif (text_.Is8Bit()) {\n// Iterate over each character in this segment of text\nfor (unsigned i = 0; i < it->num_characters_; i++) {\n// Retrieve and store each character from text into hint list\nconst UChar hint_char = text_[it->start_index_ + i];\nhint.push_back(hint_char);\nnum_chars_added++;\n// Determine whether we can stop filling hints early: no need for a full list and found a definite script character.\nif (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {\nreturn true;\n}\n}\n} else {\n// Handle case where text is not stored as single-byte characters.\nUChar32 hint_char;\nUTF16TextIterator iterator(text_.Characters16() + it->start_index_,\nit->num_characters_);\nwhile (iterator.Consume(hint_char)) {\nhint.push_back(hint_char);\nnum_chars_added++;\n// Similar check as above but using UTF-16 iterator instead.\nif (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {\nreturn true;\n}\niterator.Advance();\n}\n}\n}\n// Return true if any chars were added to indicate success.\nreturn num_chars_added > 0;\n}\n```\n",
 "is_vulnerable": true
}