

#include <deque>
#include <string>
#include <vector>

class Character {
public:
    static bool HasDefiniteScript(char hint_char) {
        // Assume implementation exists elsewhere
        return true;
    }

    static bool HasDefiniteScript(char32_t hint_char) {
        // Assume implementation exists elsewhere
        return true;
    }
};

enum Action { 
    kReshapeQueueNextFont 
};

struct ReshapeQueueItem {
    Action action;
    size_t start_index_;
    unsigned num_characters_;
};

class UTF16TextIterator {
public:
    UTF16TextIterator(const char16_t* start, unsigned num_characters) {
        // Constructor stub for UTF16TextIterator
    }
    bool Consume(char32_t& hint_char) {
        // Assume implementation exists elsewhere
        return true;
    }

    void Advance() {
        // Assume implementation exists elsewhere
    }
};

class Text {
public:
    bool Is8Bit() const {
        // Assume implementation exists elsewhere
        return true;
    }

    const char* Characters8() const {
        // Assume implementation exists elsewhere
        return nullptr;
    }

    const char16_t* Characters16() const {
        // Assume implementation exists elsewhere
        return nullptr;
    }

    size_t length() const {
        // Assume implementation exists elsewhere 
        return 0;
    }
};

typedef std::deque<ReshapeQueueItem> Deque;
typedef std::vector<char32_t> HintCharList;

class HarfBuzzShaper {
public:
    bool CollectFallbackHintChars(
        const Deque& reshape_queue,
        bool needs_hint_list,
        HintCharList& hint) const;

private:
    Text text_;
};

bool HarfBuzzShaper::CollectFallbackHintChars(
    const Deque& reshape_queue,
    bool needs_hint_list,
    HintCharList& hint) const {
  if (reshape_queue.empty())
    return false;

  hint.clear();

  size_t num_chars_added = 0;

  for (auto it = reshape_queue.begin(); it != reshape_queue.end(); ++it) {
    if (it->action == kReshapeQueueNextFont)
      break;

    if ((it->start_index_ + it->num_characters_) > text_.length())
        return false;

    if (text_.Is8Bit()) {
      for (unsigned i = 0; i < it->num_characters_; i++) {
        const char32_t hint_char = text_.Characters8()[it->start_index_ + i];
        hint.push_back(hint_char);
        num_chars_added++;
        if (!needs_hint_list && Character::HasDefiniteScript(static_cast<char>(hint_char)))
          return true;
      }
      continue;
    }

    char32_t hint_char;
    UTF16TextIterator iterator(text_.Characters16() + it->start_index_, it->num_characters_);
    while (iterator.Consume(hint_char)) {
      hint.push_back(hint_char);
      num_chars_added++;
      if (!needs_hint_list && Character::HasDefiniteScript(hint_char))
        return true;
      iterator.Advance();
    }
  }
  return num_chars_added > 0;
}

