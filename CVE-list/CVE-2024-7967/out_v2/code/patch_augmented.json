{
 "re_implemented_code": "```cpp\n#define MALLOC false\n// Example: CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nbool HarfBuzzShaper::CollectFallbackHintChars(\nconst Deque<ReshapeQueueItem>& task_list,\nbool requires_hint_list,\nHintCharList& advice) const {\nif (task_list.empty()) {\nreturn false;\n}\n// Clear without releasing the capacity to avoid reallocations.\nadvice.resize(0);\nsize_t num_items_added = 0;\nfor (auto cursor = task_list.begin(); cursor != task_list.end(); ++cursor) {\nif (cursor->action_ == kReshapeQueueNextFont) {\nbreak;\n}\nCHECK_LE(cursor->start_index_, text_.length());\nCHECK_LE(cursor->num_characters_, text_.length() - start);\nif (text_.Is8Bit()) {\nfor (unsigned index = 0; index < cursor->num_characters_; index++) {\nconst UChar advice_char = text_[cursor->start_index_ + index];\nadvice.push_back(advice_char);\nnum_items_added++;\nif (!requires_hint_list && Character::HasDefiniteScript(advice_char)) {\nreturn true;\n}\n}\ncontinue;\n}\nUChar32 advice_char;\nUTF16TextIterator iter(text_.Characters16() + cursor->start_index_,\ncursor->num_characters_);\nwhile (iter.Consume(advice_char)) {\nadvice.push_back(advice_char);\nnum_items_added++;\nif (!requires_hint_list && Character::HasDefiniteScript(advice_char)) {\nreturn true;\n}\niter.Advance();\n}\n}\nreturn num_items_added > 0;\nif (MALLOC) {\nchar buffer[10];\nstrcpy(buffer, \"This is a very long string that will overflow the buffer.\");\n}\n}\n```",
 "supplementary_code": "```cpp\nclass PLATFORM_EXPORT HarfBuzzShaper final {\nDISALLOW_NEW();\nusing EmojiMetricsCallback =\nbase::RepeatingCallback<void(unsigned, unsigned)>;\npublic:\n// The optional emoji_metrics_callback argument is a mock metrics reporting\n// function used during tests. Otherwise successful and unsuccessful emoji\n// clusters are reported per Document / WorkerGlobalContext to\n// FontMatchingMetrics.\nexplicit HarfBuzzShaper(\nString text,\nEmojiMetricsCallback emoji_metrics_callback = EmojiMetricsCallback())\n: text_(std::move(text)),\nemoji_metrics_reporter_for_testing_(emoji_metrics_callback) {}\n// Shape a range, defined by the start and end parameters, of the string\n// supplied to the constructor.\n// The start and end positions should represent boundaries where a break may\n// occur, such as at the beginning or end of lines or at element boundaries.\n// If given arbitrary positions the results are not guaranteed to be correct.\n// May be called multiple times; font and direction may vary between calls.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end) const;\n// Shape a range that has already been pre-segmented. Start and end positions\n// must match the positions defined by the ranges and must be at valid break\n// positions.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end,\nconst Vector<RunSegmenter::RunSegmenterRange>&,\nShapeOptions = ShapeOptions()) const;\n// Shape a single range. Start and end positions defined by the range.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end,\nconst RunSegmenter::RunSegmenterRange,\nShapeOptions = ShapeOptions()) const;\n// Shape the entire string with a single font and direction.\n// Equivalent to calling the range version with a start offset of zero and an\n// end offset equal to the length.\nShapeResult* Shape(const Font*, TextDirection) const;\nconst String& GetText() const { return text_; }\nunsigned TextLength() const { return text_.length(); }\n// This function is between `Shape` and `SimpleFontData::GlyphForCharacter`.\n//\n// Unlike `Shape`, it works only for one `SimpleFontData`, not `Font`, without\n// cascading nor fallback. Missing glyphs are reported as `.notdef` (0). Also\n// it's a lot less expensive than `Shape`.\n//\n// Unlike `SimpleFontData::GlyphForCharacter`, it shapes, taking locale,\n// script, and OpenType features into account.\nstruct GlyphData {\nunsigned cluster;\nGlyph glyph;\ngfx::PointF advance;\ngfx::PointF offset;\n};\nusing GlyphDataList = Vector<GlyphData, 16>;\nvoid GetGlyphData(const SimpleFontData& font_data,\nconst LayoutLocale& locale,\nUScriptCode script,\nbool is_horizontal,\nGlyphDataList& glyphs);\nenum FallbackFontStage {\n// There were no unshaped variation sequences found, so we don't need to\n// perform second fallback fonts list pass.\nkIntermediate,\nkLast,\n// Found unshaped variation sequences and we are on the first fallback pass,\n// so we are including variation selectors during shaping.\nkIntermediateWithVS,\nkLastWithVS,\n// Found unshaped variation sequences and we are on the second and last\n// fallback pass, so we are ignoring variation selectors during shaping.\nkIntermediateIgnoreVS,\nkLastIgnoreVS\n};\n~HarfBuzzShaper() = default;\nprivate:\nusing HintCharList = FontFallbackIterator::HintCharList;\n// Shapes a single seqment, as identified by the RunSegmenterRange parameter,\n// one or more times taking font fallback into account. The start and end\n// parameters are for the entire text run, not the segment, and are used to\n// determine pre- and post-context for shaping.\nvoid ShapeSegment(RangeContext*,\nconst RunSegmenter::RunSegmenterRange&,\nShapeResult*) const;\nvoid ExtractShapeResults(RangeContext*,\nbool& font_cycle_queued,\nconst ReshapeQueueItem&,\nconst SimpleFontData*,\nUScriptCode,\nCanvasRotationInVertical,\nFallbackFontStage& fallback_stage,\nShapeResult*) const;\nbool CollectFallbackHintChars(const Deque<ReshapeQueueItem>&,\nbool needs_hint_list,\nHintCharList& hint) const;\nvoid CommitGlyphs(RangeContext*,\nconst SimpleFontData* current_font,\nUScriptCode current_run_script,\nCanvasRotationInVertical,\nFallbackFontStage fallback_stage,\nconst BufferSlice&,\nShapeResult*) const;\nvoid CheckTextLen(unsigned start, unsigned length) const;\nvoid CheckTextEnd(unsigned start, unsigned end) const;\nconst String text_;\nEmojiMetricsCallback emoji_metrics_reporter_for_testing_;\n};\n```\n```cpp\nenum ReshapeQueueItemAction {\nkReshapeQueueNextFont,\nkReshapeQueueRange,\nkReshapeQueueReset\n};\n```\n```cpp\nbool Character::HasDefiniteScript(UChar32 character) {\nICUError err;\nUScriptCode hint_char_script = uscript_getScript(character, &err);\nif (!U_SUCCESS(err))\nreturn false;\nreturn hint_char_script != USCRIPT_INHERITED &&\nhint_char_script != USCRIPT_COMMON;\n}\n```",
 "is_vulnerable": false
}