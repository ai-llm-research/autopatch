

class ReshapeQueueItem {
public:
    enum ReshapeQueueItemAction { kReshapeQueueNextFont };
    ReshapeQueueItemAction action;
    unsigned start_index_;
    unsigned num_characters_;
};

template <typename T>
class Deque {
public:
    class Iterator {
    public:
        T value;
        T operator*() const { return value; }
        Iterator& operator++() { return *this; }
        bool operator!=(const Iterator&) const { return false; }
    };

    bool empty() const { return true; }
    Iterator begin() const { return Iterator(); }
    Iterator end() const { return Iterator(); }
};

class HintCharList {
public:
    void clear() {}
    void push_back(char) {}
    void push_back(int) {}
};

class Character {
public:
    static bool HasDefiniteScript(char) { return false; }
    static bool HasDefiniteScript(int) { return false; }
};

bool CHECK_LE(unsigned a, unsigned b) { return a <= b; }

class UTF16TextIterator {
public:
    UTF16TextIterator(const char16_t*, unsigned) {}
    bool Consume(char&) { return false; }
    bool Consume(int&) { return false; }
    void Advance() {}
};

class HarfBuzzShaper {
public:
    bool CollectFallbackHintChars(
        const Deque<ReshapeQueueItem>& reshape_queue,
        bool needs_hint_list,
        HintCharList& hint) const;

private:
    class Text {
    public:
        bool Is8Bit() const { return true; }
        unsigned length() const { return 0; }
        char operator[](unsigned) const { return 0; }
        const char16_t* Characters16() const { return nullptr; }
    } text_;
};

bool HarfBuzzShaper::CollectFallbackHintChars(
    const Deque<ReshapeQueueItem>& reshape_queue,
    bool needs_hint_list,
    HintCharList& hint) const {
    if (reshape_queue.empty()) {
        return false;
    }

    hint.clear();
    unsigned num_chars_added = 0;

    for (auto it = reshape_queue.begin(); it != reshape_queue.end(); ++it) {
        ReshapeQueueItem item = *it;
        if (item.action == ReshapeQueueItem::kReshapeQueueNextFont) {
            break;
        }

        CHECK_LE((item.start_index_ + item.num_characters_), text_.length());

        if (text_.Is8Bit()) {
            for (unsigned i = 0; i < item.num_characters_; i++) {
                const char hint_char = text_[item.start_index_ + i];
                hint.push_back(hint_char);
                num_chars_added++;
                if (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {
                    return true;
                }
            }
        } else {
            int hint_char;
            UTF16TextIterator iterator(text_.Characters16() + item.start_index_,
                                       item.num_characters_);
            while (iterator.Consume(hint_char)) {
                hint.push_back(hint_char);
                num_chars_added++;
                if (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {
                    return true;
                }
                iterator.Advance();
            }
        }
    }

    return num_chars_added > 0;
}

