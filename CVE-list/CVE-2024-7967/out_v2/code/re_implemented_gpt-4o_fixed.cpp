

class ReshapeQueueItem {
public:
    unsigned long start_index_;
    unsigned long num_characters_;
    int action_;
};

template<typename T>
class Deque {
public:
    bool empty() const;

    class const_iterator {
    public:
        const_iterator& operator++();
        bool operator!=(const const_iterator& other) const;
        const T& operator*() const;
    };

    const_iterator begin() const;
    const_iterator end() const;

    void clear();
    void push_back(const T&);
};

using HintCharList = Deque<wchar_t>;

class Character {
public:
    static bool HasDefiniteScript(unsigned int ch);
};

class UTF16TextIterator {
public:
    UTF16TextIterator(const unsigned short* characters, unsigned long length);
    bool Consume(unsigned int& result);
    void Advance();
};

class Text {
public:
    bool Is8Bit() const;
    unsigned char operator[](unsigned long index) const;
    const unsigned short* Characters16() const;
    unsigned long length() const;
};

class HarfBuzzShaper {
public:
    bool CollectFallbackHintChars(const Deque<ReshapeQueueItem>& reshape_queue, bool needs_hint_list, HintCharList& hint) const;

private:
    Text text_;
    static const int kReshapeQueueNextFont = 0;
};

inline void CHECK_LE(unsigned long a, unsigned long b) {
    (void)a;
    (void)b;
}

bool HarfBuzzShaper::CollectFallbackHintChars(
    const Deque<ReshapeQueueItem>& reshape_queue,
    bool needs_hint_list,
    HintCharList& hint) const {
  if (reshape_queue.empty()) {
    return false;
  }

  hint.clear();
  unsigned long num_chars_added = 0;

  for (auto it = reshape_queue.begin(); it != reshape_queue.end(); ++it) {
    const ReshapeQueueItem& item = *it;
    if (item.action_ == kReshapeQueueNextFont) {
      break;
    }

    CHECK_LE((item.start_index_ + item.num_characters_), text_.length());

    if (text_.Is8Bit()) {
      for (unsigned i = 0; i < item.num_characters_; i++) {
        const wchar_t hint_char = static_cast<wchar_t>(text_[i + item.start_index_]);
        hint.push_back(hint_char);
        num_chars_added++;

        if (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {
          return true;
        }
      }
      continue;
    }

    unsigned int hint_char;
    UTF16TextIterator iterator(text_.Characters16() + item.start_index_, item.num_characters_);

    while (iterator.Consume(hint_char)) {
      hint.push_back(hint_char);
      num_chars_added++;

      if (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {
        return true;
      }

      iterator.Advance();
    }
  }

  return num_chars_added > 0;
}

