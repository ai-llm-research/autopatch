

template <typename T>
class Deque {
public:
    bool empty() const { return true; }
    class iterator {
    public:
        iterator& operator++() { return *this; }
        bool operator!=(const iterator&) const { return false; }
        T& operator*() const { static T t; return t; }
    };

    iterator begin() const { return iterator(); }
    iterator end() const { return iterator(); }
};

class ReshapeQueueItem {
public:
    int action_;
    unsigned long start_index_;
    unsigned long num_characters_;
};

class Character {
public:
    static bool HasDefiniteScript(int advice_char) {
        return false;
    }
};

class HintCharList {
public:
    void resize(unsigned long new_size) {}
    void push_back(int value) {}
};

class HarfBuzzShaper {
public:
    bool CollectFallbackHintChars(
        const Deque<ReshapeQueueItem>& task_list,
        bool requires_hint_list,
        HintCharList& advice) const;
    
private:
    class Text {
    public:
        bool Is8Bit() const;
        char operator[](unsigned long index) const { return 0; }
        const char16_t* Characters16() const { return nullptr; }
        unsigned long length() const { return 0; }
    } text_;
};

class UTF16TextIterator {
public:
    UTF16TextIterator(const char16_t* text, unsigned long length) {}
    bool Consume(int& advice_char) { return false; }
    void Advance() {}
};

bool CHECK_LE(unsigned long a, unsigned long b) { return a <= b; }

bool HarfBuzzShaper::CollectFallbackHintChars(
    const Deque<ReshapeQueueItem>& task_list,
    bool requires_hint_list,
    HintCharList& advice) const {
  
  if (task_list.empty()) {
    return false;
  }

  advice.resize(0);

  unsigned long num_items_added = 0;
  for (auto cursor = task_list.begin(); cursor != task_list.end(); ++cursor) {
    const ReshapeQueueItem& item = *cursor;
    if (item.action_ == 0) {
      break;
    }

    CHECK_LE(item.start_index_, text_.length());
    CHECK_LE(item.num_characters_, text_.length() - item.start_index_);

    if (text_.Is8Bit()) {
      for (unsigned index = 0; index < item.num_characters_; index++) {
        const char advice_char = text_[item.start_index_ + index];
        advice.push_back(advice_char);
        num_items_added++;
        if (!requires_hint_list && Character::HasDefiniteScript(advice_char)) {
          return true;
        }
      }
      continue;
    }

    int advice_char;
    UTF16TextIterator iter(text_.Characters16() + item.start_index_,
                           item.num_characters_);
    while (iter.Consume(advice_char)) {
      advice.push_back(advice_char);
      num_items_added++;
      if (!requires_hint_list && Character::HasDefiniteScript(advice_char)) {
        return true;
      }
      iter.Advance();
    }
  }
  return num_items_added > 0;
}

