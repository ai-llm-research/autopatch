

class ReshapeQueueItem {
public:
    unsigned int start_index_;
    unsigned int num_characters_;
    int action_;
};

template <typename T>
class Deque {
public:
    bool empty() const { return true; }

    class Iterator {
    public:
        Iterator& operator++() { return *this; }
        bool operator!=(const Iterator&) { return false; }
        T& operator*() { static T dummy; return dummy; }
    };

    Iterator begin() const { return Iterator(); }
    Iterator end() const { return Iterator(); }
};

enum { kReshapeQueueNextFont };

class HintCharList {
public:
    void clear() {}
    void push_back(int) {}
};

class UTF16TextIterator {
public:
    UTF16TextIterator(const int*, unsigned) {}
    bool Next(int*) { return false; }
};

class Character {
public:
    static bool HasDefiniteScript(int) { return false; }
};

class Text {
public:
    bool Is8Bit() const { return true; }
    const char* Characters() const { return nullptr; }
    int length() const { return 0; }
};

typedef char UChar;
typedef int UChar32;

class HarfBuzzShaper {
public:
    bool CollectFallbackHintChars(const Deque<ReshapeQueueItem>& reshape_queue,
                                  bool needs_hint_list,
                                  HintCharList& hint) const;

private:
    Text text_;
};

typedef unsigned long size_t; // Stubbing size_t definition

bool HarfBuzzShaper::CollectFallbackHintChars(
    const Deque<ReshapeQueueItem>& reshape_queue,
    bool needs_hint_list,
    HintCharList& hint) const {
  if (reshape_queue.empty()) {
    return false;
  }

  hint.clear();
  size_t num_chars_added = 0;

  for (auto it = reshape_queue.begin(); it != reshape_queue.end(); ++it) {
    const ReshapeQueueItem& item = *it;
    if (item.action_ == kReshapeQueueNextFont) {
      break;
    }

    if ((item.start_index_ + item.num_characters_) > text_.length()) {
        return false;
    }

    if (text_.Is8Bit()) {
      for (unsigned i = 0; i < item.num_characters_; i++) {
        const UChar hint_char = text_.Characters()[item.start_index_ + i];
        hint.push_back(hint_char);
        num_chars_added++;

        if (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {
          return true;
        }
      }
      continue;
    }

    UChar32 hint_char;
    UTF16TextIterator iterator(reinterpret_cast<const UChar32*>(text_.Characters()) + item.start_index_, item.num_characters_);
    while (iterator.Next(&hint_char)) {
      hint.push_back(hint_char);
      num_chars_added++;

      if (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {
        return true;
      }
    }
  }

  return num_chars_added > 0;
}

