{
  "cwe_type": "Out-of-bounds Write",
  "cve_id": "CVE-2024-7967",
  "supplementary_code": "```cpp\nclass PLATFORM_EXPORT HarfBuzzShaper final {\nDISALLOW_NEW();\nusing EmojiMetricsCallback =\nbase::RepeatingCallback<void(unsigned, unsigned)>;\npublic:\n// The optional emoji_metrics_callback argument is a mock metrics reporting\n// function used during tests. Otherwise successful and unsuccessful emoji\n// clusters are reported per Document / WorkerGlobalContext to\n// FontMatchingMetrics.\nexplicit HarfBuzzShaper(\nString text,\nEmojiMetricsCallback emoji_metrics_callback = EmojiMetricsCallback())\n: text_(std::move(text)),\nemoji_metrics_reporter_for_testing_(emoji_metrics_callback) {}\n// Shape a range, defined by the start and end parameters, of the string\n// supplied to the constructor.\n// The start and end positions should represent boundaries where a break may\n// occur, such as at the beginning or end of lines or at element boundaries.\n// If given arbitrary positions the results are not guaranteed to be correct.\n// May be called multiple times; font and direction may vary between calls.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end) const;\n// Shape a range that has already been pre-segmented. Start and end positions\n// must match the positions defined by the ranges and must be at valid break\n// positions.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end,\nconst Vector<RunSegmenter::RunSegmenterRange>&,\nShapeOptions = ShapeOptions()) const;\n// Shape a single range. Start and end positions defined by the range.\nShapeResult* Shape(const Font*,\nTextDirection,\nunsigned start,\nunsigned end,\nconst RunSegmenter::RunSegmenterRange,\nShapeOptions = ShapeOptions()) const;\n// Shape the entire string with a single font and direction.\n// Equivalent to calling the range version with a start offset of zero and an\n// end offset equal to the length.\nShapeResult* Shape(const Font*, TextDirection) const;\nconst String& GetText() const { return text_; }\nunsigned TextLength() const { return text_.length(); }\n// This function is between `Shape` and `SimpleFontData::GlyphForCharacter`.\n//\n// Unlike `Shape`, it works only for one `SimpleFontData`, not `Font`, without\n// cascading nor fallback. Missing glyphs are reported as `.notdef` (0). Also\n// it's a lot less expensive than `Shape`.\n//\n// Unlike `SimpleFontData::GlyphForCharacter`, it shapes, taking locale,\n// script, and OpenType features into account.\nstruct GlyphData {\nunsigned cluster;\nGlyph glyph;\ngfx::PointF advance;\ngfx::PointF offset;\n};\nusing GlyphDataList = Vector<GlyphData, 16>;\nvoid GetGlyphData(const SimpleFontData& font_data,\nconst LayoutLocale& locale,\nUScriptCode script,\nbool is_horizontal,\nGlyphDataList& glyphs);\nenum FallbackFontStage {\n// There were no unshaped variation sequences found, so we don't need to\n// perform second fallback fonts list pass.\nkIntermediate,\nkLast,\n// Found unshaped variation sequences and we are on the first fallback pass,\n// so we are including variation selectors during shaping.\nkIntermediateWithVS,\nkLastWithVS,\n// Found unshaped variation sequences and we are on the second and last\n// fallback pass, so we are ignoring variation selectors during shaping.\nkIntermediateIgnoreVS,\nkLastIgnoreVS\n};\n~HarfBuzzShaper() = default;\nprivate:\nusing HintCharList = FontFallbackIterator::HintCharList;\n// Shapes a single seqment, as identified by the RunSegmenterRange parameter,\n// one or more times taking font fallback into account. The start and end\n// parameters are for the entire text run, not the segment, and are used to\n// determine pre- and post-context for shaping.\nvoid ShapeSegment(RangeContext*,\nconst RunSegmenter::RunSegmenterRange&,\nShapeResult*) const;\nvoid ExtractShapeResults(RangeContext*,\nbool& font_cycle_queued,\nconst ReshapeQueueItem&,\nconst SimpleFontData*,\nUScriptCode,\nCanvasRotationInVertical,\nFallbackFontStage& fallback_stage,\nShapeResult*) const;\nbool CollectFallbackHintChars(const Deque<ReshapeQueueItem>&,\nbool needs_hint_list,\nHintCharList& hint) const;\nvoid CommitGlyphs(RangeContext*,\nconst SimpleFontData* current_font,\nUScriptCode current_run_script,\nCanvasRotationInVertical,\nFallbackFontStage fallback_stage,\nconst BufferSlice&,\nShapeResult*) const;\nvoid CheckTextLen(unsigned start, unsigned length) const;\nvoid CheckTextEnd(unsigned start, unsigned end) const;\nconst String text_;\nEmojiMetricsCallback emoji_metrics_reporter_for_testing_;\n};\n```\n```cpp\nenum ReshapeQueueItemAction {\nkReshapeQueueNextFont,\nkReshapeQueueRange,\nkReshapeQueueReset\n};\n```\n```cpp\nbool Character::HasDefiniteScript(UChar32 character) {\nICUError err;\nUScriptCode hint_char_script = uscript_getScript(character, &err);\nif (!U_SUCCESS(err))\nreturn false;\nreturn hint_char_script != USCRIPT_INHERITED &&\nhint_char_script != USCRIPT_COMMON;\n}\n```",
  "original_code": "```cpp\nbool HarfBuzzShaper::CollectFallbackHintChars(\nconst Deque<ReshapeQueueItem>& reshape_queue,\nbool needs_hint_list,\nHintCharList& hint) const {\nif (reshape_queue.empty()) {\nreturn false;\n}\n// Clear without releasing the capacity to avoid reallocations.\nhint.resize(0);\nsize_t num_chars_added = 0;\nfor (auto it = reshape_queue.begin(); it != reshape_queue.end(); ++it) {\nif (it->action_ == kReshapeQueueNextFont) {\nbreak;\n}\nCHECK_LE((it->start_index_ + it->num_characters_), text_.length());\nif (text_.Is8Bit()) {\nfor (unsigned i = 0; i < it->num_characters_; i++) {\nconst UChar hint_char = text_[it->start_index_ + i];\nhint.push_back(hint_char);\nnum_chars_added++;\n// Determine if we can take a shortcut and not fill the hint list\n// further: We can do that if we do not need a hint list, and we have\n// managed to find a character with a definite script since\n// FontFallbackIterator needs a character with a determined script to\n// perform meaningful system fallback.\nif (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {\nreturn true;\n}\n}\ncontinue;\n}\n// !text_.Is8Bit()...\nUChar32 hint_char;\nUTF16TextIterator iterator(text_.Characters16() + it->start_index_,\nit->num_characters_);\nwhile (iterator.Consume(hint_char)) {\nhint.push_back(hint_char);\nnum_chars_added++;\n// Determine if we can take a shortcut and not fill the hint list\n// further: We can do that if we do not need a hint list, and we have\n// managed to find a character with a definite script since\n// FontFallbackIterator needs a character with a determined script to\n// perform meaningful system fallback.\nif (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {\nreturn true;\n}\niterator.Advance();\n}\n}\nreturn num_chars_added > 0;\n}\n```",
  "vuln_patch": "```cpp\nbool HarfBuzzShaper::CollectFallbackHintChars(\nconst Deque<ReshapeQueueItem>& reshape_queue,\nbool needs_hint_list,\nHintCharList& hint) const {\nif (reshape_queue.empty()) {\nreturn false;\n}\n// Clear without releasing the capacity to avoid reallocations.\nhint.resize(0);\nsize_t num_chars_added = 0;\nfor (auto it = reshape_queue.begin(); it != reshape_queue.end(); ++it) {\nif (it->action_ == kReshapeQueueNextFont) {\nbreak;\n}\nCHECK_LE(it->start_index_, text_.length());\nCHECK_LE(it->num_characters_, text_.length() - start);\nif (text_.Is8Bit()) {\nfor (unsigned i = 0; i < it->num_characters_; i++) {\nconst UChar hint_char = text_[it->start_index_ + i];\nhint.push_back(hint_char);\nnum_chars_added++;\n// Determine if we can take a shortcut and not fill the hint list\n// further: We can do that if we do not need a hint list, and we have\n// managed to find a character with a definite script since\n// FontFallbackIterator needs a character with a determined script to\n// perform meaningful system fallback.\nif (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {\nreturn true;\n}\n}\ncontinue;\n}\n// !text_.Is8Bit()...\nUChar32 hint_char;\nUTF16TextIterator iterator(text_.Characters16() + it->start_index_,\nit->num_characters_);\nwhile (iterator.Consume(hint_char)) {\nhint.push_back(hint_char);\nnum_chars_added++;\n// Determine if we can take a shortcut and not fill the hint list\n// further: We can do that if we do not need a hint list, and we have\n// managed to find a character with a definite script since\n// FontFallbackIterator needs a character with a determined script to\n// perform meaningful system fallback.\nif (!needs_hint_list && Character::HasDefiniteScript(hint_char)) {\nreturn true;\n}\niterator.Advance();\n}\n}\nreturn num_chars_added > 0;\n}\n```",
  "function_name": "HarfBuzzShaper::CollectFallbackHintChars",
  "function_prototype": "bool HarfBuzzShaper::CollectFallbackHintChars(const Deque<ReshapeQueueItem>& reshape_queue, bool needs_hint_list, HintCharList& hint) const",
  "code_semantics": "The code is a function that processes a list of tasks. It checks if the list is empty and returns a negative result if so. It then clears a collection without releasing its capacity. The function iterates over the tasks, stopping if a task with a specific type is encountered. For each task, it verifies that the task's range is within the bounds of a text. It then extracts characters from the text based on the task's range and adds them to the collection. If a character with a specific property is found and a condition is met, the function returns a positive result early. If the text is not in a certain format, a different method is used to extract characters. The function returns a positive result if any characters were added to the collection, otherwise a negative result.",
  "safe_verification_cot": "1. The function CollectFallbackHintChars now safely handles it->start_index_ by checking it independently against text_.length(). 2. The variable it->num_characters_ is now properly checked against the bounds of text_ by ensuring it does not exceed text_.length() - start. 3. The CHECK_LE function is used to validate both it->start_index_ and it->num_characters_ independently, ensuring robust boundary checks.",
  "verification_cot": "1. The function CollectFallbackHintChars does not safely handle it->start_index_ because it only checks the combined value of it->start_index_ + it->num_characters_ against text_.length(), which can lead to an out-of-bounds access if it->start_index_ is already out of bounds. 2. The variable it->num_characters_ is not independently checked against the bounds of text_, allowing for potential out-of-bounds access. 3. The CHECK_LE function is not used to validate it->start_index_ and it->num_characters_ independently, leading to insufficient boundary checks.",
  "vulnerability_related_variables": {
    "it->start_index_": "This variable is used to determine the starting position of a specific segment within a larger sequence of elements. It is essential for accessing and processing a subset of elements from the sequence.",
    "it->num_characters_": "This variable indicates the count of elements in a specific segment starting from a given position within a larger sequence. It is used to control the iteration over the segment's elements.",
    "text_": "This variable holds a sequence of elements that represent a complete set of data to be processed. It provides access to individual elements and supports operations based on the sequence's properties, such as its length and encoding."
  },
  "vulnerability_related_functions": {
    "CollectFallbackHintChars": "The function checks if a list of items is empty and returns false if it is. It clears a list without deallocating its memory. It iterates over a list of items, processing each item until a specific condition is met. For each item, it checks a condition and breaks the loop if true. It processes a range of elements, adding each element to a list. It checks if a shortcut can be taken based on a condition and returns true if so. It returns true if any elements were added to the list.",
    "CHECK_LE": "This function checks if one value is less than or equal to another and typically triggers an error if the condition is not met."
  },
  "root_cause": "Out-of-bounds write due to insufficient boundary checks on start_index_ and num_characters_ in relation to text_.length().",
  "patch_cot": "Step 1: Locate the function CollectFallbackHintChars in the vulnerable code. Step 2: Before accessing text_ using it->start_index_ and it->num_characters_, add a check to ensure it->start_index_ is less than or equal to text_.length(). Step 3: Add another check to ensure it->num_characters_ is less than or equal to text_.length() - it->start_index_. Step 4: Ensure these checks are performed before any operations that use these indices to access text_. Step 5: Test the function to ensure that it no longer allows out-of-bounds access and behaves correctly with valid inputs."
}