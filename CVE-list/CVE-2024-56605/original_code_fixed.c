

typedef int gfp_t;

struct net {};
struct socket {};

struct sock {
    void (*sk_destruct)(struct sock *);
    unsigned long sk_sndtimeo;
    int sk_protocol;
    int sk_state;
};

struct l2cap_chan {};

#define PF_BLUETOOTH 0
#define L2CAP_CONN_TIMEOUT 0
#define BT_OPEN 0
#define SOCK_ZAPPED 0

struct l2cap_proto_struct {
};

static struct l2cap_proto_struct l2cap_proto;

struct list_head {};

struct bt_sock {
    struct list_head accept_q;
};

struct l2cap_pi_struct {
    struct l2cap_chan *chan;
};

static struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
                             struct l2cap_proto_struct *proto, int kern) {
    return (struct sock *)0;
}

static void sock_init_data(struct socket *sock, struct sock *sk) {}

static void INIT_LIST_HEAD(struct list_head *list) {}

static struct bt_sock *bt_sk(struct sock *sk) {
    return (struct bt_sock *)0;
}

static void sock_reset_flag(struct sock *sk, int flag) {}

static struct l2cap_chan *l2cap_chan_create() {
    return (struct l2cap_chan *)0;
}

static void sk_free(struct sock *sk) {}

static void l2cap_chan_hold(struct l2cap_chan *chan) {}

static struct l2cap_pi_struct *l2cap_pi(struct sock *sk) {
    return (struct l2cap_pi_struct *)0;
}

static void l2cap_sock_destruct(struct sock *sk) {}

static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
                                     int proto, gfp_t prio, int kern) {
    struct sock *sk;
    struct l2cap_chan *chan;

    sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);
    if (!sk)
        return (struct sock *)0;

    sock_init_data(sock, sk);
    INIT_LIST_HEAD(&bt_sk(sk)->accept_q);

    sk->sk_destruct = l2cap_sock_destruct;
    sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;

    sock_reset_flag(sk, SOCK_ZAPPED);

    sk->sk_protocol = proto;
    sk->sk_state = BT_OPEN;

    chan = l2cap_chan_create();
    if (!chan) {
        sk_free(sk);
        return (struct sock *)0;
    }

    l2cap_chan_hold(chan);

    l2cap_pi(sk)->chan = chan;

    return sk;
}

