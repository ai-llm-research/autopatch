

struct sock {
    struct sock *sk_receive_queue;
    struct sock *sk_write_queue;
    void (*sk_destruct)(struct sock *sk);
    int sk_sndtimeo;
    int sk_protocol;
    int sk_state;
};

struct net {};
struct socket {};
typedef int gfp_t;

#define PF_BLUETOOTH 0
#define SOCK_ZAPPED 0
#define L2CAP_CONN_TIMEOUT 0
#define BT_OPEN 0

struct l2cap_proto {};

struct l2cap_chan {};

struct sock *sk_alloc(struct net *net, int family, gfp_t priority, struct l2cap_proto *proto, int kern) {
    return (struct sock *)0;
}

void sock_init_data_uid(struct socket *sock, struct sock *sk, int uid) {}

int current_uid() {
    return 0;
}

void skb_queue_head_init(struct sock **queue) {}

void sock_reset_flag(struct sock *sk, int flag) {}

void sk_free(struct sock *sk) {}

void (*l2cap_sock_destruct)(struct sock *sk) = 0;

struct l2cap_chan *l2cap_chan_create() {
    return (struct l2cap_chan *)0;
}

void l2cap_chan_hold(struct l2cap_chan *chan) {}

struct l2cap_proto l2cap_proto;

struct l2cap_private {
    struct l2cap_chan *chan;
};

static inline struct l2cap_private *l2cap_pi(struct sock *sk) {
    return (struct l2cap_private *)0;
}

static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
                                     int proto, gfp_t prio, int kern)
{
    struct sock *sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);
    if (!sk)
        return (struct sock *)0;

    sock_init_data_uid(sock, sk, current_uid());

    skb_queue_head_init(&sk->sk_receive_queue);
    skb_queue_head_init(&sk->sk_write_queue);

    sk->sk_destruct = l2cap_sock_destruct;

    sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;

    sock_reset_flag(sk, SOCK_ZAPPED);

    sk->sk_protocol = proto;

    sk->sk_state = BT_OPEN;

    struct l2cap_chan *chan = l2cap_chan_create();
    if (!chan) {
        sk_free(sk);
        return (struct sock *)0;
    }

    l2cap_chan_hold(chan);

    l2cap_pi(sk)->chan = chan;

    return sk;
}

