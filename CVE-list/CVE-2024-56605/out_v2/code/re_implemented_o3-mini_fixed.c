

struct sock {
    void (*sk_destruct)(struct sock *sk);
    int sk_sndtimeo;
    int sk_protocol;
    int sk_state;
};

struct net;
struct socket;
struct l2cap_chan;
typedef int gfp_t;

struct sock *sk_alloc(struct net *net, int pf, gfp_t prio, void *proto, int kern);
void sock_init_data_uid(struct socket *sock, struct sock *sk, int uid);
int make_kuid(void *ns, int uid);
void INIT_LIST_HEAD(void *list);
void sock_reset_flag(struct sock *sk, int flag);
struct l2cap_chan *l2cap_chan_create(void);
void l2cap_chan_hold(struct l2cap_chan *chan);
void sk_free(struct sock *sk);
void l2cap_sock_destruct(struct sock *sk);
void *l2cap_pi(struct sock *sk);

#define PF_BLUETOOTH 0
#define L2CAP_CONN_TIMEOUT 0
#define SOCK_ZAPPED 0
#define BT_OPEN 0

#define NULL ((void*)0)

static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
                                      int proto, gfp_t prio, int kern)
{
    struct sock *sk;
    struct l2cap_chan *chan;
    extern void *l2cap_proto;
    extern void *init_user_ns;

    sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);
    
    if (!sk)
        return NULL;

    sock_init_data_uid(sock, sk, make_kuid(&init_user_ns, 0));

    struct dummy {
        void *rx_busy;
        struct l2cap_chan *chan;
    };

    INIT_LIST_HEAD(&((struct dummy *)l2cap_pi(sk))->rx_busy);
    
    sk->sk_destruct = l2cap_sock_destruct;
    
    sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;
    
    sock_reset_flag(sk, SOCK_ZAPPED);
    
    sk->sk_protocol = proto;
    
    sk->sk_state = BT_OPEN;
    
    chan = l2cap_chan_create();
    
    if (!chan) {
        sk_free(sk);
        return NULL;
    }
    
    l2cap_chan_hold(chan);
    
    ((struct dummy *)l2cap_pi(sk))->chan = chan;
    
    return sk;
}

