
typedef int gfp_t;
typedef int uid_t;

struct list_head {
    struct list_head *next, *prev;
};

static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list->next = list;
    list->prev = list;
}

struct sock;
struct net {};
struct socket {};
struct sock {
    struct list_head sk_accept_queue;
    void (*sk_destruct)(struct sock *sk);
    unsigned long sk_sndtimeo;
    struct proto *sk_prot;
    int sk_state;
};

struct proto {};

#define AF_L2CAP 0
#define GLOBAL_ROOT_UID 0
#define L2CAP_CONN_TIMEOUT 0

enum {
    BT_OPEN = 0,
    SOCK_ZAPPED = 1
};

struct l2cap_chan {};

struct l2cap_pinfo {
    struct l2cap_chan *chan;
};

static inline void sock_init_data_uid(struct socket *sock, struct sock *sk, uid_t uid) {}

static inline void sock_reset_flag(struct sock *sk, int flag) {}

static struct sock *sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
    return (struct sock *)malloc(sizeof(struct sock));
}

static void sk_free(struct sock *sk) 
{
    free(sk);
}

static struct l2cap_chan *l2cap_chan_create(void) 
{
    return (struct l2cap_chan *)malloc(sizeof(struct l2cap_chan));
}

static void l2cap_chan_hold(struct l2cap_chan *chan) {}

static struct proto l2cap_proto;

static struct l2cap_pinfo *l2cap_pi(struct sock *sk)
{
    return (struct l2cap_pinfo *)malloc(sizeof(struct l2cap_pinfo));
}

static void l2cap_sock_destruct(struct sock *sk) {}

static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
                                     int proto, gfp_t prio, int kern)
{
    struct sock *sk = sk_alloc(net, AF_L2CAP, prio, &l2cap_proto, kern);
    if (!sk)
        return (struct sock *)0;

    sock_init_data_uid(sock, sk, GLOBAL_ROOT_UID);
    INIT_LIST_HEAD(&sk->sk_accept_queue);
    sk->sk_destruct = l2cap_sock_destruct;
    sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;
    sock_reset_flag(sk, SOCK_ZAPPED);
    sk->sk_prot = &l2cap_proto;
    sk->sk_state = BT_OPEN;

    struct l2cap_chan *chan = l2cap_chan_create();
    if (!chan) {
        sk_free(sk);
        return (struct sock *)0;
    }

    l2cap_chan_hold(chan);
    l2cap_pi(sk)->chan = chan;

    return sk;
}
