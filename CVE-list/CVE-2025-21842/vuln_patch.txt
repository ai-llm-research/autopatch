```c
static int init_user_queue(struct process_queue_manager *pqm,
				struct kfd_node *dev, struct queue **q,
				struct queue_properties *q_properties,
				unsigned int qid)
{
	int retval;

	/* Doorbell initialized in user space*/
	q_properties->doorbell_ptr = NULL;
	q_properties->exception_status = KFD_EC_MASK(EC_QUEUE_NEW);

	/* let DQM handle it*/
	q_properties->vmid = 0;
	q_properties->queue_id = qid;

	retval = init_queue(q, q_properties);
	if (retval != 0)
		return retval;

	(*q)->device = dev;
	(*q)->process = pqm->process;

	if (dev->kfd->shared_resources.enable_mes) {
		retval = amdgpu_amdkfd_alloc_gtt_mem(dev->adev,
						AMDGPU_MES_GANG_CTX_SIZE,
						&(*q)->gang_ctx_bo,
						&(*q)->gang_ctx_gpu_addr,
						&(*q)->gang_ctx_cpu_ptr,
						false);
		if (retval) {
			pr_err("failed to allocate gang context bo\n");
			goto cleanup;
		}
		memset((*q)->gang_ctx_cpu_ptr, 0, AMDGPU_MES_GANG_CTX_SIZE);

		/* Starting with GFX11, wptr BOs must be mapped to GART for MES to determine work
		 * on unmapped queues for usermode queue oversubscription (no aggregated doorbell)
		 */
		if (((dev->adev->mes.sched_version & AMDGPU_MES_API_VERSION_MASK)
		    >> AMDGPU_MES_API_VERSION_SHIFT) >= 2) {
			if (dev->adev != amdgpu_ttm_adev(q_properties->wptr_bo->tbo.bdev)) {
				pr_err("Queue memory allocated to wrong device\n");
				retval = -EINVAL;
				goto free_gang_ctx_bo;
			}

			retval = amdgpu_amdkfd_map_gtt_bo_to_gart(q_properties->wptr_bo,
								  &(*q)->wptr_bo_gart);
			if (retval) {
				pr_err("Failed to map wptr bo to GART\n");
				goto free_gang_ctx_bo;
			}
		}
	}

	pr_debug("PQM After init queue");
	return 0;

free_gang_ctx_bo:
	amdgpu_amdkfd_free_gtt_mem(dev->adev, &(*q)->gang_ctx_bo);
cleanup:
	uninit_queue(*q);
	*q = NULL;
	return retval;
}
```
