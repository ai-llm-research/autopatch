

struct process_queue_manager {
    void* process;
};

struct kfd_node {
    struct kfd_device* kfd;
    struct amdgpu_device* adev;
};

struct kfd_device {
    struct shared_resources_struct {
        int enable_mes;
    } shared_resources;
};

struct amdgpu_device {
    struct mes_struct {
        int sched_version;
    } mes;
};

struct queue {
    struct kfd_node* device;
    void* process;
    void* gang_ctx_bo;
    void* gang_ctx_gpu_addr;
    void* gang_ctx_cpu_ptr;
    void* wptr_bo_gart;
};

struct queue_properties {
    void* doorbell_ptr;
    int exception_status;
    int vmid;
    unsigned int queue_id;
    struct wptr_bo_struct {
        struct tbo_struct {
            void* bdev;
        } tbo;
    }* wptr_bo;
};

typedef unsigned long size_t;

int init_queue(struct queue** q, struct queue_properties* q_properties) {
    return 0;
}

void uninit_queue(struct queue* q) {}

void pr_err(const char* msg) {}

void pr_debug(const char* msg) {}

int amdgpu_amdkfd_alloc_gtt_mem(struct amdgpu_device* adev, size_t size,
                                void** bo, void** gpu_addr, void** cpu_ptr,
                                int flag) {
    return 0;
}

void amdgpu_amdkfd_free_gtt_mem(struct amdgpu_device* adev, void* bo) {}

int amdgpu_amdkfd_map_gtt_bo_to_gart(struct wptr_bo_struct* wptr_bo,
                                     void** wptr_bo_gart) {
    return 0;
}

struct amdgpu_device* amdgpu_ttm_adev(void* bdev) {
    return 0;
}

void memset(void* ptr, int value, size_t num) {}

#define NULL ((void*)0)
#define false 0

static int init_user_queue(struct process_queue_manager *pqm,
                           struct kfd_node *dev, struct queue **q,
                           struct queue_properties *q_properties,
                           unsigned int qid) {
    int retval;

    q_properties->doorbell_ptr = NULL;
    q_properties->exception_status = 0;
    q_properties->vmid = 0;
    q_properties->queue_id = qid;

    retval = init_queue(q, q_properties);
    if (retval != 0)
        return retval;

    (*q)->device = dev;
    (*q)->process = pqm->process;

    if (dev->kfd->shared_resources.enable_mes) {
        retval = amdgpu_amdkfd_alloc_gtt_mem(dev->adev,
                   0,
                   &(*q)->gang_ctx_bo,
                   &(*q)->gang_ctx_gpu_addr,
                   &(*q)->gang_ctx_cpu_ptr,
                   false);
        if (retval) {
            pr_err("failed to allocate gang context bo\n");
            goto cleanup;
        }

        memset((*q)->gang_ctx_cpu_ptr, 0, 0);
        
        if (((dev->adev->mes.sched_version & 0)
            >> 0) >= 2) {
            if (dev->adev != amdgpu_ttm_adev(q_properties->wptr_bo->tbo.bdev)) {
                pr_err("Queue memory allocated to wrong device\n");
                retval = -1;
                goto free_gang_ctx_bo;
            }

            retval = amdgpu_amdkfd_map_gtt_bo_to_gart(q_properties->wptr_bo,
                                                      &(*q)->wptr_bo_gart);
            if (retval) {
                pr_err("Failed to map wptr bo to GART\n");
                goto free_gang_ctx_bo;
            }
        }
    }

    pr_debug("PQM After init queue");
    return 0;

free_gang_ctx_bo:
    amdgpu_amdkfd_free_gtt_mem(dev->adev, (*q)->gang_ctx_bo);
cleanup:
    uninit_queue(*q);
    *q = NULL;
    return retval;
}

