

struct process_queue_manager {
    void *process;
};

struct kfd_node {
    struct kfd {
        struct shared_resources {
            int enable_mes;
        } shared_resources;
    } *kfd;
    struct adev {
        struct mes {
            int sched_version;
        } mes;
    } *adev;
};

struct queue_properties {
    void *doorbell_ptr;
    int exception_status;
    int vmid;
    unsigned int queue_id;
    struct wptr_bo {
        struct tbo {
            struct bdev {
                int dummy;
            } bdev;
        } tbo;
    } *wptr_bo;
};

struct queue {
    struct kfd_node *device;
    void *process;
    void *gang_ctx_bo;
    unsigned char *gang_ctx_cpu_ptr;
    unsigned long gang_ctx_gpu_addr;
    void *wptr_bo_gart;
};

#define NULL ((void*)0)

int init_queue(struct queue **job, struct queue_properties *job_props) {
    return 0;
}

int amdgpu_amdkfd_alloc_gtt_mem(struct adev *adev, int size, void **bo, unsigned long *gpu_addr, unsigned char **cpu_ptr, int flag) {
    *bo = NULL;
    *cpu_ptr = NULL;
    return 0;
}

void pr_err(const char *msg) {}

void pr_debug(const char *msg) {}

#define KFD_EC_MASK(x) (x)

#define EC_QUEUE_NEW 1

#define AMKGPU_MES_GANG_CTX_SIZE 128

#define AMDGPU_MES_API_VERSION_MASK 0xFFFF

#define AMDGPU_MES_API_VERSION_SHIFT 0

int amdgpu_ttm_adev(struct bdev *bdev) {
    return 0;
}

int amdgpu_amdkfd_map_gtt_bo_to_gart(struct wptr_bo *wptr_bo, void **gart) {
    return 0;
}

void amdgpu_amdkfd_free_gtt_mem(struct adev *adev, void **bo) {}

void uninit_queue(struct queue *job) {}

static int init_user_queue(struct process_queue_manager *session_mgr,
                struct kfd_node *node, struct queue **job,
                struct queue_properties *job_props,
                unsigned int job_id)
{          
    int status;

    job_props->doorbell_ptr = NULL;
    job_props->exception_status = KFD_EC_MASK(EC_QUEUE_NEW);

    job_props->vmid = 0; 
    job_props->queue_id = job_id;

    status = init_queue(job, job_props);
    if (status != 0)
        return status;

    (*job)->device = node;
    (*job)->process = session_mgr->process;

    if (node->kfd->shared_resources.enable_mes) {
        status = amdgpu_amdkfd_alloc_gtt_mem(node->adev,
                        AMKGPU_MES_GANG_CTX_SIZE,
                        &(*job)->gang_ctx_bo,
                        &(*job)->gang_ctx_gpu_addr,
                        &(*job)->gang_ctx_cpu_ptr,
                        0);  // false is typically represented as 0 in C
        if (status) {
            pr_err("failed to allocate gang context bo\n");
            goto cleanup;
        }

        struct bdev temp_bdev = job_props->wptr_bo->tbo.bdev;
        if (((node->adev->mes.sched_version & AMDGPU_MES_API_VERSION_MASK)
            >> AMDGPU_MES_API_VERSION_SHIFT) >= 2) {
            if (node->adev != (struct adev*)amdgpu_ttm_adev(&temp_bdev)) { // assume amdgpu_ttm_adev returns a pointer
                pr_err("Queue memory allocated to wrong device\n");
                status = -1;
                goto free_gang_ctx_bo;
            }

            status = amdgpu_amdkfd_map_gtt_bo_to_gart(job_props->wptr_bo,
                                  &(*job)->wptr_bo_gart);
            if (status) {
                pr_err("Failed to map wptr bo to GART\n");
                goto free_gang_ctx_bo;
            }
        }
    }

    pr_debug("PQM After init queue");
    return 0;

free_gang_ctx_bo:
    amdgpu_amdkfd_free_gtt_mem(node->adev, &(*job)->gang_ctx_bo);
cleanup:
    uninit_queue(*job);
    *job = NULL;
    return status;

}

