

struct bpf_hrtimer {
    struct {
        struct {
            int delete_work;
        } cb;
    } cb;
};

void* __bpf_async_cancel_and_free(void* userInput) {
    return 0;
}

typedef int bool;

bool this_cpu_read(int hrtimer_running) {
    return 0;
}

void queue_work(int system_unbound_wq, int *delete_work) {
}

void bpf_timer_delete_work(int *delete_work) {
}

void bpf_timer_cancel_and_free(void *userInput) {
    struct bpf_hrtimer *userSession;

    userSession = (struct bpf_hrtimer *)__bpf_async_cancel_and_free(userInput);

    if (!userSession)
        return;

    if (this_cpu_read(0))
        queue_work(0, &userSession->cb.cb.delete_work);
    else 
        bpf_timer_delete_work(&userSession->cb.cb.delete_work);
}

