{
 "supplementary_code": "```c\nstruct rcar_pcie_endpoint {\nstruct rcar_pcie pcie;\nphys_addr_t *ob_mapped_addr;\nstruct pci_epc_mem_window *ob_window;\nu8 max_functions;\nunsigned int bar_to_atu[MAX_NR_INBOUND_MAPS];\nunsigned long *ib_window_map;\nu32 num_ib_windows;\nu32 num_ob_windows;\n};\n```\n```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct rcar_pcie {\nstruct device *dev;\nvoid __iomem *base;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\n#define RCAR_PCI_MAX_RESOURCES 4\n```\n```c\n#define IORESOURCE_MEM 0x00000200\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n#define EIO 5 /* I/O error */\n```\n```c\n#define devm_request_mem_region(dev,start,n,name) \\\n__devm_request_region(dev, &iomem_resource, (start), (n), (name))\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n",
 "function_prototype": "static int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev)",
 "re_implemented_code": "\n```c\nstatic int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev) {\n// Get the pointer to the rcar_pcie structure from the endpoint\nstruct rcar_pcie *pci = &ep->pcie;\n// Declare a character array to store the name of the outbound resource\nchar ob_res_name[32];\n// Declare a pointer to a resource structure\nstruct resource *ob_res;\n// Initialize a counter for the number of outbound windows\nep->num_ob_windows = 0;\n// Loop through each possible outbound resource\nfor (int i = 0; i < RCAR_PCIE_MAX_RESOURCES && ep->num_ob_windows < MAX_OB_WINDOWS; ++i) {\n// Format the name of the outbound resource based on the index\nsnprintf(ob_res_name, sizeof(ob_res_name), \"%s-ob%d\", pdev->name, i);\n// Retrieve the resource by name from the platform device\nob_res = platform_get_resource(pdev, IORESOURCE_MEM, i);\n// Check if the resource was not found\nif (!ob_res) {\n// Log an error message indicating the missing outbound window\ndev_err(pci->dev, \"Outbound window %s not available\\n\", ob_res_name);\n// Return an error code for invalid argument\nreturn -EINVAL;\n}\n// Attempt to request the memory region for the resource\nif (!devm_request_mem_region(pci->dev, ob_res->start, resource_size(ob_res), ob_res_name)) {\n// Log an error message indicating the failure to request the memory region\ndev_err(pci->dev, \"Failed to request outbound mem region for %s\\n\", ob_res_name);\n// Return an error code for I/O error\nreturn -EIO;\n}\n// Set the physical base address of the outbound window\nep->ob_mapped_addr[i] = ob_res->start;\n// Set the size of the outbound window\nep->ob_window[i].page_size = resource_size(ob_res);\nep->ob_window[i].phys_offset = 0;\nep->ob_window[i].cpu_addr = (void *)ob_res->start;\nep->ob_window[i].len = resource_size(ob_res);\n// Increment the outbound window count\nep->num_ob_windows++;\n}\n// Update the number of outbound windows in the endpoint structure\nreturn 0;\n}\n",
 "is_vulnerable": true
}