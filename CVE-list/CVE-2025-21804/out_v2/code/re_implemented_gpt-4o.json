{
 "supplementary_code": "```c\nstruct rcar_pcie_endpoint {\nstruct rcar_pcie pcie;\nphys_addr_t *ob_mapped_addr;\nstruct pci_epc_mem_window *ob_window;\nu8 max_functions;\nunsigned int bar_to_atu[MAX_NR_INBOUND_MAPS];\nunsigned long *ib_window_map;\nu32 num_ib_windows;\nu32 num_ob_windows;\n};\n```\n```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct rcar_pcie {\nstruct device *dev;\nvoid __iomem *base;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\n#define RCAR_PCI_MAX_RESOURCES 4\n```\n```c\n#define IORESOURCE_MEM 0x00000200\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n#define EIO 5 /* I/O error */\n```\n```c\n#define devm_request_mem_region(dev,start,n,name) \\\n__devm_request_region(dev, &iomem_resource, (start), (n), (name))\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n",
 "function_prototype": "static int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev)",
 "re_implemented_code": "\nstatic int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev) {\n// Get the pointer to the rcar_pcie structure from the endpoint\nstruct rcar_pcie *pcie = &ep->pcie;\n// Declare a character array to store the name of the outbound resource\nchar name[16];\n// Declare a pointer to a resource structure\nstruct resource *res;\n// Initialize a counter for the number of outbound windows\nint num_ob_windows = 0;\n// Loop through each possible outbound resource\nfor (int i = 0; i < RCAR_PCI_MAX_RESOURCES; i++) {\n// Format the name of the outbound resource based on the index\nsnprintf(name, sizeof(name), \"ob%d\", i);\n// Retrieve the resource by name from the platform device\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\n// Check if the resource was not found\nif (!res) {\n// Log an error message indicating the missing outbound window\ndev_err(pcie->dev, \"missing outbound window %s\\n\", name);\n// Return an error code for invalid argument\nreturn -EINVAL;\n}\n// Attempt to request the memory region for the resource\nif (!devm_request_mem_region(pcie->dev, res->start, resource_size(res), res->name)) {\n// Log an error message indicating the failure to request the memory region\ndev_err(pcie->dev, \"failed to request mem region for %s\\n\", res->name);\n// Return an error code for I/O error\nreturn -EIO;\n}\n// Set the physical base address of the outbound window\nep->ob_window[i].phys_base = res->start;\n// Set the size of the outbound window\nep->ob_window[i].size = resource_size(res);\n// Set the page size of the outbound window to the size of the window\nep->ob_window[i].page_size = resource_size(res);\n// Increment the number of outbound windows\nnum_ob_windows++;\n}\n// Update the number of outbound windows in the endpoint structure\nep->num_ob_windows = num_ob_windows;\n// Return success\nreturn 0;\n}\n",
 "is_vulnerable": false
}