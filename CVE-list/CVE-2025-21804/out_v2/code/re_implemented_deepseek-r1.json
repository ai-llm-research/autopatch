{
 "supplementary_code": "```c\nstruct rcar_pcie_endpoint {\nstruct rcar_pcie pcie;\nphys_addr_t *ob_mapped_addr;\nstruct pci_epc_mem_window *ob_window;\nu8 max_functions;\nunsigned int bar_to_atu[MAX_NR_INBOUND_MAPS];\nunsigned long *ib_window_map;\nu32 num_ib_windows;\nu32 num_ob_windows;\n};\n```\n```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct rcar_pcie {\nstruct device *dev;\nvoid __iomem *base;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\n#define RCAR_PCI_MAX_RESOURCES 4\n```\n```c\n#define IORESOURCE_MEM 0x00000200\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n#define EIO 5 /* I/O error */\n```\n```c\n#define devm_request_mem_region(dev,start,n,name) \\\n__devm_request_region(dev, &iomem_resource, (start), (n), (name))\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n",
 "function_prototype": "static int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev)",
 "re_implemented_code": "\n```c\nstatic int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev) {\n// Get the pointer to the rcar_pcie structure from the endpoint\nstruct rcar_pcie *pcie = &ep->pcie;\n// Declare a character array to store the name of the outbound resource\nchar res_name[NAME_SIZE];\n// Declare a pointer to a resource structure\nstruct resource *res;\n// Initialize a counter for the number of outbound windows\nint i;\n// Loop through each possible outbound resource\nfor (i = 0; i < ep->num_ob_windows; ++i) {\n// Format the name of the outbound resource based on the index\nsnprintf(res_name, sizeof(res_name), \"out%d\", i);\n// Retrieve the resource by name from the platform device\nres = platform_get_resource(pdev, IORESOURCE_MEM, res_name);\n// Check if the resource was not found\nif (!res) {\n// Log an error message indicating the missing outbound window\ndev_err(pcie->dev, \"Missing outbound window %d\\n\", i);\n// Return an error code for invalid argument\nreturn -EINVAL;\n}\n// Attempt to request the memory region for the resource\nif (!request_mem_region(res->start, resource_size(res), res_name)) {\n// Log an error message indicating the failure to request the memory region\ndev_err(pcie->dev, \"Failed to request mem region for %s\\n\", res_name);\n// Return an error code for I/O error\nreturn -EIO;\n}\n// Set the physical base address of the outbound window\nep->ob_window[i]->phys_base = res->start;\n// Set the size of the outbound window\nep->ob_window[i]->size = resource_size(res);\n// Set the page size of the outbound window to the size of the window\nep->ob_window[i]->page_size = ep->ob_window[i]->size;\n}\n// Update the number of outbound windows in the endpoint structure\nep->num_ob_windows = i;\n// Return success\nreturn 0;\n}\n```\n",
 "is_vulnerable": "N/A"
}