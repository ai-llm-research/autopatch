

typedef unsigned long resource_size_t;
typedef unsigned long size_t;

struct resource {
    resource_size_t start;
    resource_size_t end;
};

struct ob_window {
    resource_size_t phys_base;
    resource_size_t size;
    resource_size_t page_size;
};

struct rcar_pcie {
    void *dev;
};

struct rcar_pcie_endpoint {
    struct rcar_pcie pcie;
    unsigned int bar_to_atu[32];
    struct ob_window ob_window[32];
    int num_ob_windows;
};

struct platform_device {
    // Placeholder for platform device structure
};

#define RCAR_PCI_MAX_RESOURCES 32
#define IORESOURCE_MEM 1

int snprintf(char *str, size_t size, const char *format, ...);
struct resource *platform_get_resource_byname(struct platform_device *pdev, unsigned int type, const char *name);
void dev_err(void *dev, const char *fmt, ...);
resource_size_t resource_size(const struct resource *res);
int devm_request_mem_region(void *dev, resource_size_t start, resource_size_t n, const char *name);

static int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep,
                                           struct platform_device *pdev)
{
    struct rcar_pcie *pcie = &ep->pcie;
    char name[32];
    struct resource *res;
    int count = 0;
    int i;

    for (i = 0; i < RCAR_PCI_MAX_RESOURCES; i++) {
        snprintf(name, sizeof(name), "ob_range%d", i);
        res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);

        if (!res) {
            dev_err(pcie->dev, "Missing outbound window: %s\n", name);
            return -22; // -EINVAL
        }

        if (!devm_request_mem_region(pcie->dev, res->start, resource_size(res), name)) {
            dev_err(pcie->dev, "Failed to request region for %s\n", name);
            return -5; // -EIO
        }

        ep->bar_to_atu[count] = (unsigned int)res->start;
        ep->ob_window[count].phys_base = res->start;
        ep->ob_window[count].size = resource_size(res);
        ep->ob_window[count].page_size = resource_size(res);

        count++;
    }

    ep->num_ob_windows = count;
    return 0;
}

