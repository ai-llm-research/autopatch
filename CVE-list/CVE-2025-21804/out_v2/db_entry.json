{
  "cwe_type": "Return of Stack Variable Address After Scope",
  "cve_id": "CVE-2025-21804",
  "supplementary_code": "```c\nstruct rcar_pcie_endpoint {\nstruct rcar_pcie pcie;\nphys_addr_t *ob_mapped_addr;\nstruct pci_epc_mem_window *ob_window;\nu8 max_functions;\nunsigned int bar_to_atu[MAX_NR_INBOUND_MAPS];\nunsigned long *ib_window_map;\nu32 num_ib_windows;\nu32 num_ob_windows;\n};\n```\n```c\nstruct platform_device {\nconst char *name;\nint id;\nbool id_auto;\nstruct device dev;\nu64 platform_dma_mask;\nstruct device_dma_parameters dma_parms;\nu32 num_resources;\nstruct resource *resource;\nconst struct platform_device_id *id_entry;\n/*\n* Driver name to force a match. Do not set directly, because core\n* frees it. Use driver_set_override() to set or clear it.\n*/\nconst char *driver_override;\n/* MFD cell pointer */\nstruct mfd_cell *mfd_cell;\n/* arch specific additions */\nstruct pdev_archdata archdata;\n};\n```\n```c\nstruct rcar_pcie {\nstruct device *dev;\nvoid __iomem *base;\n};\n```\n```c\nstruct resource {\nresource_size_t start;\nresource_size_t end;\nconst char *name;\nunsigned long flags;\nunsigned long desc;\nstruct resource *parent, *sibling, *child;\n};\n```\n```c\n#define RCAR_PCI_MAX_RESOURCES 4\n```\n```c\n#define IORESOURCE_MEM 0x00000200\n```\n```c\n#define EINVAL 22 /* Invalid argument */\n#define EIO 5 /* I/O error */\n```\n```c\n#define devm_request_mem_region(dev,start,n,name) \\\n__devm_request_region(dev, &iomem_resource, (start), (n), (name))\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```\n```c\n#define dev_err(dev, fmt, ...) \\\ndev_printk_index_wrap(_dev_err, KERN_ERR, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\nreturn res->end - res->start + 1;\n}\n```",
  "original_code": "```c\nstatic int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev)\n{\nstruct rcar_pcie *pcie = &ep->pcie;\nchar outbound_name[10];\nstruct resource *res;\nunsigned int i = 0;\nep->num_ob_windows = 0;\nfor (i = 0; i < RCAR_PCI_MAX_RESOURCES; i++) {\nsprintf(outbound_name, \"memory%u\", i);\nres = platform_get_resource_byname(pdev,\nIORESOURCE_MEM,\noutbound_name);\nif (!res) {\ndev_err(pcie->dev, \"missing outbound window %u\\n\", i);\nreturn -EINVAL;\n}\nif (!devm_request_mem_region(&pdev->dev, res->start,\nresource_size(res),\noutbound_name)) {\ndev_err(pcie->dev, \"Cannot request memory region %s.\\n\",\noutbound_name);\nreturn -EIO;\n}\nep->ob_window[i].phys_base = res->start;\nep->ob_window[i].size = resource_size(res);\n/* controller doesn't support multiple allocation\n* from same window, so set page_size to window size\n*/\nep->ob_window[i].page_size = resource_size(res);\n}\nep->num_ob_windows = i;\nreturn 0;\n}\n```",
  "vuln_patch": "```c\nstatic int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep,\nstruct platform_device *pdev)\n{\nstruct rcar_pcie *pcie = &ep->pcie;\nchar outbound_name[10];\nstruct resource *res;\nunsigned int i = 0;\nep->num_ob_windows = 0;\nfor (i = 0; i < RCAR_PCI_MAX_RESOURCES; i++) {\nsprintf(outbound_name, \"memory%u\", i);\nres = platform_get_resource_byname(pdev,\nIORESOURCE_MEM,\noutbound_name);\nif (!res) {\ndev_err(pcie->dev, \"missing outbound window %u\\n\", i);\nreturn -EINVAL;\n}\nif (!devm_request_mem_region(&pdev->dev, res->start,\nresource_size(res),\nres->name)) {\ndev_err(pcie->dev, \"Cannot request memory region %s.\\n\",\noutbound_name);\nreturn -EIO;\n}\nep->ob_window[i].phys_base = res->start;\nep->ob_window[i].size = resource_size(res);\n/* controller doesn't support multiple allocation\n* from same window, so set page_size to window size\n*/\nep->ob_window[i].page_size = resource_size(res);\n}\nep->num_ob_windows = i;\nreturn 0;\n}\n```",
  "function_name": "rcar_pcie_parse_outbound_ranges",
  "function_prototype": "static int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep, struct platform_device *pdev)",
  "code_semantics": "The function initializes a counter for outbound memory windows. It loops through a set number of potential memory resources, constructing a name for each. It attempts to find each resource by name. If a resource is not found, it logs an error and exits with an error code. If a resource is found, it tries to reserve the memory region. If this reservation fails, it logs an error and exits with an error code. If successful, it records the starting address, size, and page size of the memory region in a data structure. It updates the count of successfully configured memory windows.",
  "safe_verification_cot": "1. The devm_request_mem_region function is called with res->name, which is part of the resource structure and not a stack-allocated variable, ensuring safe handling. 2. The outbound_name variable is not used as an argument to devm_request_mem_region, preventing the return of a stack variable address after its scope ends. 3. The use of res->name ensures that the memory region is accessed safely, as it is not dependent on the stack-allocated outbound_name.",
  "verification_cot": "1. The devm_request_mem_region function is called with outbound_name, a stack-allocated variable, which is not safe because the address of this variable could be returned after its scope ends. 2. The outbound_name variable is used directly as an argument to devm_request_mem_region, which could lead to undefined behavior if the memory region is accessed after the function returns. 3. The code does not use res->name, which is a safer alternative as it is part of the resource structure and not a stack-allocated variable.",
  "vulnerability_related_variables": {
    "outbound_name": "This variable is a temporary storage for a formatted string that represents a memory resource name. It is constructed by appending a numeric identifier to a base string. The formatted string is used to identify and request specific memory resources and to log error messages if the requests fail.",
    "res->name": "This field is part of a data structure that represents a memory resource. It is used to store the name of the resource, which is utilized by functions to identify and manage the resource. The name is crucial for matching and retrieving the correct resource from a collection of resources."
  },
  "vulnerability_related_functions": {
    "devm_request_mem_region": "This function requests a specific memory region for a device. It takes the device, the starting address of the memory region, the size of the memory region, and the name of the memory region as parameters. It checks if the memory region can be allocated for the device, and if not, it returns an error. The function ensures that the specified memory region is reserved for the device's use, preventing other parts of the system from using it."
  },
  "root_cause": "The use of a stack-allocated variable (outbound_name) as an argument to devm_request_mem_region, leading to the return of a stack variable address after its scope ends.",
  "patch_cot": "1. First, identify where the stack-allocated variable 'outbound_name' is being used in the function 'devm_request_mem_region'.\n2. Replace the use of 'outbound_name' with a more persistent variable, such as 'res->name', which is not stack-allocated and remains valid beyond the function's scope.\n3. Ensure that all instances where 'outbound_name' was used in a similar context are replaced with a non-stack-allocated variable to prevent similar vulnerabilities."
}