{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic char *sqfs_resolve_symlink(struct squashfs_symlink_inode *sym,\nconst char *user_input)\n{\nchar *user_buffer, *source;\nu32 offset;\noffset = get_unaligned_le32(&sym->symlink_size);\nsource = malloc(offset + 1);\nif (!source)\nreturn NULL;\n/*\n* There is no trailling null byte in the symlink's target path, so a\n* copy is made and a '\\0' is added at its end.\n*/\nsource[offset] = '\\0';\n/* Get target name (relative path) */\nstrncpy(source, sym->symlink, offset);\n/* Relative -> absolute path conversion */\nuser_buffer = sqfs_get_abs_path(user_input, source);\nfree(source);\nif (MALLOC) {\n/* CWE-134: Use of Externally-Controlled Format String */\nchar buffer[100];\nsprintf(buffer, user_input);\nprintf(buffer);\n}\nreturn user_buffer;\n}\n```",
 "supplementary_code": "```c\nstruct squashfs_symlink_inode {\n__le16\tinode_type;\n__le16\tmode;\n__le16\tuid;\n__le16\tguid;\n__le32\tmtime;\n__le32\tinode_number;\n__le32\tnlink;\n__le32\tsymlink_size;\nchar\tsymlink[];\n};\n```\n``c\n/*\n* Given the base (\"current dir.\") path and the relative one, generate the\n* absolute path.\n*/\nstatic char *sqfs_get_abs_path(const char *base, const char *rel)\n{\nchar **base_tokens, **rel_tokens, *resolved = NULL;\nint ret, bc, rc, i, updir = 0, resolved_size = 0, offset = 0;\nbase_tokens = NULL;\nrel_tokens = NULL;\n/* Memory allocation for the token lists */\nbc = sqfs_count_tokens(base);\nrc = sqfs_count_tokens(rel);\nif (bc < 1 || rc < 1)\nreturn NULL;\nbase_tokens = calloc(bc, sizeof(char *));\nif (!base_tokens)\nreturn NULL;\nrel_tokens = calloc(rc, sizeof(char *));\nif (!rel_tokens)\ngoto out;\n/* Fill token lists */\nret = sqfs_tokenize(base_tokens, bc, base);\nif (ret)\ngoto out;\nret = sqfs_tokenize(rel_tokens, rc, rel);\nif (ret)\ngoto out;\n/* count '..' occurrences in target path */\nfor (i = 0; i < rc; i++) {\nif (!strcmp(rel_tokens[i], \"..\"))\nupdir++;\n}\n/* Remove the last token and the '..' occurrences */\nbc = sqfs_clean_base_path(base_tokens, bc, updir);\nif (bc < 0)\ngoto out;\n/* Calculate resolved path size */\nif (!bc)\nresolved_size++;\nresolved_size += sqfs_get_tokens_length(base_tokens, bc) +\nsqfs_get_tokens_length(rel_tokens, rc);\nresolved = malloc(resolved_size + 1);\nif (!resolved)\ngoto out;\n/* Set resolved path */\nmemset(resolved, '\\0', resolved_size + 1);\noffset += sqfs_join(base_tokens, resolved + offset, 0, bc, '/');\nresolved[offset++] = '/';\noffset += sqfs_join(rel_tokens, resolved + offset, updir, rc, '/');\nout:\nif (rel_tokens)\nfor (i = 0; i < rc; i++)\nfree(rel_tokens[i]);\nif (base_tokens)\nfor (i = 0; i < bc; i++)\nfree(base_tokens[i]);\nfree(rel_tokens);\nfree(base_tokens);\nreturn resolved;\n}\n```",
 "is_vulnerable": true
}