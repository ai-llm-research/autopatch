{
 "supplementary_code": "```c\nstruct squashfs_symlink_inode {\n__le16\tinode_type;\n__le16\tmode;\n__le16\tuid;\n__le16\tguid;\n__le32\tmtime;\n__le32\tinode_number;\n__le32\tnlink;\n__le32\tsymlink_size;\nchar\tsymlink[];\n};\n```\n``c\n/*\n* Given the base (\"current dir.\") path and the relative one, generate the\n* absolute path.\n*/\nstatic char *sqfs_get_abs_path(const char *base, const char *rel)\n{\nchar **base_tokens, **rel_tokens, *resolved = NULL;\nint ret, bc, rc, i, updir = 0, resolved_size = 0, offset = 0;\nbase_tokens = NULL;\nrel_tokens = NULL;\n/* Memory allocation for the token lists */\nbc = sqfs_count_tokens(base);\nrc = sqfs_count_tokens(rel);\nif (bc < 1 || rc < 1)\nreturn NULL;\nbase_tokens = calloc(bc, sizeof(char *));\nif (!base_tokens)\nreturn NULL;\nrel_tokens = calloc(rc, sizeof(char *));\nif (!rel_tokens)\ngoto out;\n/* Fill token lists */\nret = sqfs_tokenize(base_tokens, bc, base);\nif (ret)\ngoto out;\nret = sqfs_tokenize(rel_tokens, rc, rel);\nif (ret)\ngoto out;\n/* count '..' occurrences in target path */\nfor (i = 0; i < rc; i++) {\nif (!strcmp(rel_tokens[i], \"..\"))\nupdir++;\n}\n/* Remove the last token and the '..' occurrences */\nbc = sqfs_clean_base_path(base_tokens, bc, updir);\nif (bc < 0)\ngoto out;\n/* Calculate resolved path size */\nif (!bc)\nresolved_size++;\nresolved_size += sqfs_get_tokens_length(base_tokens, bc) +\nsqfs_get_tokens_length(rel_tokens, rc);\nresolved = malloc(resolved_size + 1);\nif (!resolved)\ngoto out;\n/* Set resolved path */\nmemset(resolved, '\\0', resolved_size + 1);\noffset += sqfs_join(base_tokens, resolved + offset, 0, bc, '/');\nresolved[offset++] = '/';\noffset += sqfs_join(rel_tokens, resolved + offset, updir, rc, '/');\nout:\nif (rel_tokens)\nfor (i = 0; i < rc; i++)\nfree(rel_tokens[i]);\nif (base_tokens)\nfor (i = 0; i < bc; i++)\nfree(base_tokens[i]);\nfree(rel_tokens);\nfree(base_tokens);\nreturn resolved;\n}\n```",
 "function_prototype": "static char *sqfs_resolve_symlink(struct squashfs_symlink_inode *sym, const char *base_path)",
 "re_implemented_code": "\nstatic char *sqfs_resolve_symlink(struct squashfs_symlink_inode *sym,\nconst char *base_path)\n{\n// Declare pointers for the resolved path and target path, and a variable for size\nchar *resolved = NULL;\nchar *target = NULL;\nint target_size = 0;\n// Retrieve the size of the symlink target path from the inode structure\ntarget_size = sym->symlink_size;\n// Allocate memory for the target path, including space for a null terminator\ntarget = malloc(target_size + 1);\n// Check if memory allocation failed and return NULL if it did\nif (!target)\nreturn NULL;\n/*\n* There is no trailing null byte in the symlink's target path, so a\n* copy is made and a '\\0' is added at its end.\n*/\n// Copy the symlink target path from the inode to the allocated memory\nmemcpy(target, sym->symlink, target_size);\n// Add a null terminator at the end of the target path\ntarget[target_size] = '\\0';\n// Convert the relative target path to an absolute path using the base path\nresolved = sqfs_get_abs_path(base_path, target);\n// Free the memory allocated for the target path\nfree(target);\n// Return the resolved absolute path\nreturn resolved;\n}\n",
 "is_vulnerable": true
}