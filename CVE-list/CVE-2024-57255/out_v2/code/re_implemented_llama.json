{
 "supplementary_code": "```c\nstruct squashfs_symlink_inode {\n__le16\tinode_type;\n__le16\tmode;\n__le16\tuid;\n__le16\tguid;\n__le32\tmtime;\n__le32\tinode_number;\n__le32\tnlink;\n__le32\tsymlink_size;\nchar\tsymlink[];\n};\n```\n``c\n/*\n* Given the base (\"current dir.\") path and the relative one, generate the\n* absolute path.\n*/\nstatic char *sqfs_get_abs_path(const char *base, const char *rel)\n{\nchar **base_tokens, **rel_tokens, *resolved = NULL;\nint ret, bc, rc, i, updir = 0, resolved_size = 0, offset = 0;\nbase_tokens = NULL;\nrel_tokens = NULL;\n/* Memory allocation for the token lists */\nbc = sqfs_count_tokens(base);\nrc = sqfs_count_tokens(rel);\nif (bc < 1 || rc < 1)\nreturn NULL;\nbase_tokens = calloc(bc, sizeof(char *));\nif (!base_tokens)\nreturn NULL;\nrel_tokens = calloc(rc, sizeof(char *));\nif (!rel_tokens)\ngoto out;\n/* Fill token lists */\nret = sqfs_tokenize(base_tokens, bc, base);\nif (ret)\ngoto out;\nret = sqfs_tokenize(rel_tokens, rc, rel);\nif (ret)\ngoto out;\n/* count '..' occurrences in target path */\nfor (i = 0; i < rc; i++) {\nif (!strcmp(rel_tokens[i], \"..\"))\nupdir++;\n}\n/* Remove the last token and the '..' occurrences */\nbc = sqfs_clean_base_path(base_tokens, bc, updir);\nif (bc < 0)\ngoto out;\n/* Calculate resolved path size */\nif (!bc)\nresolved_size++;\nresolved_size += sqfs_get_tokens_length(base_tokens, bc) +\nsqfs_get_tokens_length(rel_tokens, rc);\nresolved = malloc(resolved_size + 1);\nif (!resolved)\ngoto out;\n/* Set resolved path */\nmemset(resolved, '\\0', resolved_size + 1);\noffset += sqfs_join(base_tokens, resolved + offset, 0, bc, '/');\nresolved[offset++] = '/';\noffset += sqfs_join(rel_tokens, resolved + offset, updir, rc, '/');\nout:\nif (rel_tokens)\nfor (i = 0; i < rc; i++)\nfree(rel_tokens[i]);\nif (base_tokens)\nfor (i = 0; i < bc; i++)\nfree(base_tokens[i]);\nfree(rel_tokens);\nfree(base_tokens);\nreturn resolved;\n}\n```",
 "function_prototype": "static char *sqfs_resolve_symlink(struct squashfs_symlink_inode *sym, const char *base_path)",
 "re_implemented_code": "\n```c\nstatic char *sqfs_resolve_symlink(struct squashfs_symlink_inode *sym,\nconst char *base_path)\n{\nchar *target_path, *resolved_path;\nunsigned long sym_len;\nsym_len = le32_to_cpu(sym->symlink_size);\ntarget_path = malloc((sym_len+1)*sizeof(*target_path));\nif(!target_path){\nfprintf(stderr,\"failed to allocate %lu bytes\\n\", sym_len*sizeof(*target_path)+1);\nexit(-ENOMEM);\n}\nmemcpy(target_path, &sym->symlink, sym_len);\ntarget_path[sym_len]=0;\nresolved_path=sqfs_get_abs_path(base_path, target_path);\nfree(target_path);\nreturn resolved_path;\n}\n```\n",
 "is_vulnerable": true
}