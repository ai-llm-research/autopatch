```cpp
// Support for equality checking of recursion groups, where type indexes have
// to be compared relative to their respective recursion group.
struct CanonicalEquality {
  // Recursion group bounds for LHS and RHS.
  const RecursionGroupRange recgroup1;
  const RecursionGroupRange recgroup2;

  CanonicalEquality(RecursionGroupRange recgroup1,
                    RecursionGroupRange recgroup2)
      : recgroup1{recgroup1}, recgroup2{recgroup2} {}

  bool EqualTypeIndex(CanonicalTypeIndex index1,
                      CanonicalTypeIndex index2) const {
    <Target Code Place>
  }

  bool EqualType(const CanonicalType& type1,
                  const CanonicalType& type2) const {
    if (!EqualTypeIndex(type1.supertype, type2.supertype)) return false;
    if (type1.is_final != type2.is_final) return false;
    if (type1.is_shared != type2.is_shared) return false;
    switch (type1.kind) {
      case CanonicalType::kFunction:
        return type2.kind == CanonicalType::kFunction &&
                EqualSig(*type1.function_sig, *type2.function_sig);
      case CanonicalType::kStruct:
        return type2.kind == CanonicalType::kStruct &&
                EqualStructType(*type1.struct_type, *type2.struct_type);
      case CanonicalType::kArray:
        return type2.kind == CanonicalType::kArray &&
                EqualArrayType(*type1.array_type, *type2.array_type);
      case CanonicalType::kCont:
        return type2.kind == CanonicalType::kCont &&
                EqualContType(*type1.cont_type, *type2.cont_type);
    }
  }

  bool EqualTypes(base::Vector<const CanonicalType> types1,
                  base::Vector<const CanonicalType> types2) const {
    return std::equal(types1.begin(), types1.end(), types2.begin(),
                      types2.end(),
                      std::bind_front(&CanonicalEquality::EqualType, this));
  }

  bool EqualValueType(CanonicalValueType type1,
                      CanonicalValueType type2) const {
    const bool indexed = type1.has_index();
    if (indexed != type2.has_index()) return false;
    if (indexed) {
      return EqualTypeIndex(type1.ref_index(), type2.ref_index());
    }
    return type1 == type2;
  }

  bool EqualSig(const CanonicalSig& sig1, const CanonicalSig& sig2) const {
    if (sig1.parameter_count() != sig2.parameter_count()) return false;
    return std::equal(
        sig1.all().begin(), sig1.all().end(), sig2.all().begin(),
        sig2.all().end(),
        std::bind_front(&CanonicalEquality::EqualValueType, this));
  }

  bool EqualStructType(const CanonicalStructType& type1,
                        const CanonicalStructType& type2) const {
    return
        // Compare fields, including a check that the size is the same.
        std::equal(
            type1.fields().begin(), type1.fields().end(),
            type2.fields().begin(), type2.fields().end(),
            std::bind_front(&CanonicalEquality::EqualValueType, this)) &&
        // Compare mutabilities, skipping the check for the size.
        std::equal(type1.mutabilities().begin(), type1.mutabilities().end(),
                    type2.mutabilities().begin());
  }

  bool EqualArrayType(const CanonicalArrayType& type1,
                      const CanonicalArrayType& type2) const {
    return type1.mutability() == type2.mutability() &&
            EqualValueType(type1.element_type(), type2.element_type());
  }

  bool EqualContType(const CanonicalContType& type1,
                      const CanonicalContType& type2) const {
    return EqualTypeIndex(type1.contfun_typeindex(),
                          type2.contfun_typeindex());
  }
};
```

```cpp
struct CanonicalTypeIndex : public TypeIndex {
  inline static constexpr CanonicalTypeIndex Invalid();

  bool operator==(CanonicalTypeIndex other) const {
    return index == other.index;
  }
  auto operator<=>(CanonicalTypeIndex other) const {
    return index <=> other.index;
  }
};
```

```cpp
bool EqualTypeIndex(CanonicalTypeIndex index1,
					CanonicalTypeIndex index2) const {
  if (recgroup1.Contains(index1)) {
	// Compare relative supertypes in the recgroups.
	if (!recgroup2.Contains(index2)) return false;
	uint32_t rel_supertype1 = index1.index - recgroup1.start.index;
	uint32_t rel_supertype2 = index2.index - recgroup2.start.index;
	if (rel_supertype1 != rel_supertype2) return false;
  } else {
	if (recgroup2.Contains(index2)) return false;
	if (index1 != index2) return false;
  }
  return true;
}
```

```cpp
 // Define the range of a recursion group; for use in {CanonicalHashing} and
  // {CanonicalEquality}.
  struct RecursionGroupRange {
    const CanonicalTypeIndex first;
    const CanonicalTypeIndex last;

    bool Contains(CanonicalTypeIndex index) const {
      return base::IsInRange(index.index, first.index, last.index);
    }
  };
```