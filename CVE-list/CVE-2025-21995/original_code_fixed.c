

typedef int spinlock_t;
typedef int bool;

struct dma_fence {};
struct completion {};
struct request_queue {};
struct spsc_queue {};
struct callback {};

#define true 1
#define false 0

struct drm_sched_entity {
    struct request_queue *rq;
    int stopped;
    spinlock_t rq_lock; // Changed type to spinlock_t
    struct completion entity_idle;
    struct drm_sched_job *last_scheduled;
    struct spsc_queue job_queue;
};

struct drm_sched_job {
    struct drm_sched_fence *s_fence;
    struct callback finish_cb;
};

struct drm_sched_fence {
    struct dma_fence finished;
};

static void spin_lock(spinlock_t *lock) {}
static void spin_unlock(spinlock_t *lock) {}
static void wait_for_completion(struct completion *x) {}
static struct drm_sched_job* to_drm_sched_job(void *entry) { return 0; }
static void* spsc_queue_pop(struct spsc_queue *queue) { return 0; }
static struct drm_sched_job* rcu_dereference_check(struct drm_sched_job *ptr, bool check) { return 0; }
static void dma_fence_get(struct dma_fence *fence) {}
static void dma_fence_put(struct dma_fence *fence) {}
static int dma_fence_add_callback(struct dma_fence *fence, struct callback *cb, void (*func)(void *, struct callback *)) { return 0; }
static void drm_sched_entity_kill_jobs_cb(void *param, struct callback *cb) {}
static void drm_sched_rq_remove_entity(struct request_queue *rq, struct drm_sched_entity *entity) {}

static void drm_sched_entity_kill(struct drm_sched_entity *entity)
{
    struct drm_sched_job *job;
    struct dma_fence *prev;

    if (!entity->rq)
        return;

    spin_lock(&entity->rq_lock);
    entity->stopped = true;
    drm_sched_rq_remove_entity(entity->rq, entity);
    spin_unlock(&entity->rq_lock);

    /* Make sure this entity is not used by the scheduler at the moment */
    wait_for_completion(&entity->entity_idle);

    /* The entity is guaranteed to not be used by the scheduler */
    prev = (struct dma_fence *)rcu_dereference_check(entity->last_scheduled, true);
    dma_fence_get(prev);
    while ((job = to_drm_sched_job(spsc_queue_pop(&entity->job_queue)))) {
        struct drm_sched_fence *s_fence = job->s_fence;

        dma_fence_get(&s_fence->finished);
        if (!prev || dma_fence_add_callback(prev, &job->finish_cb,
                           drm_sched_entity_kill_jobs_cb))
            drm_sched_entity_kill_jobs_cb(0, &job->finish_cb);

        prev = &s_fence->finished;
    }
    dma_fence_put(prev);
}

