

typedef int bool;
#define true 1
#define false 0
#define NULL ((void *)0)

struct rq {
    int lock;
};

struct completion {
    int completed;
};

struct dma_fence {
    int status;
};

struct spsc_queue {
    int count;
};

struct callback {
    int triggered;
};

struct drm_sched_entity {
    struct rq *rq;
    bool stopped;
    struct completion entity_idle;
    struct dma_fence *last_scheduled;
    struct spsc_queue job_queue;
};

struct drm_sched_job {
    struct {
        struct dma_fence finished;
    } *s_fence;
    struct callback finish_cb;
};

static void spin_lock(int *lock) {
    // Stub function
}

static void spin_unlock(int *lock) {
    // Stub function
}

static void wait_for_completion(struct completion *comp) {
    // Stub function
}

static struct drm_sched_job* to_drm_sched_job(int job) {
    return 0; // Stub function
}

static struct drm_sched_job* spsc_queue_pop(struct spsc_queue *queue) {
    return 0; // Stub function
}

static struct dma_fence* dma_fence_get(struct dma_fence *fence) {
    return 0; // Stub function
}

static void dma_fence_put(struct dma_fence *fence) {
    // Stub function
}

static int dma_fence_add_callback(struct dma_fence *fence, struct callback *cb, void (*func)(struct dma_fence *, struct callback *)) {
    return 0; // Stub function
}

static void drm_sched_entity_kill_jobs_cb(struct dma_fence *fence, struct callback *cb) {
    // Stub function
}

static void drm_sched_rq_remove_entity(struct rq *rq, struct drm_sched_entity *entity) {
    // Stub function
}

static inline void* rcu_dereference(struct dma_fence *ptr) {
    return ptr; // Stub function
}

static void drm_sched_entity_kill(struct drm_sched_entity *entity) {
    struct drm_sched_job *job;
    struct dma_fence *prev = NULL;

    if (!entity->rq)
        return;

    spin_lock(&entity->rq->lock);
    entity->stopped = true;
    drm_sched_rq_remove_entity(entity->rq, entity);
    spin_unlock(&entity->rq->lock);

    wait_for_completion(&entity->entity_idle);

    prev = rcu_dereference(entity->last_scheduled);
    if (prev)
        prev = dma_fence_get(prev);

    while ((job = to_drm_sched_job(spsc_queue_pop(&entity->job_queue)))) {
        struct dma_fence *fence = &job->s_fence->finished;

        fence = dma_fence_get(fence);

        if (!prev || dma_fence_add_callback(prev, &job->finish_cb,
                               drm_sched_entity_kill_jobs_cb)) {
            drm_sched_entity_kill_jobs_cb(prev, &job->finish_cb);
        }

        prev = fence;
    }

    if (prev)
        dma_fence_put(prev);
}

