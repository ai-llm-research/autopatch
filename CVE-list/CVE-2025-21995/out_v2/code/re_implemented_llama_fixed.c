

struct dma_fence {
    // Minimal stub of dma_fence
};

struct dma_fence_cb {
    // Minimal stub of dma_fence_cb
};

struct rq {
    void *lock;
    // Minimal stub for 'rq'
};

typedef int atomic_t;

typedef int bool;

struct drm_sched_job {
    struct dma_fence finished;
    struct dma_fence_cb finish_cb;
    // Minimal stub of drm_sched_job
};

struct drm_sched_entity {
    struct rq *rq;
    bool stopped;
    struct entity_idle_wq {
        // Minimal stub for wait queue
    } entity_idle;
    struct dma_fence *last_scheduled;
    atomic_t karma;
    struct job_queue {
        // Minimal stub for job queue
    } job_queue;
    // Minimal stub of drm_sched_entity
};

static void dma_fence_put(struct dma_fence *fence) {
    // Stub for dma_fence_put
}

struct dma_fence *dma_fence_get_rcu(struct dma_fence **fence) {
    // Stub for dma_fence_get_rcu
    return *fence;
}

static void spin_lock(void *lock) {
    // Stub for spin_lock
}

static void spin_unlock(void *lock) {
    // Stub for spin_unlock
}

static void wake_up_all(struct entity_idle_wq *wq) {
    // Stub for wake_up_all
}

static int atomic_read(atomic_t *atom) {
    // Stub for atomic_read
    return 0;
}

static void wait_event(struct entity_idle_wq wq, int condition) {
    // Stub for wait_event
}

int dma_fence_add_callback(struct dma_fence *fence, struct dma_fence_cb *cb, void (*func)(struct dma_fence *, struct dma_fence_cb *)) {
    // Stub for dma_fence_add_callback
    return 0;
}

void drm_sched_entity_kill_jobs_cb(struct dma_fence *fence, struct dma_fence_cb *cb) {
    // Stub for drm_sched_entity_kill_jobs_cb
}

static void drm_sched_rq_remove_entity(struct rq *rq, struct drm_sched_entity *entity) {
    // Stub for drm_sched_rq_remove_entity
}

void *spsc_queue_pop(struct job_queue *queue) {
    // Stub for spsc_queue_pop
    return (void *)0;
}

static void drm_sched_entity_kill(struct drm_sched_entity *entity) {
    struct drm_sched_job *job;
    struct dma_fence *prev = (struct dma_fence *)0;

    if (!entity->rq)
        return;

    spin_lock(&entity->rq->lock);

    entity->stopped = 1;
    wake_up_all(&entity->entity_idle);

    drm_sched_rq_remove_entity(entity->rq, entity);

    spin_unlock(&entity->rq->lock);

    wait_event(entity->entity_idle,
              atomic_read(&entity->karma) >= 0);

    prev = dma_fence_get_rcu(&entity->last_scheduled);

    while ((job = (struct drm_sched_job *)spsc_queue_pop(&entity->job_queue))) {
        struct dma_fence *cur = dma_fence_get_rcu(&job->finished);

        if (!prev || dma_fence_add_callback(prev, &job->finish_cb,
                           drm_sched_entity_kill_jobs_cb))
            drm_sched_entity_kill_jobs_cb((struct dma_fence *)0, &job->finish_cb);

        prev = cur;
    }

    dma_fence_put(prev);
}

