

struct drm_sched_entity {
    struct drm_sched_rq *rq;
    int stopped;
    void *lock;
    struct {
        struct dma_fence *last_scheduled;
    };
    struct spsc_queue {
    } job_queue;
    struct completion {
    } entity_idle;
};

struct drm_sched_job {
    struct {
        struct dma_fence *finished;
    } *s_fence;
    struct dma_fence_callback {
    } finish_cb;
};

struct drm_sched_rq {
};

struct drm_sched_job *to_drm_sched_job(struct drm_sched_job *job) {
    return job;
}

struct dma_fence {
};

void drm_sched_rq_remove_entity(struct drm_sched_rq *rq, struct drm_sched_entity *entity) {
}

void wait_for_completion(struct completion *comp) {
}

struct dma_fence *rcu_dereference_check(struct dma_fence *f, int under_rcu) {
    return f;
}

void dma_fence_get(struct dma_fence *fence) {
}

int dma_fence_add_callback(struct dma_fence *fence, struct dma_fence_callback *cb,
                           void (*func)(struct dma_fence *, struct dma_fence_callback *)) {
    return 0;
}

void drm_sched_entity_kill_jobs_cb(struct dma_fence *fence, struct dma_fence_callback *cb) {
}

void dma_fence_put(struct dma_fence *fence) {
}

struct drm_sched_job *spsc_queue_pop(struct spsc_queue *queue) {
    return (struct drm_sched_job *)0;
}

void spin_lock(void *lock) {
}

void spin_unlock(void *lock) {
}

static void drm_sched_entity_kill(struct drm_sched_entity *entity) {
    struct drm_sched_job *job;
    struct dma_fence *prev = 0;

    if (!entity->rq)
        return;

    spin_lock(&entity->lock);

    entity->stopped = 1;
    drm_sched_rq_remove_entity(entity->rq, entity);
    spin_unlock(&entity->lock);
    wait_for_completion(&entity->entity_idle);

    prev = rcu_dereference_check(entity->last_scheduled, 0);
    dma_fence_get(prev);

    while ((job = to_drm_sched_job(spsc_queue_pop(&entity->job_queue)))) {
        struct dma_fence *curr_fence = job->s_fence->finished;
        dma_fence_get(curr_fence);

        if (!prev || dma_fence_add_callback(prev, &job->finish_cb,
                                            drm_sched_entity_kill_jobs_cb))
            drm_sched_entity_kill_jobs_cb(curr_fence, &job->finish_cb);

        prev = curr_fence;
    }

    dma_fence_put(prev);
}

