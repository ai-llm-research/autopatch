

struct dma_fence {
    int dummy;
};

struct list_head {
    struct list_head *next, *prev;
};

struct completion {
    int done;
};

struct spsc_queue {
    int dummy;
};

struct dma_fence_cb {
    int dummy;
};

struct drm_sched_job {
    struct s_fence {
        struct dma_fence finished;
    } *s_fence;
    struct dma_fence_cb finish_cb;
    struct list_head queue_node;
};

typedef int spinlock_t;

struct drm_sched_entity {
    struct drm_sched_rq *rq;
    int stopped;
    struct list_head list;
    struct completion entity_idle;
    struct spsc_queue job_queue;
    struct dma_fence *last_scheduled;
};

struct drm_sched_rq {
    spinlock_t lock;
};

void spin_lock(spinlock_t *lock) {}
void spin_unlock(spinlock_t *lock) {}
void wait_for_completion(struct completion *comp) {}
void dma_fence_get(struct dma_fence *fence) {}
void dma_fence_put(struct dma_fence *fence) {}
struct dma_fence *rcu_dereference(struct dma_fence *fence) { return fence; }
void rcu_read_lock() {}
void rcu_read_unlock() {}
void *spsc_queue_pop(struct spsc_queue *queue) { return 0; }
int dma_fence_add_callback(struct dma_fence *fence, struct dma_fence_cb *cb, void (*func)(struct dma_fence *, struct dma_fence_cb *)) { return 0; }
void list_del_init(struct list_head *entry) {}
void drm_sched_entity_kill_jobs_cb(struct dma_fence *fence, struct dma_fence_cb *cb) {}

#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))

#define NULL ((void *)0)

static void drm_sched_entity_kill(struct drm_sched_entity *entity)
{
    struct drm_sched_job *job;
    struct dma_fence *prev = 0;

    if (!entity->rq)
        return;

    spin_lock(&entity->rq->lock);
    entity->stopped = 1;
    list_del_init(&entity->list);
    spin_unlock(&entity->rq->lock);
    wait_for_completion(&entity->entity_idle);

    rcu_read_lock();
    prev = rcu_dereference(entity->last_scheduled);
    if (prev)
        dma_fence_get(prev);
    rcu_read_unlock();

    while ((job = container_of(spsc_queue_pop(&entity->job_queue), struct drm_sched_job, queue_node))) {
        struct dma_fence *fence = &job->s_fence->finished;
        dma_fence_get(fence);

        if (!prev || dma_fence_add_callback(prev, &job->finish_cb, drm_sched_entity_kill_jobs_cb))
            drm_sched_entity_kill_jobs_cb(NULL, &job->finish_cb);

        dma_fence_put(prev);
        prev = fence;
    }

    dma_fence_put(prev);
}

