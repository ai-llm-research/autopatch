

typedef int bool;
#define true 1
#define false 0

typedef int atomic_t;

struct completion {};

struct spinlock_t {};

struct spsc_queue {
    // Minimal structure definition to fix incomplete type error
    void *dummy;
};

struct drm_sched_rq {
    struct spinlock_t lock;
};

struct drm_sched_entity {
    bool stopped;
    struct drm_sched_rq *rq;
    struct completion entity_idle;
    atomic_t *last_scheduled;
    struct spsc_queue job_queue;
};

struct dma_fence {};

struct dma_fence_cb {
    void (*func)(struct dma_fence *, struct dma_fence_cb *);
};

struct sched_fence {
    struct dma_fence finished;
};

struct drm_sched_job {
    struct sched_fence *s_fence;
    struct dma_fence_cb finish_cb;
};

struct drm_sched_job* to_drm_sched_job(void* node) {
    return 0;
}

void* spsc_queue_pop(struct spsc_queue* queue) {
    return 0;
}

struct dma_fence* dma_fence_get(struct dma_fence* fence) {
    return fence;
}

void dma_fence_put(struct dma_fence* fence) {}

int dma_fence_add_callback(struct dma_fence* fence, struct dma_fence_cb* cb, void(*func)(struct dma_fence*, struct dma_fence_cb*)) {
    return 0;
}

void wait_for_completion(struct completion *comp) {}

void spin_lock(struct spinlock_t *lock) {}

void spin_unlock(struct spinlock_t *lock) {}

void drm_sched_rq_remove_entity(struct drm_sched_rq *rq, struct drm_sched_entity *entity) {}

void drm_sched_entity_kill_jobs_cb(struct dma_fence* fence, struct dma_fence_cb* cb) {}

void *rcu_dereference_check(atomic_t *last_scheduled, int check) {
    return (void *) last_scheduled;
}

static void drm_sched_entity_kill(struct drm_sched_entity *entity)
{
    struct drm_sched_job *job;
    struct dma_fence *prev = 0;

    if (!entity->rq)
        return;

    spin_lock(&entity->rq->lock);

    entity->stopped = true;

    drm_sched_rq_remove_entity(entity->rq, entity);

    spin_unlock(&entity->rq->lock);

    wait_for_completion(&entity->entity_idle);

    prev = dma_fence_get(rcu_dereference_check(entity->last_scheduled, true));

    while ((job = to_drm_sched_job(spsc_queue_pop(&entity->job_queue)))) {
        struct dma_fence *fence = dma_fence_get(&job->s_fence->finished);

        if (!prev || dma_fence_add_callback(prev, &job->finish_cb, drm_sched_entity_kill_jobs_cb))
            job->finish_cb.func(prev, &job->finish_cb);

        if (prev)
            dma_fence_put(prev);
        prev = fence;
    }

    if (prev)
        dma_fence_put(prev);
}
