```c
struct ext2fs_node {
	struct ext2_data *data;
	struct ext2_inode inode;
	int ino;
	int inode_read;
};
```

```c
/* Information about a "mounted" ext2 filesystem. */
struct ext2_data {
	struct ext2_sblock sblock;
	struct ext2_inode *inode;
	struct ext2fs_node diropen;
};
```

```c
/**
 * struct ext2_inode - ext2 inode
 *
 * For details see Linux file
 * Documentation/filesystems/ext4/inodes.rst.
 */
struct ext2_inode {
	/** @mode: file mode */
	__le16 mode;
	/** @uid: lower 16 bits of owner UID */
	__le16 uid;
	/** @size: lower 32 bits of file size */
	__le32 size;
	/** @atime: last access time */
	__le32 atime;
	/** @ctime: last change time */
	__le32 ctime;
	/** @mtime: last modification time */
	__le32 mtime;
	/** @dtime: deletion time */
	__le32 dtime;
	/** @gid: lower 16 bits of group ID */
	__le16 gid;
	/** @nlinks: number of hard links */
	__le16 nlinks;
	/** @blockcnt: lower 32 bit of block count */
	__le32 blockcnt;
	/** @flags: inode flags */
	__le32 flags;
	/** @osd1: operating system specific data */
	__le32 osd1;
	/** @b: block map or extent tree */
	union {
		struct datablocks {
			__le32 dir_blocks[INDIRECT_BLOCKS];
			__le32 indir_block;
			__le32 double_indir_block;
			__le32 triple_indir_block;
		} blocks;
		char symlink[60];
		char inline_data[60];
	} b;
	/** @version: file version (for NFS) */
	__le32 version;
	/** @acl: lower 32 bit of extended attribute block */
	__le32 acl;
	/** @size_high - dir_acl on ext2/3, upper 32 size bits on ext4
	 *
	 * In ext2/3 this field was named i_dir_acl, though it was usually set
	 * to zero and never used.
	 */
	__le32 size_high;
	/** @fragment_addr - (obsolete) fragment address */
	__le32 fragment_addr;
	/** @osd2: operating system specific data */
	__le32 osd2[3];
};
```

```c
int ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)
{
	struct ext2_block_group *blkgrp;
	struct ext2_sblock *sblock = &data->sblock;
	struct ext_filesystem *fs = get_fs();
	int log2blksz = get_fs()->dev_desc->log2blksz;
	int inodes_per_block, status;
	long int blkno;
	unsigned int blkoff;

	/* Allocate blkgrp based on gdsize (for 64-bit support). */
	blkgrp = zalloc(get_fs()->gdsize);
	if (!blkgrp)
		return 0;

	/* It is easier to calculate if the first inode is 0. */
	ino--;
	if ( le32_to_cpu(sblock->inodes_per_group) == 0 || fs->inodesz == 0) {
		free(blkgrp);
		return 0;
	}
	status = ext4fs_blockgroup(data, ino / le32_to_cpu
				   (sblock->inodes_per_group), blkgrp);
	if (status == 0) {
		free(blkgrp);
		return 0;
	}

	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
	if ( inodes_per_block == 0 ) {
		free(blkgrp);
		return 0;
	}
	blkno = ext4fs_bg_get_inode_table_id(blkgrp, fs) +
	    (ino % le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
	blkoff = (ino % inodes_per_block) * fs->inodesz;

	/* Free blkgrp as it is no longer required. */
	free(blkgrp);

	/* Read the inode. */
	status = ext4fs_devread((lbaint_t)blkno << (LOG2_BLOCK_SIZE(data) -
				log2blksz), blkoff,
				sizeof(struct ext2_inode), (char *)inode);
	if (status == 0)
		return 0;

	return 1;
}
```

```c
static inline void *zalloc(size_t size)
{
	return kzalloc(size, 0);
}
```

```c
/*
 * Taken from openmoko-kernel mailing list: By Andy green
 * Optimized read file API : collects and defers contiguous sector
 * reads into one potentially more efficient larger sequential read action
 */
int ext4fs_read_file(struct ext2fs_node *node, loff_t pos,
		loff_t len, char *buf, loff_t *actread)
{
	struct ext_filesystem *fs = get_fs();
	int i;
	lbaint_t blockcnt;
	int log2blksz = fs->dev_desc->log2blksz;
	int log2_fs_blocksize = LOG2_BLOCK_SIZE(node->data) - log2blksz;
	int blocksize = (1 << (log2_fs_blocksize + log2blksz));
	unsigned int filesize = le32_to_cpu(node->inode.size);
	lbaint_t previous_block_number = -1;
	lbaint_t delayed_start = 0;
	lbaint_t delayed_extent = 0;
	lbaint_t delayed_skipfirst = 0;
	lbaint_t delayed_next = 0;
	char *delayed_buf = NULL;
	char *start_buf = buf;
	short status;
	struct ext_block_cache cache;

	ext_cache_init(&cache);

	/* Adjust len so it we can't read past the end of the file. */
	if (len + pos > filesize)
		len = (filesize - pos);

	if (blocksize <= 0 || len <= 0) {
		ext_cache_fini(&cache);
		return -1;
	}

	blockcnt = lldiv(((len + pos) + blocksize - 1), blocksize);

	for (i = lldiv(pos, blocksize); i < blockcnt; i++) {
		long int blknr;
		int blockoff = pos - (blocksize * i);
		int blockend = blocksize;
		int skipfirst = 0;
		blknr = read_allocated_block(&node->inode, i, &cache);
		if (blknr < 0) {
			ext_cache_fini(&cache);
			return -1;
		}

		blknr = blknr << log2_fs_blocksize;

		/* Last block.  */
		if (i == blockcnt - 1) {
			blockend = (len + pos) - (blocksize * i);

			/* The last portion is exactly blocksize. */
			if (!blockend)
				blockend = blocksize;
		}

		/* First block. */
		if (i == lldiv(pos, blocksize)) {
			skipfirst = blockoff;
			blockend -= skipfirst;
		}
		if (blknr) {
			int status;

			if (previous_block_number != -1) {
				if (delayed_next == blknr) {
					delayed_extent += blockend;
					delayed_next += blockend >> log2blksz;
				} else {	/* spill */
					status = ext4fs_devread(delayed_start,
							delayed_skipfirst,
							delayed_extent,
							delayed_buf);
					if (status == 0) {
						ext_cache_fini(&cache);
						return -1;
					}
					previous_block_number = blknr;
					delayed_start = blknr;
					delayed_extent = blockend;
					delayed_skipfirst = skipfirst;
					delayed_buf = buf;
					delayed_next = blknr +
						(blockend >> log2blksz);
				}
			} else {
				previous_block_number = blknr;
				delayed_start = blknr;
				delayed_extent = blockend;
				delayed_skipfirst = skipfirst;
				delayed_buf = buf;
				delayed_next = blknr +
					(blockend >> log2blksz);
			}
		} else {
			int n;
			int n_left;
			if (previous_block_number != -1) {
				/* spill */
				status = ext4fs_devread(delayed_start,
							delayed_skipfirst,
							delayed_extent,
							delayed_buf);
				if (status == 0) {
					ext_cache_fini(&cache);
					return -1;
				}
				previous_block_number = -1;
			}
			/* Zero no more than `len' bytes. */
			n = blocksize - skipfirst;
			n_left = len - ( buf - start_buf );
			if (n > n_left)
				n = n_left;
			memset(buf, 0, n);
		}
		buf += blocksize - skipfirst;
	}
	if (previous_block_number != -1) {
		/* spill */
		status = ext4fs_devread(delayed_start,
					delayed_skipfirst, delayed_extent,
					delayed_buf);
		if (status == 0) {
			ext_cache_fini(&cache);
			return -1;
		}
		previous_block_number = -1;
	}

	*actread  = len;
	ext_cache_fini(&cache);
	return 0;
}
```