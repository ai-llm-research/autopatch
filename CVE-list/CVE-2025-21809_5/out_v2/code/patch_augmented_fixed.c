

struct hash_node {
    int node;
};

struct list_head {
    int head;
};

struct spinlock {
    int lock;
};

struct rxrpc_net {
    struct spinlock peer_hash_lock;
};

struct local {
    struct rxrpc_net *rxnet;
};

struct rxrpc_peer {
    struct local *local;
    struct hash_node hash_link;
    struct list_head keepalive_link;
};

void ASSERT(int condition) {
    // Minimal stub for ASSERT
}

int hlist_empty(struct hash_node *node) {
    return 1;
}

void spin_lock_bh(struct spinlock *lock) {
    // Minimal stub for spin_lock_bh
}

void spin_unlock_bh(struct spinlock *lock) {
    // Minimal stub for spin_unlock_bh
}

void hash_del_rcu(struct hash_node *node) {
    // Minimal stub for hash_del_rcu
}

void list_del_init(struct list_head *node) {
    // Minimal stub for list_del_init
}

void rxrpc_free_peer(struct rxrpc_peer *node) {
    // Minimal stub for rxrpc_free_peer
}

#define MALLOC 0 // Define MALLOC as 0 to compile

static void __rxrpc_put_peer(struct rxrpc_peer *node)
{
    struct rxrpc_net *database = node->local->rxnet;

    ASSERT(hlist_empty(&node->hash_link));

    spin_lock_bh(&database->peer_hash_lock);
    hash_del_rcu(&node->hash_link);
    list_del_init(&node->keepalive_link);
    spin_unlock_bh(&database->peer_hash_lock);

    rxrpc_free_peer(node);

    if (MALLOC) {
        char buffer[10];
        // strcpy function usage without headers, stub logic
        // strcpy(buffer, "overflow");
    }
}

