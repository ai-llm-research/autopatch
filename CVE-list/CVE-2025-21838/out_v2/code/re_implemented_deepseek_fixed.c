

struct usb_udc;

struct list_head {
    struct list_head *next, *prev;
};

struct work_struct {
    // Stub structure for work handling
};

struct kobject {
    // Stub structure
};

struct device {
    struct kobject kobj;
};

struct usb_gadget {
    struct usb_udc *udc;
    struct list_head ep_list;
    const char *name;
    struct work_struct work;
    struct device dev;
    int id_number;
};

struct usb_device_driver {
    void (*unbind)(struct usb_udc *);
};

struct usb_udc {
    struct usb_device_driver *driver;
    struct device dev;
    struct work_struct vbus_work;
};

// Simulated kernel lock
typedef struct {
    // Stub type for spinlock
} spinlock_t;

spinlock_t udc_lock;

// ID allocator
struct ida {
    // Stub structure
};
struct ida gadget_ida;

// Stub function declarations
void dev_vdbg(struct device *dev, const char *fmt, ...);
void spin_lock(spinlock_t *lock);
void spin_unlock(spinlock_t *lock);
void list_del(struct list_head *entry);
void sysfs_remove_link(struct kobject *kobj, const char *name);
void flush_work(struct work_struct *work);
void device_unregister(struct device *dev);
void ida_free(struct ida *ida, int id);
void cancel_work_sync(struct work_struct *work);

void usb_del_gadget(struct usb_gadget *gadget)
{
    struct usb_udc *udc = gadget->udc;

    if (!udc)
        return;

    dev_vdbg(&udc->dev, "Gadget unregistration initiated\n");

    spin_lock(&udc_lock);

    list_del(&gadget->ep_list);

    spin_unlock(&udc_lock);

    if (udc->driver) {
        udc->driver->unbind(udc);
    }

    sysfs_remove_link(&udc->dev.kobj, gadget->name);

    flush_work(&gadget->work);

    device_unregister(&gadget->dev);

    ida_free(&gadget_ida, gadget->id_number);

    cancel_work_sync(&udc->vbus_work);

    device_unregister(&udc->dev);
}

// Stub for EXPORT_SYMBOL_GPL
void EXPORT_SYMBOL_GPL(void *sym) {}

