{
 "supplementary_code": "```c\nstruct usb_gadget {\nstruct work_struct work;\nstruct usb_udc *udc;\n/* readonly to gadget driver */\nconst struct usb_gadget_ops *ops;\nstruct usb_ep *ep0;\nstruct list_head ep_list; /* of usb_ep */\nenum usb_device_speed speed;\nenum usb_device_speed max_speed;\n/* USB SuperSpeed Plus only */\nenum usb_ssp_rate ssp_rate;\nenum usb_ssp_rate max_ssp_rate;\nenum usb_device_state state;\nconst char *name;\nstruct device dev;\nunsigned isoch_delay;\nunsigned out_epnum;\nunsigned in_epnum;\nunsigned mA;\nstruct usb_otg_caps *otg_caps;\nunsigned sg_supported:1;\nunsigned is_otg:1;\nunsigned is_a_peripheral:1;\nunsigned b_hnp_enable:1;\nunsigned a_hnp_support:1;\nunsigned a_alt_hnp_support:1;\nunsigned hnp_polling_support:1;\nunsigned host_request_flag:1;\nunsigned quirk_ep_out_aligned_size:1;\nunsigned quirk_altset_not_supp:1;\nunsigned quirk_stall_not_supp:1;\nunsigned quirk_zlp_not_supp:1;\nunsigned quirk_avoids_skb_reserve:1;\nunsigned is_selfpowered:1;\nunsigned deactivated:1;\nunsigned connected:1;\nunsigned lpm_capable:1;\nunsigned wakeup_capable:1;\nunsigned wakeup_armed:1;\nint irq;\nint id_number;\n};\n```\n```c\nstruct usb_udc {\nstruct usb_gadget_driver *driver;\nstruct usb_gadget *gadget;\nstruct device dev;\nstruct list_head list;\nbool vbus;\nbool started;\nbool allow_connect;\nstruct work_struct vbus_work;\nstruct mutex connect_lock;\n};\n```\n```c\n#define dev_vdbg(dev, fmt, ...) \\\ndev_no_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic int mutex_lock(unsigned long *m)\n{\nint c;\nint flags = FUTEX_WAIT;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nc = cmpxchg(m, 0, 1);\nif (!c)\nreturn 0;\nif (c == 1)\nc = xchg(m, 2);\nwhile (c) {\nsys_futex(m, flags, 2, NULL, NULL, 0);\nc = xchg(m, 2);\n}\nreturn 0;\n}\n```\n```c\nstatic inline void list_del(struct list_head *entry)\n{\n__list_del(entry->prev, entry->next);\nentry->next = LIST_POISON1;\nentry->prev = LIST_POISON2;\n}\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\nint kobject_uevent(struct kobject *kobj, enum kobject_action action)\n{\nreturn kobject_uevent_env(kobj, action, NULL);\n}\nEXPORT_SYMBOL_GPL(kobject_uevent);\n```\n```c\nstatic inline void sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n}\n```\n```c\nbool flush_work(struct work_struct *work)\n{\nmight_sleep();\nreturn __flush_work(work, false);\n}\nEXPORT_SYMBOL_GPL(flush_work);\n```\n```c\nbool flush_work(struct work_struct *work)\n{\nmight_sleep();\nreturn __flush_work(work, false);\n}\nEXPORT_SYMBOL_GPL(flush_work);\n```\n```c\nvoid device_del(struct device *dev)\n{\nstruct subsys_private *sp;\nstruct device *parent = dev->parent;\nstruct kobject *glue_dir = NULL;\nstruct class_interface *class_intf;\nunsigned int noio_flag;\ndevice_lock(dev);\nkill_device(dev);\ndevice_unlock(dev);\nif (dev->fwnode && dev->fwnode->dev == dev)\ndev->fwnode->dev = NULL;\n/* Notify clients of device removal. This call must come\n* before dpm_sysfs_remove().\n*/\nnoio_flag = memalloc_noio_save();\nbus_notify(dev, BUS_NOTIFY_DEL_DEVICE);\ndpm_sysfs_remove(dev);\nif (parent)\nklist_del(&dev->p->knode_parent);\nif (MAJOR(dev->devt)) {\ndevtmpfs_delete_node(dev);\ndevice_remove_sys_dev_entry(dev);\ndevice_remove_file(dev, &dev_attr_dev);\n}\nsp = class_to_subsys(dev->class);\nif (sp) {\ndevice_remove_class_symlinks(dev);\nmutex_lock(&sp->mutex);\n/* notify any interfaces that the device is now gone */\nlist_for_each_entry(class_intf, &sp->interfaces, node)\nif (class_intf->remove_dev)\nclass_intf->remove_dev(dev);\n/* remove the device from the class list */\nklist_del(&dev->p->knode_class);\nmutex_unlock(&sp->mutex);\nsubsys_put(sp);\n}\ndevice_remove_file(dev, &dev_attr_uevent);\ndevice_remove_attrs(dev);\nbus_remove_device(dev);\ndevice_pm_remove(dev);\ndriver_deferred_probe_del(dev);\ndevice_platform_notify_remove(dev);\ndevice_links_purge(dev);\n/*\n* If a device does not have a driver attached, we need to clean\n* up any managed resources. We do this in device_release(), but\n* it's never called (and we leak the device) if a managed\n* resource holds a reference to the device. So release all\n* managed resources here, like we do in driver_detach(). We\n* still need to do so again in device_release() in case someone\n* adds a new resource after this point, though.\n*/\ndevres_release_all(dev);\nbus_notify(dev, BUS_NOTIFY_REMOVED_DEVICE);\nkobject_uevent(&dev->kobj, KOBJ_REMOVE);\nglue_dir = get_glue_dir(dev);\nkobject_del(&dev->kobj);\ncleanup_glue_dir(dev, glue_dir);\nmemalloc_noio_restore(noio_flag);\nput_device(parent);\n}\nEXPORT_SYMBOL_GPL(device_del);\n```\n```c\nvoid ida_free(struct ida *ida, unsigned int id)\n{\nXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\nunsigned bit = id % IDA_BITMAP_BITS;\nstruct ida_bitmap *bitmap;\nunsigned long flags;\nif ((int)id < 0)\nreturn;\nxas_lock_irqsave(&xas, flags);\nbitmap = xas_load(&xas);\nif (xa_is_value(bitmap)) {\nunsigned long v = xa_to_value(bitmap);\nif (bit >= BITS_PER_XA_VALUE)\ngoto err;\nif (!(v & (1UL << bit)))\ngoto err;\nv &= ~(1UL << bit);\nif (!v)\ngoto delete;\nxas_store(&xas, xa_mk_value(v));\n} else {\nif (!bitmap || !test_bit(bit, bitmap->bitmap))\ngoto err;\n__clear_bit(bit, bitmap->bitmap);\nxas_set_mark(&xas, XA_FREE_MARK);\nif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\nkfree(bitmap);\ndelete:\nxas_store(&xas, NULL);\n}\n}\nxas_unlock_irqrestore(&xas, flags);\nreturn;\nerr:\nxas_unlock_irqrestore(&xas, flags);\nWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}\nEXPORT_SYMBOL(ida_free);\n```\n```c\nbool cancel_work_sync(struct work_struct *work)\n{\nreturn __cancel_work_sync(work, 0);\n}\nEXPORT_SYMBOL_GPL(cancel_work_sync);\n```\n```c\nvoid device_unregister(struct device *dev)\n{\npr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);\ndevice_del(dev);\nput_device(dev);\n}\nEXPORT_SYMBOL_GPL(device_unregister);\n```\n",
 "function_prototype": "void usb_del_gadget(struct usb_gadget *gadget)",
 "re_implemented_code": "\n```c\nvoid usb_del_gadget(struct usb_gadget *gadget)\n{\n// Retrieve the USB device controller associated with the gadget\nstruct usb_udc *udc = gadget->udc;\n// If there is no associated USB device controller, exit the function\nif (!udc)\nreturn;\n// Log a debug message indicating the gadget is being unregistered\ndev_vdbg(&gadget->dev, \"unregistering gadget\\n\");\n// Acquire the lock to ensure exclusive access to the USB device controller list\nmutex_lock(&udc->connect_lock);\n// Remove the USB device controller from the list\nlist_del(&udc->list);\n// Release the lock after modifying the list\nmutex_unlock(&udc->connect_lock);\n// Notify the system that the USB device controller is being removed\nkobject_uevent(&gadget->dev.kobj, KOBJ_REMOVE);\n// Remove the sysfs link for the gadget\nsysfs_remove_link(&gadget->dev.kobj, \"gadget\");\n// Ensure any pending work for the gadget is completed\nflush_work(&gadget->work);\n// Remove the device associated with the gadget\ndevice_del(&gadget->dev);\n// Free the ID number associated with the gadget\nida_free(&gadget->dev.id, gadget->id_number);\n// Cancel any pending work related to the USB device controller's VBUS\ncancel_work_sync(&udc->vbus_work);\n// Unregister the device associated with the USB device controller\ndevice_unregister(&udc->dev);\n}\n// Export the function to be available for use in other modules\nEXPORT_SYMBOL_GPL(usb_del_gadget);\n```\n",
 "is_vulnerable": true
}