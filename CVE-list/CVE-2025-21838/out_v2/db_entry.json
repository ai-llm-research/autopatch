{
  "cwe_type": "Improper Control of a Resource Through Its Lifetime",
  "cve_id": "CVE-2025-21838",
  "supplementary_code": "```c\nstruct usb_gadget {\nstruct work_struct work;\nstruct usb_udc *udc;\n/* readonly to gadget driver */\nconst struct usb_gadget_ops *ops;\nstruct usb_ep *ep0;\nstruct list_head ep_list; /* of usb_ep */\nenum usb_device_speed speed;\nenum usb_device_speed max_speed;\n/* USB SuperSpeed Plus only */\nenum usb_ssp_rate ssp_rate;\nenum usb_ssp_rate max_ssp_rate;\nenum usb_device_state state;\nconst char *name;\nstruct device dev;\nunsigned isoch_delay;\nunsigned out_epnum;\nunsigned in_epnum;\nunsigned mA;\nstruct usb_otg_caps *otg_caps;\nunsigned sg_supported:1;\nunsigned is_otg:1;\nunsigned is_a_peripheral:1;\nunsigned b_hnp_enable:1;\nunsigned a_hnp_support:1;\nunsigned a_alt_hnp_support:1;\nunsigned hnp_polling_support:1;\nunsigned host_request_flag:1;\nunsigned quirk_ep_out_aligned_size:1;\nunsigned quirk_altset_not_supp:1;\nunsigned quirk_stall_not_supp:1;\nunsigned quirk_zlp_not_supp:1;\nunsigned quirk_avoids_skb_reserve:1;\nunsigned is_selfpowered:1;\nunsigned deactivated:1;\nunsigned connected:1;\nunsigned lpm_capable:1;\nunsigned wakeup_capable:1;\nunsigned wakeup_armed:1;\nint irq;\nint id_number;\n};\n```\n```c\nstruct usb_udc {\nstruct usb_gadget_driver *driver;\nstruct usb_gadget *gadget;\nstruct device dev;\nstruct list_head list;\nbool vbus;\nbool started;\nbool allow_connect;\nstruct work_struct vbus_work;\nstruct mutex connect_lock;\n};\n```\n```c\n#define dev_vdbg(dev, fmt, ...) \\\ndev_no_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)\n```\n```c\nstatic int mutex_lock(unsigned long *m)\n{\nint c;\nint flags = FUTEX_WAIT;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nc = cmpxchg(m, 0, 1);\nif (!c)\nreturn 0;\nif (c == 1)\nc = xchg(m, 2);\nwhile (c) {\nsys_futex(m, flags, 2, NULL, NULL, 0);\nc = xchg(m, 2);\n}\nreturn 0;\n}\n```\n```c\nstatic inline void list_del(struct list_head *entry)\n{\n__list_del(entry->prev, entry->next);\nentry->next = LIST_POISON1;\nentry->prev = LIST_POISON2;\n}\n```\n```c\nstatic int mutex_unlock(unsigned long *m)\n{\nint flags = FUTEX_WAKE;\nif (!processes)\nflags |= FUTEX_PRIVATE_FLAG;\nif (*m == 2)\n*m = 0;\nelse if (xchg(m, 0) == 1)\nreturn 0;\nsys_futex(m, flags, 1, NULL, NULL, 0);\nreturn 0;\n}\n```\n```c\nint kobject_uevent(struct kobject *kobj, enum kobject_action action)\n{\nreturn kobject_uevent_env(kobj, action, NULL);\n}\nEXPORT_SYMBOL_GPL(kobject_uevent);\n```\n```c\nstatic inline void sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n}\n```\n```c\nbool flush_work(struct work_struct *work)\n{\nmight_sleep();\nreturn __flush_work(work, false);\n}\nEXPORT_SYMBOL_GPL(flush_work);\n```\n```c\nbool flush_work(struct work_struct *work)\n{\nmight_sleep();\nreturn __flush_work(work, false);\n}\nEXPORT_SYMBOL_GPL(flush_work);\n```\n```c\nvoid device_del(struct device *dev)\n{\nstruct subsys_private *sp;\nstruct device *parent = dev->parent;\nstruct kobject *glue_dir = NULL;\nstruct class_interface *class_intf;\nunsigned int noio_flag;\ndevice_lock(dev);\nkill_device(dev);\ndevice_unlock(dev);\nif (dev->fwnode && dev->fwnode->dev == dev)\ndev->fwnode->dev = NULL;\n/* Notify clients of device removal. This call must come\n* before dpm_sysfs_remove().\n*/\nnoio_flag = memalloc_noio_save();\nbus_notify(dev, BUS_NOTIFY_DEL_DEVICE);\ndpm_sysfs_remove(dev);\nif (parent)\nklist_del(&dev->p->knode_parent);\nif (MAJOR(dev->devt)) {\ndevtmpfs_delete_node(dev);\ndevice_remove_sys_dev_entry(dev);\ndevice_remove_file(dev, &dev_attr_dev);\n}\nsp = class_to_subsys(dev->class);\nif (sp) {\ndevice_remove_class_symlinks(dev);\nmutex_lock(&sp->mutex);\n/* notify any interfaces that the device is now gone */\nlist_for_each_entry(class_intf, &sp->interfaces, node)\nif (class_intf->remove_dev)\nclass_intf->remove_dev(dev);\n/* remove the device from the class list */\nklist_del(&dev->p->knode_class);\nmutex_unlock(&sp->mutex);\nsubsys_put(sp);\n}\ndevice_remove_file(dev, &dev_attr_uevent);\ndevice_remove_attrs(dev);\nbus_remove_device(dev);\ndevice_pm_remove(dev);\ndriver_deferred_probe_del(dev);\ndevice_platform_notify_remove(dev);\ndevice_links_purge(dev);\n/*\n* If a device does not have a driver attached, we need to clean\n* up any managed resources. We do this in device_release(), but\n* it's never called (and we leak the device) if a managed\n* resource holds a reference to the device. So release all\n* managed resources here, like we do in driver_detach(). We\n* still need to do so again in device_release() in case someone\n* adds a new resource after this point, though.\n*/\ndevres_release_all(dev);\nbus_notify(dev, BUS_NOTIFY_REMOVED_DEVICE);\nkobject_uevent(&dev->kobj, KOBJ_REMOVE);\nglue_dir = get_glue_dir(dev);\nkobject_del(&dev->kobj);\ncleanup_glue_dir(dev, glue_dir);\nmemalloc_noio_restore(noio_flag);\nput_device(parent);\n}\nEXPORT_SYMBOL_GPL(device_del);\n```\n```c\nvoid ida_free(struct ida *ida, unsigned int id)\n{\nXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\nunsigned bit = id % IDA_BITMAP_BITS;\nstruct ida_bitmap *bitmap;\nunsigned long flags;\nif ((int)id < 0)\nreturn;\nxas_lock_irqsave(&xas, flags);\nbitmap = xas_load(&xas);\nif (xa_is_value(bitmap)) {\nunsigned long v = xa_to_value(bitmap);\nif (bit >= BITS_PER_XA_VALUE)\ngoto err;\nif (!(v & (1UL << bit)))\ngoto err;\nv &= ~(1UL << bit);\nif (!v)\ngoto delete;\nxas_store(&xas, xa_mk_value(v));\n} else {\nif (!bitmap || !test_bit(bit, bitmap->bitmap))\ngoto err;\n__clear_bit(bit, bitmap->bitmap);\nxas_set_mark(&xas, XA_FREE_MARK);\nif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\nkfree(bitmap);\ndelete:\nxas_store(&xas, NULL);\n}\n}\nxas_unlock_irqrestore(&xas, flags);\nreturn;\nerr:\nxas_unlock_irqrestore(&xas, flags);\nWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}\nEXPORT_SYMBOL(ida_free);\n```\n```c\nbool cancel_work_sync(struct work_struct *work)\n{\nreturn __cancel_work_sync(work, 0);\n}\nEXPORT_SYMBOL_GPL(cancel_work_sync);\n```\n```c\nvoid device_unregister(struct device *dev)\n{\npr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);\ndevice_del(dev);\nput_device(dev);\n}\nEXPORT_SYMBOL_GPL(device_unregister);\n```",
  "original_code": "```c\nvoid usb_del_gadget(struct usb_gadget *gadget)\n{\nstruct usb_udc *udc = gadget->udc;\nif (!udc)\nreturn;\ndev_vdbg(gadget->dev.parent, \"unregistering gadget\\n\");\nmutex_lock(&udc_lock);\nlist_del(&udc->list);\nmutex_unlock(&udc_lock);\nkobject_uevent(&udc->dev.kobj, KOBJ_REMOVE);\nsysfs_remove_link(&udc->dev.kobj, \"gadget\");\nflush_work(&gadget->work);\ndevice_del(&gadget->dev);\nida_free(&gadget_id_numbers, gadget->id_number);\ncancel_work_sync(&udc->vbus_work);\ndevice_unregister(&udc->dev);\n}\nEXPORT_SYMBOL_GPL(usb_del_gadget);\n```",
  "vuln_patch": "```c\nvoid usb_del_gadget(struct usb_gadget *gadget)\n{\nstruct usb_udc *udc = gadget->udc;\nif (!udc)\nreturn;\ndev_vdbg(gadget->dev.parent, \"unregistering gadget\\n\");\nmutex_lock(&udc_lock);\nlist_del(&udc->list);\nmutex_unlock(&udc_lock);\nkobject_uevent(&udc->dev.kobj, KOBJ_REMOVE);\nsysfs_remove_link(&udc->dev.kobj, \"gadget\");\ndevice_del(&gadget->dev);\nflush_work(&gadget->work);\nida_free(&gadget_id_numbers, gadget->id_number);\ncancel_work_sync(&udc->vbus_work);\ndevice_unregister(&udc->dev);\n}\nEXPORT_SYMBOL_GPL(usb_del_gadget);\n```",
  "function_name": "usb_del_gadget",
  "function_prototype": "void usb_del_gadget(struct usb_gadget *gadget)",
  "code_semantics": "The function is responsible for unregistering a USB gadget. It first checks if the gadget has an associated USB device controller. If it does, it logs a debug message, locks a mutex, and removes the device controller from a list. It then unlocks the mutex, triggers a user-space event to notify of the device removal, and removes a sysfs link representing the gadget. The function flushes any pending work for the gadget, deletes the associated device, frees the gadget's identifier, cancels pending VBUS work, and unregisters the device controller, completing the cleanup process.",
  "safe_verification_cot": "1. In the Target Code, device_del(&gadget->dev); is called before flush_work(&gadget->work);. This satisfies the checklist item, ensuring that the device is properly deleted before flushing any associated work.\n2. The gadget->work is properly handled after device_del is called, as it is flushed only after the device is fully deleted.\n3. The order of operations ensures that device_del is called before any operations that might access the device's resources, maintaining proper control of the resource through its lifetime.",
  "verification_cot": "1. In the Vulnerable Code, flush_work(&gadget->work); is called before device_del(&gadget->dev);. This violates the checklist item, as the work is being flushed while the device is still in the process of being deleted, leading to potential resource management issues.\n2. The gadget->work is not properly handled after device_del is called, as it is flushed before the device is fully deleted.\n3. The order of operations does not ensure that device_del is called before any operations that might access the device's resources, leading to improper control of the resource through its lifetime.",
  "vulnerability_related_variables": {
    "gadget->work": "This variable represents a unit of work that can be scheduled and executed asynchronously. It is used to manage tasks that need to be completed in the background, ensuring they are finished before the associated entity is deleted.",
    "gadget->dev": "This variable represents the entity as a device within the system. It is used to manage the lifecycle of the device, including its registration, removal, and cleanup of associated resources."
  },
  "vulnerability_related_functions": {
    "flush_work": "This function ensures that any pending tasks associated with a given task structure are completed before proceeding. It may involve waiting for the task to finish if it is currently being executed.",
    "device_del": "This function is responsible for removing a device from the system. It involves notifying clients about the removal, cleaning up system file entries, and releasing any resources associated with the device. It ensures that the device is properly unregistered and all related resources are freed."
  },
  "root_cause": "Improper order of operations in usb_del_gadget function, where flush_work was called before device_del, leading to potential use-after-free or resource management issues.",
  "patch_cot": "First, identify the order of operations in the usb_del_gadget function. The original order was causing the vulnerability. Move the call to device_del(&gadget->dev); before the call to flush_work(&gadget->work);. This ensures that the device is properly deleted and its resources are managed before any work associated with it is flushed. By doing this, we ensure that the device's resources are not accessed after they have been freed, thus preventing the use-after-free condition."
}