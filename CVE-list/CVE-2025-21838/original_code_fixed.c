

struct list_head {
    struct list_head *next, *prev;
};

struct work_struct {
    void (*func)(void *);
    void *data;
};

struct usb_gadget {
    struct usb_udc *udc;
    struct {
        struct {
            void *parent;
        } dev;
    } dev;
    struct work_struct work;
    int id_number;
};

struct usb_udc {
    struct {
        struct {
            void *kobj;
        } dev;
    } dev;
    struct list_head list;
    struct work_struct vbus_work;
};

void dev_vdbg(void *parent, const char *fmt) {}
void mutex_lock(void *lock) {}
void mutex_unlock(void *lock) {}
void list_del(struct list_head *entry) {}
void kobject_uevent(void *kobj, int action) {}
void sysfs_remove_link(void *kobj, const char *name) {}
void flush_work(struct work_struct *work) {}
void device_del(void *dev) {}
void ida_free(void *ida, int id) {}
void cancel_work_sync(struct work_struct *work) {}
void device_unregister(void *dev) {}

void usb_del_gadget(struct usb_gadget *gadget)
{
    struct usb_udc *udc = gadget->udc;
    void *udc_lock = 0;
    void *gadget_id_numbers = 0;

    if (!udc)
        return;

    dev_vdbg(gadget->dev.dev.parent, "unregistering gadget\n");

    mutex_lock(&udc_lock);
    list_del(&udc->list);
    mutex_unlock(&udc_lock);

    kobject_uevent(&udc->dev.dev.kobj, 0); // Assuming KOBJ_REMOVE corresponds to 0
    sysfs_remove_link(&udc->dev.dev.kobj, "gadget");
    flush_work(&gadget->work);
    device_del(&gadget->dev);
    ida_free(&gadget_id_numbers, gadget->id_number);
    cancel_work_sync(&udc->vbus_work);
    device_unregister(&udc->dev);
}

void EXPORT_SYMBOL_GPL(void (*func)(struct usb_gadget *)) {}

