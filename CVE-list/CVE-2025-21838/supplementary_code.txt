```c
struct usb_gadget {
    struct work_struct      work;
    struct usb_udc          *udc;
    /* readonly to gadget driver */
    const struct usb_gadget_ops *ops;
    struct usb_ep           *ep0;
    struct list_head        ep_list;    /* of usb_ep */
    enum usb_device_speed       speed;
    enum usb_device_speed       max_speed;

    /* USB SuperSpeed Plus only */
    enum usb_ssp_rate       ssp_rate;
    enum usb_ssp_rate       max_ssp_rate;

    enum usb_device_state       state;
    const char          *name;
    struct device           dev;
    unsigned            isoch_delay;
    unsigned            out_epnum;
    unsigned            in_epnum;
    unsigned            mA;
    struct usb_otg_caps     *otg_caps;

    unsigned            sg_supported:1;
    unsigned            is_otg:1;
    unsigned            is_a_peripheral:1;
    unsigned            b_hnp_enable:1;
    unsigned            a_hnp_support:1;
    unsigned            a_alt_hnp_support:1;
    unsigned            hnp_polling_support:1;
    unsigned            host_request_flag:1;
    unsigned            quirk_ep_out_aligned_size:1;
    unsigned            quirk_altset_not_supp:1;
    unsigned            quirk_stall_not_supp:1;
    unsigned            quirk_zlp_not_supp:1;
    unsigned            quirk_avoids_skb_reserve:1;
    unsigned            is_selfpowered:1;
    unsigned            deactivated:1;
    unsigned            connected:1;
    unsigned            lpm_capable:1;
    unsigned            wakeup_capable:1;
    unsigned            wakeup_armed:1;
    int             irq;
    int             id_number;
};
```

```c
struct usb_udc {
    struct usb_gadget_driver    *driver;
    struct usb_gadget       *gadget;
    struct device           dev;
    struct list_head        list;
    bool                vbus;
    bool                started;
    bool                allow_connect;
    struct work_struct      vbus_work;
    struct mutex            connect_lock;
};
```

```c
#define dev_vdbg(dev, fmt, ...)                     \
    dev_no_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)
```

```c
static int mutex_lock(unsigned long *m)
{
    int c;
    int flags = FUTEX_WAIT;
    if (!processes)
        flags |= FUTEX_PRIVATE_FLAG;

    c = cmpxchg(m, 0, 1);
    if (!c)
        return 0;

    if (c == 1)
        c = xchg(m, 2);

    while (c) {
        sys_futex(m, flags, 2, NULL, NULL, 0);
        c = xchg(m, 2);
    }

    return 0;
}
```

```c
static inline void list_del(struct list_head *entry)
{
    __list_del(entry->prev, entry->next);
    entry->next = LIST_POISON1;
    entry->prev = LIST_POISON2;
}
```

```c
static int mutex_unlock(unsigned long *m)
{
    int flags = FUTEX_WAKE;
    if (!processes)
        flags |= FUTEX_PRIVATE_FLAG;

    if (*m == 2)
        *m = 0;
    else if (xchg(m, 0) == 1)
        return 0;

    sys_futex(m, flags, 1, NULL, NULL, 0);

    return 0;
}
```

```c
int kobject_uevent(struct kobject *kobj, enum kobject_action action)
{
    return kobject_uevent_env(kobj, action, NULL);
}
EXPORT_SYMBOL_GPL(kobject_uevent);
```

```c
static inline void sysfs_remove_link(struct kobject *kobj, const char *name)
{
}
```

```c
bool flush_work(struct work_struct *work)
{
    might_sleep();
    return __flush_work(work, false);
}
EXPORT_SYMBOL_GPL(flush_work);
```

```c
bool flush_work(struct work_struct *work)
{
    might_sleep();
    return __flush_work(work, false);
}
EXPORT_SYMBOL_GPL(flush_work);
```

```c
void device_del(struct device *dev)
{
    struct subsys_private *sp;
    struct device *parent = dev->parent;
    struct kobject *glue_dir = NULL;
    struct class_interface *class_intf;
    unsigned int noio_flag;

    device_lock(dev);
    kill_device(dev);
    device_unlock(dev);

    if (dev->fwnode && dev->fwnode->dev == dev)
        dev->fwnode->dev = NULL;

    /* Notify clients of device removal.  This call must come
     * before dpm_sysfs_remove().
     */
    noio_flag = memalloc_noio_save();
    bus_notify(dev, BUS_NOTIFY_DEL_DEVICE);

    dpm_sysfs_remove(dev);
    if (parent)
        klist_del(&dev->p->knode_parent);
    if (MAJOR(dev->devt)) {
        devtmpfs_delete_node(dev);
        device_remove_sys_dev_entry(dev);
        device_remove_file(dev, &dev_attr_dev);
    }

    sp = class_to_subsys(dev->class);
    if (sp) {
        device_remove_class_symlinks(dev);

        mutex_lock(&sp->mutex);
        /* notify any interfaces that the device is now gone */
        list_for_each_entry(class_intf, &sp->interfaces, node)
            if (class_intf->remove_dev)
                class_intf->remove_dev(dev);
        /* remove the device from the class list */
        klist_del(&dev->p->knode_class);
        mutex_unlock(&sp->mutex);
        subsys_put(sp);
    }
    device_remove_file(dev, &dev_attr_uevent);
    device_remove_attrs(dev);
    bus_remove_device(dev);
    device_pm_remove(dev);
    driver_deferred_probe_del(dev);
    device_platform_notify_remove(dev);
    device_links_purge(dev);

    /*
     * If a device does not have a driver attached, we need to clean
     * up any managed resources. We do this in device_release(), but
     * it's never called (and we leak the device) if a managed
     * resource holds a reference to the device. So release all
     * managed resources here, like we do in driver_detach(). We
     * still need to do so again in device_release() in case someone
     * adds a new resource after this point, though.
     */
    devres_release_all(dev);

    bus_notify(dev, BUS_NOTIFY_REMOVED_DEVICE);
    kobject_uevent(&dev->kobj, KOBJ_REMOVE);
    glue_dir = get_glue_dir(dev);
    kobject_del(&dev->kobj);
    cleanup_glue_dir(dev, glue_dir);
    memalloc_noio_restore(noio_flag);
    put_device(parent);
}
EXPORT_SYMBOL_GPL(device_del);
```

```c
void ida_free(struct ida *ida, unsigned int id)
{
    XA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);
    unsigned bit = id % IDA_BITMAP_BITS;
    struct ida_bitmap *bitmap;
    unsigned long flags;

    if ((int)id < 0)
        return;

    xas_lock_irqsave(&xas, flags);
    bitmap = xas_load(&xas);

    if (xa_is_value(bitmap)) {
        unsigned long v = xa_to_value(bitmap);
        if (bit >= BITS_PER_XA_VALUE)
            goto err;
        if (!(v & (1UL << bit)))
            goto err;
        v &= ~(1UL << bit);
        if (!v)
            goto delete;
        xas_store(&xas, xa_mk_value(v));
    } else {
        if (!bitmap || !test_bit(bit, bitmap->bitmap))
            goto err;
        __clear_bit(bit, bitmap->bitmap);
        xas_set_mark(&xas, XA_FREE_MARK);
        if (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {
            kfree(bitmap);
delete:
            xas_store(&xas, NULL);
        }
    }
    xas_unlock_irqrestore(&xas, flags);
    return;
 err:
    xas_unlock_irqrestore(&xas, flags);
    WARN(1, "ida_free called for id=%d which is not allocated.\n", id);
}
EXPORT_SYMBOL(ida_free);
```

```c
bool cancel_work_sync(struct work_struct *work)
{
    return __cancel_work_sync(work, 0);
}
EXPORT_SYMBOL_GPL(cancel_work_sync);
```

```c
void device_unregister(struct device *dev)
{
    pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
    device_del(dev);
    put_device(dev);
}
EXPORT_SYMBOL_GPL(device_unregister);
```
