
struct device {
    int dummy;
};

struct auxiliary_device {
    struct device dev;
};

struct auxiliary_device_id {
};

struct qcom_tzmem_pool_config {
    int initial_size;
    int policy;
    int increment;
    int max_size;
};

struct efivars {
    int dummy;
};

struct qcom_tzmem_pool {
    int dummy;
};

struct qseecom_client {
    struct auxiliary_device aux_dev;
};

struct qcuefi_client {
    struct qseecom_client *client;
    struct efivars efivars;
    struct qcom_tzmem_pool *mempool;
};

typedef unsigned long size_t;

static struct qcom_tzmem_pool *devm_qcom_tzmem_pool_new(struct device *dev, struct qcom_tzmem_pool_config *config) {
    return 0;
}

static struct qcuefi_client *devm_kzalloc(struct device *dev, size_t size, int gfp) {
    return 0;
}

static void auxiliary_set_drvdata(struct auxiliary_device *aux_dev, void *data) {
}

static int qcuefi_set_reference(struct qcuefi_client *client) {
    return 0;
}

static int efivars_register(struct efivars *efivars, const void *ops) {
    return 0;
}

#undef NULL
#define NULL 0

#define GFP_KERNEL 0
#define ENOMEM 12
#define SZ_4K 4096
#define QCOM_TZMEM_POLICY_MULTIPLIER 1
#define SZ_256K 262144

#define IS_ERR(x) ((unsigned long)(x) > (unsigned long)-1000L)
#define PTR_ERR(x) ((int)(long)(x))

static struct qseecom_client *container_of(struct auxiliary_device *aux_dev, struct qseecom_client *ptr, struct auxiliary_device *aux) {
    return NULL;
}

static void my_memset(void *destination, int value, size_t size) {
    char *p = (char *)destination;
    while (size--) {
        *p++ = (char)value;
    }
}

static const void *qcom_efivar_ops;

static int qcom_uefisecapp_probe(struct auxiliary_device *aux_dev,
                 const struct auxiliary_device_id *aux_dev_id)
{
    struct qcom_tzmem_pool_config pool_config;
    struct qcuefi_client *qcuefi;
    int status;

    qcuefi = devm_kzalloc(&aux_dev->dev, sizeof(*qcuefi), GFP_KERNEL);
    if (!qcuefi)
        return -ENOMEM;

    qcuefi->client = container_of(aux_dev, (struct qseecom_client *)NULL, (struct auxiliary_device *)NULL);

    auxiliary_set_drvdata(aux_dev, qcuefi);
    status = qcuefi_set_reference(qcuefi);
    if (status)
        return status;

    status = efivars_register(&qcuefi->efivars, qcom_efivar_ops);
    if (status)
        qcuefi_set_reference(NULL);

    my_memset(&pool_config, 0, sizeof(pool_config));
    pool_config.initial_size = SZ_4K;
    pool_config.policy = QCOM_TZMEM_POLICY_MULTIPLIER;
    pool_config.increment = 2;
    pool_config.max_size = SZ_256K;

    qcuefi->mempool = devm_qcom_tzmem_pool_new(&aux_dev->dev, &pool_config);
    if (IS_ERR(qcuefi->mempool))
        return PTR_ERR(qcuefi->mempool);

    return 0;
}
