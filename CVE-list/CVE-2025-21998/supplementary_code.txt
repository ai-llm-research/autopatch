```c
struct auxiliary_device {
    struct device dev;
    const char *name;
    u32 id;
    struct {
        struct xarray irqs;
        struct mutex lock; /* Synchronize irq sysfs creation */
        bool irq_dir_exists;
    } sysfs;
};
```

```c
struct auxiliary_device_id {
    char name[AUXILIARY_NAME_SIZE];
    kernel_ulong_t driver_data;
};

```

```c
static inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
{
    return devm_kmalloc(dev, size, gfp | __GFP_ZERO);
}
```

```c
#define GFP_KERNEL  (__GFP_RECLAIM | __GFP_IO | __GFP_FS)
```

```c
#define ENOMEM      12  /* Out of memory */
```

```c
#define container_of(ptr, type, member) ({              \
    void *__mptr = (void *)(ptr);                   \
    static_assert(__same_type(*(ptr), ((type *)0)->member) ||   \
              __same_type(*(ptr), void),            \
              "pointer type mismatch in container_of()");   \
    ((type *)(__mptr - offsetof(type, member))); })
```

```c
static inline void auxiliary_set_drvdata(struct auxiliary_device *auxdev, void *data)
{
    dev_set_drvdata(&auxdev->dev, data);
}
```

```c
static int qcuefi_set_reference(struct qcuefi_client *qcuefi)
{
    mutex_lock(&__qcuefi_lock);

    if (qcuefi && __qcuefi) {
        mutex_unlock(&__qcuefi_lock);
        return -EEXIST;
    }

    __qcuefi = qcuefi;

    mutex_unlock(&__qcuefi_lock);
    return 0;
}
```

```c
int efivars_register(struct efivars *efivars,
             const struct efivar_operations *ops)
{
    int rv;
    int event;

    if (down_interruptible(&efivars_lock))
        return -EINTR;

    if (__efivars) {
        pr_warn("efivars already registered\n");
        rv = -EBUSY;
        goto out;
    }

    efivars->ops = ops;

    __efivars = efivars;

    if (efivar_supports_writes())
        event = EFIVAR_OPS_RDWR;
    else
        event = EFIVAR_OPS_RDONLY;

    blocking_notifier_call_chain(&efivar_ops_nh, event, NULL);

    pr_info("Registered efivars operations\n");
    rv = 0;
out:
    up(&efivars_lock);

    return rv;
}
EXPORT_SYMBOL_GPL(efivars_register);
```

```c
#define __HAVE_ARCH_MEMSET
extern void *memset(void *, int, __kernel_size_t);
#define memset(d, c, n) __builtin_memset(d, c, n)
```

```c
#define SZ_4K               0x00001000
#define SZ_256K             0x00040000
```

```c
enum qcom_tzmem_policy {
    /**< Static pool, never grow above initial size. */
    QCOM_TZMEM_POLICY_STATIC = 1,
    /**< When out of memory, add increment * current size of memory. */
    QCOM_TZMEM_POLICY_MULTIPLIER,
    /**< When out of memory add as much as is needed until max_size. */
    QCOM_TZMEM_POLICY_ON_DEMAND,
};
```

```c
struct qcom_tzmem_pool *
devm_qcom_tzmem_pool_new(struct device *dev,
             const struct qcom_tzmem_pool_config *config)
{
    struct qcom_tzmem_pool *pool;
    int ret;

    pool = qcom_tzmem_pool_new(config);
    if (IS_ERR(pool))
        return pool;

    ret = devm_add_action_or_reset(dev, devm_qcom_tzmem_pool_free, pool);
    if (ret)
        return ERR_PTR(ret);

    return pool;
}
EXPORT_SYMBOL_GPL(devm_qcom_tzmem_pool_new);
```

```c
static inline bool __must_check IS_ERR(__force const void *ptr)
{
    return IS_ERR_VALUE((unsigned long)ptr);
}
```

```c
static inline long __must_check PTR_ERR(__force const void *ptr)
{
    return (long) ptr;
}
```
