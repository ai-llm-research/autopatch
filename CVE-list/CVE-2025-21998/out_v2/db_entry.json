{
  "cwe_type": "Race Condition",
  "cve_id": "CVE-2025-21998",
  "supplementary_code": "```c\nstruct auxiliary_device {\nstruct device dev;\nconst char *name;\nu32 id;\nstruct {\nstruct xarray irqs;\nstruct mutex lock; /* Synchronize irq sysfs creation */\nbool irq_dir_exists;\n} sysfs;\n};\n```\n```c\nstruct auxiliary_device_id {\nchar name[AUXILIARY_NAME_SIZE];\nkernel_ulong_t driver_data;\n};\n```\n```c\nstatic inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)\n{\nreturn devm_kmalloc(dev, size, gfp | __GFP_ZERO);\n}\n```\n```c\n#define GFP_KERNEL (__GFP_RECLAIM | __GFP_IO | __GFP_FS)\n```\n```c\n#define ENOMEM 12 /* Out of memory */\n```\n```c\n#define container_of(ptr, type, member) ({ \\\nvoid *__mptr = (void *)(ptr); \\\nstatic_assert(__same_type(*(ptr), ((type *)0)->member) || \\\n__same_type(*(ptr), void), \\\n\"pointer type mismatch in container_of()\"); \\\n((type *)(__mptr - offsetof(type, member))); })\n```\n```c\nstatic inline void auxiliary_set_drvdata(struct auxiliary_device *auxdev, void *data)\n{\ndev_set_drvdata(&auxdev->dev, data);\n}\n```\n```c\nstatic int qcuefi_set_reference(struct qcuefi_client *qcuefi)\n{\nmutex_lock(&__qcuefi_lock);\nif (qcuefi && __qcuefi) {\nmutex_unlock(&__qcuefi_lock);\nreturn -EEXIST;\n}\n__qcuefi = qcuefi;\nmutex_unlock(&__qcuefi_lock);\nreturn 0;\n}\n```\n```c\nint efivars_register(struct efivars *efivars,\nconst struct efivar_operations *ops)\n{\nint rv;\nint event;\nif (down_interruptible(&efivars_lock))\nreturn -EINTR;\nif (__efivars) {\npr_warn(\"efivars already registered\\n\");\nrv = -EBUSY;\ngoto out;\n}\nefivars->ops = ops;\n__efivars = efivars;\nif (efivar_supports_writes())\nevent = EFIVAR_OPS_RDWR;\nelse\nevent = EFIVAR_OPS_RDONLY;\nblocking_notifier_call_chain(&efivar_ops_nh, event, NULL);\npr_info(\"Registered efivars operations\\n\");\nrv = 0;\nout:\nup(&efivars_lock);\nreturn rv;\n}\nEXPORT_SYMBOL_GPL(efivars_register);\n```\n```c\n#define __HAVE_ARCH_MEMSET\nextern void *memset(void *, int, __kernel_size_t);\n#define memset(d, c, n) __builtin_memset(d, c, n)\n```\n```c\n#define SZ_4K 0x00001000\n#define SZ_256K 0x00040000\n```\n```c\nenum qcom_tzmem_policy {\n/**< Static pool, never grow above initial size. */\nQCOM_TZMEM_POLICY_STATIC = 1,\n/**< When out of memory, add increment * current size of memory. */\nQCOM_TZMEM_POLICY_MULTIPLIER,\n/**< When out of memory add as much as is needed until max_size. */\nQCOM_TZMEM_POLICY_ON_DEMAND,\n};\n```\n```c\nstruct qcom_tzmem_pool *\ndevm_qcom_tzmem_pool_new(struct device *dev,\nconst struct qcom_tzmem_pool_config *config)\n{\nstruct qcom_tzmem_pool *pool;\nint ret;\npool = qcom_tzmem_pool_new(config);\nif (IS_ERR(pool))\nreturn pool;\nret = devm_add_action_or_reset(dev, devm_qcom_tzmem_pool_free, pool);\nif (ret)\nreturn ERR_PTR(ret);\nreturn pool;\n}\nEXPORT_SYMBOL_GPL(devm_qcom_tzmem_pool_new);\n```\n```c\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\nreturn IS_ERR_VALUE((unsigned long)ptr);\n}\n```\n```c\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\nreturn (long) ptr;\n}\n```",
  "original_code": "```c\nstatic int qcom_uefisecapp_probe(struct auxiliary_device *aux_dev,\nconst struct auxiliary_device_id *aux_dev_id)\n{\nstruct qcom_tzmem_pool_config pool_config;\nstruct qcuefi_client *qcuefi;\nint status;\nqcuefi = devm_kzalloc(&aux_dev->dev, sizeof(*qcuefi), GFP_KERNEL);\nif (!qcuefi)\nreturn -ENOMEM;\nqcuefi->client = container_of(aux_dev, struct qseecom_client, aux_dev);\nauxiliary_set_drvdata(aux_dev, qcuefi);\nstatus = qcuefi_set_reference(qcuefi);\nif (status)\nreturn status;\nstatus = efivars_register(&qcuefi->efivars, &qcom_efivar_ops);\nif (status)\nqcuefi_set_reference(NULL);\nmemset(&pool_config, 0, sizeof(pool_config));\npool_config.initial_size = SZ_4K;\npool_config.policy = QCOM_TZMEM_POLICY_MULTIPLIER;\npool_config.increment = 2;\npool_config.max_size = SZ_256K;\nqcuefi->mempool = devm_qcom_tzmem_pool_new(&aux_dev->dev, &pool_config);\nif (IS_ERR(qcuefi->mempool))\nreturn PTR_ERR(qcuefi->mempool);\nreturn status;\n}\n```",
  "vuln_patch": "```c\nstatic int qcom_uefisecapp_probe(struct auxiliary_device *aux_dev,\nconst struct auxiliary_device_id *aux_dev_id)\n{\nstruct qcom_tzmem_pool_config pool_config;\nstruct qcuefi_client *qcuefi;\nint status;\nqcuefi = devm_kzalloc(&aux_dev->dev, sizeof(*qcuefi), GFP_KERNEL);\nif (!qcuefi)\nreturn -ENOMEM;\nqcuefi->client = container_of(aux_dev, struct qseecom_client, aux_dev);\nmemset(&pool_config, 0, sizeof(pool_config));\npool_config.initial_size = SZ_4K;\npool_config.policy = QCOM_TZMEM_POLICY_MULTIPLIER;\npool_config.increment = 2;\npool_config.max_size = SZ_256K;\nqcuefi->mempool = devm_qcom_tzmem_pool_new(&aux_dev->dev, &pool_config);\nif (IS_ERR(qcuefi->mempool))\nreturn PTR_ERR(qcuefi->mempool);\nauxiliary_set_drvdata(aux_dev, qcuefi);\nstatus = qcuefi_set_reference(qcuefi);\nif (status)\nreturn status;\nstatus = efivars_register(&qcuefi->efivars, &qcom_efivar_ops);\nif (status)\nqcuefi_set_reference(NULL);\nreturn status;\n}\n```",
  "function_name": "qcom_uefisecapp_probe",
  "function_prototype": "static int qcom_uefisecapp_probe(struct auxiliary_device *aux_dev, const struct auxiliary_device_id *aux_dev_id)",
  "code_semantics": "The function initializes a client structure for a Qualcomm UEFI secure application. It allocates memory for the client, associates it with an auxiliary device, and sets a reference to it. It registers EFI variables and configures a memory pool with specific size and policy parameters. The function checks for errors at each step and returns a status indicating success or failure.",
  "safe_verification_cot": "1. In the Target Code, auxiliary_set_drvdata is called after devm_qcom_tzmem_pool_new, ensuring that the memory pool is initialized before setting the driver data. 2. qcuefi_set_reference is called after the memory pool is initialized, preventing the setting of a reference to an uninitialized qcuefi_client. 3. efivars_register is called after the memory pool is initialized, ensuring that all operations are performed on a fully initialized qcuefi_client. 4. devm_kzalloc is used correctly, and the order of operations ensures that the allocated memory is properly initialized before use.",
  "verification_cot": "1. In the Vulnerable Code, auxiliary_set_drvdata is called before devm_qcom_tzmem_pool_new, leading to a potential race condition. 2. qcuefi_set_reference is also called before the memory pool is initialized, which can lead to a situation where the reference is set to an uninitialized or partially initialized qcuefi_client. 3. efivars_register is called after qcuefi_set_reference, but since the memory pool is not initialized before these calls, it can lead to race conditions. 4. devm_kzalloc is correctly used to allocate qcuefi, but the order of subsequent operations introduces the vulnerability.",
  "vulnerability_related_variables": {
    "qcuefi": "This variable acts as a container for client-specific data, including a reference to a client structure, EFI variable operations, and a memory pool. It is initialized with zeroed memory, linked to a device, and used to manage resources and operations specific to the client.",
    "pool_config": "This variable is a configuration structure used to define the parameters for a memory pool, including its initial size, allocation policy, increment factor, and maximum size. It is initialized to zero and then populated with specific values to guide the creation of a memory pool."
  },
  "vulnerability_related_functions": {
    "devm_kzalloc": "Allocates a block of memory of a specified size, initializes it to zero, and associates it with a device for automatic cleanup.",
    "auxiliary_set_drvdata": "Stores a custom data pointer within a device structure for later retrieval.",
    "qcuefi_set_reference": "Sets a global reference to a client object if not already set, ensuring exclusive access using a mutex.",
    "efivars_register": "Registers a set of operations for managing EFI variables, ensuring exclusive registration and notifying other components of the registration.",
    "devm_qcom_tzmem_pool_new": "Creates and configures a memory pool associated with a device, ensuring automatic management and cleanup."
  },
  "root_cause": "Race condition due to improper order of operations, leading to access of uninitialized or partially initialized data.",
  "patch_cot": "Step 1: Initialize qcuefi using devm_kzalloc and check for successful allocation. Step 2: Set up pool_config using memset to ensure it is zeroed out and then configure its fields. Step 3: Create the memory pool using devm_qcom_tzmem_pool_new and check for errors. Step 4: Only after qcuefi and pool_config are fully initialized, call auxiliary_set_drvdata to set the driver data. Step 5: Call qcuefi_set_reference to set the reference, ensuring that qcuefi is fully initialized. Step 6: Register efivars using efivars_register, ensuring that all previous steps have been completed successfully."
}