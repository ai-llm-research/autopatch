

typedef long long int64_t;

struct AVIOContext {};

struct AVStream {
    int64_t duration;
};

struct AVFormatContext {
    struct AVIOContext *pb;
    struct AVStream **streams;
    void *priv_data;
};

struct CafContext {
    int packet_cnt;
    int frame_cnt;
    int bytes_per_packet;
    int frames_per_packet;
    int64_t num_bytes;
};

// Function stubs
int64_t avio_tell(struct AVIOContext *pb) { return 0; }
int avio_rb32(struct AVIOContext *pb) { return 0; }
int avio_feof(struct AVIOContext *pb) { return 0; }
int av_add_index_entry(struct AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags) { return 0; }
int av_log(struct AVFormatContext *s, int level, const char *fmt, ...) { return 0; }
int avio_seek(struct AVIOContext *pb, int64_t offset, int whence) { return 0; }

// Error codes
#define AVERROR_INVALIDDATA (-1)
#define AVERROR_EOF (-2)
#define AV_LOG_ERROR 16
#define AVINDEX_KEYFRAME 1
#define SEEK_SET 0

static int read_pakt_chunk(struct AVFormatContext *s, int64_t size) {
    struct AVIOContext *pb = s->pb;
    struct AVStream *st = s->streams[0];
    struct CafContext *caf = (struct CafContext *)s->priv_data;

    caf->packet_cnt = 0;
    caf->frame_cnt  = 0;

    int64_t pos = avio_tell(pb);

    int num_packets = avio_rb32(pb);
    if (num_packets <= 0)
        return AVERROR_INVALIDDATA;

    int total_frames = avio_rb32(pb);
    (void)total_frames;

    if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {
        int64_t duration = (int64_t)num_packets * caf->frames_per_packet;
        st->duration = duration;
        pos += (int64_t)num_packets * caf->bytes_per_packet;
        caf->packet_cnt += num_packets;
        caf->frame_cnt  += duration;
    } else {
        st->duration = 0;
        for (int i = 0; i < num_packets; i++) {
            if (avio_feof(pb))
                return AVERROR_EOF;

            int pkt_size = avio_rb32(pb);
            int ret = av_add_index_entry(st, pos, st->duration, pkt_size, 0, AVINDEX_KEYFRAME);
            if (ret < 0)
                return ret;

            pos += pkt_size;
            st->duration++;
            caf->packet_cnt++;
            caf->frame_cnt++;
        }
    }

    if (avio_tell(pb) > size) {
        av_log(s, AV_LOG_ERROR, "Packet table chunk exceeds expected size\n");
        return AVERROR_INVALIDDATA;
    }

    int ret = avio_seek(pb, size, SEEK_SET);
    if (ret < 0)
        return ret;

    caf->num_bytes = size;

    return 0;
}

