

typedef struct AVIOContext AVIOContext;
typedef struct AVStream AVStream;
typedef struct AVFormatContext AVFormatContext;
typedef struct CafContext CafContext;

typedef long long int64_t;

struct AVFormatContext {
    AVIOContext *pb;
    AVStream **streams;
};

struct AVStream {
    void *priv_data;
    int64_t duration;
    int time_base;
};

struct CafContext {
    int64_t num_bytes;
    int packets;
    int packet_cnt;
    int frame_cnt;
    int bytes_per_packet;
    int frames_per_packet;
    double bit_rate;
};

int64_t avio_tell(AVIOContext *s);
int64_t avio_rl32(AVIOContext *s);
int avio_feof(AVIOContext *s);
void avio_skip(AVIOContext *s, int64_t offset);
int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags);
void av_log(AVFormatContext *s, int level, const char *fmt, ...);
int av_rescale_q(int a, int b, int c);

// Error constants
#define AVERROR_INVALIDDATA -1
#define AVERROR_UNKNOWN -2
#define AVERROR_EOF -3

// AV_LOG constants
#define AV_LOG_ERROR 0
#define AV_LOG_WARNING 1

#define STREAM_FRAME_RATE 25
#define STREAM_DURATION 3600
#define AV_TIME_BASE_Q 1

static int read_pakt_chunk(AVFormatContext *s, int64_t size) {
    AVIOContext *pb = s->pb;
    AVStream *st = s->streams[0];
    CafContext *caf = (CafContext *)st->priv_data;

    caf->num_bytes = 0;
    caf->packet_cnt = 0;
    caf->frame_cnt = 0;

    int64_t cur_pos = avio_tell(pb);
    int64_t pakt_length = avio_rl32(pb);
    if (pakt_length <= 0) {
        av_log(s, AV_LOG_ERROR, "Invalid PAKT chunk length\n");
        return AVERROR_INVALIDDATA;
    }

    if (pakt_length % 4 != 0) {
        av_log(s, AV_LOG_ERROR, "PAKT chunk length is not divisible by 4\n");
        return AVERROR_INVALIDDATA;
    }

    int num_packets = pakt_length / 4;
    double total_duration = 0;
    int64_t prev_timestamp = 0;

    if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {
        total_duration = (double)(num_packets * caf->bytes_per_packet) / caf->bit_rate;
        int64_t final_pos = cur_pos + pakt_length;

        if (final_pos > size) {
            av_log(s, AV_LOG_WARNING, "Truncating PAKT chunk due to size constraint\n");
            final_pos = size;
        }

        for (int i = 0; i < num_packets; ++i) {
            int64_t packet_pos = cur_pos + i * caf->bytes_per_packet;
            int64_t timestamp = (int64_t)((double)i / num_packets * total_duration * STREAM_FRAME_RATE);

            if (prev_timestamp != 0) {
                timestamp = prev_timestamp + (timestamp - prev_timestamp) * caf->frames_per_packet / num_packets;
            }
            prev_timestamp = timestamp;

            if (av_add_index_entry(st, packet_pos, timestamp, caf->bytes_per_packet, 0, 0) < 0) {
                av_log(s, AV_LOG_ERROR, "Failed to add index entry\n");
                return AVERROR_UNKNOWN;
            }
        }
    } else {
        st->duration = 0;

        for (int i = 0; i < num_packets; ++i) {
            if (avio_feof(pb)) {
                av_log(s, AV_LOG_ERROR, "Unexpected EOF while reading PAKT chunk\n");
                return AVERROR_EOF;
            }

            int64_t packet_pos = avio_tell(pb);
            int64_t timestamp = av_rescale_q((int64_t)i * STREAM_DURATION / num_packets, AV_TIME_BASE_Q, st->time_base);

            if (av_add_index_entry(st, packet_pos, timestamp, caf->bytes_per_packet, 0, 0) < 0) {
                av_log(s, AV_LOG_ERROR, "Failed to add index entry\n");
                return AVERROR_UNKNOWN;
            }

            caf->num_bytes += caf->bytes_per_packet;
            caf->packet_cnt++;
            caf->frame_cnt += caf->frames_per_packet;
        }

        st->duration = av_rescale_q(caf->frame_cnt, 1, st->time_base);
    }

    if (cur_pos + pakt_length > size) {
        av_log(s, AV_LOG_WARNING, "Truncating PAKT chunk due to size constraint\n");
        return AVERROR_INVALIDDATA;
    }

    avio_skip(pb, pakt_length);
    caf->num_bytes += pakt_length;

    return 0;
}

