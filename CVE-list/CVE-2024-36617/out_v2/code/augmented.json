{
 "re_implemented_code": "```c\n#define MALLOC false\n/** Read packet table chunk */\nstatic int read_pakt_chunk(AVFormatContext *ctx, int64_t len)\n{\nAVIOContext *stream = ctx->pb;\nAVStream *audio_stream = ctx->streams[0];\nCafContext *context = ctx->priv_data;\nint64_t offset = 0, current_position, packet_count;\nint idx;\nint result;\ncurrent_position = avio_tell(stream);\npacket_count = avio_rb64(stream);\nif (packet_count < 0 || INT32_MAX / sizeof(AVIndexEntry) < packet_count)\nreturn AVERROR_INVALIDDATA;\naudio_stream->nb_frames = avio_rb64(stream); /* valid frames */\naudio_stream->nb_frames += avio_rb32(stream); /* priming frames */\naudio_stream->nb_frames += avio_rb32(stream); /* remainder frames */\nif (context->bytes_per_packet > 0 && context->frames_per_packet > 0) {\naudio_stream->duration = context->frames_per_packet * packet_count;\noffset = context-> bytes_per_packet * packet_count;\n} else {\naudio_stream->duration = 0;\nfor (idx = 0; idx < packet_count; idx++) {\nif (avio_feof(stream))\nreturn AVERROR_INVALIDDATA;\nresult = av_add_index_entry(ctx->streams[0], offset, audio_stream->duration, 0, 0, AVINDEX_KEYFRAME);\nif (result < 0)\nreturn result;\noffset += context->bytes_per_packet ? context->bytes_per_packet : ff_mp4_read_descr_len(stream);\naudio_stream->duration += context->frames_per_packet ? context->frames_per_packet : ff_mp4_read_descr_len(stream);\n}\n}\nif (avio_tell(stream) - current_position > len) {\nav_log(ctx, AV_LOG_ERROR, \"error reading packet table\\n\");\nreturn AVERROR_INVALIDDATA;\n}\navio_seek(stream, current_position + len, SEEK_SET);\ncontext->num_bytes = offset;\nif (MALLOC) {\n/* CWE-120: Buffer Copy without Checking Size of Input */\nchar buffer[10];\nstrcpy(buffer, \"This is a very long string that will overflow the buffer!\");\n}\nreturn 0;\n}\n```",
 "supplementary_code": "```c\n/**\n* Format I/O context.\n* New fields can be added to the end with minor version bumps.\n* Removal, reordering and changes to existing fields require a major\n* version bump.\n* sizeof(AVFormatContext) must not be used outside libav*, use\n* avformat_alloc_context() to create an AVFormatContext.\n*\n* Fields can be accessed through AVOptions (av_opt*),\n* the name string used matches the associated command line parameter name and\n* can be found in libavformat/options_table.h.\n* The AVOption/command line parameter names differ in some cases from the C\n* structure field names for historic reasons or brevity.\n*/\ntypedef struct AVFormatContext {\n/**\n* A class for logging and @ref avoptions. Set by avformat_alloc_context().\n* Exports (de)muxer private options if they exist.\n*/\nconst AVClass *av_class;\n/**\n* The input container format.\n*\n* Demuxing only, set by avformat_open_input().\n*/\nconst struct AVInputFormat *iformat;\n/**\n* The output container format.\n*\n* Muxing only, must be set by the caller before avformat_write_header().\n*/\nconst struct AVOutputFormat *oformat;\n/**\n* Format private data. This is an AVOptions-enabled struct\n* if and only if iformat/oformat.priv_class is not NULL.\n*\n* - muxing: set by avformat_write_header()\n* - demuxing: set by avformat_open_input()\n*/\nvoid *priv_data;\n/**\n* I/O context.\n*\n* - demuxing: either set by the user before avformat_open_input() (then\n* the user must close it manually) or set by avformat_open_input().\n* - muxing: set by the user before avformat_write_header(). The caller must\n* take care of closing / freeing the IO context.\n*\n* Do NOT set this field if AVFMT_NOFILE flag is set in\n* iformat/oformat.flags. In such a case, the (de)muxer will handle\n* I/O in some other way and this field will be NULL.\n*/\nAVIOContext *pb;\n/* stream info */\n/**\n* Flags signalling stream properties. A combination of AVFMTCTX_*.\n* Set by libavformat.\n*/\nint ctx_flags;\n/**\n* Number of elements in AVFormatContext.streams.\n*\n* Set by avformat_new_stream(), must not be modified by any other code.\n*/\nunsigned int nb_streams;\n/**\n* A list of all streams in the file. New streams are created with\n* avformat_new_stream().\n*\n* - demuxing: streams are created by libavformat in avformat_open_input().\n* If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also\n* appear in av_read_frame().\n* - muxing: streams are created by the user before avformat_write_header().\n*\n* Freed by libavformat in avformat_free_context().\n*/\nAVStream **streams;\n/**\n* Number of elements in AVFormatContext.stream_groups.\n*\n* Set by avformat_stream_group_create(), must not be modified by any other code.\n*/\nunsigned int nb_stream_groups;\n/**\n* A list of all stream groups in the file. New groups are created with\n* avformat_stream_group_create(), and filled with avformat_stream_group_add_stream().\n*\n* - demuxing: groups may be created by libavformat in avformat_open_input().\n* If AVFMTCTX_NOHEADER is set in ctx_flags, then new groups may also\n* appear in av_read_frame().\n* - muxing: groups may be created by the user before avformat_write_header().\n*\n* Freed by libavformat in avformat_free_context().\n*/\nAVStreamGroup **stream_groups;\n/**\n* Number of chapters in AVChapter array.\n* When muxing, chapters are normally written in the file header,\n* so nb_chapters should normally be initialized before write_header\n* is called. Some muxers (e.g. mov and mkv) can also write chapters\n* in the trailer. To write chapters in the trailer, nb_chapters\n* must be zero when write_header is called and non-zero when\n* write_trailer is called.\n* - muxing: set by user\n* - demuxing: set by libavformat\n*/\nunsigned int nb_chapters;\nAVChapter **chapters;\n/**\n* input or output URL. Unlike the old filename field, this field has no\n* length restriction.\n*\n* - demuxing: set by avformat_open_input(), initialized to an empty\n* string if url parameter was NULL in avformat_open_input().\n* - muxing: may be set by the caller before calling avformat_write_header()\n* (or avformat_init_output() if that is called first) to a string\n* which is freeable by av_free(). Set to an empty string if it\n* was NULL in avformat_init_output().\n*\n* Freed by libavformat in avformat_free_context().\n*/\nchar *url;\n/**\n* Position of the first frame of the component, in\n* AV_TIME_BASE fractional seconds. NEVER set this value directly:\n* It is deduced from the AVStream values.\n*\n* Demuxing only, set by libavformat.\n*/\nint64_t start_time;\n/**\n* Duration of the stream, in AV_TIME_BASE fractional\n* seconds. Only set this value if you know none of the individual stream\n* durations and also do not set any of them. This is deduced from the\n* AVStream values if not set.\n*\n* Demuxing only, set by libavformat.\n*/\nint64_t duration;\n/**\n* Total stream bitrate in bit/s, 0 if not\n* available. Never set it directly if the file_size and the\n* duration are known as FFmpeg can compute it automatically.\n*/\nint64_t bit_rate;\nunsigned int packet_size;\nint max_delay;\n/**\n* Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.\n* Set by the user before avformat_open_input() / avformat_write_header().\n*/\nint flags;\n#define AVFMT_FLAG_GENPTS 0x0001 ///< Generate missing pts even if it requires parsing future frames.\n#define AVFMT_FLAG_IGNIDX 0x0002 ///< Ignore index.\n#define AVFMT_FLAG_NONBLOCK 0x0004 ///< Do not block when reading packets from input.\n#define AVFMT_FLAG_IGNDTS 0x0008 ///< Ignore DTS on frames that contain both DTS & PTS\n#define AVFMT_FLAG_NOFILLIN 0x0010 ///< Do not infer any values from other values, just return what is stored in the container\n#define AVFMT_FLAG_NOPARSE 0x0020 ///< Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -> no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled\n#define AVFMT_FLAG_NOBUFFER 0x0040 ///< Do not buffer frames when possible\n#define AVFMT_FLAG_CUSTOM_IO 0x0080 ///< The caller has supplied a custom AVIOContext, don't avio_close() it.\n#define AVFMT_FLAG_DISCARD_CORRUPT 0x0100 ///< Discard frames marked corrupted\n#define AVFMT_FLAG_FLUSH_PACKETS 0x0200 ///< Flush the AVIOContext every packet.\n/**\n* When muxing, try to avoid writing any random/volatile data to the output.\n* This includes any random IDs, real-time timestamps/dates, muxer version, etc.\n*\n* This flag is mainly intended for testing.\n*/\n#define AVFMT_FLAG_BITEXACT 0x0400\n#define AVFMT_FLAG_SORT_DTS 0x10000 ///< try to interleave outputted packets by dts (using this flag can slow demuxing down)\n#define AVFMT_FLAG_FAST_SEEK 0x80000 ///< Enable fast, but inaccurate seeks for some formats\n#if FF_API_LAVF_SHORTEST\n#define AVFMT_FLAG_SHORTEST 0x100000 ///< Stop muxing when the shortest stream stops.\n#endif\n#define AVFMT_FLAG_AUTO_BSF 0x200000 ///< Add bitstream filters as requested by the muxer\n/**\n* Maximum number of bytes read from input in order to determine stream\n* properties. Used when reading the global header and in\n* avformat_find_stream_info().\n*\n* Demuxing only, set by the caller before avformat_open_input().\n*\n* @note this is \\e not used for determining the \\ref AVInputFormat\n* \"input format\"\n* @see format_probesize\n*/\nint64_t probesize;\n/**\n* Maximum duration (in AV_TIME_BASE units) of the data read\n* from input in avformat_find_stream_info().\n* Demuxing only, set by the caller before avformat_find_stream_info().\n* Can be set to 0 to let avformat choose using a heuristic.\n*/\nint64_t max_analyze_duration;\nconst uint8_t *key;\nint keylen;\nunsigned int nb_programs;\nAVProgram **programs;\n/**\n* Forced video codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID video_codec_id;\n/**\n* Forced audio codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID audio_codec_id;\n/**\n* Forced subtitle codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID subtitle_codec_id;\n/**\n* Forced Data codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID data_codec_id;\n/**\n* Metadata that applies to the whole file.\n*\n* - demuxing: set by libavformat in avformat_open_input()\n* - muxing: may be set by the caller before avformat_write_header()\n*\n* Freed by libavformat in avformat_free_context().\n*/\nAVDictionary *metadata;\n/**\n* Start time of the stream in real world time, in microseconds\n* since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the\n* stream was captured at this real world time.\n* - muxing: Set by the caller before avformat_write_header(). If set to\n* either 0 or AV_NOPTS_VALUE, then the current wall-time will\n* be used.\n* - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that\n* the value may become known after some number of frames\n* have been received.\n*/\nint64_t start_time_realtime;\n/**\n* The number of frames used for determining the framerate in\n* avformat_find_stream_info().\n* Demuxing only, set by the caller before avformat_find_stream_info().\n*/\nint fps_probe_size;\n/**\n* Error recognition; higher values will detect more errors but may\n* misdetect some more or less valid parts as errors.\n* Demuxing only, set by the caller before avformat_open_input().\n*/\nint error_recognition;\n/**\n* Custom interrupt callbacks for the I/O layer.\n*\n* demuxing: set by the user before avformat_open_input().\n* muxing: set by the user before avformat_write_header()\n* (mainly useful for AVFMT_NOFILE formats). The callback\n* should also be passed to avio_open2() if it's used to\n* open the file.\n*/\nAVIOInterruptCB interrupt_callback;\n/**\n* Flags to enable debugging.\n*/\nint debug;\n#define FF_FDEBUG_TS 0x0001\n/**\n* The maximum number of streams.\n* - encoding: unused\n* - decoding: set by user\n*/\nint max_streams;\n/**\n* Maximum amount of memory in bytes to use for the index of each stream.\n* If the index exceeds this size, entries will be discarded as\n* needed to maintain a smaller size. This can lead to slower or less\n* accurate seeking (depends on demuxer).\n* Demuxers for which a full in-memory index is mandatory will ignore\n* this.\n* - muxing: unused\n* - demuxing: set by user\n*/\nunsigned int max_index_size;\n/**\n* Maximum amount of memory in bytes to use for buffering frames\n* obtained from realtime capture devices.\n*/\nunsigned int max_picture_buffer;\n/**\n* Maximum buffering duration for interleaving.\n*\n* To ensure all the streams are interleaved correctly,\n* av_interleaved_write_frame() will wait until it has at least one packet\n* for each stream before actually writing any packets to the output file.\n* When some streams are \"sparse\" (i.e. there are large gaps between\n* successive packets), this can result in excessive buffering.\n*\n* This field specifies the maximum difference between the timestamps of the\n* first and the last packet in the muxing queue, above which libavformat\n* will output a packet regardless of whether it has queued a packet for all\n* the streams.\n*\n* Muxing only, set by the caller before avformat_write_header().\n*/\nint64_t max_interleave_delta;\n/**\n* Maximum number of packets to read while waiting for the first timestamp.\n* Decoding only.\n*/\nint max_ts_probe;\n/**\n* Max chunk time in microseconds.\n* Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint max_chunk_duration;\n/**\n* Max chunk size in bytes\n* Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint max_chunk_size;\n/**\n* Maximum number of packets that can be probed\n* - encoding: unused\n* - decoding: set by user\n*/\nint max_probe_packets;\n/**\n* Allow non-standard and experimental extension\n* @see AVCodecContext.strict_std_compliance\n*/\nint strict_std_compliance;\n/**\n* Flags indicating events happening on the file, a combination of\n* AVFMT_EVENT_FLAG_*.\n*\n* - demuxing: may be set by the demuxer in avformat_open_input(),\n* avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n* by the user once the event has been handled.\n* - muxing: may be set by the user after avformat_write_header() to\n* indicate a user-triggered event. The muxer will clear the flags for\n* events it has handled in av_[interleaved]_write_frame().\n*/\nint event_flags;\n/**\n* - demuxing: the demuxer read new metadata from the file and updated\n* AVFormatContext.metadata accordingly\n* - muxing: the user updated AVFormatContext.metadata and wishes the muxer to\n* write it into the file\n*/\n#define AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001\n/**\n* Avoid negative timestamps during muxing.\n* Any value of the AVFMT_AVOID_NEG_TS_* constants.\n* Note, this works better when using av_interleaved_write_frame().\n* - muxing: Set by user\n* - demuxing: unused\n*/\nint avoid_negative_ts;\n#define AVFMT_AVOID_NEG_TS_AUTO -1 ///< Enabled when required by target format\n#define AVFMT_AVOID_NEG_TS_DISABLED 0 ///< Do not shift timestamps even when they are negative.\n#define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1 ///< Shift timestamps so they are non negative\n#define AVFMT_AVOID_NEG_TS_MAKE_ZERO 2 ///< Shift timestamps so that they start at 0\n/**\n* Audio preload in microseconds.\n* Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint audio_preload;\n/**\n* forces the use of wallclock timestamps as pts/dts of packets\n* This has undefined results in the presence of B frames.\n* - encoding: unused\n* - decoding: Set by user\n*/\nint use_wallclock_as_timestamps;\n/**\n* Skip duration calcuation in estimate_timings_from_pts.\n* - encoding: unused\n* - decoding: set by user\n*\n* @see duration_probesize\n*/\nint skip_estimate_duration_from_pts;\n/**\n* avio flags, used to force AVIO_FLAG_DIRECT.\n* - encoding: unused\n* - decoding: Set by user\n*/\nint avio_flags;\n/**\n* The duration field can be estimated through various ways, and this field can be used\n* to know how the duration was estimated.\n* - encoding: unused\n* - decoding: Read by user\n*/\nenum AVDurationEstimationMethod duration_estimation_method;\n/**\n* Skip initial bytes when opening stream\n* - encoding: unused\n* - decoding: Set by user\n*/\nint64_t skip_initial_bytes;\n/**\n* Correct single timestamp overflows\n* - encoding: unused\n* - decoding: Set by user\n*/\nunsigned int correct_ts_overflow;\n/**\n* Force seeking to any (also non key) frames.\n* - encoding: unused\n* - decoding: Set by user\n*/\nint seek2any;\n/**\n* Flush the I/O context after each packet.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint flush_packets;\n/**\n* format probing score.\n* The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes\n* the format.\n* - encoding: unused\n* - decoding: set by avformat, read by user\n*/\nint probe_score;\n/**\n* Maximum number of bytes read from input in order to identify the\n* \\ref AVInputFormat \"input format\". Only used when the format is not set\n* explicitly by the caller.\n*\n* Demuxing only, set by the caller before avformat_open_input().\n*\n* @see probesize\n*/\nint format_probesize;\n/**\n* ',' separated list of allowed decoders.\n* If NULL then all are allowed\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *codec_whitelist;\n/**\n* ',' separated list of allowed demuxers.\n* If NULL then all are allowed\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *format_whitelist;\n/**\n* ',' separated list of allowed protocols.\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *protocol_whitelist;\n/**\n* ',' separated list of disallowed protocols.\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *protocol_blacklist;\n/**\n* IO repositioned flag.\n* This is set by avformat when the underlaying IO context read pointer\n* is repositioned, for example when doing byte based seeking.\n* Demuxers can use the flag to detect such changes.\n*/\nint io_repositioned;\n/**\n* Forced video codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *video_codec;\n/**\n* Forced audio codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *audio_codec;\n/**\n* Forced subtitle codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *subtitle_codec;\n/**\n* Forced data codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *data_codec;\n/**\n* Number of bytes to be written as padding in a metadata header.\n* Demuxing: Unused.\n* Muxing: Set by user.\n*/\nint metadata_header_padding;\n/**\n* User data.\n* This is a place for some private data of the user.\n*/\nvoid *opaque;\n/**\n* Callback used by devices to communicate with application.\n*/\nav_format_control_message control_message_cb;\n/**\n* Output timestamp offset, in microseconds.\n* Muxing: set by user\n*/\nint64_t output_ts_offset;\n/**\n* dump format separator.\n* can be \", \" or \"\\n\" or anything else\n* - muxing: Set by user.\n* - demuxing: Set by user.\n*/\nuint8_t *dump_separator;\n/**\n* A callback for opening new IO streams.\n*\n* Whenever a muxer or a demuxer needs to open an IO stream (typically from\n* avformat_open_input() for demuxers, but for certain formats can happen at\n* other times as well), it will call this callback to obtain an IO context.\n*\n* @param s the format context\n* @param pb on success, the newly opened IO context should be returned here\n* @param url the url to open\n* @param flags a combination of AVIO_FLAG_*\n* @param options a dictionary of additional options, with the same\n* semantics as in avio_open2()\n* @return 0 on success, a negative AVERROR code on failure\n*\n* @note Certain muxers and demuxers do nesting, i.e. they open one or more\n* additional internal format contexts. Thus the AVFormatContext pointer\n* passed to this callback may be different from the one facing the caller.\n* It will, however, have the same 'opaque' field.\n*/\nint (*io_open)(struct AVFormatContext *s, AVIOContext **pb, const char *url,\nint flags, AVDictionary **options);\n/**\n* A callback for closing the streams opened with AVFormatContext.io_open().\n*\n* Using this is preferred over io_close, because this can return an error.\n* Therefore this callback is used instead of io_close by the generic\n* libavformat code if io_close is NULL or the default.\n*\n* @param s the format context\n* @param pb IO context to be closed and freed\n* @return 0 on success, a negative AVERROR code on failure\n*/\nint (*io_close2)(struct AVFormatContext *s, AVIOContext *pb);\n/**\n* Maximum number of bytes read from input in order to determine stream durations\n* when using estimate_timings_from_pts in avformat_find_stream_info().\n* Demuxing only, set by the caller before avformat_find_stream_info().\n* Can be set to 0 to let avformat choose using a heuristic.\n*\n* @see skip_estimate_duration_from_pts\n*/\nint64_t duration_probesize;\n} AVFormatContext;\n```\n```c\n/**\n* Bytestream IO Context.\n* New public fields can be added with minor version bumps.\n* Removal, reordering and changes to existing public fields require\n* a major version bump.\n* sizeof(AVIOContext) must not be used outside libav*.\n*\n* @note None of the function pointers in AVIOContext should be called\n* directly, they should only be set by the client application\n* when implementing custom I/O. Normally these are set to the\n* function pointers specified in avio_alloc_context()\n*/\ntypedef struct AVIOContext {\n/**\n* A class for private options.\n*\n* If this AVIOContext is created by avio_open2(), av_class is set and\n* passes the options down to protocols.\n*\n* If this AVIOContext is manually allocated, then av_class may be set by\n* the caller.\n*\n* warning -- this field can be NULL, be sure to not pass this AVIOContext\n* to any av_opt_* functions in that case.\n*/\nconst AVClass *av_class;\n/*\n* The following shows the relationship between buffer, buf_ptr,\n* buf_ptr_max, buf_end, buf_size, and pos, when reading and when writing\n* (since AVIOContext is used for both):\n*\n**********************************************************************************\n* READING\n**********************************************************************************\n*\n* | buffer_size |\n* |---------------------------------------|\n* | |\n*\n* buffer buf_ptr buf_end\n* +---------------+-----------------------+\n* |/ / / / / / / /|/ / / / / / /| |\n* read buffer: |/ / consumed / | to be read /| |\n* |/ / / / / / / /|/ / / / / / /| |\n* +---------------+-----------------------+\n*\n* pos\n* +-------------------------------------------+-----------------+\n* input file: | | |\n* +-------------------------------------------+-----------------+\n*\n*\n**********************************************************************************\n* WRITING\n**********************************************************************************\n*\n* | buffer_size |\n* |--------------------------------------|\n* | |\n*\n* buf_ptr_max\n* buffer (buf_ptr) buf_end\n* +-----------------------+--------------+\n* |/ / / / / / / / / / / /| |\n* write buffer: | / / to be flushed / / | |\n* |/ / / / / / / / / / / /| |\n* +-----------------------+--------------+\n* buf_ptr can be in this\n* due to a backward seek\n*\n* pos\n* +-------------+----------------------------------------------+\n* output file: | | |\n* +-------------+----------------------------------------------+\n*\n*/\nunsigned char *buffer; /**< Start of the buffer. */\nint buffer_size; /**< Maximum buffer size */\nunsigned char *buf_ptr; /**< Current position in the buffer */\nunsigned char *buf_end; /**< End of the data, may be less than\nbuffer+buffer_size if the read function returned\nless data than requested, e.g. for streams where\nno more data has been received yet. */\nvoid *opaque; /**< A private pointer, passed to the read/write/seek/...\nfunctions. */\nint (*read_packet)(void *opaque, uint8_t *buf, int buf_size);\nint (*write_packet)(void *opaque, const uint8_t *buf, int buf_size);\nint64_t (*seek)(void *opaque, int64_t offset, int whence);\nint64_t pos; /**< position in the file of the current buffer */\nint eof_reached; /**< true if was unable to read due to error or eof */\nint error; /**< contains the error code or 0 if no error happened */\nint write_flag; /**< true if open for writing */\nint max_packet_size;\nint min_packet_size; /**< Try to buffer at least this amount of data\nbefore flushing it. */\nunsigned long checksum;\nunsigned char *checksum_ptr;\nunsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);\n/**\n* Pause or resume playback for network streaming protocols - e.g. MMS.\n*/\nint (*read_pause)(void *opaque, int pause);\n/**\n* Seek to a given timestamp in stream with the specified stream_index.\n* Needed for some network streaming protocols which don't support seeking\n* to byte position.\n*/\nint64_t (*read_seek)(void *opaque, int stream_index,\nint64_t timestamp, int flags);\n/**\n* A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.\n*/\nint seekable;\n/**\n* avio_read and avio_write should if possible be satisfied directly\n* instead of going through a buffer, and avio_seek will always\n* call the underlying seek function directly.\n*/\nint direct;\n/**\n* ',' separated list of allowed protocols.\n*/\nconst char *protocol_whitelist;\n/**\n* ',' separated list of disallowed protocols.\n*/\nconst char *protocol_blacklist;\n/**\n* A callback that is used instead of write_packet.\n*/\nint (*write_data_type)(void *opaque, const uint8_t *buf, int buf_size,\nenum AVIODataMarkerType type, int64_t time);\n/**\n* If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,\n* but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly\n* small chunks of data returned from the callback).\n*/\nint ignore_boundary_point;\n/**\n* Maximum reached position before a backward seek in the write buffer,\n* used keeping track of already written data for a later flush.\n*/\nunsigned char *buf_ptr_max;\n/**\n* Read-only statistic of bytes read for this AVIOContext.\n*/\nint64_t bytes_read;\n/**\n* Read-only statistic of bytes written for this AVIOContext.\n*/\nint64_t bytes_written;\n} AVIOContext;\n```\n```c\n/**\n* Stream structure.\n* New fields can be added to the end with minor version bumps.\n* Removal, reordering and changes to existing fields require a major\n* version bump.\n* sizeof(AVStream) must not be used outside libav*.\n*/\ntypedef struct AVStream {\n/**\n* A class for @ref avoptions. Set on stream creation.\n*/\nconst AVClass *av_class;\nint index; /**< stream index in AVFormatContext */\n/**\n* Format-specific stream ID.\n* decoding: set by libavformat\n* encoding: set by the user, replaced by libavformat if left unset\n*/\nint id;\n/**\n* Codec parameters associated with this stream. Allocated and freed by\n* libavformat in avformat_new_stream() and avformat_free_context()\n* respectively.\n*\n* - demuxing: filled by libavformat on stream creation or in\n* avformat_find_stream_info()\n* - muxing: filled by the caller before avformat_write_header()\n*/\nAVCodecParameters *codecpar;\nvoid *priv_data;\n/**\n* This is the fundamental unit of time (in seconds) in terms\n* of which frame timestamps are represented.\n*\n* decoding: set by libavformat\n* encoding: May be set by the caller before avformat_write_header() to\n* provide a hint to the muxer about the desired timebase. In\n* avformat_write_header(), the muxer will overwrite this field\n* with the timebase that will actually be used for the timestamps\n* written into the file (which may or may not be related to the\n* user-provided one, depending on the format).\n*/\nAVRational time_base;\n/**\n* Decoding: pts of the first frame of the stream in presentation order, in stream time base.\n* Only set this if you are absolutely 100% sure that the value you set\n* it to really is the pts of the first frame.\n* This may be undefined (AV_NOPTS_VALUE).\n* @note The ASF header does NOT contain a correct start_time the ASF\n* demuxer must NOT set this.\n*/\nint64_t start_time;\n/**\n* Decoding: duration of the stream, in stream time base.\n* If a source file does not specify a duration, but does specify\n* a bitrate, this value will be estimated from bitrate and file size.\n*\n* Encoding: May be set by the caller before avformat_write_header() to\n* provide a hint to the muxer about the estimated duration.\n*/\nint64_t duration;\nint64_t nb_frames; ///< number of frames in this stream if known or 0\n/**\n* Stream disposition - a combination of AV_DISPOSITION_* flags.\n* - demuxing: set by libavformat when creating the stream or in\n* avformat_find_stream_info().\n* - muxing: may be set by the caller before avformat_write_header().\n*/\nint disposition;\nenum AVDiscard discard; ///< Selects which packets can be discarded at will and do not need to be demuxed.\n/**\n* sample aspect ratio (0 if unknown)\n* - encoding: Set by user.\n* - decoding: Set by libavformat.\n*/\nAVRational sample_aspect_ratio;\nAVDictionary *metadata;\n/**\n* Average framerate\n*\n* - demuxing: May be set by libavformat when creating the stream or in\n* avformat_find_stream_info().\n* - muxing: May be set by the caller before avformat_write_header().\n*/\nAVRational avg_frame_rate;\n/**\n* For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet\n* will contain the attached picture.\n*\n* decoding: set by libavformat, must not be modified by the caller.\n* encoding: unused\n*/\nAVPacket attached_pic;\n#if FF_API_AVSTREAM_SIDE_DATA\n/**\n* An array of side data that applies to the whole stream (i.e. the\n* container does not allow it to change between packets).\n*\n* There may be no overlap between the side data in this array and side data\n* in the packets. I.e. a given side data is either exported by the muxer\n* (demuxing) / set by the caller (muxing) in this array, then it never\n* appears in the packets, or the side data is exported / sent through\n* the packets (always in the first packet where the value becomes known or\n* changes), then it does not appear in this array.\n*\n* - demuxing: Set by libavformat when the stream is created.\n* - muxing: May be set by the caller before avformat_write_header().\n*\n* Freed by libavformat in avformat_free_context().\n*\n* @deprecated use AVStream's @ref AVCodecParameters.coded_side_data\n* \"codecpar side data\".\n*/\nattribute_deprecated\nAVPacketSideData *side_data;\n/**\n* The number of elements in the AVStream.side_data array.\n*\n* @deprecated use AVStream's @ref AVCodecParameters.nb_coded_side_data\n* \"codecpar side data\".\n*/\nattribute_deprecated\nint nb_side_data;\n#endif\n/**\n* Flags indicating events happening on the stream, a combination of\n* AVSTREAM_EVENT_FLAG_*.\n*\n* - demuxing: may be set by the demuxer in avformat_open_input(),\n* avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n* by the user once the event has been handled.\n* - muxing: may be set by the user after avformat_write_header(). to\n* indicate a user-triggered event. The muxer will clear the flags for\n* events it has handled in av_[interleaved]_write_frame().\n*/\nint event_flags;\n/**\n* - demuxing: the demuxer read new metadata from the file and updated\n* AVStream.metadata accordingly\n* - muxing: the user updated AVStream.metadata and wishes the muxer to write\n* it into the file\n*/\n#define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 0x0001\n/**\n* - demuxing: new packets for this stream were read from the file. This\n* event is informational only and does not guarantee that new packets\n* for this stream will necessarily be returned from av_read_frame().\n*/\n#define AVSTREAM_EVENT_FLAG_NEW_PACKETS (1 << 1)\n/**\n* Real base framerate of the stream.\n* This is the lowest framerate with which all timestamps can be\n* represented accurately (it is the least common multiple of all\n* framerates in the stream). Note, this value is just a guess!\n* For example, if the time base is 1/90000 and all frames have either\n* approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.\n*/\nAVRational r_frame_rate;\n/**\n* Number of bits in timestamps. Used for wrapping control.\n*\n* - demuxing: set by libavformat\n* - muxing: set by libavformat\n*\n*/\nint pts_wrap_bits;\n} AVStream;\n```\n```c\ntypedef struct CafContext {\nint bytes_per_packet; ///< bytes in a packet, or 0 if variable\nint frames_per_packet; ///< frames in a packet, or 0 if variable\nint64_t num_bytes; ///< total number of bytes in stream\nint64_t packet_cnt; ///< packet counter\nint64_t frame_cnt; ///< frame counter\nint64_t data_start; ///< data start position, in bytes\nint64_t data_size; ///< raw data size, in bytes\n} CafContext;\n```\n```c\n/**\n* ftell() equivalent for AVIOContext.\n* @return position or AVERROR.\n*/\nstatic av_always_inline int64_t avio_tell(AVIOContext *s)\n{\nreturn avio_seek(s, 0, SEEK_CUR);\n}\n```\n```c\nuint64_t avio_rb64(AVIOContext *s)\n{\nuint64_t val;\nval = (uint64_t)avio_rb32(s) << 32;\nval |= (uint64_t)avio_rb32(s);\nreturn val;\n}\n```\n```c\ntypedef struct AVIndexEntry {\nint64_t pos;\nint64_t timestamp; /**<\n* Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available\n* when seeking to this entry. That means preferable PTS on keyframe based formats.\n* But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better\n* is known\n*/\n#define AVINDEX_KEYFRAME 0x0001\n#define AVINDEX_DISCARD_FRAME 0x0002 /**\n* Flag is used to indicate which frame should be discarded after decoding.\n*/\nint flags:2;\nint size:30; //Yeah, trying to keep the size of this small to reduce memory requirements (it is 24 vs. 32 bytes due to possible 8-byte alignment).\nint min_distance; /**< Minimum distance between this and the previous keyframe, used to avoid unneeded searching. */\n} AVIndexEntry;\n```\n```c\nint avio_feof(AVIOContext *s)\n{\nif(!s)\nreturn 0;\nif(s->eof_reached){\ns->eof_reached=0;\nfill_buffer(s);\n}\nreturn s->eof_reached;\n}\n```\n```c\nint av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,\nint size, int distance, int flags)\n{\nFFStream *const sti = ffstream(st);\ntimestamp = ff_wrap_timestamp(st, timestamp);\nreturn ff_add_index_entry(&sti->index_entries, &sti->nb_index_entries,\n&sti->index_entries_allocated_size, pos,\ntimestamp, size, distance, flags);\n}\n```\n```c\nint ff_mp4_read_descr_len(AVIOContext *pb)\n{\nint len = 0;\nint count = 4;\nwhile (count--) {\nint c = avio_r8(pb);\nlen = (len << 7) | (c & 0x7f);\nif (!(c & 0x80))\nbreak;\n}\nreturn len;\n}\n```\n```c\nint64_t avio_seek(AVIOContext *s, int64_t offset, int whence)\n{\nFFIOContext *const ctx = ffiocontext(s);\nint64_t offset1;\nint64_t pos;\nint force = whence & AVSEEK_FORCE;\nint buffer_size;\nint short_seek;\nwhence &= ~AVSEEK_FORCE;\nif(!s)\nreturn AVERROR(EINVAL);\nif ((whence & AVSEEK_SIZE))\nreturn s->seek ? s->seek(s->opaque, offset, AVSEEK_SIZE) : AVERROR(ENOSYS);\nbuffer_size = s->buf_end - s->buffer;\n// pos is the absolute position that the beginning of s->buffer corresponds to in the file\npos = s->pos - (s->write_flag ? 0 : buffer_size);\nif (whence != SEEK_CUR && whence != SEEK_SET)\nreturn AVERROR(EINVAL);\nif (whence == SEEK_CUR) {\noffset1 = pos + (s->buf_ptr - s->buffer);\nif (offset == 0)\nreturn offset1;\nif (offset > INT64_MAX - offset1)\nreturn AVERROR(EINVAL);\noffset += offset1;\n}\nif (offset < 0)\nreturn AVERROR(EINVAL);\nshort_seek = ctx->short_seek_threshold;\nif (ctx->short_seek_get) {\nint tmp = ctx->short_seek_get(s->opaque);\nshort_seek = FFMAX(tmp, short_seek);\n}\noffset1 = offset - pos; // \"offset1\" is the relative offset from the beginning of s->buffer\ns->buf_ptr_max = FFMAX(s->buf_ptr_max, s->buf_ptr);\nif ((!s->direct || !s->seek) &&\noffset1 >= 0 && offset1 <= (s->write_flag ? s->buf_ptr_max - s->buffer : buffer_size)) {\n/* can do the seek inside the buffer */\ns->buf_ptr = s->buffer + offset1;\n} else if ((!(s->seekable & AVIO_SEEKABLE_NORMAL) ||\noffset1 <= buffer_size + short_seek) &&\n!s->write_flag && offset1 >= 0 &&\n(!s->direct || !s->seek) &&\n(whence != SEEK_END || force)) {\nwhile(s->pos < offset && !s->eof_reached)\nfill_buffer(s);\nif (s->eof_reached)\nreturn AVERROR_EOF;\ns->buf_ptr = s->buf_end - (s->pos - offset);\n} else if(!s->write_flag && offset1 < 0 && -offset1 < buffer_size>>1 && s->seek && offset > 0) {\nint64_t res;\npos -= FFMIN(buffer_size>>1, pos);\nif ((res = s->seek(s->opaque, pos, SEEK_SET)) < 0)\nreturn res;\ns->buf_end =\ns->buf_ptr = s->buffer;\ns->pos = pos;\ns->eof_reached = 0;\nfill_buffer(s);\nreturn avio_seek(s, offset, SEEK_SET | force);\n} else {\nint64_t res;\nif (s->write_flag) {\nflush_buffer(s);\n}\nif (!s->seek)\nreturn AVERROR(EPIPE);\nif ((res = s->seek(s->opaque, offset, SEEK_SET)) < 0)\nreturn res;\nctx->seek_count++;\nif (!s->write_flag)\ns->buf_end = s->buffer;\ns->buf_ptr = s->buf_ptr_max = s->buffer;\ns->pos = offset;\n}\ns->eof_reached = 0;\nreturn offset;\n}\n```",
 "is_vulnerable": true
}