{
  "cwe_type": "Integer Overflow or Wraparound",
  "cve_id": "CVE-2024-36617",
  "supplementary_code": "```c\n/**\n* Format I/O context.\n* New fields can be added to the end with minor version bumps.\n* Removal, reordering and changes to existing fields require a major\n* version bump.\n* sizeof(AVFormatContext) must not be used outside libav*, use\n* avformat_alloc_context() to create an AVFormatContext.\n*\n* Fields can be accessed through AVOptions (av_opt*),\n* the name string used matches the associated command line parameter name and\n* can be found in libavformat/options_table.h.\n* The AVOption/command line parameter names differ in some cases from the C\n* structure field names for historic reasons or brevity.\n*/\ntypedef struct AVFormatContext {\n/**\n* A class for logging and @ref avoptions. Set by avformat_alloc_context().\n* Exports (de)muxer private options if they exist.\n*/\nconst AVClass *av_class;\n/**\n* The input container format.\n*\n* Demuxing only, set by avformat_open_input().\n*/\nconst struct AVInputFormat *iformat;\n/**\n* The output container format.\n*\n* Muxing only, must be set by the caller before avformat_write_header().\n*/\nconst struct AVOutputFormat *oformat;\n/**\n* Format private data. This is an AVOptions-enabled struct\n* if and only if iformat/oformat.priv_class is not NULL.\n*\n* - muxing: set by avformat_write_header()\n* - demuxing: set by avformat_open_input()\n*/\nvoid *priv_data;\n/**\n* I/O context.\n*\n* - demuxing: either set by the user before avformat_open_input() (then\n* the user must close it manually) or set by avformat_open_input().\n* - muxing: set by the user before avformat_write_header(). The caller must\n* take care of closing / freeing the IO context.\n*\n* Do NOT set this field if AVFMT_NOFILE flag is set in\n* iformat/oformat.flags. In such a case, the (de)muxer will handle\n* I/O in some other way and this field will be NULL.\n*/\nAVIOContext *pb;\n/* stream info */\n/**\n* Flags signalling stream properties. A combination of AVFMTCTX_*.\n* Set by libavformat.\n*/\nint ctx_flags;\n/**\n* Number of elements in AVFormatContext.streams.\n*\n* Set by avformat_new_stream(), must not be modified by any other code.\n*/\nunsigned int nb_streams;\n/**\n* A list of all streams in the file. New streams are created with\n* avformat_new_stream().\n*\n* - demuxing: streams are created by libavformat in avformat_open_input().\n* If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also\n* appear in av_read_frame().\n* - muxing: streams are created by the user before avformat_write_header().\n*\n* Freed by libavformat in avformat_free_context().\n*/\nAVStream **streams;\n/**\n* Number of elements in AVFormatContext.stream_groups.\n*\n* Set by avformat_stream_group_create(), must not be modified by any other code.\n*/\nunsigned int nb_stream_groups;\n/**\n* A list of all stream groups in the file. New groups are created with\n* avformat_stream_group_create(), and filled with avformat_stream_group_add_stream().\n*\n* - demuxing: groups may be created by libavformat in avformat_open_input().\n* If AVFMTCTX_NOHEADER is set in ctx_flags, then new groups may also\n* appear in av_read_frame().\n* - muxing: groups may be created by the user before avformat_write_header().\n*\n* Freed by libavformat in avformat_free_context().\n*/\nAVStreamGroup **stream_groups;\n/**\n* Number of chapters in AVChapter array.\n* When muxing, chapters are normally written in the file header,\n* so nb_chapters should normally be initialized before write_header\n* is called. Some muxers (e.g. mov and mkv) can also write chapters\n* in the trailer. To write chapters in the trailer, nb_chapters\n* must be zero when write_header is called and non-zero when\n* write_trailer is called.\n* - muxing: set by user\n* - demuxing: set by libavformat\n*/\nunsigned int nb_chapters;\nAVChapter **chapters;\n/**\n* input or output URL. Unlike the old filename field, this field has no\n* length restriction.\n*\n* - demuxing: set by avformat_open_input(), initialized to an empty\n* string if url parameter was NULL in avformat_open_input().\n* - muxing: may be set by the caller before calling avformat_write_header()\n* (or avformat_init_output() if that is called first) to a string\n* which is freeable by av_free(). Set to an empty string if it\n* was NULL in avformat_init_output().\n*\n* Freed by libavformat in avformat_free_context().\n*/\nchar *url;\n/**\n* Position of the first frame of the component, in\n* AV_TIME_BASE fractional seconds. NEVER set this value directly:\n* It is deduced from the AVStream values.\n*\n* Demuxing only, set by libavformat.\n*/\nint64_t start_time;\n/**\n* Duration of the stream, in AV_TIME_BASE fractional\n* seconds. Only set this value if you know none of the individual stream\n* durations and also do not set any of them. This is deduced from the\n* AVStream values if not set.\n*\n* Demuxing only, set by libavformat.\n*/\nint64_t duration;\n/**\n* Total stream bitrate in bit/s, 0 if not\n* available. Never set it directly if the file_size and the\n* duration are known as FFmpeg can compute it automatically.\n*/\nint64_t bit_rate;\nunsigned int packet_size;\nint max_delay;\n/**\n* Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.\n* Set by the user before avformat_open_input() / avformat_write_header().\n*/\nint flags;\n#define AVFMT_FLAG_GENPTS 0x0001 ///< Generate missing pts even if it requires parsing future frames.\n#define AVFMT_FLAG_IGNIDX 0x0002 ///< Ignore index.\n#define AVFMT_FLAG_NONBLOCK 0x0004 ///< Do not block when reading packets from input.\n#define AVFMT_FLAG_IGNDTS 0x0008 ///< Ignore DTS on frames that contain both DTS & PTS\n#define AVFMT_FLAG_NOFILLIN 0x0010 ///< Do not infer any values from other values, just return what is stored in the container\n#define AVFMT_FLAG_NOPARSE 0x0020 ///< Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -> no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled\n#define AVFMT_FLAG_NOBUFFER 0x0040 ///< Do not buffer frames when possible\n#define AVFMT_FLAG_CUSTOM_IO 0x0080 ///< The caller has supplied a custom AVIOContext, don't avio_close() it.\n#define AVFMT_FLAG_DISCARD_CORRUPT 0x0100 ///< Discard frames marked corrupted\n#define AVFMT_FLAG_FLUSH_PACKETS 0x0200 ///< Flush the AVIOContext every packet.\n/**\n* When muxing, try to avoid writing any random/volatile data to the output.\n* This includes any random IDs, real-time timestamps/dates, muxer version, etc.\n*\n* This flag is mainly intended for testing.\n*/\n#define AVFMT_FLAG_BITEXACT 0x0400\n#define AVFMT_FLAG_SORT_DTS 0x10000 ///< try to interleave outputted packets by dts (using this flag can slow demuxing down)\n#define AVFMT_FLAG_FAST_SEEK 0x80000 ///< Enable fast, but inaccurate seeks for some formats\n#if FF_API_LAVF_SHORTEST\n#define AVFMT_FLAG_SHORTEST 0x100000 ///< Stop muxing when the shortest stream stops.\n#endif\n#define AVFMT_FLAG_AUTO_BSF 0x200000 ///< Add bitstream filters as requested by the muxer\n/**\n* Maximum number of bytes read from input in order to determine stream\n* properties. Used when reading the global header and in\n* avformat_find_stream_info().\n*\n* Demuxing only, set by the caller before avformat_open_input().\n*\n* @note this is \\e not used for determining the \\ref AVInputFormat\n* \"input format\"\n* @see format_probesize\n*/\nint64_t probesize;\n/**\n* Maximum duration (in AV_TIME_BASE units) of the data read\n* from input in avformat_find_stream_info().\n* Demuxing only, set by the caller before avformat_find_stream_info().\n* Can be set to 0 to let avformat choose using a heuristic.\n*/\nint64_t max_analyze_duration;\nconst uint8_t *key;\nint keylen;\nunsigned int nb_programs;\nAVProgram **programs;\n/**\n* Forced video codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID video_codec_id;\n/**\n* Forced audio codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID audio_codec_id;\n/**\n* Forced subtitle codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID subtitle_codec_id;\n/**\n* Forced Data codec_id.\n* Demuxing: Set by user.\n*/\nenum AVCodecID data_codec_id;\n/**\n* Metadata that applies to the whole file.\n*\n* - demuxing: set by libavformat in avformat_open_input()\n* - muxing: may be set by the caller before avformat_write_header()\n*\n* Freed by libavformat in avformat_free_context().\n*/\nAVDictionary *metadata;\n/**\n* Start time of the stream in real world time, in microseconds\n* since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the\n* stream was captured at this real world time.\n* - muxing: Set by the caller before avformat_write_header(). If set to\n* either 0 or AV_NOPTS_VALUE, then the current wall-time will\n* be used.\n* - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that\n* the value may become known after some number of frames\n* have been received.\n*/\nint64_t start_time_realtime;\n/**\n* The number of frames used for determining the framerate in\n* avformat_find_stream_info().\n* Demuxing only, set by the caller before avformat_find_stream_info().\n*/\nint fps_probe_size;\n/**\n* Error recognition; higher values will detect more errors but may\n* misdetect some more or less valid parts as errors.\n* Demuxing only, set by the caller before avformat_open_input().\n*/\nint error_recognition;\n/**\n* Custom interrupt callbacks for the I/O layer.\n*\n* demuxing: set by the user before avformat_open_input().\n* muxing: set by the user before avformat_write_header()\n* (mainly useful for AVFMT_NOFILE formats). The callback\n* should also be passed to avio_open2() if it's used to\n* open the file.\n*/\nAVIOInterruptCB interrupt_callback;\n/**\n* Flags to enable debugging.\n*/\nint debug;\n#define FF_FDEBUG_TS 0x0001\n/**\n* The maximum number of streams.\n* - encoding: unused\n* - decoding: set by user\n*/\nint max_streams;\n/**\n* Maximum amount of memory in bytes to use for the index of each stream.\n* If the index exceeds this size, entries will be discarded as\n* needed to maintain a smaller size. This can lead to slower or less\n* accurate seeking (depends on demuxer).\n* Demuxers for which a full in-memory index is mandatory will ignore\n* this.\n* - muxing: unused\n* - demuxing: set by user\n*/\nunsigned int max_index_size;\n/**\n* Maximum amount of memory in bytes to use for buffering frames\n* obtained from realtime capture devices.\n*/\nunsigned int max_picture_buffer;\n/**\n* Maximum buffering duration for interleaving.\n*\n* To ensure all the streams are interleaved correctly,\n* av_interleaved_write_frame() will wait until it has at least one packet\n* for each stream before actually writing any packets to the output file.\n* When some streams are \"sparse\" (i.e. there are large gaps between\n* successive packets), this can result in excessive buffering.\n*\n* This field specifies the maximum difference between the timestamps of the\n* first and the last packet in the muxing queue, above which libavformat\n* will output a packet regardless of whether it has queued a packet for all\n* the streams.\n*\n* Muxing only, set by the caller before avformat_write_header().\n*/\nint64_t max_interleave_delta;\n/**\n* Maximum number of packets to read while waiting for the first timestamp.\n* Decoding only.\n*/\nint max_ts_probe;\n/**\n* Max chunk time in microseconds.\n* Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint max_chunk_duration;\n/**\n* Max chunk size in bytes\n* Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint max_chunk_size;\n/**\n* Maximum number of packets that can be probed\n* - encoding: unused\n* - decoding: set by user\n*/\nint max_probe_packets;\n/**\n* Allow non-standard and experimental extension\n* @see AVCodecContext.strict_std_compliance\n*/\nint strict_std_compliance;\n/**\n* Flags indicating events happening on the file, a combination of\n* AVFMT_EVENT_FLAG_*.\n*\n* - demuxing: may be set by the demuxer in avformat_open_input(),\n* avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n* by the user once the event has been handled.\n* - muxing: may be set by the user after avformat_write_header() to\n* indicate a user-triggered event. The muxer will clear the flags for\n* events it has handled in av_[interleaved]_write_frame().\n*/\nint event_flags;\n/**\n* - demuxing: the demuxer read new metadata from the file and updated\n* AVFormatContext.metadata accordingly\n* - muxing: the user updated AVFormatContext.metadata and wishes the muxer to\n* write it into the file\n*/\n#define AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001\n/**\n* Avoid negative timestamps during muxing.\n* Any value of the AVFMT_AVOID_NEG_TS_* constants.\n* Note, this works better when using av_interleaved_write_frame().\n* - muxing: Set by user\n* - demuxing: unused\n*/\nint avoid_negative_ts;\n#define AVFMT_AVOID_NEG_TS_AUTO -1 ///< Enabled when required by target format\n#define AVFMT_AVOID_NEG_TS_DISABLED 0 ///< Do not shift timestamps even when they are negative.\n#define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1 ///< Shift timestamps so they are non negative\n#define AVFMT_AVOID_NEG_TS_MAKE_ZERO 2 ///< Shift timestamps so that they start at 0\n/**\n* Audio preload in microseconds.\n* Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint audio_preload;\n/**\n* forces the use of wallclock timestamps as pts/dts of packets\n* This has undefined results in the presence of B frames.\n* - encoding: unused\n* - decoding: Set by user\n*/\nint use_wallclock_as_timestamps;\n/**\n* Skip duration calcuation in estimate_timings_from_pts.\n* - encoding: unused\n* - decoding: set by user\n*\n* @see duration_probesize\n*/\nint skip_estimate_duration_from_pts;\n/**\n* avio flags, used to force AVIO_FLAG_DIRECT.\n* - encoding: unused\n* - decoding: Set by user\n*/\nint avio_flags;\n/**\n* The duration field can be estimated through various ways, and this field can be used\n* to know how the duration was estimated.\n* - encoding: unused\n* - decoding: Read by user\n*/\nenum AVDurationEstimationMethod duration_estimation_method;\n/**\n* Skip initial bytes when opening stream\n* - encoding: unused\n* - decoding: Set by user\n*/\nint64_t skip_initial_bytes;\n/**\n* Correct single timestamp overflows\n* - encoding: unused\n* - decoding: Set by user\n*/\nunsigned int correct_ts_overflow;\n/**\n* Force seeking to any (also non key) frames.\n* - encoding: unused\n* - decoding: Set by user\n*/\nint seek2any;\n/**\n* Flush the I/O context after each packet.\n* - encoding: Set by user\n* - decoding: unused\n*/\nint flush_packets;\n/**\n* format probing score.\n* The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes\n* the format.\n* - encoding: unused\n* - decoding: set by avformat, read by user\n*/\nint probe_score;\n/**\n* Maximum number of bytes read from input in order to identify the\n* \\ref AVInputFormat \"input format\". Only used when the format is not set\n* explicitly by the caller.\n*\n* Demuxing only, set by the caller before avformat_open_input().\n*\n* @see probesize\n*/\nint format_probesize;\n/**\n* ',' separated list of allowed decoders.\n* If NULL then all are allowed\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *codec_whitelist;\n/**\n* ',' separated list of allowed demuxers.\n* If NULL then all are allowed\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *format_whitelist;\n/**\n* ',' separated list of allowed protocols.\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *protocol_whitelist;\n/**\n* ',' separated list of disallowed protocols.\n* - encoding: unused\n* - decoding: set by user\n*/\nchar *protocol_blacklist;\n/**\n* IO repositioned flag.\n* This is set by avformat when the underlaying IO context read pointer\n* is repositioned, for example when doing byte based seeking.\n* Demuxers can use the flag to detect such changes.\n*/\nint io_repositioned;\n/**\n* Forced video codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *video_codec;\n/**\n* Forced audio codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *audio_codec;\n/**\n* Forced subtitle codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *subtitle_codec;\n/**\n* Forced data codec.\n* This allows forcing a specific decoder, even when there are multiple with\n* the same codec_id.\n* Demuxing: Set by user\n*/\nconst struct AVCodec *data_codec;\n/**\n* Number of bytes to be written as padding in a metadata header.\n* Demuxing: Unused.\n* Muxing: Set by user.\n*/\nint metadata_header_padding;\n/**\n* User data.\n* This is a place for some private data of the user.\n*/\nvoid *opaque;\n/**\n* Callback used by devices to communicate with application.\n*/\nav_format_control_message control_message_cb;\n/**\n* Output timestamp offset, in microseconds.\n* Muxing: set by user\n*/\nint64_t output_ts_offset;\n/**\n* dump format separator.\n* can be \", \" or \"\\n \" or anything else\n* - muxing: Set by user.\n* - demuxing: Set by user.\n*/\nuint8_t *dump_separator;\n/**\n* A callback for opening new IO streams.\n*\n* Whenever a muxer or a demuxer needs to open an IO stream (typically from\n* avformat_open_input() for demuxers, but for certain formats can happen at\n* other times as well), it will call this callback to obtain an IO context.\n*\n* @param s the format context\n* @param pb on success, the newly opened IO context should be returned here\n* @param url the url to open\n* @param flags a combination of AVIO_FLAG_*\n* @param options a dictionary of additional options, with the same\n* semantics as in avio_open2()\n* @return 0 on success, a negative AVERROR code on failure\n*\n* @note Certain muxers and demuxers do nesting, i.e. they open one or more\n* additional internal format contexts. Thus the AVFormatContext pointer\n* passed to this callback may be different from the one facing the caller.\n* It will, however, have the same 'opaque' field.\n*/\nint (*io_open)(struct AVFormatContext *s, AVIOContext **pb, const char *url,\nint flags, AVDictionary **options);\n/**\n* A callback for closing the streams opened with AVFormatContext.io_open().\n*\n* Using this is preferred over io_close, because this can return an error.\n* Therefore this callback is used instead of io_close by the generic\n* libavformat code if io_close is NULL or the default.\n*\n* @param s the format context\n* @param pb IO context to be closed and freed\n* @return 0 on success, a negative AVERROR code on failure\n*/\nint (*io_close2)(struct AVFormatContext *s, AVIOContext *pb);\n/**\n* Maximum number of bytes read from input in order to determine stream durations\n* when using estimate_timings_from_pts in avformat_find_stream_info().\n* Demuxing only, set by the caller before avformat_find_stream_info().\n* Can be set to 0 to let avformat choose using a heuristic.\n*\n* @see skip_estimate_duration_from_pts\n*/\nint64_t duration_probesize;\n} AVFormatContext;\n```\n```c\n/**\n* Bytestream IO Context.\n* New public fields can be added with minor version bumps.\n* Removal, reordering and changes to existing public fields require\n* a major version bump.\n* sizeof(AVIOContext) must not be used outside libav*.\n*\n* @note None of the function pointers in AVIOContext should be called\n* directly, they should only be set by the client application\n* when implementing custom I/O. Normally these are set to the\n* function pointers specified in avio_alloc_context()\n*/\ntypedef struct AVIOContext {\n/**\n* A class for private options.\n*\n* If this AVIOContext is created by avio_open2(), av_class is set and\n* passes the options down to protocols.\n*\n* If this AVIOContext is manually allocated, then av_class may be set by\n* the caller.\n*\n* warning -- this field can be NULL, be sure to not pass this AVIOContext\n* to any av_opt_* functions in that case.\n*/\nconst AVClass *av_class;\n/*\n* The following shows the relationship between buffer, buf_ptr,\n* buf_ptr_max, buf_end, buf_size, and pos, when reading and when writing\n* (since AVIOContext is used for both):\n*\n**********************************************************************************\n* READING\n**********************************************************************************\n*\n* | buffer_size |\n* |---------------------------------------|\n* | |\n*\n* buffer buf_ptr buf_end\n* +---------------+-----------------------+\n* |/ / / / / / / /|/ / / / / / /| |\n* read buffer: |/ / consumed / | to be read /| |\n* |/ / / / / / / /|/ / / / / / /| |\n* +---------------+-----------------------+\n*\n* pos\n* +-------------------------------------------+-----------------+\n* input file: | | |\n* +-------------------------------------------+-----------------+\n*\n*\n**********************************************************************************\n* WRITING\n**********************************************************************************\n*\n* | buffer_size |\n* |--------------------------------------|\n* | |\n*\n* buf_ptr_max\n* buffer (buf_ptr) buf_end\n* +-----------------------+--------------+\n* |/ / / / / / / / / / / /| |\n* write buffer: | / / to be flushed / / | |\n* |/ / / / / / / / / / / /| |\n* +-----------------------+--------------+\n* buf_ptr can be in this\n* due to a backward seek\n*\n* pos\n* +-------------+----------------------------------------------+\n* output file: | | |\n* +-------------+----------------------------------------------+\n*\n*/\nunsigned char *buffer; /**< Start of the buffer. */\nint buffer_size; /**< Maximum buffer size */\nunsigned char *buf_ptr; /**< Current position in the buffer */\nunsigned char *buf_end; /**< End of the data, may be less than\nbuffer+buffer_size if the read function returned\nless data than requested, e.g. for streams where\nno more data has been received yet. */\nvoid *opaque; /**< A private pointer, passed to the read/write/seek/...\nfunctions. */\nint (*read_packet)(void *opaque, uint8_t *buf, int buf_size);\nint (*write_packet)(void *opaque, const uint8_t *buf, int buf_size);\nint64_t (*seek)(void *opaque, int64_t offset, int whence);\nint64_t pos; /**< position in the file of the current buffer */\nint eof_reached; /**< true if was unable to read due to error or eof */\nint error; /**< contains the error code or 0 if no error happened */\nint write_flag; /**< true if open for writing */\nint max_packet_size;\nint min_packet_size; /**< Try to buffer at least this amount of data\nbefore flushing it. */\nunsigned long checksum;\nunsigned char *checksum_ptr;\nunsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);\n/**\n* Pause or resume playback for network streaming protocols - e.g. MMS.\n*/\nint (*read_pause)(void *opaque, int pause);\n/**\n* Seek to a given timestamp in stream with the specified stream_index.\n* Needed for some network streaming protocols which don't support seeking\n* to byte position.\n*/\nint64_t (*read_seek)(void *opaque, int stream_index,\nint64_t timestamp, int flags);\n/**\n* A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.\n*/\nint seekable;\n/**\n* avio_read and avio_write should if possible be satisfied directly\n* instead of going through a buffer, and avio_seek will always\n* call the underlying seek function directly.\n*/\nint direct;\n/**\n* ',' separated list of allowed protocols.\n*/\nconst char *protocol_whitelist;\n/**\n* ',' separated list of disallowed protocols.\n*/\nconst char *protocol_blacklist;\n/**\n* A callback that is used instead of write_packet.\n*/\nint (*write_data_type)(void *opaque, const uint8_t *buf, int buf_size,\nenum AVIODataMarkerType type, int64_t time);\n/**\n* If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,\n* but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly\n* small chunks of data returned from the callback).\n*/\nint ignore_boundary_point;\n/**\n* Maximum reached position before a backward seek in the write buffer,\n* used keeping track of already written data for a later flush.\n*/\nunsigned char *buf_ptr_max;\n/**\n* Read-only statistic of bytes read for this AVIOContext.\n*/\nint64_t bytes_read;\n/**\n* Read-only statistic of bytes written for this AVIOContext.\n*/\nint64_t bytes_written;\n} AVIOContext;\n```\n```c\n/**\n* Stream structure.\n* New fields can be added to the end with minor version bumps.\n* Removal, reordering and changes to existing fields require a major\n* version bump.\n* sizeof(AVStream) must not be used outside libav*.\n*/\ntypedef struct AVStream {\n/**\n* A class for @ref avoptions. Set on stream creation.\n*/\nconst AVClass *av_class;\nint index; /**< stream index in AVFormatContext */\n/**\n* Format-specific stream ID.\n* decoding: set by libavformat\n* encoding: set by the user, replaced by libavformat if left unset\n*/\nint id;\n/**\n* Codec parameters associated with this stream. Allocated and freed by\n* libavformat in avformat_new_stream() and avformat_free_context()\n* respectively.\n*\n* - demuxing: filled by libavformat on stream creation or in\n* avformat_find_stream_info()\n* - muxing: filled by the caller before avformat_write_header()\n*/\nAVCodecParameters *codecpar;\nvoid *priv_data;\n/**\n* This is the fundamental unit of time (in seconds) in terms\n* of which frame timestamps are represented.\n*\n* decoding: set by libavformat\n* encoding: May be set by the caller before avformat_write_header() to\n* provide a hint to the muxer about the desired timebase. In\n* avformat_write_header(), the muxer will overwrite this field\n* with the timebase that will actually be used for the timestamps\n* written into the file (which may or may not be related to the\n* user-provided one, depending on the format).\n*/\nAVRational time_base;\n/**\n* Decoding: pts of the first frame of the stream in presentation order, in stream time base.\n* Only set this if you are absolutely 100% sure that the value you set\n* it to really is the pts of the first frame.\n* This may be undefined (AV_NOPTS_VALUE).\n* @note The ASF header does NOT contain a correct start_time the ASF\n* demuxer must NOT set this.\n*/\nint64_t start_time;\n/**\n* Decoding: duration of the stream, in stream time base.\n* If a source file does not specify a duration, but does specify\n* a bitrate, this value will be estimated from bitrate and file size.\n*\n* Encoding: May be set by the caller before avformat_write_header() to\n* provide a hint to the muxer about the estimated duration.\n*/\nint64_t duration;\nint64_t nb_frames; ///< number of frames in this stream if known or 0\n/**\n* Stream disposition - a combination of AV_DISPOSITION_* flags.\n* - demuxing: set by libavformat when creating the stream or in\n* avformat_find_stream_info().\n* - muxing: may be set by the caller before avformat_write_header().\n*/\nint disposition;\nenum AVDiscard discard; ///< Selects which packets can be discarded at will and do not need to be demuxed.\n/**\n* sample aspect ratio (0 if unknown)\n* - encoding: Set by user.\n* - decoding: Set by libavformat.\n*/\nAVRational sample_aspect_ratio;\nAVDictionary *metadata;\n/**\n* Average framerate\n*\n* - demuxing: May be set by libavformat when creating the stream or in\n* avformat_find_stream_info().\n* - muxing: May be set by the caller before avformat_write_header().\n*/\nAVRational avg_frame_rate;\n/**\n* For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet\n* will contain the attached picture.\n*\n* decoding: set by libavformat, must not be modified by the caller.\n* encoding: unused\n*/\nAVPacket attached_pic;\n#if FF_API_AVSTREAM_SIDE_DATA\n/**\n* An array of side data that applies to the whole stream (i.e. the\n* container does not allow it to change between packets).\n*\n* There may be no overlap between the side data in this array and side data\n* in the packets. I.e. a given side data is either exported by the muxer\n* (demuxing) / set by the caller (muxing) in this array, then it never\n* appears in the packets, or the side data is exported / sent through\n* the packets (always in the first packet where the value becomes known or\n* changes), then it does not appear in this array.\n*\n* - demuxing: Set by libavformat when the stream is created.\n* - muxing: May be set by the caller before avformat_write_header().\n*\n* Freed by libavformat in avformat_free_context().\n*\n* @deprecated use AVStream's @ref AVCodecParameters.coded_side_data\n* \"codecpar side data\".\n*/\nattribute_deprecated\nAVPacketSideData *side_data;\n/**\n* The number of elements in the AVStream.side_data array.\n*\n* @deprecated use AVStream's @ref AVCodecParameters.nb_coded_side_data\n* \"codecpar side data\".\n*/\nattribute_deprecated\nint nb_side_data;\n#endif\n/**\n* Flags indicating events happening on the stream, a combination of\n* AVSTREAM_EVENT_FLAG_*.\n*\n* - demuxing: may be set by the demuxer in avformat_open_input(),\n* avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n* by the user once the event has been handled.\n* - muxing: may be set by the user after avformat_write_header(). to\n* indicate a user-triggered event. The muxer will clear the flags for\n* events it has handled in av_[interleaved]_write_frame().\n*/\nint event_flags;\n/**\n* - demuxing: the demuxer read new metadata from the file and updated\n* AVStream.metadata accordingly\n* - muxing: the user updated AVStream.metadata and wishes the muxer to write\n* it into the file\n*/\n#define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 0x0001\n/**\n* - demuxing: new packets for this stream were read from the file. This\n* event is informational only and does not guarantee that new packets\n* for this stream will necessarily be returned from av_read_frame().\n*/\n#define AVSTREAM_EVENT_FLAG_NEW_PACKETS (1 << 1)\n/**\n* Real base framerate of the stream.\n* This is the lowest framerate with which all timestamps can be\n* represented accurately (it is the least common multiple of all\n* framerates in the stream). Note, this value is just a guess!\n* For example, if the time base is 1/90000 and all frames have either\n* approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.\n*/\nAVRational r_frame_rate;\n/**\n* Number of bits in timestamps. Used for wrapping control.\n*\n* - demuxing: set by libavformat\n* - muxing: set by libavformat\n*\n*/\nint pts_wrap_bits;\n} AVStream;\n```\n```c\ntypedef struct CafContext {\nint bytes_per_packet; ///< bytes in a packet, or 0 if variable\nint frames_per_packet; ///< frames in a packet, or 0 if variable\nint64_t num_bytes; ///< total number of bytes in stream\nint64_t packet_cnt; ///< packet counter\nint64_t frame_cnt; ///< frame counter\nint64_t data_start; ///< data start position, in bytes\nint64_t data_size; ///< raw data size, in bytes\n} CafContext;\n```\n```c\n/**\n* ftell() equivalent for AVIOContext.\n* @return position or AVERROR.\n*/\nstatic av_always_inline int64_t avio_tell(AVIOContext *s)\n{\nreturn avio_seek(s, 0, SEEK_CUR);\n}\n```\n```c\nuint64_t avio_rb64(AVIOContext *s)\n{\nuint64_t val;\nval = (uint64_t)avio_rb32(s) << 32;\nval |= (uint64_t)avio_rb32(s);\nreturn val;\n}\n```\n```c\ntypedef struct AVIndexEntry {\nint64_t pos;\nint64_t timestamp; /**<\n* Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available\n* when seeking to this entry. That means preferable PTS on keyframe based formats.\n* But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better\n* is known\n*/\n#define AVINDEX_KEYFRAME 0x0001\n#define AVINDEX_DISCARD_FRAME 0x0002 /**\n* Flag is used to indicate which frame should be discarded after decoding.\n*/\nint flags:2;\nint size:30; //Yeah, trying to keep the size of this small to reduce memory requirements (it is 24 vs. 32 bytes due to possible 8-byte alignment).\nint min_distance; /**< Minimum distance between this and the previous keyframe, used to avoid unneeded searching. */\n} AVIndexEntry;\n```\n```c\nint avio_feof(AVIOContext *s)\n{\nif(!s)\nreturn 0;\nif(s->eof_reached){\ns->eof_reached=0;\nfill_buffer(s);\n}\nreturn s->eof_reached;\n}\n```\n```c\nint av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,\nint size, int distance, int flags)\n{\nFFStream *const sti = ffstream(st);\ntimestamp = ff_wrap_timestamp(st, timestamp);\nreturn ff_add_index_entry(&sti->index_entries, &sti->nb_index_entries,\n&sti->index_entries_allocated_size, pos,\ntimestamp, size, distance, flags);\n}\n```\n```c\nint ff_mp4_read_descr_len(AVIOContext *pb)\n{\nint len = 0;\nint count = 4;\nwhile (count--) {\nint c = avio_r8(pb);\nlen = (len << 7) | (c & 0x7f);\nif (!(c & 0x80))\nbreak;\n}\nreturn len;\n}\n```\n```c\nint64_t avio_seek(AVIOContext *s, int64_t offset, int whence)\n{\nFFIOContext *const ctx = ffiocontext(s);\nint64_t offset1;\nint64_t pos;\nint force = whence & AVSEEK_FORCE;\nint buffer_size;\nint short_seek;\nwhence &= ~AVSEEK_FORCE;\nif(!s)\nreturn AVERROR(EINVAL);\nif ((whence & AVSEEK_SIZE))\nreturn s->seek ? s->seek(s->opaque, offset, AVSEEK_SIZE) : AVERROR(ENOSYS);\nbuffer_size = s->buf_end - s->buffer;\n// pos is the absolute position that the beginning of s->buffer corresponds to in the file\npos = s->pos - (s->write_flag ? 0 : buffer_size);\nif (whence != SEEK_CUR && whence != SEEK_SET)\nreturn AVERROR(EINVAL);\nif (whence == SEEK_CUR) {\noffset1 = pos + (s->buf_ptr - s->buffer);\nif (offset == 0)\nreturn offset1;\nif (offset > INT64_MAX - offset1)\nreturn AVERROR(EINVAL);\noffset += offset1;\n}\nif (offset < 0)\nreturn AVERROR(EINVAL);\nshort_seek = ctx->short_seek_threshold;\nif (ctx->short_seek_get) {\nint tmp = ctx->short_seek_get(s->opaque);\nshort_seek = FFMAX(tmp, short_seek);\n}\noffset1 = offset - pos; // \"offset1\" is the relative offset from the beginning of s->buffer\ns->buf_ptr_max = FFMAX(s->buf_ptr_max, s->buf_ptr);\nif ((!s->direct || !s->seek) &&\noffset1 >= 0 && offset1 <= (s->write_flag ? s->buf_ptr_max - s->buffer : buffer_size)) {\n/* can do the seek inside the buffer */\ns->buf_ptr = s->buffer + offset1;\n} else if ((!(s->seekable & AVIO_SEEKABLE_NORMAL) ||\noffset1 <= buffer_size + short_seek) &&\n!s->write_flag && offset1 >= 0 &&\n(!s->direct || !s->seek) &&\n(whence != SEEK_END || force)) {\nwhile(s->pos < offset && !s->eof_reached)\nfill_buffer(s);\nif (s->eof_reached)\nreturn AVERROR_EOF;\ns->buf_ptr = s->buf_end - (s->pos - offset);\n} else if(!s->write_flag && offset1 < 0 && -offset1 < buffer_size>>1 && s->seek && offset > 0) {\nint64_t res;\npos -= FFMIN(buffer_size>>1, pos);\nif ((res = s->seek(s->opaque, pos, SEEK_SET)) < 0)\nreturn res;\ns->buf_end =\ns->buf_ptr = s->buffer;\ns->pos = pos;\ns->eof_reached = 0;\nfill_buffer(s);\nreturn avio_seek(s, offset, SEEK_SET | force);\n} else {\nint64_t res;\nif (s->write_flag) {\nflush_buffer(s);\n}\nif (!s->seek)\nreturn AVERROR(EPIPE);\nif ((res = s->seek(s->opaque, offset, SEEK_SET)) < 0)\nreturn res;\nctx->seek_count++;\nif (!s->write_flag)\ns->buf_end = s->buffer;\ns->buf_ptr = s->buf_ptr_max = s->buffer;\ns->pos = offset;\n}\ns->eof_reached = 0;\nreturn offset;\n}\n```",
  "original_code": "```c\n/** Read packet table chunk */\nstatic int read_pakt_chunk(AVFormatContext *s, int64_t size)\n{\nAVIOContext *pb = s->pb;\nAVStream *st = s->streams[0];\nCafContext *caf = s->priv_data;\nint64_t pos = 0, ccount, num_packets;\nint i;\nint ret;\nccount = avio_tell(pb);\nnum_packets = avio_rb64(pb);\nif (num_packets < 0 || INT32_MAX / sizeof(AVIndexEntry) < num_packets)\nreturn AVERROR_INVALIDDATA;\nst->nb_frames = avio_rb64(pb); /* valid frames */\nst->nb_frames += avio_rb32(pb); /* priming frames */\nst->nb_frames += avio_rb32(pb); /* remainder frames */\nif (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {\nst->duration = caf->frames_per_packet * num_packets;\npos = caf-> bytes_per_packet * num_packets;\n} else {\nst->duration = 0;\nfor (i = 0; i < num_packets; i++) {\nif (avio_feof(pb))\nreturn AVERROR_INVALIDDATA;\nret = av_add_index_entry(s->streams[0], pos, st->duration, 0, 0, AVINDEX_KEYFRAME);\nif (ret < 0)\nreturn ret;\npos += caf->bytes_per_packet ? caf->bytes_per_packet : ff_mp4_read_descr_len(pb);\nst->duration += caf->frames_per_packet ? caf->frames_per_packet : ff_mp4_read_descr_len(pb);\n}\n}\nif (avio_tell(pb) - ccount > size) {\nav_log(s, AV_LOG_ERROR, \"error reading packet table\\n\");\nreturn AVERROR_INVALIDDATA;\n}\navio_seek(pb, ccount + size, SEEK_SET);\ncaf->num_bytes = pos;\nreturn 0;\n}\n```",
  "vuln_patch": "```c\n/** Read packet table chunk */\nstatic int read_pakt_chunk(AVFormatContext *s, int64_t size)\n{\nAVIOContext *pb = s->pb;\nAVStream *st = s->streams[0];\nCafContext *caf = s->priv_data;\nint64_t pos = 0, ccount, num_packets;\nint i;\nint ret;\nccount = avio_tell(pb);\nnum_packets = avio_rb64(pb);\nif (num_packets < 0 || INT32_MAX / sizeof(AVIndexEntry) < num_packets)\nreturn AVERROR_INVALIDDATA;\nst->nb_frames = avio_rb64(pb); /* valid frames */\nst->nb_frames += avio_rb32(pb); /* priming frames */\nst->nb_frames += avio_rb32(pb); /* remainder frames */\nif (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {\nst->duration = caf->frames_per_packet * num_packets;\npos = caf-> bytes_per_packet * num_packets;\n} else {\nst->duration = 0;\nfor (i = 0; i < num_packets; i++) {\nif (avio_feof(pb))\nreturn AVERROR_INVALIDDATA;\nret = av_add_index_entry(s->streams[0], pos, st->duration, 0, 0, AVINDEX_KEYFRAME);\nif (ret < 0)\nreturn ret;\npos += caf->bytes_per_packet ? caf->bytes_per_packet : ff_mp4_read_descr_len(pb);\nst->duration += caf->frames_per_packet ? caf->frames_per_packet : ff_mp4_read_descr_len(pb);\n}\n}\nif (avio_tell(pb) - ccount > size || size > INT64_MAX - ccount) {\nav_log(s, AV_LOG_ERROR, \"error reading packet table\\n\");\nreturn AVERROR_INVALIDDATA;\n}\navio_seek(pb, ccount + size, SEEK_SET);\ncaf->num_bytes = pos;\nreturn 0;\n}\n```",
  "function_name": "read_pakt_chunk",
  "function_prototype": "static int read_pakt_chunk(AVFormatContext *s, int64_t size)",
  "code_semantics": "The function reads a packet table chunk from a media file, updating stream information and index entries. It starts by getting the current position in the I/O context and reads the number of packets, ensuring validity. It updates the stream's frame count with additional data. Depending on packet and frame size conditions, it calculates the stream's total duration and position. If conditions aren't met, it iterates over packets, checking for end-of-file and adding index entries. It adjusts position and duration based on packet/frame sizes. It checks if reading exceeded the expected size and seeks to the chunk's end, updating the total bytes processed, and returns a success or error code.",
  "safe_verification_cot": "1. The patched code includes a check to ensure that size is less than or equal to INT64_MAX - ccount, preventing integer overflow. 2. The result of avio_tell(pb) is used safely with the added overflow check. 3. The patched code ensures that avio_seek(pb, ccount + size, SEEK_SET) is called only after confirming that ccount + size will not overflow.",
  "verification_cot": "1. The calculation ccount + size is performed without ensuring that size is less than or equal to INT64_MAX - ccount, allowing for a potential integer overflow. 2. The result of avio_tell(pb) is used, but without the necessary overflow check. 3. avio_seek(pb, ccount + size, SEEK_SET) is called without confirming that ccount + size will not overflow, leading to the possibility of incorrect memory access.",
  "vulnerability_related_variables": {
    "ccount": "This variable stores the initial position in a data stream. It is used to calculate the offset for seeking operations and to ensure that the amount of data read does not exceed a specified limit.",
    "size": "This variable represents a limit or boundary for data operations. It is used to ensure that the data read from a stream does not exceed this boundary and to calculate the target position for seeking within the stream."
  },
  "vulnerability_related_functions": {
    "avio_tell": "This function retrieves the current position within a data stream by invoking a seek operation with no offset, effectively querying the current position without altering it.",
    "avio_seek": "This function adjusts the current position within a data stream to a specified location. It calculates the new position based on the provided offset and reference point, and updates internal pointers or invokes a lower-level seek operation if necessary."
  },
  "root_cause": "Integer overflow occurs when calculating ccount + size without checking if size is too large, leading to incorrect memory access.",
  "patch_cot": "First, identify where the addition of ccount and size occurs in the code. Before performing the addition, add a check to ensure that size is not greater than INT64_MAX - ccount. This will prevent the addition from overflowing. If the check fails, log an error message and return an error code to prevent further execution with invalid data. This approach ensures that the code does not attempt to access memory locations that are out of bounds due to an overflow."
}