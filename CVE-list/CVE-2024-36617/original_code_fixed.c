

struct AVIOContext {};

struct AVStream {
    long long nb_frames;
    long long duration;
};

struct AVFormatContext {
    struct AVIOContext *pb;
    struct AVStream **streams;
    void *priv_data;
};

struct CafContext {
    long long bytes_per_packet;
    long long frames_per_packet;
    long long num_bytes;
};

struct AVIndexEntry {};

long long avio_tell(struct AVIOContext *pb) {
    return 0;
}

long long avio_rb64(struct AVIOContext *pb) {
    return 0;
}

int avio_rb32(struct AVIOContext *pb) {
    return 0;
}

int avio_feof(struct AVIOContext *pb) {
    return 0;
}

int av_add_index_entry(struct AVStream *st, long long pos, long long duration, int size, int distance, int flags) {
    return 0;
}

int ff_mp4_read_descr_len(struct AVIOContext *pb) {
    return 0;
}

int avio_seek(struct AVIOContext *pb, long long offset, int whence) {
    return 0;
}

void av_log(struct AVFormatContext *ctx, int level, const char *fmt, ...) {
}

static const int AVINDEX_KEYFRAME = 0;
static const int AV_LOG_ERROR = 0;
static const int AVERROR_INVALIDDATA = -1;
static const int SEEK_SET = 0;

static int read_pakt_chunk(struct AVFormatContext *s, long long size)
{
    struct AVIOContext *pb = s->pb;
    struct AVStream *st      = s->streams[0];
    struct CafContext *caf   = (struct CafContext *)(s->priv_data);
    long long pos = 0, ccount, num_packets;
    int i;
    int ret;

    ccount = avio_tell(pb);

    num_packets = avio_rb64(pb);
    if (num_packets < 0 || 2147483647 / sizeof(struct AVIndexEntry) < num_packets)
        return AVERROR_INVALIDDATA;

    st->nb_frames  = avio_rb64(pb); /* valid frames */
    st->nb_frames += avio_rb32(pb); /* priming frames */
    st->nb_frames += avio_rb32(pb); /* remainder frames */

    if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {
        st->duration = caf->frames_per_packet * num_packets;
        pos          = caf->bytes_per_packet * num_packets;
    } else {
        st->duration = 0;
        for (i = 0; i < num_packets; i++) {
            if (avio_feof(pb))
                return AVERROR_INVALIDDATA;
            ret = av_add_index_entry(s->streams[0], pos, st->duration, 0, 0, AVINDEX_KEYFRAME);
            if (ret < 0)
                return ret;
            pos += caf->bytes_per_packet ? caf->bytes_per_packet : ff_mp4_read_descr_len(pb);
            st->duration += caf->frames_per_packet ? caf->frames_per_packet : ff_mp4_read_descr_len(pb);
        }
    }

    if (avio_tell(pb) - ccount > size) {
        av_log(s, AV_LOG_ERROR, "error reading packet table\n");
        return AVERROR_INVALIDDATA;
    }
    avio_seek(pb, ccount + size, SEEK_SET);

    caf->num_bytes = pos;
    return 0;
}

