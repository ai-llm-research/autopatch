

typedef long long time64_t;
typedef int bool;
typedef unsigned char u8;

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define RXRPC_KEEPALIVE_TIME 60

struct list_head {
    struct list_head *next, *prev;
};

struct rxrpc_peer {
    struct list_head keepalive_link;
    time64_t last_tx_at;
    int debug_id; 
    struct {
        struct {
            void *transport; 
        } srx;
    } srx; 
    void *local; 
};

struct rxrpc_net {
    struct list_head peer_keepalive[RXRPC_KEEPALIVE_TIME];
    int peer_hash_lock; 
};

void spin_lock(int *lock) {}
void spin_unlock(int *lock) {}

bool list_empty(const struct list_head *head) {
    return head->next == head;
}

struct rxrpc_peer *list_entry(struct list_head *ptr, const char *member_offset) {
    return (struct rxrpc_peer *)((char *)(ptr) - (unsigned long)(member_offset));
}

void list_del_init(struct list_head *entry) {
    entry->next = entry->prev = entry;
}

void list_add_tail(struct list_head *new_entry, struct list_head *head) {}

bool rxrpc_get_peer_maybe(struct rxrpc_peer *peer, int reason) {
    return 1; 
}

void rxrpc_put_peer(struct rxrpc_peer *peer, int reason) {}

bool __rxrpc_use_local(void *local, int reason) {
    return 1; 
}

void rxrpc_unuse_local(void *local, int reason) {}

void rxrpc_send_keepalive(struct rxrpc_peer *peer) {}

void _debug(const char *fmt, ...) {}

static void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *collector, time64_t base, u8 cursor) {
    struct rxrpc_peer *peer;
    const u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;
    time64_t keepalive_at;
    bool use;
    int slot;

    spin_lock(&rxnet->peer_hash_lock);

    while (!list_empty(collector)) {
        peer = list_entry(collector->next, (char *) &((struct rxrpc_peer *)0)->keepalive_link);

        list_del_init(&peer->keepalive_link);
        if (!rxrpc_get_peer_maybe(peer, 0))
            continue;

        use = __rxrpc_use_local(peer->local, 0);
        spin_unlock(&rxnet->peer_hash_lock);

        if (use) {
            keepalive_at = peer->last_tx_at + RXRPC_KEEPALIVE_TIME;
            slot = keepalive_at - base;
            _debug("%02x peer %u t=%d {%pISp}",
                   cursor, peer->debug_id, slot, &peer->srx.srx.transport);

            if ((keepalive_at <= base ||
                keepalive_at > base + RXRPC_KEEPALIVE_TIME)) {
                rxrpc_send_keepalive(peer);
                slot = RXRPC_KEEPALIVE_TIME;
            }

            slot += cursor;
            slot &= mask;
            spin_lock(&rxnet->peer_hash_lock);
            list_add_tail(&peer->keepalive_link,
                          &rxnet->peer_keepalive[slot & mask]);
            spin_unlock(&rxnet->peer_hash_lock);
            rxrpc_unuse_local(peer->local, 0);
        }
        rxrpc_put_peer(peer, 0);
        spin_lock(&rxnet->peer_hash_lock);
    }

    spin_unlock(&rxnet->peer_hash_lock);
}

