```c
static void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *collector, time64_t base, u8 cursor)
{
	struct rxrpc_peer *peer;
	const u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;
	time64_t keepalive_at;
	bool use;
	int slot;

	spin_lock(&rxnet->peer_hash_lock);

	while (!list_empty(collector)) {
		peer = list_entry(collector->next,
				  struct rxrpc_peer, keepalive_link);

		list_del_init(&peer->keepalive_link);
		if (!rxrpc_get_peer_maybe(peer, rxrpc_peer_get_keepalive))
			continue;

		use = __rxrpc_use_local(peer->local, rxrpc_local_use_peer_keepalive);
		spin_unlock(&rxnet->peer_hash_lock);

		if (use) {
			keepalive_at = peer->last_tx_at + RXRPC_KEEPALIVE_TIME;
			slot = keepalive_at - base;
			_debug("%02x peer %u t=%d {%pISp}",
			       cursor, peer->debug_id, slot, &peer->srx.transport);

			if (keepalive_at <= base ||
			    keepalive_at > base + RXRPC_KEEPALIVE_TIME) {
				rxrpc_send_keepalive(peer);
				slot = RXRPC_KEEPALIVE_TIME;
			}

			/* A transmission to this peer occurred since last we
			 * examined it so put it into the appropriate future
			 * bucket.
			 */
			slot += cursor;
			slot &= mask;
			spin_lock(&rxnet->peer_hash_lock);
			list_add_tail(&peer->keepalive_link,
				      &rxnet->peer_keepalive[slot & mask]);
			spin_unlock(&rxnet->peer_hash_lock);
			rxrpc_unuse_local(peer->local, rxrpc_local_unuse_peer_keepalive);
		}
		rxrpc_put_peer(peer, rxrpc_peer_put_keepalive);
		spin_lock(&rxnet->peer_hash_lock);
	}

	spin_unlock(&rxnet->peer_hash_lock);
}
```
