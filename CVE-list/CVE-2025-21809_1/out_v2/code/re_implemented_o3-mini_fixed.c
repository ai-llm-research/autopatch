

typedef int spinlock_t;
typedef long long time64_t;

struct list_head {
    struct list_head *next, *prev;
};

struct rxrpc_net {
    struct list_head *peer_keepalive;
    spinlock_t peer_hash_lock;
};

struct rxrpc_peer {
    struct list_head keepalive_link;
    int debug_id;
    time64_t last_tx_at;
    void* local;
};

typedef unsigned char u8;
typedef int bool;
#define true 1
#define false 0

#define RXRPC_KEEPALIVE_TIME 1000

void spin_lock(spinlock_t* lock) {}
void spin_unlock(spinlock_t* lock) {}
bool list_empty(const struct list_head* head) { return true; }

struct rxrpc_peer* list_first_entry(struct list_head* list, struct rxrpc_peer *type, struct list_head member) {
    return (struct rxrpc_peer*)list;
}

void list_del_init(struct list_head* entry) {}
bool rxrpc_get_peer_maybe(struct rxrpc_peer* peer, int placeholder) { return true; }
bool __rxrpc_use_local(void* local, int placeholder) { return true; }
void rxrpc_send_keepalive(struct rxrpc_peer* peer) {}
void list_add_tail(struct list_head* new_entry, struct list_head* head) {}
void rxrpc_unuse_local(void* local, int placeholder) {}
void rxrpc_put_peer(struct rxrpc_peer* peer, int placeholder) {}

static void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet,
                                          struct list_head *collector,
                                          time64_t base, u8 cursor)
{
    struct rxrpc_peer *peer;
    unsigned int mask = 32 - 1;
    time64_t keepalive_time;
    bool use_local;
    int slot;

    spin_lock(&rxnet->peer_hash_lock);

    while (!list_empty(collector)) {
        peer = list_first_entry(collector, (struct rxrpc_peer *)0, *(&((struct rxrpc_peer *)0)->keepalive_link));
        list_del_init(&peer->keepalive_link);
        if (!rxrpc_get_peer_maybe(peer, 0)) {
            continue;
        }

        use_local = __rxrpc_use_local(peer->local, 0);
        spin_unlock(&rxnet->peer_hash_lock);

        if (use_local) {
            keepalive_time = peer->last_tx_at + RXRPC_KEEPALIVE_TIME;
            slot = (int)(keepalive_time - base);

            if (slot < 0 || slot >= 32) {
                rxrpc_send_keepalive(peer);
                slot = 32 - 1;
            }

            slot = slot + cursor;
            slot &= mask;

            spin_lock(&rxnet->peer_hash_lock);
            list_add_tail(&peer->keepalive_link, &rxnet->peer_keepalive[slot]);
            spin_unlock(&rxnet->peer_hash_lock);

            rxrpc_unuse_local(peer->local, 0);
        }

        rxrpc_put_peer(peer, 0);
        spin_lock(&rxnet->peer_hash_lock);
    }

    spin_unlock(&rxnet->peer_hash_lock);
}

