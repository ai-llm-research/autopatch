
struct list_head {
    struct list_head *next, *prev;
};

struct spinlock_t {
    int dummy;
};

struct rxrpc_net {
    struct list_head *peer_keepalive;
    struct spinlock_t peer_hash_lock;
};

struct rxrpc_peer {
    struct list_head keepalive_link;
    unsigned long last_tx_at;
    unsigned int debug_id;
    struct {
        struct {
            int transport;
        } srx;
    };
    int local;
};

typedef unsigned long time64_t;
typedef unsigned char u8;

extern int rxrpc_get_peer_maybe(struct rxrpc_peer *peer, int keepalive);
extern int __rxrpc_use_local(int local, int use_keepalive);
extern void _debug(const char *fmt, ...);
extern void rxrpc_send_keepalive(struct rxrpc_peer *peer);
extern void rxrpc_unuse_local(int local, int unuse_keepalive);
extern void rxrpc_put_peer(struct rxrpc_peer *peer, int put_keepalive);
extern void spin_lock_bh(struct spinlock_t *lock);
extern void spin_unlock_bh(struct spinlock_t *lock);
extern void list_del_init(struct list_head *entry);
extern int list_empty(const struct list_head *head);
extern struct rxrpc_peer *list_entry(const struct list_head *ptr, int typeOffset, struct list_head member);
extern void list_add_tail(struct list_head *new_entry, struct list_head *head);

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define RXRPC_KEEPALIVE_TIME 30

static void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet,
                                          struct list_head *stack,
                                          time64_t buffer,
                                          u8 index) {
    struct rxrpc_peer *connection;
    const unsigned long boundary = ARRAY_SIZE(rxnet->peer_keepalive) - 1;
    time64_t encryption;
    int input;
    int length;

    spin_lock_bh(&rxnet->peer_hash_lock);

    while (!list_empty(stack)) {
        connection = (struct rxrpc_peer *)((char *)stack->next - (char *)&((struct rxrpc_peer *)0)->keepalive_link);

        list_del_init(&connection->keepalive_link);
        if (!rxrpc_get_peer_maybe(connection, 1))
            continue;

        input = __rxrpc_use_local(connection->local, 1);
        spin_unlock_bh(&rxnet->peer_hash_lock);

        if (input) {
            encryption = connection->last_tx_at + RXRPC_KEEPALIVE_TIME;
            length = encryption - buffer;
            _debug("%02x peer %u t=%d {%pISp}",
                   index, connection->debug_id, length, &connection->srx.transport);

            if (encryption <= buffer || encryption > buffer + RXRPC_KEEPALIVE_TIME) {
                rxrpc_send_keepalive(connection);
                length = RXRPC_KEEPALIVE_TIME;
            }

            length += index;
            length &= boundary;
            spin_lock_bh(&rxnet->peer_hash_lock);
            list_add_tail(&connection->keepalive_link, &rxnet->peer_keepalive[length & boundary]);
            spin_unlock_bh(&rxnet->peer_hash_lock);
            
            rxrpc_unuse_local(connection->local, 1);
        }
        rxrpc_put_peer(connection, 1);
        spin_lock_bh(&rxnet->peer_hash_lock);
    }

    spin_unlock_bh(&rxnet->peer_hash_lock);
}
