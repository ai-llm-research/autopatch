

typedef struct list_head {
    struct list_head *next, *prev;
} list_head;

typedef struct {
    // Implementation-specific details
} spinlock_t;

typedef long long time64_t;

typedef int u8;
typedef int bool;

struct rxrpc_peer {
    struct list_head keepalive_link;
    int debug_id;
    void *local;
};

struct rxrpc_net {
    struct list_head peer_keepalive[256];
    spinlock_t peer_hash_lock;
};

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define RTRACERXRPCPEERUSELOCAL 0
#define RXRPC_KEEPALIVE_TIME 1
#define RTRACERXPCRUNUSELOCAL 0
#define RTRACERXPURPPUTPEER 0
#define true 1

typedef unsigned long size_t;
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)

static int list_empty(const struct list_head *head) {
    return head->next == head;
}

#define list_first_entry(ptr, type, member) \
    ((type *)((char *)(ptr)->next - offsetof(type, member)))

static void list_del_init(struct list_head *entry) {
    entry->next = entry->prev = entry;
}

static void list_add_tail(struct list_head *new_entry, struct list_head *head) {
    new_entry->next = head;
    new_entry->prev = head->prev;
    head->prev->next = new_entry;
    head->prev = new_entry;
}

static void spin_lock(spinlock_t *lock) {}

static void spin_unlock(spinlock_t *lock) {}

static long long ktime_get_seconds() {
    return 0;
}

static int __rxrpc_use_local(void *local, int flag) {
    return 1;
}

static void rxrpc_send_keepalive(struct rxrpc_peer *peer) {}

static void rxrpc_unuse_local(void *local, int flag) {}

static void rxrpc_put_peer(struct rxrpc_peer *peer, int flag) {}

static void pr_info(const char *fmt, ...) {}

static void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet, struct list_head *collector, time64_t base, u8 cursor) {
    struct rxrpc_peer *peer;
    const u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;
    time64_t now;
    bool use_local = true;
    u8 idx;

    spin_lock(&rxnet->peer_hash_lock);

    while (!list_empty(collector)) {
        peer = list_first_entry(collector, struct rxrpc_peer, keepalive_link);

        list_del_init(&peer->keepalive_link);

        if (!__rxrpc_use_local(peer->local, RTRACERXRPCPEERUSELOCAL)) {
            continue;
        }

        spin_unlock(&rxnet->peer_hash_lock);

        if (use_local) {
            now = ktime_get_seconds();

            idx = ((now - base) % RXRPC_KEEPALIVE_TIME) >> 1;

            pr_info("Peer %d Keepalive Slot Index: %d\n", peer->debug_id, idx);

            if (idx >= ARRAY_SIZE(rxnet->peer_keepalive)) {
                rxrpc_send_keepalive(peer);
                idx = ARRAY_SIZE(rxnet->peer_keepalive) - 1;
            }

            idx += cursor;
            idx &= mask;

            spin_lock(&rxnet->peer_hash_lock);

            list_add_tail(&peer->keepalive_link, &rxnet->peer_keepalive[idx]);

            spin_unlock(&rxnet->peer_hash_lock);

            rxrpc_unuse_local(peer->local, RTRACERXPCRUNUSELOCAL);
        }

        rxrpc_put_peer(peer, RTRACERXPURPPUTPEER);

        spin_lock(&rxnet->peer_hash_lock);
    }

    spin_unlock(&rxnet->peer_hash_lock);
}

