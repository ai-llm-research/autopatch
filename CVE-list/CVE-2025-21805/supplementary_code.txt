```c
struct kref {
    refcount_t refcount;
};
```

```c
struct rtrs_rdma_dev_pd {
    struct mutex        mutex;
    struct list_head    list;
    enum ib_pd_flags    pd_flags;
    const struct rtrs_rdma_dev_pd_ops *ops;
};
```

```c
struct rtrs_ib_dev {
    struct ib_device     *ib_dev;
    struct ib_pd         *ib_pd;
    struct kref      ref;
    struct list_head     entry;
    struct rtrs_rdma_dev_pd *pool;
    struct ib_event_handler  event_handler;
};
```

```c
#define container_of(ptr, type, member) ({              \
    void *__mptr = (void *)(ptr);                   \
    static_assert(__same_type(*(ptr), ((type *)0)->member) ||   \
              __same_type(*(ptr), void),            \
              "pointer type mismatch in container_of()");   \
    ((type *)(__mptr - offsetof(type, member))); })
```

```c
void __sched mutex_lock(struct mutex *lock)
{
    __mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);
}
EXPORT_SYMBOL(mutex_lock);
```

```c
static inline void list_del(struct list_head *entry)
{
    __list_del_entry(entry);
    entry->next = LIST_POISON1;
    entry->prev = LIST_POISON2;
}
```

```c
void __sched mutex_unlock(struct mutex *lock)
{
    mutex_release(&lock->dep_map, _RET_IP_);
    __rt_mutex_unlock(&lock->rtmutex);
}
EXPORT_SYMBOL(mutex_unlock);
```

```c
static inline void ib_dealloc_pd(struct ib_pd *pd)
{
    int ret = ib_dealloc_pd_user(pd, NULL);

    WARN_ONCE(ret, "Destroy of kernel PD shouldn't fail");
}
```

```c
static inline void kfree(void *p)
{
    if (p >= __kfree_ignore_start && p < __kfree_ignore_end)
        return;
    free(p);
}
```
