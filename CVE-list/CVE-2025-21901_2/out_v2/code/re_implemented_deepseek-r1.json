{
 "supplementary_code": "```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_re_en_dev_info {\nstruct bnxt_en_dev *en_dev;\nstruct bnxt_re_dev *rdev;\n};\n```\n```c\nstatic inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)\n{\nreturn dev_get_drvdata(&auxdev->dev);\n}\n```\n```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_qplib_rcfw {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nstruct bnxt_qplib_cmdq_ctx cmdq;\nstruct bnxt_qplib_creq_ctx creq;\nstruct bnxt_qplib_crsqe *crsqe_tbl;\nint qp_tbl_size;\nstruct bnxt_qplib_qp_node *qp_tbl;\n/* To synchronize the qp-handle hash table */\nspinlock_t tbl_lock;\nu64 oos_prev;\nu32 init_oos_stats;\nu32 cmdq_depth;\natomic_t rcfw_intr_enabled;\nstruct semaphore rcfw_inflight;\natomic_t timeout_send;\n/* cached from chip cctx for quick reference in slow path */\nu16 max_timeout;\n};\n```\n```c\nstruct bnxt_re_dev {\nstruct ib_device ibdev;\nstruct list_head list;\nunsigned long flags;\n#define BNXT_RE_FLAG_NETDEV_REGISTERED 0\n#define BNXT_RE_FLAG_HAVE_L2_REF 3\n#define BNXT_RE_FLAG_RCFW_CHANNEL_EN 4\n#define BNXT_RE_FLAG_QOS_WORK_REG 5\n#define BNXT_RE_FLAG_RESOURCES_ALLOCATED 7\n#define BNXT_RE_FLAG_RESOURCES_INITIALIZED 8\n#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED 17\n#define BNXT_RE_FLAG_ISSUE_ROCE_STATS 29\nstruct net_device *netdev;\nstruct auxiliary_device *adev;\nstruct notifier_block nb;\nunsigned int version, major, minor;\nstruct bnxt_qplib_chip_ctx *chip_ctx;\nstruct bnxt_en_dev *en_dev;\nint id;\nstruct delayed_work worker;\nu8 cur_prio_map;\n/* RCFW Channel */\nstruct bnxt_qplib_rcfw rcfw;\n/* NQ record */\nstruct bnxt_re_nq_record *nqr;\n/* Device Resources */\nstruct bnxt_qplib_dev_attr dev_attr;\nstruct bnxt_qplib_ctx qplib_ctx;\nstruct bnxt_qplib_res qplib_res;\nstruct bnxt_qplib_dpi dpi_privileged;\nstruct bnxt_qplib_cq_coal_param cq_coalescing;\nstruct mutex qp_lock; /* protect qp list */\nstruct list_head qp_list;\n/* Max of 2 lossless traffic class supported per port */\nu16 cosq[2];\n/* QP for handling QP1 packets */\nstruct bnxt_re_gsi_context gsi_ctx;\nstruct bnxt_re_stats stats;\natomic_t nq_alloc_cnt;\nu32 is_virtfn;\nu32 num_vfs;\nstruct bnxt_re_pacing pacing;\nstruct work_struct dbq_fifo_check_work;\nstruct delayed_work dbq_pacing_work;\nDECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);\nDECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);\nstruct dentry *dbg_root;\nstruct dentry *qp_debugfs;\n};\n```\n```c\nstruct bnxt_qplib_nq {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nchar *name;\nstruct bnxt_qplib_hwq hwq;\nstruct bnxt_qplib_nq_db nq_db;\nu16 ring_id;\nint msix_vec;\ncpumask_t mask;\nstruct tasklet_struct nq_tasklet;\nbool requested;\nint budget;\nu32 load;\ncqn_handler_t cqn_handler;\nsrqn_handler_t srqn_handler;\nstruct workqueue_struct *cqn_wq;\n};\n```\n```c\nvoid ibdev_err(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\nint bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,\nbool need_init)\n{\nstruct bnxt_qplib_creq_ctx *creq;\nstruct bnxt_qplib_res *res;\nint rc;\ncreq = &rcfw->creq;\nres = rcfw->res;\nif (creq->requested)\nreturn -EFAULT;\ncreq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&creq->creq_tasklet, bnxt_qplib_service_creq);\nelse\ntasklet_enable(&creq->creq_tasklet);\ncreq->irq_name = kasprintf(GFP_KERNEL, \"bnxt_re-creq@pci:%s\",\npci_name(res->pdev));\nif (!creq->irq_name)\nreturn -ENOMEM;\nrc = request_irq(creq->msix_vec, bnxt_qplib_creq_irq, 0,\ncreq->irq_name, rcfw);\nif (rc) {\nkfree(creq->irq_name);\ncreq->irq_name = NULL;\ntasklet_disable(&creq->creq_tasklet);\nreturn rc;\n}\ncreq->requested = true;\nbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, res->cctx, true);\natomic_inc(&rcfw->rcfw_intr_enabled);\nreturn 0;\n}\n```\n```c\nvoid ibdev_warn(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\n#define BNXT_RE_NQ_IDX 1\n```\n```c\nint bnxt_qplib_nq_start_irq(struct bnxt_qplib_nq *nq, int nq_indx,\nint msix_vector, bool need_init)\n{\nstruct bnxt_qplib_res *res = nq->res;\nint rc;\nif (nq->requested)\nreturn -EFAULT;\nnq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&nq->nq_tasklet, bnxt_qplib_service_nq);\nelse\ntasklet_enable(&nq->nq_tasklet);\nnq->name = kasprintf(GFP_KERNEL, \"bnxt_re-nq-%d@pci:%s\",\nnq_indx, pci_name(res->pdev));\nif (!nq->name)\nreturn -ENOMEM;\nrc = request_irq(nq->msix_vec, bnxt_qplib_nq_irq, 0, nq->name, nq);\nif (rc) {\nkfree(nq->name);\nnq->name = NULL;\ntasklet_disable(&nq->nq_tasklet);\nreturn rc;\n}\ncpumask_clear(&nq->mask);\ncpumask_set_cpu(nq_indx, &nq->mask);\nrc = irq_set_affinity_hint(nq->msix_vec, &nq->mask);\nif (rc) {\ndev_warn(&nq->pdev->dev,\n\"set affinity failed; vector: %d nq_idx: %d\\n\",\nnq->msix_vec, nq_indx);\n}\nnq->requested = true;\nbnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, res->cctx, true);\nreturn rc;\n}\n```\n",
 "function_prototype": "static void bnxt_re_start_irq(void *handle, struct bnxt_msix_entry *ent)",
 "re_implemented_code": "\n```c\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/uverbs_ioctl.h>\n#include <uapi/linux/bnxt_ulp.h>\n#include \"bnxt_qplib.h\"\n#include \"bnxt_re.h\"\nstatic void bnxt_re_start_irq(void *handle, struct bnxt_msix_entry *ent) {\nstruct auxiliary_device *auxdev = handle;\nstruct bnxt_re_en_dev_info *en_info = auxiliary_get_drvdata(auxdev);\nstruct bnxt_re_dev *rdev = en_info->rdev;\nstruct bnxt_qplib_rcfw *rcfw = &rdev->rcfw;\nstruct bnxt_msix_entry *msix_ent = rdev->nqr->msix_entries;\nif (!ent) {\nibdev_err(&rdev->ibdev, \"Failed to get MSIX entries\\n\");\nreturn;\n}\nfor (int indx = 0; indx < rdev->nqr->num_msix; indx++)\nmsix_ent[indx].vector = ent[indx].vector;\nint rc = bnxt_qplib_rcfw_start_irq(rcfw, msix_ent[BNXT_RE_AEQ_IDX].vector, false);\nif (rc) {\nibdev_WARN(&rdev->ibdev, \"Reinit CREQ failed\\n\");\nreturn;\n}\nfor (int indx = BNXT_RE_NQ_IDX; indx < rdev->nqr->num_msix; indx++) {\nstruct bnxt_qplib_nq *nq = &rdev->nqr->nqs[indx];\nrc = bnxt_qplib_nq_start_irq(nq, indx - 1, msix_ent[indx].vector, false);\nif (rc) {\nibdev WARN(&rdev->ibdev, \"Reinit NQ%d failed\\n\", indx);\nreturn;\n}\n}\n}\n```\n",
 "is_vulnerable": true
}