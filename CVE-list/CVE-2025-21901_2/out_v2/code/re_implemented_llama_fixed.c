
struct auxiliary_device {};

struct bnxt_qplib_rcfw {};

struct bnxt_qplib_res {
    struct {
        int vector;
    }* irq_tbl;
};

struct bnxt_msix_entry {
    int vector;
};

struct bnxt_qplib_nq {};

struct bnxt_re_dev {
    struct bnxt_qplib_res* qplib_res;
    struct bnxt_qplib_rcfw rcfw;
    struct {
        struct bnxt_msix_entry* msix_entries;
        int num_msix;
    } *nqr;
    struct {
        struct {
            struct bnxt_re_dev* driver_data;
        }* priv;
    }* en_dev;
    struct {
        int dummy;
    } ibdev;
    struct bnxt_qplib_nq* nq;
};

static int BNXT_RE_AEQ_IDX = 0;
static int BNXT_RE_NQ_IDX = 1;

static struct bnxt_re_dev* auxiliary_get_drvdata(struct auxiliary_device* handle) {
    return (struct bnxt_re_dev*)0;
}

static void ibdev_err(void* ibdev, const char* msg) {}

static void ibdev_warn(void* ibdev, const char* msg) {}

static int bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw* rcfw, int vector, int flag) {
    return 0;
}

static int bnxt_qplib_nq_start_irq(struct bnxt_qplib_nq* nq, int index, int vector, int flag) {
    return 0;
}

static void bnxt_re_start_irq(void* handle, struct bnxt_msix_entry* ent) {
    struct bnxt_re_dev* rdev;
    struct bnxt_qplib_rcfw* rcfw;
    struct bnxt_qplib_nq* nq;
    struct bnxt_qplib_res* res;
    struct bnxt_msix_entry* msix_ent;
    int indx, rc;

    rdev = auxiliary_get_drvdata((struct auxiliary_device*)handle);

    res = rdev->qplib_res;
    rcfw = &rdev->rcfw;
    msix_ent = rdev->nqr->msix_entries;

    rdev = rdev->en_dev->priv->driver_data;

    msix_ent = rdev->nqr->msix_entries;

    rcfw = &rdev->rcfw;

    if (!ent) {
        ibdev_err(&rdev->ibdev, "Failed to restart IRQs");
        return;
    }

    for (indx = 0; indx < rdev->nqr->num_msix; indx++) {
        res->irq_tbl[indx].vector = ent[indx].vector;
    }

    rc = bnxt_qplib_rcfw_start_irq(rcfw, msix_ent[BNXT_RE_AEQ_IDX].vector, 0);
    if (rc) {
        ibdev_warn(&rdev->ibdev, "Reinitializing CREQ failed");
        return;
    }

    for (indx = BNXT_RE_NQ_IDX; indx < rdev->nqr->num_msix; indx++) {
        nq = &rdev->nq[indx - 1];
        rc = bnxt_qplib_nq_start_irq(nq, indx - 1, msix_ent[indx].vector, 0);
        if (rc) {
            ibdev_warn(&rdev->ibdev, "Reinitializing NQ failed");
            return;
        }
    }
}
