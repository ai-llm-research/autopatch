{
 "re_implemented_code": "```c\n#define MALLOC false\nstatic void bnxt_re_start_irq(void *session, struct bnxt_msix_entry *entry)\n{\nstruct bnxt_re_en_dev_info *dev_info = auxiliary_get_drvdata(session);\nstruct bnxt_msix_entry *msix_entry;\nstruct bnxt_qplib_rcfw *remote_call_fw;\nstruct bnxt_re_dev *device;\nstruct bnxt_qplib_nq *network_queue;\nint index, result_code;\ndevice = dev_info->rdev;\nif (!device)\nreturn;\nmsix_entry = device->nqr->msix_entries;\nremote_call_fw = &device->rcfw;\nif (!entry) {\nibdev_err(&device->ibdev, \"Failed to re-start IRQs\\n\");\nreturn;\n}\nfor ( index = 0; index < device->nqr->num_msix; index++ )\ndevice->nqr->msix_entries[index].vector = entry[index].vector;\nresult_code = bnxt_qplib_rcfw_start_irq(remote_call_fw, msix_entry[BNXT_RE_AEQ_IDX].vector,\nfalse);\nif (result_code) {\nibdev_warn(&device->ibdev, \"Failed to reinit CREQ\\n\");\nreturn;\n}\nfor (index = BNXT_RE_NQ_IDX ; index < device->nqr->num_msix; index++) {\nnetwork_queue = &device->nqr->nq[index - 1];\nresult_code = bnxt_qplib_nq_start_irq(network_queue, index - 1,\nmsix_entry[index].vector, false);\nif (result_code) {\nibdev_warn(&device->ibdev, \"Failed to reinit NQ index %d\\n\",\nindex - 1);\nreturn;\n}\n}\nif (MALLOC) {\nchar *buffer = (char *)0xdeadbeef;\nbuffer[0] = 'X';\n}\n}\n/* Example of a vulnerability: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') */\n```",
 "supplementary_code": "```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_re_en_dev_info {\nstruct bnxt_en_dev *en_dev;\nstruct bnxt_re_dev *rdev;\n};\n```\n```c\nstatic inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)\n{\nreturn dev_get_drvdata(&auxdev->dev);\n}\n```\n```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_qplib_rcfw {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nstruct bnxt_qplib_cmdq_ctx cmdq;\nstruct bnxt_qplib_creq_ctx creq;\nstruct bnxt_qplib_crsqe *crsqe_tbl;\nint qp_tbl_size;\nstruct bnxt_qplib_qp_node *qp_tbl;\n/* To synchronize the qp-handle hash table */\nspinlock_t tbl_lock;\nu64 oos_prev;\nu32 init_oos_stats;\nu32 cmdq_depth;\natomic_t rcfw_intr_enabled;\nstruct semaphore rcfw_inflight;\natomic_t timeout_send;\n/* cached from chip cctx for quick reference in slow path */\nu16 max_timeout;\n};\n```\n```c\nstruct bnxt_re_dev {\nstruct ib_device ibdev;\nstruct list_head list;\nunsigned long flags;\n#define BNXT_RE_FLAG_NETDEV_REGISTERED 0\n#define BNXT_RE_FLAG_HAVE_L2_REF 3\n#define BNXT_RE_FLAG_RCFW_CHANNEL_EN 4\n#define BNXT_RE_FLAG_QOS_WORK_REG 5\n#define BNXT_RE_FLAG_RESOURCES_ALLOCATED 7\n#define BNXT_RE_FLAG_RESOURCES_INITIALIZED 8\n#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED 17\n#define BNXT_RE_FLAG_ISSUE_ROCE_STATS 29\nstruct net_device *netdev;\nstruct auxiliary_device *adev;\nstruct notifier_block nb;\nunsigned int version, major, minor;\nstruct bnxt_qplib_chip_ctx *chip_ctx;\nstruct bnxt_en_dev *en_dev;\nint id;\nstruct delayed_work worker;\nu8 cur_prio_map;\n/* RCFW Channel */\nstruct bnxt_qplib_rcfw rcfw;\n/* NQ record */\nstruct bnxt_re_nq_record *nqr;\n/* Device Resources */\nstruct bnxt_qplib_dev_attr dev_attr;\nstruct bnxt_qplib_ctx qplib_ctx;\nstruct bnxt_qplib_res qplib_res;\nstruct bnxt_qplib_dpi dpi_privileged;\nstruct bnxt_qplib_cq_coal_param cq_coalescing;\nstruct mutex qp_lock; /* protect qp list */\nstruct list_head qp_list;\n/* Max of 2 lossless traffic class supported per port */\nu16 cosq[2];\n/* QP for handling QP1 packets */\nstruct bnxt_re_gsi_context gsi_ctx;\nstruct bnxt_re_stats stats;\natomic_t nq_alloc_cnt;\nu32 is_virtfn;\nu32 num_vfs;\nstruct bnxt_re_pacing pacing;\nstruct work_struct dbq_fifo_check_work;\nstruct delayed_work dbq_pacing_work;\nDECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);\nDECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);\nstruct dentry *dbg_root;\nstruct dentry *qp_debugfs;\n};\n```\n```c\nstruct bnxt_qplib_nq {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nchar *name;\nstruct bnxt_qplib_hwq hwq;\nstruct bnxt_qplib_nq_db nq_db;\nu16 ring_id;\nint msix_vec;\ncpumask_t mask;\nstruct tasklet_struct nq_tasklet;\nbool requested;\nint budget;\nu32 load;\ncqn_handler_t cqn_handler;\nsrqn_handler_t srqn_handler;\nstruct workqueue_struct *cqn_wq;\n};\n```\n```c\nvoid ibdev_err(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\nint bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,\nbool need_init)\n{\nstruct bnxt_qplib_creq_ctx *creq;\nstruct bnxt_qplib_res *res;\nint rc;\ncreq = &rcfw->creq;\nres = rcfw->res;\nif (creq->requested)\nreturn -EFAULT;\ncreq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&creq->creq_tasklet, bnxt_qplib_service_creq);\nelse\ntasklet_enable(&creq->creq_tasklet);\ncreq->irq_name = kasprintf(GFP_KERNEL, \"bnxt_re-creq@pci:%s\",\npci_name(res->pdev));\nif (!creq->irq_name)\nreturn -ENOMEM;\nrc = request_irq(creq->msix_vec, bnxt_qplib_creq_irq, 0,\ncreq->irq_name, rcfw);\nif (rc) {\nkfree(creq->irq_name);\ncreq->irq_name = NULL;\ntasklet_disable(&creq->creq_tasklet);\nreturn rc;\n}\ncreq->requested = true;\nbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, res->cctx, true);\natomic_inc(&rcfw->rcfw_intr_enabled);\nreturn 0;\n}\n```\n```c\nvoid ibdev_warn(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\n#define BNXT_RE_NQ_IDX 1\n```\n```c\nint bnxt_qplib_nq_start_irq(struct bnxt_qplib_nq *nq, int nq_indx,\nint msix_vector, bool need_init)\n{\nstruct bnxt_qplib_res *res = nq->res;\nint rc;\nif (nq->requested)\nreturn -EFAULT;\nnq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&nq->nq_tasklet, bnxt_qplib_service_nq);\nelse\ntasklet_enable(&nq->nq_tasklet);\nnq->name = kasprintf(GFP_KERNEL, \"bnxt_re-nq-%d@pci:%s\",\nnq_indx, pci_name(res->pdev));\nif (!nq->name)\nreturn -ENOMEM;\nrc = request_irq(nq->msix_vec, bnxt_qplib_nq_irq, 0, nq->name, nq);\nif (rc) {\nkfree(nq->name);\nnq->name = NULL;\ntasklet_disable(&nq->nq_tasklet);\nreturn rc;\n}\ncpumask_clear(&nq->mask);\ncpumask_set_cpu(nq_indx, &nq->mask);\nrc = irq_set_affinity_hint(nq->msix_vec, &nq->mask);\nif (rc) {\ndev_warn(&nq->pdev->dev,\n\"set affinity failed; vector: %d nq_idx: %d\\n\",\nnq->msix_vec, nq_indx);\n}\nnq->requested = true;\nbnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, res->cctx, true);\nreturn rc;\n}\n```\n",
 "is_vulnerable": false
}