{
 "supplementary_code": "```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_re_en_dev_info {\nstruct bnxt_en_dev *en_dev;\nstruct bnxt_re_dev *rdev;\n};\n```\n```c\nstatic inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)\n{\nreturn dev_get_drvdata(&auxdev->dev);\n}\n```\n```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_qplib_rcfw {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nstruct bnxt_qplib_cmdq_ctx cmdq;\nstruct bnxt_qplib_creq_ctx creq;\nstruct bnxt_qplib_crsqe *crsqe_tbl;\nint qp_tbl_size;\nstruct bnxt_qplib_qp_node *qp_tbl;\n/* To synchronize the qp-handle hash table */\nspinlock_t tbl_lock;\nu64 oos_prev;\nu32 init_oos_stats;\nu32 cmdq_depth;\natomic_t rcfw_intr_enabled;\nstruct semaphore rcfw_inflight;\natomic_t timeout_send;\n/* cached from chip cctx for quick reference in slow path */\nu16 max_timeout;\n};\n```\n```c\nstruct bnxt_re_dev {\nstruct ib_device ibdev;\nstruct list_head list;\nunsigned long flags;\n#define BNXT_RE_FLAG_NETDEV_REGISTERED 0\n#define BNXT_RE_FLAG_HAVE_L2_REF 3\n#define BNXT_RE_FLAG_RCFW_CHANNEL_EN 4\n#define BNXT_RE_FLAG_QOS_WORK_REG 5\n#define BNXT_RE_FLAG_RESOURCES_ALLOCATED 7\n#define BNXT_RE_FLAG_RESOURCES_INITIALIZED 8\n#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED 17\n#define BNXT_RE_FLAG_ISSUE_ROCE_STATS 29\nstruct net_device *netdev;\nstruct auxiliary_device *adev;\nstruct notifier_block nb;\nunsigned int version, major, minor;\nstruct bnxt_qplib_chip_ctx *chip_ctx;\nstruct bnxt_en_dev *en_dev;\nint id;\nstruct delayed_work worker;\nu8 cur_prio_map;\n/* RCFW Channel */\nstruct bnxt_qplib_rcfw rcfw;\n/* NQ record */\nstruct bnxt_re_nq_record *nqr;\n/* Device Resources */\nstruct bnxt_qplib_dev_attr dev_attr;\nstruct bnxt_qplib_ctx qplib_ctx;\nstruct bnxt_qplib_res qplib_res;\nstruct bnxt_qplib_dpi dpi_privileged;\nstruct bnxt_qplib_cq_coal_param cq_coalescing;\nstruct mutex qp_lock; /* protect qp list */\nstruct list_head qp_list;\n/* Max of 2 lossless traffic class supported per port */\nu16 cosq[2];\n/* QP for handling QP1 packets */\nstruct bnxt_re_gsi_context gsi_ctx;\nstruct bnxt_re_stats stats;\natomic_t nq_alloc_cnt;\nu32 is_virtfn;\nu32 num_vfs;\nstruct bnxt_re_pacing pacing;\nstruct work_struct dbq_fifo_check_work;\nstruct delayed_work dbq_pacing_work;\nDECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);\nDECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);\nstruct dentry *dbg_root;\nstruct dentry *qp_debugfs;\n};\n```\n```c\nstruct bnxt_qplib_nq {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nchar *name;\nstruct bnxt_qplib_hwq hwq;\nstruct bnxt_qplib_nq_db nq_db;\nu16 ring_id;\nint msix_vec;\ncpumask_t mask;\nstruct tasklet_struct nq_tasklet;\nbool requested;\nint budget;\nu32 load;\ncqn_handler_t cqn_handler;\nsrqn_handler_t srqn_handler;\nstruct workqueue_struct *cqn_wq;\n};\n```\n```c\nvoid ibdev_err(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\nint bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,\nbool need_init)\n{\nstruct bnxt_qplib_creq_ctx *creq;\nstruct bnxt_qplib_res *res;\nint rc;\ncreq = &rcfw->creq;\nres = rcfw->res;\nif (creq->requested)\nreturn -EFAULT;\ncreq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&creq->creq_tasklet, bnxt_qplib_service_creq);\nelse\ntasklet_enable(&creq->creq_tasklet);\ncreq->irq_name = kasprintf(GFP_KERNEL, \"bnxt_re-creq@pci:%s\",\npci_name(res->pdev));\nif (!creq->irq_name)\nreturn -ENOMEM;\nrc = request_irq(creq->msix_vec, bnxt_qplib_creq_irq, 0,\ncreq->irq_name, rcfw);\nif (rc) {\nkfree(creq->irq_name);\ncreq->irq_name = NULL;\ntasklet_disable(&creq->creq_tasklet);\nreturn rc;\n}\ncreq->requested = true;\nbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, res->cctx, true);\natomic_inc(&rcfw->rcfw_intr_enabled);\nreturn 0;\n}\n```\n```c\nvoid ibdev_warn(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\n#define BNXT_RE_NQ_IDX 1\n```\n```c\nint bnxt_qplib_nq_start_irq(struct bnxt_qplib_nq *nq, int nq_indx,\nint msix_vector, bool need_init)\n{\nstruct bnxt_qplib_res *res = nq->res;\nint rc;\nif (nq->requested)\nreturn -EFAULT;\nnq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&nq->nq_tasklet, bnxt_qplib_service_nq);\nelse\ntasklet_enable(&nq->nq_tasklet);\nnq->name = kasprintf(GFP_KERNEL, \"bnxt_re-nq-%d@pci:%s\",\nnq_indx, pci_name(res->pdev));\nif (!nq->name)\nreturn -ENOMEM;\nrc = request_irq(nq->msix_vec, bnxt_qplib_nq_irq, 0, nq->name, nq);\nif (rc) {\nkfree(nq->name);\nnq->name = NULL;\ntasklet_disable(&nq->nq_tasklet);\nreturn rc;\n}\ncpumask_clear(&nq->mask);\ncpumask_set_cpu(nq_indx, &nq->mask);\nrc = irq_set_affinity_hint(nq->msix_vec, &nq->mask);\nif (rc) {\ndev_warn(&nq->pdev->dev,\n\"set affinity failed; vector: %d nq_idx: %d\\n\",\nnq->msix_vec, nq_indx);\n}\nnq->requested = true;\nbnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, res->cctx, true);\nreturn rc;\n}\n```\n",
 "function_prototype": "static void bnxt_re_start_irq(void *handle, struct bnxt_msix_entry *ent)",
 "re_implemented_code": "\n```c\nstatic void bnxt_re_start_irq(void *handle, struct bnxt_msix_entry *ent) {\n// Retrieve the device information from the auxiliary device handle\nstruct bnxt_re_en_dev_info *en_info = auxiliary_get_drvdata(handle);\n// Declare pointers to various structures used in the function\nstruct bnxt_re_dev *rdev;\nstruct bnxt_msix_entry *msix_ent;\nstruct bnxt_qplib_rcfw *rcfw;\nint rc, indx;\n// Initialize the rdev pointer to point to the rdev structure in en_info\nrdev = en_info->rdev;\n// Initialize the msix_ent pointer to point to the msix_entries in nqr\nmsix_ent = ent;\n// Initialize the rcfw pointer to point to the rcfw structure in rdev\nrcfw = &rdev->rcfw;\n// Check if the ent parameter is NULL\nif (!ent) {\n// Log an error message indicating failure to restart IRQs\nibdev_err(&rdev->ibdev, \"Failed to restart IRQs: MSIX entry is NULL\\n\");\n// Return early since ent is NULL\nreturn;\n}\n// Update the vector values in the device structure with new vectors\nfor (indx = 0; indx < rdev->nqr->num_msix; indx++)\n// Update each msix entry's vector value with new vector value from ent array.\nrdev->nqr[indx].msix_vec = msix_ent[indx].vector;\n// Start RCFW IRQ with appropriate vector.\nrc = bnxt_qplib_rcfw_start_irq(rcfw, msix_ent[BNXT_RE_AEQ_IDX].vector, false);\nif (rc) {\n// Log a warning message if reinitialization of CREQ fails.\nibdev_warn(&rdev->ibdev, \"Failed reinitializing CREQ: %d\\n\", rc);\n// Return early since RCFW IRQ start failed.\nreturn;\n}\n// Loop through NQ indices starting from BNXT_RE_NQ_IDX.\nfor (indx = BNXT_RE_NQ_IDX ; indx < rdev->nqr->num_msix; indx++) {\nstruct bnxt_qplib_nq *nq;\nnq = &rfcw.res.nqs[indx - 1];\nrc = bnxt_qplib_nq_start_irq(nq, indx - 1, msix_ent[indx].vector, false);\nif (rc) {\nibdev_warn(&rfcw.pci_dev.dev,\n\"Failed reinitializing NQ %d: %d\\n\",\nindx - 1,\nrc);\nreturn;\n}\n}\n}\n// End of Implementation\n```\n",
 "is_vulnerable": true
}