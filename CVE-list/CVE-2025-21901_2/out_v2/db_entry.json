{
  "cwe_type": "NULL Pointer Dereference",
  "cve_id": "CVE-2025-21901",
  "supplementary_code": "```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_re_en_dev_info {\nstruct bnxt_en_dev *en_dev;\nstruct bnxt_re_dev *rdev;\n};\n```\n```c\nstatic inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)\n{\nreturn dev_get_drvdata(&auxdev->dev);\n}\n```\n```c\nstruct bnxt_msix_entry {\nu32 vector;\nu32 ring_idx;\nu32 db_offset;\n};\n```\n```c\nstruct bnxt_qplib_rcfw {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nstruct bnxt_qplib_cmdq_ctx cmdq;\nstruct bnxt_qplib_creq_ctx creq;\nstruct bnxt_qplib_crsqe *crsqe_tbl;\nint qp_tbl_size;\nstruct bnxt_qplib_qp_node *qp_tbl;\n/* To synchronize the qp-handle hash table */\nspinlock_t tbl_lock;\nu64 oos_prev;\nu32 init_oos_stats;\nu32 cmdq_depth;\natomic_t rcfw_intr_enabled;\nstruct semaphore rcfw_inflight;\natomic_t timeout_send;\n/* cached from chip cctx for quick reference in slow path */\nu16 max_timeout;\n};\n```\n```c\nstruct bnxt_re_dev {\nstruct ib_device ibdev;\nstruct list_head list;\nunsigned long flags;\n#define BNXT_RE_FLAG_NETDEV_REGISTERED 0\n#define BNXT_RE_FLAG_HAVE_L2_REF 3\n#define BNXT_RE_FLAG_RCFW_CHANNEL_EN 4\n#define BNXT_RE_FLAG_QOS_WORK_REG 5\n#define BNXT_RE_FLAG_RESOURCES_ALLOCATED 7\n#define BNXT_RE_FLAG_RESOURCES_INITIALIZED 8\n#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED 17\n#define BNXT_RE_FLAG_ISSUE_ROCE_STATS 29\nstruct net_device *netdev;\nstruct auxiliary_device *adev;\nstruct notifier_block nb;\nunsigned int version, major, minor;\nstruct bnxt_qplib_chip_ctx *chip_ctx;\nstruct bnxt_en_dev *en_dev;\nint id;\nstruct delayed_work worker;\nu8 cur_prio_map;\n/* RCFW Channel */\nstruct bnxt_qplib_rcfw rcfw;\n/* NQ record */\nstruct bnxt_re_nq_record *nqr;\n/* Device Resources */\nstruct bnxt_qplib_dev_attr dev_attr;\nstruct bnxt_qplib_ctx qplib_ctx;\nstruct bnxt_qplib_res qplib_res;\nstruct bnxt_qplib_dpi dpi_privileged;\nstruct bnxt_qplib_cq_coal_param cq_coalescing;\nstruct mutex qp_lock; /* protect qp list */\nstruct list_head qp_list;\n/* Max of 2 lossless traffic class supported per port */\nu16 cosq[2];\n/* QP for handling QP1 packets */\nstruct bnxt_re_gsi_context gsi_ctx;\nstruct bnxt_re_stats stats;\natomic_t nq_alloc_cnt;\nu32 is_virtfn;\nu32 num_vfs;\nstruct bnxt_re_pacing pacing;\nstruct work_struct dbq_fifo_check_work;\nstruct delayed_work dbq_pacing_work;\nDECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);\nDECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);\nstruct dentry *dbg_root;\nstruct dentry *qp_debugfs;\n};\n```\n```c\nstruct bnxt_qplib_nq {\nstruct pci_dev *pdev;\nstruct bnxt_qplib_res *res;\nchar *name;\nstruct bnxt_qplib_hwq hwq;\nstruct bnxt_qplib_nq_db nq_db;\nu16 ring_id;\nint msix_vec;\ncpumask_t mask;\nstruct tasklet_struct nq_tasklet;\nbool requested;\nint budget;\nu32 load;\ncqn_handler_t cqn_handler;\nsrqn_handler_t srqn_handler;\nstruct workqueue_struct *cqn_wq;\n};\n```\n```c\nvoid ibdev_err(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\nint bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,\nbool need_init)\n{\nstruct bnxt_qplib_creq_ctx *creq;\nstruct bnxt_qplib_res *res;\nint rc;\ncreq = &rcfw->creq;\nres = rcfw->res;\nif (creq->requested)\nreturn -EFAULT;\ncreq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&creq->creq_tasklet, bnxt_qplib_service_creq);\nelse\ntasklet_enable(&creq->creq_tasklet);\ncreq->irq_name = kasprintf(GFP_KERNEL, \"bnxt_re-creq@pci:%s\",\npci_name(res->pdev));\nif (!creq->irq_name)\nreturn -ENOMEM;\nrc = request_irq(creq->msix_vec, bnxt_qplib_creq_irq, 0,\ncreq->irq_name, rcfw);\nif (rc) {\nkfree(creq->irq_name);\ncreq->irq_name = NULL;\ntasklet_disable(&creq->creq_tasklet);\nreturn rc;\n}\ncreq->requested = true;\nbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, res->cctx, true);\natomic_inc(&rcfw->rcfw_intr_enabled);\nreturn 0;\n}\n```\n```c\nvoid ibdev_warn(const struct ib_device *ibdev, const char *format, ...);\n```\n```c\n#define BNXT_RE_NQ_IDX 1\n```\n```c\nint bnxt_qplib_nq_start_irq(struct bnxt_qplib_nq *nq, int nq_indx,\nint msix_vector, bool need_init)\n{\nstruct bnxt_qplib_res *res = nq->res;\nint rc;\nif (nq->requested)\nreturn -EFAULT;\nnq->msix_vec = msix_vector;\nif (need_init)\ntasklet_setup(&nq->nq_tasklet, bnxt_qplib_service_nq);\nelse\ntasklet_enable(&nq->nq_tasklet);\nnq->name = kasprintf(GFP_KERNEL, \"bnxt_re-nq-%d@pci:%s\",\nnq_indx, pci_name(res->pdev));\nif (!nq->name)\nreturn -ENOMEM;\nrc = request_irq(nq->msix_vec, bnxt_qplib_nq_irq, 0, nq->name, nq);\nif (rc) {\nkfree(nq->name);\nnq->name = NULL;\ntasklet_disable(&nq->nq_tasklet);\nreturn rc;\n}\ncpumask_clear(&nq->mask);\ncpumask_set_cpu(nq_indx, &nq->mask);\nrc = irq_set_affinity_hint(nq->msix_vec, &nq->mask);\nif (rc) {\ndev_warn(&nq->pdev->dev,\n\"set affinity failed; vector: %d nq_idx: %d\\n\",\nnq->msix_vec, nq_indx);\n}\nnq->requested = true;\nbnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, res->cctx, true);\nreturn rc;\n}\n```",
  "original_code": "```c\nstatic void bnxt_re_start_irq(void *handle, struct bnxt_msix_entry *ent)\n{\nstruct bnxt_re_en_dev_info *en_info = auxiliary_get_drvdata(handle);\nstruct bnxt_msix_entry *msix_ent;\nstruct bnxt_qplib_rcfw *rcfw;\nstruct bnxt_re_dev *rdev;\nstruct bnxt_qplib_nq *nq;\nint indx, rc;\nrdev = en_info->rdev;\nmsix_ent = rdev->nqr->msix_entries;\nrcfw = &rdev->rcfw;\nif (!ent) {\n/* Not setting the f/w timeout bit in rcfw.\n* During the driver unload the first command\n* to f/w will timeout and that will set the\n* timeout bit.\n*/\nibdev_err(&rdev->ibdev, \"Failed to re-start IRQs\\n\");\nreturn;\n}\n/* Vectors may change after restart, so update with new vectors\n* in device sctructure.\n*/\nfor (indx = 0; indx < rdev->nqr->num_msix; indx++)\nrdev->nqr->msix_entries[indx].vector = ent[indx].vector;\nrc = bnxt_qplib_rcfw_start_irq(rcfw, msix_ent[BNXT_RE_AEQ_IDX].vector,\nfalse);\nif (rc) {\nibdev_warn(&rdev->ibdev, \"Failed to reinit CREQ\\n\");\nreturn;\n}\nfor (indx = BNXT_RE_NQ_IDX ; indx < rdev->nqr->num_msix; indx++) {\nnq = &rdev->nqr->nq[indx - 1];\nrc = bnxt_qplib_nq_start_irq(nq, indx - 1,\nmsix_ent[indx].vector, false);\nif (rc) {\nibdev_warn(&rdev->ibdev, \"Failed to reinit NQ index %d\\n\",\nindx - 1);\nreturn;\n}\n}\n}\n```",
  "vuln_patch": "```c\nstatic void bnxt_re_start_irq(void *handle, struct bnxt_msix_entry *ent)\n{\nstruct bnxt_re_en_dev_info *en_info = auxiliary_get_drvdata(handle);\nstruct bnxt_msix_entry *msix_ent;\nstruct bnxt_qplib_rcfw *rcfw;\nstruct bnxt_re_dev *rdev;\nstruct bnxt_qplib_nq *nq;\nint indx, rc;\nrdev = en_info->rdev;\nif (!rdev)\nreturn;\nmsix_ent = rdev->nqr->msix_entries;\nrcfw = &rdev->rcfw;\nif (!ent) {\n/* Not setting the f/w timeout bit in rcfw.\n* During the driver unload the first command\n* to f/w will timeout and that will set the\n* timeout bit.\n*/\nibdev_err(&rdev->ibdev, \"Failed to re-start IRQs\\n\");\nreturn;\n}\n/* Vectors may change after restart, so update with new vectors\n* in device sctructure.\n*/\nfor (indx = 0; indx < rdev->nqr->num_msix; indx++)\nrdev->nqr->msix_entries[indx].vector = ent[indx].vector;\nrc = bnxt_qplib_rcfw_start_irq(rcfw, msix_ent[BNXT_RE_AEQ_IDX].vector,\nfalse);\nif (rc) {\nibdev_warn(&rdev->ibdev, \"Failed to reinit CREQ\\n\");\nreturn;\n}\nfor (indx = BNXT_RE_NQ_IDX ; indx < rdev->nqr->num_msix; indx++) {\nnq = &rdev->nqr->nq[indx - 1];\nrc = bnxt_qplib_nq_start_irq(nq, indx - 1,\nmsix_ent[indx].vector, false);\nif (rc) {\nibdev_warn(&rdev->ibdev, \"Failed to reinit NQ index %d\\n\",\nindx - 1);\nreturn;\n}\n}\n}\n```",
  "function_name": "bnxt_re_start_irq",
  "function_prototype": "static void bnxt_re_start_irq(void *handle, struct bnxt_msix_entry *ent)",
  "code_semantics": "The function manages the restart of interrupt requests for a device. It retrieves device-specific information using a provided handle, checks the validity of input data, and logs an error if invalid. It updates the device's interrupt vector information with new values and attempts to restart the command request framework's interrupt handling, logging a warning if it fails. The function then restarts interrupt handling for network queues, logging warnings if any restarts fail.",
  "safe_verification_cot": "1. The function bnxt_re_start_irq is called, and en_info is obtained using auxiliary_get_drvdata. 2. The rdev variable is assigned from en_info->rdev. 3. A check is performed to verify if rdev is NULL. 4. If rdev is NULL, the function returns immediately, preventing any dereference of a NULL pointer. 5. This ensures that the code does not attempt to access rdev->nqr->msix_entries or other members if rdev is NULL, thus preventing the vulnerability.",
  "verification_cot": "1. The function bnxt_re_start_irq is called, and en_info is obtained using auxiliary_get_drvdata. 2. The rdev variable is assigned from en_info->rdev. 3. There is no check to verify if rdev is NULL before it is dereferenced. 4. If rdev is NULL, any attempt to access rdev->nqr->msix_entries or other members will result in a NULL pointer dereference, leading to a crash or undefined behavior.",
  "vulnerability_related_variables": {
    "rdev": "This variable acts as a container for accessing various device-specific resources and configurations. It provides access to network queue resources, interrupt configurations, and device-specific operations. It is used to manage and configure device interrupts and handle device-specific operations.",
    "en_info": "This variable serves as a bridge to access device-specific information. It retrieves and holds a reference to the device's runtime data, allowing access to the device's resources and configurations. It is primarily used to obtain the device context necessary for further operations."
  },
  "vulnerability_related_functions": {
    "auxiliary_get_drvdata": "This function takes a pointer to a structure containing a device and retrieves a driver-specific data pointer associated with that device, returning the data pointer."
  },
  "root_cause": "The root cause of CVE-2025-21901 is the lack of a NULL check for the rdev pointer before it is dereferenced.",
  "patch_cot": "First, ensure that the function auxiliary_get_drvdata correctly retrieves the driver data and assigns it to en_info. After retrieving en_info, immediately check if en_info is NULL. If it is, return from the function to prevent further operations. Assign rdev from en_info->rdev. Check if rdev is NULL. If it is, return from the function to prevent any dereferencing of rdev. Proceed with the rest of the function logic only if rdev is not NULL."
}