```c
struct bnxt_msix_entry {
    u32 vector;
    u32 ring_idx;
    u32 db_offset;
};
```

```c
struct bnxt_re_en_dev_info {
    struct bnxt_en_dev *en_dev;
    struct bnxt_re_dev *rdev;
};
```

```c
static inline void *auxiliary_get_drvdata(struct auxiliary_device *auxdev)
{
    return dev_get_drvdata(&auxdev->dev);
}
```

```c
struct bnxt_msix_entry {
    u32 vector;
    u32 ring_idx;
    u32 db_offset;
};
```

```c
struct bnxt_qplib_rcfw {
    struct pci_dev      *pdev;
    struct bnxt_qplib_res   *res;
    struct bnxt_qplib_cmdq_ctx  cmdq;
    struct bnxt_qplib_creq_ctx  creq;
    struct bnxt_qplib_crsqe     *crsqe_tbl;
    int qp_tbl_size;
    struct bnxt_qplib_qp_node *qp_tbl;
    /* To synchronize the qp-handle hash table */
    spinlock_t          tbl_lock;
    u64 oos_prev;
    u32 init_oos_stats;
    u32 cmdq_depth;
    atomic_t rcfw_intr_enabled;
    struct semaphore rcfw_inflight;
    atomic_t timeout_send;
    /* cached from chip cctx for quick reference in slow path */
    u16 max_timeout;
};
```

```c
struct bnxt_re_dev {
    struct ib_device        ibdev;
    struct list_head        list;
    unsigned long           flags;
#define BNXT_RE_FLAG_NETDEV_REGISTERED      0
#define BNXT_RE_FLAG_HAVE_L2_REF        3
#define BNXT_RE_FLAG_RCFW_CHANNEL_EN        4
#define BNXT_RE_FLAG_QOS_WORK_REG       5
#define BNXT_RE_FLAG_RESOURCES_ALLOCATED    7
#define BNXT_RE_FLAG_RESOURCES_INITIALIZED  8
#define BNXT_RE_FLAG_ERR_DEVICE_DETACHED       17
#define BNXT_RE_FLAG_ISSUE_ROCE_STATS          29
    struct net_device       *netdev;
    struct auxiliary_device         *adev;
    struct notifier_block       nb;
    unsigned int            version, major, minor;
    struct bnxt_qplib_chip_ctx  *chip_ctx;
    struct bnxt_en_dev      *en_dev;

    int             id;

    struct delayed_work     worker;
    u8              cur_prio_map;

    /* RCFW Channel */
    struct bnxt_qplib_rcfw      rcfw;

    /* NQ record */
    struct bnxt_re_nq_record    *nqr;

    /* Device Resources */
    struct bnxt_qplib_dev_attr  dev_attr;
    struct bnxt_qplib_ctx       qplib_ctx;
    struct bnxt_qplib_res       qplib_res;
    struct bnxt_qplib_dpi       dpi_privileged;
    struct bnxt_qplib_cq_coal_param cq_coalescing;

    struct mutex            qp_lock;    /* protect qp list */
    struct list_head        qp_list;

    /* Max of 2 lossless traffic class supported per port */
    u16             cosq[2];

    /* QP for handling QP1 packets */
    struct bnxt_re_gsi_context  gsi_ctx;
    struct bnxt_re_stats        stats;
    atomic_t nq_alloc_cnt;
    u32 is_virtfn;
    u32 num_vfs;
    struct bnxt_re_pacing pacing;
    struct work_struct dbq_fifo_check_work;
    struct delayed_work dbq_pacing_work;
    DECLARE_HASHTABLE(cq_hash, MAX_CQ_HASH_BITS);
    DECLARE_HASHTABLE(srq_hash, MAX_SRQ_HASH_BITS);
    struct dentry           *dbg_root;
    struct dentry           *qp_debugfs;
};
```

```c
struct bnxt_qplib_nq {
    struct pci_dev          *pdev;
    struct bnxt_qplib_res       *res;
    char                *name;
    struct bnxt_qplib_hwq       hwq;
    struct bnxt_qplib_nq_db     nq_db;
    u16             ring_id;
    int             msix_vec;
    cpumask_t           mask;
    struct tasklet_struct       nq_tasklet;
    bool                requested;
    int             budget;
    u32             load;

    cqn_handler_t           cqn_handler;
    srqn_handler_t          srqn_handler;
    struct workqueue_struct     *cqn_wq;
};
```

```c
void ibdev_err(const struct ib_device *ibdev, const char *format, ...);
```

```c
int bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,
                  bool need_init)
{
    struct bnxt_qplib_creq_ctx *creq;
    struct bnxt_qplib_res *res;
    int rc;

    creq = &rcfw->creq;
    res = rcfw->res;

    if (creq->requested)
        return -EFAULT;

    creq->msix_vec = msix_vector;
    if (need_init)
        tasklet_setup(&creq->creq_tasklet, bnxt_qplib_service_creq);
    else
        tasklet_enable(&creq->creq_tasklet);

    creq->irq_name = kasprintf(GFP_KERNEL, "bnxt_re-creq@pci:%s",
                   pci_name(res->pdev));
    if (!creq->irq_name)
        return -ENOMEM;
    rc = request_irq(creq->msix_vec, bnxt_qplib_creq_irq, 0,
             creq->irq_name, rcfw);
    if (rc) {
        kfree(creq->irq_name);
        creq->irq_name = NULL;
        tasklet_disable(&creq->creq_tasklet);
        return rc;
    }
    creq->requested = true;

    bnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, res->cctx, true);
    atomic_inc(&rcfw->rcfw_intr_enabled);

    return 0;
}
```

```c
void ibdev_warn(const struct ib_device *ibdev, const char *format, ...);
```

```c
#define BNXT_RE_NQ_IDX          1
```

```c
int bnxt_qplib_nq_start_irq(struct bnxt_qplib_nq *nq, int nq_indx,
                int msix_vector, bool need_init)
{
    struct bnxt_qplib_res *res = nq->res;
    int rc;

    if (nq->requested)
        return -EFAULT;

    nq->msix_vec = msix_vector;
    if (need_init)
        tasklet_setup(&nq->nq_tasklet, bnxt_qplib_service_nq);
    else
        tasklet_enable(&nq->nq_tasklet);

    nq->name = kasprintf(GFP_KERNEL, "bnxt_re-nq-%d@pci:%s",
                 nq_indx, pci_name(res->pdev));
    if (!nq->name)
        return -ENOMEM;
    rc = request_irq(nq->msix_vec, bnxt_qplib_nq_irq, 0, nq->name, nq);
    if (rc) {
        kfree(nq->name);
        nq->name = NULL;
        tasklet_disable(&nq->nq_tasklet);
        return rc;
    }

    cpumask_clear(&nq->mask);
    cpumask_set_cpu(nq_indx, &nq->mask);
    rc = irq_set_affinity_hint(nq->msix_vec, &nq->mask);
    if (rc) {
        dev_warn(&nq->pdev->dev,
             "set affinity failed; vector: %d nq_idx: %d\n",
             nq->msix_vec, nq_indx);
    }
    nq->requested = true;
    bnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, res->cctx, true);

    return rc;
}
```
